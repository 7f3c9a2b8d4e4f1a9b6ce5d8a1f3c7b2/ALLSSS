# Audit Report

## Title
ImpliedIrreversibleBlockHeight Validation Bypass Due to Premature State Recovery

## Summary
The `LibInformationValidationProvider` validation logic in the AEDPoS consensus contract is broken because `RecoverFromUpdateValue` modifies the `baseRound` state before validation occurs. This causes the validation check to compare identical values instead of comparing StateDb values against newly provided values, allowing malicious miners to report artificially low `ImpliedIrreversibleBlockHeight` values that would otherwise be rejected. This can prevent Last Irreversible Block (LIB) advancement if 1/3+ miners collude.

## Finding Description

The vulnerability exists in the validation flow for UpdateValue consensus behavior. The validation sequence executes as follows:

1. **State Retrieval**: The validation process begins by fetching the current round from StateDb [1](#0-0) 

2. **Premature Recovery**: Before validation providers are invoked, `RecoverFromUpdateValue` is called on `baseRound` for UpdateValue behavior [2](#0-1) 

3. **State Corruption**: The `RecoverFromUpdateValue` method copies values from `providedRound` into `baseRound`, including the miner's `ImpliedIrreversibleBlockHeight` [3](#0-2) 

4. **Validation Context Creation**: A validation context is created using the now-modified `baseRound` [4](#0-3) 

5. **Broken Validation**: The `LibInformationValidationProvider` is added to validators [5](#0-4)  and attempts to validate that the miner's `ImpliedIrreversibleBlockHeight` hasn't decreased [6](#0-5) 

**Root Cause**: Since `baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` was already overwritten with `providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight`, the comparison always evaluates identical values. The check can never detect a decrease because both sides of the comparison reference the same value. The validation context uses `ProvidedRound => ExtraData.Round` [7](#0-6) , which points to the same source that was already copied into baseRound.

The intended behavior is to compare the value from StateDb (representing the miner's previously reported height) against the new value being provided, rejecting any regression. However, the premature recovery destroys the StateDb baseline before comparison occurs.

## Impact Explanation

**Operational Impact - High Severity**:

1. **LIB Finalization Prevention**: Malicious miners can report artificially low `ImpliedIrreversibleBlockHeight` values without detection. During LIB calculation, these values are sorted and the value at position `(count-1)/3` is selected as the new LIB height [8](#0-7) . If 1/3+ miners collude to provide artificially low values, the calculated LIB will be suppressed [9](#0-8) .

2. **Cross-Chain Operations Disruption**: LIB height is critical for cross-chain verification and merkle proof validation. Stalled LIB prevents parent/side-chain synchronization and cross-chain message processing.

3. **State Management Issues**: LIB determines which blocks can be safely pruned from the state database. Preventing LIB advancement causes unbounded state growth and eventual resource exhaustion.

4. **Transaction Finality Delay**: Users cannot achieve finality guarantees on their transactions when LIB is stalled, affecting economic activity and user confidence in the system.

While this is a liveness attack rather than a safety violation (LIB cannot decrease due to the check in ProcessUpdateValue [10](#0-9) ), the operational impact is severe enough to warrant HIGH severity classification.

## Likelihood Explanation

**Medium Likelihood**:

**Attacker Capabilities**: 
- Must be an elected miner in the consensus round (achievable through the election mechanism)
- Can modify consensus extra data before block production, as the `ImpliedIrreversibleBlockHeight` is set during ProcessUpdateValue [11](#0-10)  and the miner receives this data which they can tamper with before signing and producing the block

**Attack Complexity**: 
- Low complexity for an individual miner to provide false data
- Medium complexity to coordinate 1/3+ miners for significant LIB impact
- No cryptographic protection prevents miners from modifying their own consensus extra data

**Feasibility Conditions**:
- Block validation is sequential, eliminating race conditions
- Post-execution validation also fails to detect tampering [12](#0-11)  since it performs recovery again on already-updated StateDb
- No upper-bound validation exists, only the broken lower-bound check

**Detection/Operational Constraints**:
- Attack is detectable through explicit monitoring of individual miner `ImpliedIrreversibleBlockHeight` reports
- Miners have reputation and economic stake at risk through the election mechanism
- However, subtle variations in reported heights may go unnoticed without dedicated monitoring infrastructure

The attack requires malicious intent from elected miners but is technically straightforward to execute once mining permissions are obtained through the election process.

## Recommendation

The validation logic must be fixed to preserve the original StateDb values before recovery. The recommended fix is to perform validation BEFORE modifying baseRound:

1. Create the validation context with the unmodified baseRound
2. Execute all validation providers
3. Only after successful validation, call RecoverFromUpdateValue to apply the changes

Alternatively, clone baseRound before recovery and use the cloned (unmodified) version for validation while using the recovered version for subsequent processing.

## Proof of Concept

The following conceptual test demonstrates the vulnerability:

```plaintext
Test: ImpliedIrreversibleBlockHeight_ValidationBypass_Test

1. Setup: Initialize consensus with multiple miners
2. Miner A reports ImpliedIrreversibleBlockHeight = 1000 in round N
3. State is updated: baseRound.RealTimeMinersInformation[MinerA].ImpliedIrreversibleBlockHeight = 1000
4. In round N+1, Miner A produces a block with ImpliedIrreversibleBlockHeight = 500 (artificially low)
5. ValidateBeforeExecution is called:
   - baseRound is fetched (has value 1000 from previous round)
   - RecoverFromUpdateValue is called, copying 500 into baseRound
   - LibInformationValidationProvider checks: baseRound[MinerA] (500) > providedRound[MinerA] (500)
   - Check fails to detect regression (500 == 500)
   - Validation passes incorrectly
6. ProcessUpdateValue executes and stores the artificially low value
7. Result: Miner successfully reported a decreased ImpliedIrreversibleBlockHeight without triggering validation failure

Expected: Validation should reject the block because 500 < 1000
Actual: Validation passes because both sides of comparison equal 500
```

**Notes**

This vulnerability demonstrates a critical timing issue in the validation pipeline where state modification occurs before validation instead of after. The issue affects both pre-execution validation [2](#0-1)  and post-execution validation [12](#0-11) , making it impossible for the system to detect maliciously low ImpliedIrreversibleBlockHeight values through the intended validation mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L82-82)
```csharp
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-21)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L32-32)
```csharp
            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-18)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-272)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```
