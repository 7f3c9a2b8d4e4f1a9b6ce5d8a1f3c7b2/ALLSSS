# Audit Report

## Title
Virtual Balance Mismatch Causes Denial of Service in TokenConverter Sell Operations

## Summary
The TokenConverter contract uses a 10 million token virtual balance for deposit connectors in Bancor pricing calculations, but this virtual balance does not represent actual tokens held by the contract. When deposit balances are low, the Bancor formula calculates payouts exceeding actual holdings, causing `Sell` transactions to fail with SafeMath underflow exceptions, preventing legitimate users from selling resource tokens.

## Finding Description
The vulnerability stems from a critical mismatch between the balance used for pricing calculations and the balance used for state updates in the `Sell` method.

The `NativeTokenToResourceBalance` constant is set to 10 million tokens [1](#0-0) , which is assigned as the `VirtualBalance` for native token deposit connectors during initialization [2](#0-1) .

The `GetSelfBalance` method combines this virtual balance with the actual deposit balance when calculating pricing [3](#0-2) . This inflated balance is used by the Bancor formula [4](#0-3)  to calculate `amountToReceive`.

However, the actual state update attempts to subtract `amountToReceive` from the real `DepositBalance` [5](#0-4) . When `amountToReceive` exceeds the actual `DepositBalance`, the `SafeMath.Sub` operation throws an overflow exception [6](#0-5) , causing the transaction to revert.

The Bancor formula for equal weights simplifies to: `return = toBalance * paidAmount / (fromBalance + paidAmount)` [7](#0-6) , where `toBalance` includes the 10M virtual balance, leading to calculated returns that exceed actual available deposits.

Connectors can be initialized with zero deposit balance [8](#0-7)  when all resource tokens are already held by the contract, making this scenario immediately reachable.

## Impact Explanation
**Denial of Service - Medium Severity**

Users are unable to sell resource tokens when deposit balances are insufficient relative to the 10M virtual balance. The transaction reverts cleanly without fund loss, but creates significant operational disruption:

- Legitimate sell operations fail unexpectedly despite pricing calculations indicating they should succeed
- Resource tokens become effectively frozen until sufficient deposits accumulate through Buy operations
- Impact multiplies across multiple resource token pairs (READ, WRITE, STORAGE, TRAFFIC, etc.), each with its own 10M virtual balance
- More severe during early system stages or after periods of heavy withdrawals

The issue affects system availability rather than fund security. No tokens are lost or stolen—transactions simply revert. This justifies Medium severity: significant operational impact without direct fund loss.

## Likelihood Explanation
**High Likelihood**

The vulnerability is highly likely to manifest in realistic scenarios:

The `Sell` method is publicly accessible [9](#0-8)  requiring no special privileges—any user holding resource tokens can call it.

Feasible preconditions exist naturally:
- System initialization can set deposit balance to zero when all resource tokens are in the contract
- Early adoption phase where limited Buy operations have occurred (deposit balance << 10M virtual)
- Multiple resource connectors fragment available deposits across 8+ different pairs

The mathematical condition for failure is straightforward: when `(virtualBalance + depositBalance) * sellAmount / (resourceBalance + sellAmount) > depositBalance`, which occurs frequently when `depositBalance << virtualBalance` (10M).

No attack is required—this is a natural system state during normal operation. Users have legitimate economic incentives to sell resource tokens but are blocked by insufficient deposit backing.

## Recommendation
The virtual balance mechanism should be redesigned to ensure consistency between pricing calculations and available reserves. Recommended fixes:

1. **Option A - Remove Virtual Balance from State Updates**: Modify the Sell method to track virtual balance separately and only deduct from actual DepositBalance what is actually available
2. **Option B - Validate Before Calculation**: Add a check before line 193 to ensure `amountToReceive <= State.DepositBalance[toConnector.Symbol]`, and adjust the Bancor calculation if needed
3. **Option C - Back Virtual Balance with Real Tokens**: Initialize deposit connectors with actual tokens equal to the virtual balance during system setup

The most robust solution is Option C, ensuring the virtual balance represents actual backing collateral.

## Proof of Concept

```csharp
[Fact]
public async Task Sell_WithLowDepositBalance_ShouldFail()
{
    // Setup: Initialize TokenConverter with resource connector
    await InitializeTokenConverterContract();
    
    // Create and enable a resource token connector with minimal deposit
    var resourceSymbol = "TEST";
    var ntSymbol = "(NT)TEST";
    
    // Enable connector with zero deposit (all tokens in contract)
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = resourceSymbol,
        AmountToTokenConvert = 100_000_00000000, // All tokens in contract
    });
    
    // User tries to sell resource tokens
    // Virtual balance = 10M, actual deposit = 0
    // Bancor will calculate payout > 0, but DepositBalance = 0
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(new SellInput
    {
        Symbol = resourceSymbol,
        Amount = 1000_00000000, // Sell 1000 tokens
        ReceiveLimit = 0
    });
    
    // Transaction should fail with SafeMath underflow
    sellResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    sellResult.TransactionResult.Error.ShouldContain("overflow");
}
```

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L20-20)
```csharp
    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L246-246)
```csharp
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-161)
```csharp
    public override Empty Sell(SellInput input)
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L387-387)
```csharp
        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L47-49)
```csharp
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L74-84)
```csharp
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```
