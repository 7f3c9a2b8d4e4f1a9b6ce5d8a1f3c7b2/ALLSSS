# Audit Report

## Title
QuadraticVotesCountMap Never Decremented Causing Inflated Costs and Permanent Token Loss on VoteId Reuse

## Summary
The Vote contract's quadratic voting implementation fails to decrement the `QuadraticVotesCountMap` counter during withdrawals and lacks VoteId uniqueness validation. When VoteIds collide due to deterministic generation from cycling `VotesAmount` values, subsequent voters must lock inflated token amounts while previous voters with the same VoteId permanently lose access to their locked tokens due to voting record corruption. [1](#0-0) 

## Finding Description

The Vote contract tracks quadratic vote counts in `QuadraticVotesCountMap`, which is incremented during voting to calculate the required lock amount as `TicketCost * currentVotesCount`. However, the `Withdraw` method never decrements this counter, leaving it permanently elevated. [2](#0-1) 

The `Vote` method lacks VoteId uniqueness validation and simply overwrites existing voting records: [3](#0-2) 

This contrasts with the Election contract's explicit validation: [4](#0-3) 

For regular voting (`IsLockToken=true`), VoteIds are deterministically generated from the current `VotesAmount`: [5](#0-4) 

Since `VotesAmount` increases on votes and decreases on withdrawals, it naturally cycles back to previous values, causing VoteId collisions: [6](#0-5) [7](#0-6) 

**Attack Scenario:**
1. User B votes 100 tokens → VoteId="Y", `QuadraticVotesCountMap["Y"]=1`, `VotesAmount=100`
2. Another user votes → `VotesAmount=200`
3. Another user withdraws → `VotesAmount=100` (cycled back)
4. User C votes → VoteId="Y" (collision), `QuadraticVotesCountMap["Y"]=2`, must lock 200 tokens
5. `VotingRecords["Y"]` overwrites User B's record
6. User B cannot withdraw due to permission check failure: [8](#0-7) 

## Impact Explanation

**Critical Impacts:**

1. **Permanent Token Loss for First User**: When User B's voting record is overwritten by User C, User B cannot call `Withdraw` because the permission check compares `votingRecord.Voter` (now User C) against `Context.Sender` (User B). User B's 100 tokens remain permanently locked in the virtual address.

2. **Capital Inefficiency for Second User**: User C must lock 200 tokens instead of 100 due to the accumulated counter, reducing capital efficiency by 100%.

3. **Vote Record Corruption**: User B's vote data is permanently lost, affecting voting integrity and results accuracy.

4. **Systemic Risk**: In active voting systems, this creates a cascading effect where multiple users can be affected as VoteIds continue to collide.

The severity is HIGH because it results in permanent, unrecoverable token loss for users through normal protocol operations without any warning or protection mechanism.

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability triggers through normal user behavior:
- VoteId collisions occur whenever `VotesAmount` cycles to previous values
- No special privileges or sophisticated attacks required
- Deterministic VoteId generation (`Context.GenerateId()` with only `VotesAmount` as seed) guarantees collisions in active voting scenarios
- Natural vote/withdraw activity patterns make this inevitable

In any voting item with reasonable activity (multiple users voting and withdrawing), `VotesAmount` will cycle through values multiple times, causing frequent collisions. The vulnerability is not theoretical but a mathematical certainty given sufficient activity.

## Recommendation

**Fix 1: Add VoteId Uniqueness Validation**
```csharp
public override Empty Vote(VoteInput input)
{
    var votingItem = AssertValidVoteInput(input);
    
    // Add uniqueness check
    Assert(State.VotingRecords[input.VoteId] == null || 
           State.VotingRecords[input.VoteId].IsWithdrawn, 
           "Vote ID already exists.");
    
    // ... rest of method
}
```

**Fix 2: Reset Counter on Withdrawal**
```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    var votingItem = State.VotingItems[votingRecord.VotingItemId];
    
    // ... existing checks ...
    
    // Reset quadratic counter for this VoteId
    if (votingItem.IsQuadratic)
    {
        State.QuadraticVotesCountMap.Remove(input.VoteId);
    }
    
    // ... rest of method
}
```

**Fix 3: Use Transaction-Based VoteId Generation**
```csharp
// Instead of VotesAmount-based generation, use transaction hash
input.VoteId = Context.TransactionId;
```

This ensures each vote gets a unique identifier that cannot collide.

## Proof of Concept

```csharp
[Fact]
public void Test_QuadraticVoteId_Collision_Causes_Permanent_Lock()
{
    // Setup quadratic voting item
    var votingItemId = RegisterQuadraticVotingItem(ticketCost: 100);
    
    // User B votes 100 tokens
    var userB = Accounts[1].Address;
    VoteContract.SetAccount(userB);
    VoteContract.Vote(new VoteInput
    {
        VotingItemId = votingItemId,
        Amount = 100,
        Option = "OptionA"
    });
    var voteBId = GetLastGeneratedVoteId(); // Based on VotesAmount
    
    // Another user votes to increase VotesAmount
    var userD = Accounts[3].Address;
    VoteContract.SetAccount(userD);
    VoteContract.Vote(new VoteInput
    {
        VotingItemId = votingItemId,
        Amount = 100,
        Option = "OptionB"
    });
    
    // User D withdraws, cycling VotesAmount back
    VoteContract.Withdraw(new WithdrawInput { VoteId = GetLastGeneratedVoteId() });
    
    // User C votes - gets same VoteId as User B due to cycled VotesAmount
    var userC = Accounts[2].Address;
    VoteContract.SetAccount(userC);
    
    // User C must lock 200 tokens (2x) due to non-reset counter
    var tokenBalance = TokenContract.GetBalance(userC, "ELF");
    Assert.True(tokenBalance >= 200, "User C needs 200 tokens for inflated cost");
    
    VoteContract.Vote(new VoteInput
    {
        VotingItemId = votingItemId,
        Amount = 200, // Must provide double due to QuadraticVotesCountMap
        Option = "OptionC"
    });
    
    // User B cannot withdraw - voting record overwritten
    VoteContract.SetAccount(userB);
    var exception = Assert.Throws<AssertionException>(() =>
        VoteContract.Withdraw(new WithdrawInput { VoteId = voteBId })
    );
    Assert.Contains("No permission to withdraw votes of others", exception.Message);
    
    // User B's 100 tokens are permanently locked
    var lockedAmount = GetLockedAmount(userB, voteBId);
    Assert.Equal(100, lockedAmount); // Still locked, unrecoverable
}
```

## Notes

This vulnerability is more severe than initially described because it causes **permanent token loss** for the first user whose VoteId gets reused, not merely capital inefficiency. The overwriting of `VotingRecords` without validation breaks the fundamental security guarantee that users can withdraw their own votes. The deterministic VoteId generation from `VotesAmount` makes collisions inevitable in any active voting scenario, representing a critical protocol-level flaw in the quadratic voting implementation.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-103)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L179-180)
```csharp
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L433-433)
```csharp
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
```
