# Audit Report

## Title
Unvalidated TuneOrderInformation Allows Arbitrary Order Manipulation Breaking Consensus Timing and Continuous Mining Prevention

## Summary
The `ProcessUpdateValue` function in the AEDPoS consensus contract accepts arbitrary `FinalOrderOfNextRound` values through the `TuneOrderInformation` field without validating they fall within the valid range [1, minersCount]. This allows any active miner to manipulate mining orders, breaking consensus timing calculations, bypassing continuous mining prevention, and violating order uniqueness invariants fundamental to the AEDPoS consensus mechanism.

## Finding Description

**Root Cause:**

The vulnerability exists in `ProcessUpdateValue` where `TuneOrderInformation` values from user input are directly applied to miners' `FinalOrderOfNextRound` without any range or validity checks: [1](#0-0) 

**Why Existing Protections Fail:**

1. **UpdateValueValidationProvider** only validates cryptographic fields (OutValue, Signature, PreviousInValue) but completely ignores `TuneOrderInformation`: [2](#0-1) 

2. **NextRoundMiningOrderValidationProvider** is only applied for `NextRound` behavior, NOT for `UpdateValue`: [3](#0-2) 

3. Even if it were applied, `NextRoundMiningOrderValidationProvider` only checks distinct count, not that orders are within valid range: [4](#0-3) 

**Execution Path:**

When `GenerateNextRoundInformation` is called during the next round transition, it processes the manipulated `FinalOrderOfNextRound` values directly. The function orders miners by these values and uses them for timing calculations: [5](#0-4) [6](#0-5) 

The invalid order values (e.g., 1000) are multiplied by `miningInterval` to calculate `ExpectedMiningTime`, pushing mining slots far into the future and breaking the consensus schedule.

## Impact Explanation

**Concrete Harms:**

1. **Consensus Timing Manipulation**: The `ExpectedMiningTime` calculation directly multiplies order by miningInterval. An order of 1000 instead of a valid order (e.g., 1-10 for 10 miners) pushes the miner's time slot 100x further into the future than intended, completely breaking the round timing mechanism: [7](#0-6) 

2. **BreakContinuousMining Bypass**: The `BreakContinuousMining` function looks for `lastMinerOfNextRound` with `Order == minersCount`. When no miner has this order (because one has an invalid order like 1000), it returns null and exits early without performing the swap, allowing the same miner to produce both the last block and extra block consecutively: [8](#0-7) 

3. **Order Uniqueness Violation**: Multiple miners can be assigned identical orders through crafted `TuneOrderInformation`, violating the fundamental invariant that each miner has a unique sequential order in [1, minersCount].

4. **Extra Block Producer Selection**: The extra block calculation relies on order values, and invalid orders corrupt this selection mechanism.

**Severity**: HIGH - Breaks critical consensus invariants including miner schedule integrity, time-slot validation, and continuous mining prevention, enabling consensus disruption and potential chain stalling.

## Likelihood Explanation

**Attacker Capabilities**: Any active miner in the current round can execute this attack. The `UpdateValue` method is a public RPC accessible during the miner's designated time slot: [9](#0-8) 

The only access control is `PreCheck()` which validates the sender is in the miner list: [10](#0-9) 

**Attack Complexity**: LOW - The attacker simply crafts an `UpdateValueInput` with malicious `TuneOrderInformation` values and calls `UpdateValue`. No special privileges beyond being an active miner are required.

**Feasibility**: HIGH - Miners regularly call `UpdateValue` during normal operation. While the honest flow uses `ExtractInformationToUpdateConsensus` to build the input: [11](#0-10) 

There is no enforcement that miners must use this method. They can construct their own `UpdateValueInput` with arbitrary `TuneOrderInformation` values.

**Detection**: Difficult to detect proactively as the malicious transaction appears valid to all existing validation providers and would only be noticed when the next round generates with corrupted timing.

## Recommendation

Add validation for `TuneOrderInformation` in the `UpdateValueValidationProvider` or create a dedicated validator that checks:

1. All `FinalOrderOfNextRound` values are within the valid range [1, minersCount]
2. All `FinalOrderOfNextRound` values are unique (no duplicates)
3. The count of miners with non-zero `FinalOrderOfNextRound` matches the count of miners who have mined

Alternatively, add validation directly in `ProcessUpdateValue` before applying the tuning information:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate TuneOrderInformation
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
            "Invalid FinalOrderOfNextRound value.");
        Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
            "Cannot tune order for non-existent miner.");
    }
    
    // Check for duplicate orders
    var ordersSet = new HashSet<int>();
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(ordersSet.Add(tuneOrder.Value), 
            "Duplicate FinalOrderOfNextRound values detected.");
    }
    
    // ... rest of existing logic
}
```

## Proof of Concept

A malicious miner can exploit this vulnerability with the following transaction:

```csharp
// Craft malicious UpdateValueInput with invalid order
var maliciousInput = new UpdateValueInput
{
    OutValue = computedOutValue,
    Signature = computedSignature,
    PreviousInValue = previousInValue,
    RoundId = currentRoundId,
    ActualMiningTime = currentTime,
    SupposedOrderOfNextRound = normalOrder,
    ImpliedIrreversibleBlockHeight = libHeight,
    RandomNumber = randomNumber,
    // Malicious tuning: set another miner's order to 1000
    TuneOrderInformation = 
    {
        { victimMinerPubkey, 1000 }  // Invalid order value
    }
};

// Call UpdateValue - this will pass all validations
consensusContract.UpdateValue(maliciousInput);

// When next round is generated, the victim miner will have:
// - Order = 1000 in next round
// - ExpectedMiningTime pushed ~100x into the future
// - BreakContinuousMining fails to find Order == minersCount
```

**Notes**

The vulnerability stems from incomplete input validation in the consensus contract. While the honest implementation uses `ExtractInformationToUpdateConsensus` to generate legitimate tuning information for resolving order conflicts, there is no enforcement mechanism requiring miners to use this helper method. The contract trusts user-provided `TuneOrderInformation` values without bounds checking, allowing malicious miners to corrupt the consensus timing mechanism and bypass continuous mining prevention safeguards.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L92-95)
```csharp
        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L16-51)
```csharp
    public UpdateValueInput ExtractInformationToUpdateConsensus(string pubkey, ByteString randomNumber)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return null;

        var minerInRound = RealTimeMinersInformation[pubkey];

        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
    }
```
