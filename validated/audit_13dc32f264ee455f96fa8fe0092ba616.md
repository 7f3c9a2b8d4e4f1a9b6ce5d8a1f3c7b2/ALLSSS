# Audit Report

## Title
Insufficient Alternative Candidates Allows Banned Miners to Remain in Consensus

## Summary
The AEDPoS consensus contract's miner replacement mechanism contains a critical logic error that allows banned miners to continue participating in consensus when the alternative candidate pool is insufficient. The replacement loop iterates based on the number of available alternatives rather than the number of evil miners, causing partial replacement and allowing unreplaced banned miners to continue producing blocks and earning rewards.

## Finding Description

When generating the next consensus round during the same term, the system calls `GetMinerReplacementInformation` to identify banned miners from the current miner list and find replacement candidates from the election snapshot. [1](#0-0) 

The Election contract's `GetMinerReplacementInformation` method can legitimately return fewer alternatives than evil miners when the candidate pool is exhausted. It first attempts to take candidates from the election snapshot (limited by availability): [2](#0-1) 

Then tries to fill the gap with initial miners, but these are filtered to exclude banned and currently active miners: [3](#0-2) 

The method returns both lists potentially with mismatched sizes: [4](#0-3) 

**Root Cause:** The replacement logic uses a loop that iterates based on `AlternativeCandidatePubkeys.Count` and accesses both lists by the same index: [5](#0-4) 

When `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`, the replacement loop only removes the first N evil miners (where N equals the alternative count). The remaining evil miners at indices N and beyond are never accessed and remain in `currentRound.RealTimeMinersInformation`.

Subsequently, `Round.GenerateNextRoundInformation` generates the next round using whatever miners exist in `RealTimeMinersInformation` without filtering for banned status: [6](#0-5) 

The unreplaced banned miners propagate into the next round and can continue producing blocks because block validation only checks if the miner is in the current miner list, not if they're banned: [7](#0-6) 

Miners become banned when they miss too many time slots (4320 time slots = 3 days): [8](#0-7) 

The system detects evil miners during round processing: [9](#0-8) 

And sets their banned status in the Election contract: [10](#0-9) 

## Impact Explanation

**Critical Consensus Integrity Violation:** This vulnerability breaks the fundamental invariant that miners banned via `State.BannedPubkeyMap` for violating consensus rules must be excluded from consensus participation. Unreplaced evil miners continue producing blocks despite being penalized for excessive missed time slots, directly compromising consensus integrity.

**Reward Misallocation:** Banned miners continue earning block production rewards through the Treasury contract's mining reward distribution mechanism: [11](#0-10) 

This undermines the economic security model that relies on punishment to discourage misbehavior, as malicious miners can avoid the intended economic penalty.

**Attack Amplification:** Multiple malicious miners can coordinate to simultaneously misbehave (miss time slots). If the alternative candidate pool is shallow due to low election participation or most initial miners being already active or banned, several evil miners will remain active. This enables sustained coordinated attacks against chain liveness and security while continuing to earn rewards.

**Severity: Critical** - This breaks core consensus assumptions, allows complete circumvention of the punishment mechanism, and enables persistent malicious activity that threatens the blockchain's security guarantees.

## Likelihood Explanation

**Automatically Triggered:** The vulnerability is part of the normal consensus block production flow through `GenerateNextRoundInformation`, requiring no special permissions or attacker intervention to be invoked during regular round transitions.

**Realistic Preconditions:**
1. Multiple miners marked as evil in the same term (naturally occurs through network issues, bugs, or coordinated attacks)
2. Limited alternative candidates in the election snapshot (common during periods of low voter participation)
3. Most initial miners already in the current miner list or also banned (typical in mature blockchain networks)

**High Execution Practicality:** The scenario occurs naturally when election participation is low, multiple miners fail simultaneously, or the initial miner set is largely exhausted. Attackers controlling multiple miner nodes can deliberately cause time slot misses across their nodes, and with shallow candidate pools, some nodes will remain active despite being marked evil.

**Limited Detection:** The mismatch is only visible through debug logs, and unreplaced evil miners continue normal operation, making the issue difficult to detect without specifically monitoring the banned pubkey map against active miner lists.

**Likelihood: High** - All preconditions are realistic in production environments, especially during low election participation periods or network stress events.

## Recommendation

The replacement loop should iterate over the evil miners list and handle the case where there are insufficient alternatives. Suggested fix:

```csharp
if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
{
    var alternativeCount = minerReplacementInformation.AlternativeCandidatePubkeys.Count;
    
    // Replace as many evil miners as we have alternatives for
    for (var i = 0; i < alternativeCount; i++)
    {
        var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
        var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
        
        // ... existing replacement logic ...
        
        currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
        currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
    }
    
    // Remove remaining evil miners without replacements to maintain security
    for (var i = alternativeCount; i < minerReplacementInformation.EvilMinerPubkeys.Count; i++)
    {
        var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
        UpdateCandidateInformation(evilMinerPubkey,
            currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
            currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);
        currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
    }
    
    isMinerListChanged = true;
}
```

Alternatively, add a validation check in `MiningPermissionValidationProvider` to reject blocks from banned miners, though removing them from the miner list is the correct fix.

## Proof of Concept

```csharp
[Fact]
public async Task BannedMinersRemainInConsensus_WhenInsufficientAlternatives()
{
    // Setup: Initialize chain with initial miners
    await InitializeContracts();
    
    // Scenario: 5 miners, 3 become evil, only 1 alternative candidate available
    
    // Step 1: Fast forward to accumulate 4320 missed time slots for 3 miners
    for (int i = 0; i < 4320; i++)
    {
        // Miners at indices 0, 1, 2 miss their time slots
        await MineEmptyBlock();
    }
    
    // Step 2: Trigger evil miner detection
    var currentRound = await GetCurrentRound();
    var evilMiners = currentRound.RealTimeMinersInformation.Values
        .Where(m => m.MissedTimeSlots >= 4320)
        .Select(m => m.Pubkey)
        .ToList();
    
    // Verify 3 evil miners detected
    evilMiners.Count.ShouldBe(3);
    
    // Step 3: Verify only 1 alternative candidate available (low election participation)
    var replacementInfo = await ElectionContractStub.GetMinerReplacementInformation.CallAsync(
        new GetMinerReplacementInformationInput
        {
            CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
        });
    
    replacementInfo.EvilMinerPubkeys.Count.ShouldBe(3);
    replacementInfo.AlternativeCandidatePubkeys.Count.ShouldBe(1); // Only 1 available
    
    // Step 4: Trigger round transition - this should replace miners
    await ConsensusContractStub.NextRound.SendAsync(BuildNextRoundInput());
    
    // Step 5: VULNERABILITY - Check next round still contains 2 unreplaced evil miners
    var nextRound = await GetCurrentRound();
    
    var unreplacedEvilMiners = nextRound.RealTimeMinersInformation.Keys
        .Where(pubkey => evilMiners.Contains(pubkey))
        .ToList();
    
    // Expected: 0 evil miners remaining
    // Actual: 2 evil miners remaining (only 1 was replaced out of 3)
    unreplacedEvilMiners.Count.ShouldBe(2); // VULNERABILITY CONFIRMED
    
    // Step 6: Verify these banned miners can still produce blocks
    var bannedMiner = unreplacedEvilMiners[0];
    var isBanned = await ElectionContractStub.GetReplacedPubkey.CallAsync(
        new StringValue { Value = bannedMiner });
    
    // Miner is banned in Election contract
    (await ElectionContractStub.GetCandidates.CallAsync(new Empty()))
        .Value.Any(c => c.ToHex() == bannedMiner).ShouldBeFalse();
    
    // But can still produce blocks (block validation passes)
    await ProduceBlockAs(bannedMiner); // Should fail but succeeds
    
    // Step 7: Verify banned miner receives rewards
    var treasuryPeriod = await GetCurrentTermNumber();
    await TreasuryContractStub.Release.SendAsync(new ReleaseInput
    {
        PeriodNumber = treasuryPeriod
    });
    
    var minerRewards = await GetMinerRewards(bannedMiner);
    minerRewards.ShouldBeGreaterThan(0); // Banned miner still earns rewards
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-339)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-380)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L383-392)
```csharp
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L394-398)
```csharp
        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-822)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```
