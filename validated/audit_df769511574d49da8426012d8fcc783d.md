# Audit Report

## Title
Case-Insensitive Token Duplicate Registration via CrossChainCreateToken Bypass

## Summary
The `CrossChainCreateToken` method fails to enforce case-insensitive token uniqueness, allowing attackers to register duplicate tokens with different casing (e.g., "ABC" and "abc") as separate entities. This violates the protocol's fundamental invariant that token symbols must be case-insensitively unique.

## Finding Description

The vulnerability exists in how `CrossChainCreateToken` validates token existence before registration. The method performs only a case-sensitive check against `State.TokenInfos` [1](#0-0) , bypassing the case-insensitive duplicate protection that should be enforced.

In contrast, the normal token creation path properly prevents case-variant duplicates by calling `CheckTokenExists` before registration [2](#0-1) .

The `CheckTokenExists` method enforces case-insensitive uniqueness by checking the `InsensitiveTokenExisting` state map with uppercased symbols [3](#0-2) .

The `RegisterTokenInfo` method performs no duplicate checking—it only validates symbol format and unconditionally sets both the case-sensitive token info and the case-insensitive existence flag [4](#0-3) .

Since `CrossChainCreateToken` skips `CheckTokenExists`, an attacker can register case variants (e.g., "ABC" after "abc" already exists) by providing valid cross-chain proofs, resulting in:
- Multiple entries in `State.TokenInfos` with different cases ("abc" and "ABC")
- Both mapping to the same `State.InsensitiveTokenExisting["ABC"]` key (the later registration overwrites)
- Broken case-insensitive uniqueness invariant

## Impact Explanation

**Protocol Integrity Violation:**
The fundamental invariant that token symbols must be case-insensitively unique is broken. The `InsensitiveTokenExisting` state map [5](#0-4)  exists specifically to enforce this invariant, but it becomes unreliable when multiple case-variant tokens can be registered.

**User Confusion & Phishing Risk:**
Users cannot visually distinguish between "ABC" and "abc" tokens. Attackers can create malicious lookalike tokens to deceive users into transferring funds, granting approvals, or interacting with the wrong token. Token operations (transfers, approvals, burns) require exact symbol matching and may target unintended tokens.

**Operational Impact:**
Future legitimate token creators may be incorrectly blocked if attempting to register a symbol whose case-variant was maliciously registered. Token metadata queries become unreliable when multiple case-variants exist in the system.

**Severity: High** - Violates a core security invariant with a concrete exploitation path, though requires cross-chain infrastructure access.

## Likelihood Explanation

**Reachable Entry Point:**
`CrossChainCreateToken` is a public RPC method [6](#0-5)  callable by any address with valid cross-chain proofs.

**Preconditions:**
1. Source chain must be registered in `State.CrossChainTransferWhiteList` [7](#0-6)  (requires one-time governance approval, but once set up for legitimate cross-chain operations, remains persistently accessible)
2. Attacker must provide valid merkle proof of a `ValidateTokenInfoExists` transaction from the source chain [8](#0-7) 
3. Target symbol must not already exist with exact case in `State.TokenInfos`

**Attack Complexity:**
Moderate—requires cross-chain infrastructure setup but no special privileges beyond standard cross-chain operations. An attacker can create token "XYZ" on the source chain, then register "xyz" on the target chain via `CrossChainCreateToken`. No rate limiting or cooldown mechanisms prevent repeated exploitation.

**Detection Difficulty:**
The attack blends with legitimate cross-chain token registrations. No events or logs distinguish malicious from benign case-variant registrations.

**Economic Rationality:**
Cost is limited to cross-chain transaction fees plus token creation costs on the source chain. High payoff potential if attacker creates phishing tokens mimicking high-value assets.

**Likelihood: Medium** - Requires cross-chain access but is otherwise straightforward to execute once infrastructure is available.

## Recommendation

Add case-insensitive duplicate checking to `CrossChainCreateToken` before calling `RegisterTokenInfo`. The fix should call `CheckTokenExists` or implement equivalent validation:

```csharp
public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
{
    // ... existing validation code ...
    
    var tokenInfo = new TokenInfo
    {
        Symbol = validateTokenInfoExistsInput.Symbol,
        // ... other fields ...
    };
    
    var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
    if (State.TokenInfos[tokenInfo.Symbol] == null)
    {
        // ADD THIS CHECK BEFORE REGISTRATION:
        CheckTokenExists(tokenInfo.Symbol);
        
        RegisterTokenInfo(tokenInfo);
        // ... rest of the code ...
    }
    // ... rest of the method ...
}
```

This ensures that both normal `Create` and `CrossChainCreateToken` paths enforce the same case-insensitive uniqueness invariant.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_CaseInsensitiveDuplicate_ShouldFail()
{
    var sideChainId = await GenerateSideChainAsync();
    await RegisterMainChainTokenContractAddressOnSideChainAsync(sideChainId);
    
    // Step 1: Create token "ABC" on target (main) chain normally
    var upperSymbol = "ABC";
    await CreateTokenAsync(TokenContractStub, DefaultAccount.Address, upperSymbol);
    
    // Verify "ABC" exists
    var upperTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = upperSymbol });
    upperTokenInfo.Symbol.ShouldBe(upperSymbol);
    
    // Step 2: Create token "abc" on source (side) chain
    var lowerSymbol = "abc";
    var createTransaction = await CreateTransactionForTokenCreation(
        SideChainTokenContractStub, 
        SideChainTestKit.DefaultAccount.Address,
        lowerSymbol, 
        SideTokenContractAddress);
    var executedSet = await SideChainTestKit.MineAsync(new List<Transaction> { createTransaction });
    
    // Step 3: Get validation transaction from side chain
    var createdTokenInfo = await SideChainTokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = lowerSymbol });
    var tokenValidationTransaction = CreateTokenInfoValidationTransaction(
        createdTokenInfo, 
        SideChainTokenContractStub);
    
    executedSet = await SideChainTestKit.MineAsync(new List<Transaction> { tokenValidationTransaction });
    var merklePath = GetTransactionMerklePathAndRoot(tokenValidationTransaction, out var blockRoot);
    await BootMinerChangeRoundAsync(AEDPoSContractStub, true);
    await MainAndSideIndexAsync(sideChainId, executedSet.Height, blockRoot);
    var boundParentChainHeightAndMerklePath = 
        await GetBoundParentChainHeightAndMerklePathByHeight(executedSet.Height);
    
    // Step 4: Attempt to register "abc" on main chain via CrossChainCreateToken
    var crossChainCreateTokenInput = new CrossChainCreateTokenInput
    {
        FromChainId = sideChainId,
        ParentChainHeight = boundParentChainHeightAndMerklePath.BoundParentChainHeight,
        TransactionBytes = tokenValidationTransaction.ToByteString(),
        MerklePath = merklePath
    };
    crossChainCreateTokenInput.MerklePath.MerklePathNodes.AddRange(
        boundParentChainHeightAndMerklePath.MerklePathFromParentChain.MerklePathNodes);
    
    // This should fail but currently succeeds, allowing duplicate case-variant
    var result = await TokenContractStub.CrossChainCreateToken.SendAsync(crossChainCreateTokenInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // BUG: Should fail!
    
    // Step 5: Verify both "ABC" and "abc" now exist (vulnerability demonstrated)
    var lowerTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = lowerSymbol });
    lowerTokenInfo.Symbol.ShouldBe(lowerSymbol); // This succeeds - case variant created!
    
    // Both tokens exist with different cases, violating case-insensitive uniqueness
    upperTokenInfo.Symbol.ShouldBe("ABC");
    lowerTokenInfo.Symbol.ShouldBe("abc");
}
```

This test demonstrates that after creating "ABC" normally, an attacker can use `CrossChainCreateToken` to register "abc" as a separate token, breaking the case-insensitive uniqueness invariant.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-87)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-478)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-482)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L486-488)
```csharp
        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-506)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L17-17)
```csharp
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
```
