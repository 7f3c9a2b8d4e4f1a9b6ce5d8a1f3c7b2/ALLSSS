# Audit Report

## Title
Hex Encoding Case Sensitivity Causes Miner DoS Through Candidate Replacement

## Summary
The consensus contract's `RecordCandidateReplacement` method accepts pubkey strings without case normalization, while all normal operations use lowercase hex from `.ToHex()`. This allows a candidate admin to replace a miner's pubkey with an uppercase variant, causing dictionary key mismatches that prevent the miner from producing blocks.

## Finding Description

The vulnerability exists in the interaction between the Election Contract's pubkey replacement flow and the Consensus Contract's miner information storage.

**Root Cause - Missing Case Normalization:**

The `RecordCandidateReplacement` method directly uses input strings as dictionary keys without normalization: [1](#0-0) 

**Normal Flow Uses Lowercase:**

The `.ToHex()` method produces lowercase hexadecimal characters. The encoding formula `b + 0x37 + 0x20` generates lowercase 'a'-'f' (ASCII 97-102): [2](#0-1) 

All miner dictionary keys are initialized using `.ToHex()`, creating lowercase entries: [3](#0-2) 

**Dictionary Access in Block Production:**

When generating consensus data, the miner's pubkey is converted to lowercase and used to access the dictionary: [4](#0-3) [5](#0-4) 

**Dictionary Access in Consensus Commands:**

The `GetConsensusCommand` method also converts to lowercase and checks miner list membership: [6](#0-5) [7](#0-6) 

The `IsInMinerList` check performs case-sensitive dictionary lookup: [8](#0-7) 

**Attack Entry Point:**

The Election Contract's `ReplaceCandidatePubkey` accepts string pubkeys without format validation and passes them directly to the consensus contract: [9](#0-8) [10](#0-9) 

The protobuf message has no format constraints: [11](#0-10) 

## Impact Explanation

**Direct Consensus Impact:**
- When a miner's pubkey is replaced with an uppercase variant, the dictionary contains an uppercase key while all lookups use lowercase
- `GetConsensusCommand` returns `InvalidConsensusCommand` because `IsInMinerList` fails (line 26-27 of ACS4 provider)
- `GetConsensusBlockExtraData` throws `KeyNotFoundException` when accessing the dictionary (line 58-63)
- The affected miner becomes completely unable to produce blocks

**Consensus Integrity:**
- Affected miners miss their assigned time slots, causing consensus delays
- If multiple miners are affected, block production speed decreases significantly
- Other miners must compensate, potentially centralizing consensus power
- No automatic recovery mechanism exists

**Severity Justification:**
HIGH - This is a direct DoS attack on core consensus functionality. Unlike availability issues that degrade performance, this completely prevents specific miners from participating in consensus, violating the fundamental guarantee that elected miners can produce blocks.

## Likelihood Explanation

**Attacker Profile:**
The attacker is a candidate admin - a non-privileged role that candidates set themselves during election registration. This role is designed for operational management and requires no special permissions beyond being designated by the candidate.

**Attack Execution:**
1. Candidate admin calls `Election.ReplaceCandidatePubkey`
2. Provides uppercase hex string as `new_pubkey` parameter
3. Single transaction, no complex timing or state requirements
4. No economic cost beyond transaction fee

**Feasibility:**
- **Preconditions**: Candidate must be an active miner (common scenario in normal operations)
- **Technical Complexity**: Trivial - just use uppercase characters in hex string
- **Detection**: Not immediately apparent; only discovered when miner attempts block production
- **Accidental Trigger**: Possible if developers/admins use uppercase hex strings (common in blockchain tooling)

**Likelihood Assessment:**
MEDIUM-HIGH - While requiring candidate admin access, this role is non-privileged and the attack is trivially simple. More concerningly, this can occur accidentally when using standard hex representations, making it a realistic operational risk even without malicious intent.

## Recommendation

Add case normalization in `RecordCandidateReplacement` before dictionary operations:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    // Normalize case to lowercase
    var oldPubkey = input.OldPubkey.ToLower();
    var newPubkey = input.NewPubkey.ToLower();

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(oldPubkey)) return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[oldPubkey];
    realTimeMinerInformation.Pubkey = newPubkey;
    currentRound.RealTimeMinersInformation.Remove(oldPubkey);
    currentRound.RealTimeMinersInformation.Add(newPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == oldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = newPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = oldPubkey,
        NewPubkey = newPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Additionally, add input validation in `ReplaceCandidatePubkey` to normalize case before cross-contract calls, ensuring consistency across the entire replacement flow.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task ReplaceCandidatePubkey_UppercaseHex_CausesMinerDoS()
{
    // Setup: Create and elect a candidate as miner
    var minerKeyPair = SampleAccount.Accounts[0].KeyPair;
    var minerPubkey = minerKeyPair.PublicKey.ToHex(); // lowercase
    
    // Announce election and become miner
    await ElectionContractStub.AnnounceElection.SendAsync(Address.FromPublicKey(minerKeyPair.PublicKey));
    await AdvanceToNextTerm(); // Elect as miner
    
    // Verify miner can produce blocks normally
    var consensusCommand = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = minerKeyPair.PublicKey });
    Assert.NotEqual(AElfConsensusBehaviour.Invalid, consensusCommand.Hint);
    
    // Attack: Replace with uppercase variant
    var newKeyPair = SampleAccount.Accounts[1].KeyPair;
    var uppercasePubkey = newKeyPair.PublicKey.ToHex().ToUpper(); // UPPERCASE
    
    await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerPubkey,
        NewPubkey = uppercasePubkey // Attack vector: uppercase hex
    });
    
    // Verify DoS: Miner can no longer get consensus commands
    var result = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = newKeyPair.PublicKey });
    
    // Expected: Returns InvalidConsensusCommand because IsInMinerList fails
    // Dictionary has uppercase key but lookup uses lowercase
    Assert.Equal(AElfConsensusBehaviour.Invalid, result.Hint);
    
    // Attempting to produce block would throw KeyNotFoundException
    // when accessing RealTimeMinersInformation[lowercasePubkey]
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-143)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L37-41)
```csharp
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L16-17)
```csharp
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L22-23)
```csharp
        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L19-19)
```csharp
        _processingBlockMinerPubkey = input.Value.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-181)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** protobuf/election_contract.proto (L504-507)
```text
message ReplaceCandidatePubkeyInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
}
```
