# Audit Report

## Title
Missing Term Period Validation Allows Premature Term Transitions

## Summary
The AEDPoS consensus contract lacks on-chain validation to verify that the configured term period has elapsed before allowing term transitions. While timing checks exist during off-chain consensus command generation, they are never re-validated during block validation or execution, allowing malicious miners to force premature term transitions and trigger early treasury releases, reward distributions, and election snapshots.

## Finding Description

The vulnerability exists in a critical architectural gap between consensus command generation (off-chain) and validation/execution flows (on-chain).

**Command Generation (Off-Chain):** The timing check occurs in `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` which calls `CurrentRound.NeedToChangeTerm()` with `blockchainStartTimestamp` and `periodSeconds` parameters. [1](#0-0)  This method validates whether sufficient miners have `ActualMiningTimes` satisfying the term period threshold using `IsTimeToChangeTerm()`. [2](#0-1) 

**Missing Validation in Block Validation:** When `ValidateBeforeExecution()` processes `NextTerm` behavior, it only adds `RoundTerminateValidationProvider` without any timing checks. [3](#0-2) 

The `RoundTerminateValidationProvider.ValidationForNextTerm()` only validates structural correctness: round number increments by 1, InValues are null, and term number increments by 1. It performs no timing verification. [4](#0-3) 

Critically, `ConsensusValidationContext` does not contain `periodSeconds` or `blockchainStartTimestamp` parameters needed for timing validation. [5](#0-4) 

**Missing Validation in Execution:** During `ProcessNextTerm()`, the only validation is `TryToUpdateTermNumber()` which merely checks that the new term number equals the current term number plus one, without any timing verification. [6](#0-5) [7](#0-6) 

**Attack Vector:** A malicious miner can:
1. Modify their node software to bypass the local `NeedToChangeTerm()` check in command generation
2. Generate valid `NextTermInput` with properly structured Round data (correct round/term number increments, null InValues)
3. Submit a block with `NextTerm` behavior before the term period expires (e.g., on day 3 of a 7-day term)
4. The block passes all validation checks because no timing validation exists in the on-chain validation pipeline
5. `ProcessNextTerm()` executes all economic actions prematurely

## Impact Explanation

**Consensus Timing Invariant Violation:** The attack breaks the fundamental term period invariant that ensures terms last the configured duration (default 604800 seconds = 7 days). This allows attackers to arbitrarily accelerate term transitions.

**Economic Impact:** Premature term transitions trigger three critical economic actions unconditionally:

1. **Treasury Release:** `State.TreasuryContract.Release.Send()` distributes treasury funds before the scheduled time. [8](#0-7) 

2. **Mining Reward Donations:** `DonateMiningReward()` calculates and donates mining rewards to Treasury ahead of schedule. [9](#0-8) [10](#0-9) 

3. **Election Snapshot Manipulation:** `State.ElectionContract.TakeSnapshot.Send()` creates election snapshots at incorrect times, affecting staking reward calculations. [11](#0-10) 

All network participants suffer from disrupted economic schedules, incorrect reward timing, and potential manipulation of election outcomes.

## Likelihood Explanation

**Attacker Capabilities:** Requires being in the current miner list, which is realistic:
- Miners are elected through public staking mechanisms
- A compromised or malicious miner is within the threat model
- The `MiningPermissionValidationProvider` only checks that the sender is in the current miner list [12](#0-11) 

**Attack Complexity:** Moderate - requires modifying node software to override consensus behavior determination, but does not require breaking cryptography or complex state manipulation.

**Execution Practicality:** High - the attack path is straightforward:
1. Miner produces block during normal operation (e.g., day 3 of 7-day term)
2. Modified node forces `NextTerm` behavior instead of `NextRound`
3. Block passes all validation checks (structural only, no timing)
4. Term changes 4 days early

**Detection Difficulty:** Real-time detection is difficult as the block appears structurally valid. Only observable by monitoring term transition frequency against expected schedule.

**Economic Rationality:** Attack cost is zero (already a miner). Potential benefits include manipulating treasury release timing for front-running opportunities or coordinating with governance proposals timed to specific terms.

## Recommendation

Add term period timing validation to the on-chain validation and/or execution flow:

**Option 1: Add timing validation to `RoundTerminateValidationProvider.ValidationForNextTerm()`**
- Include `blockchainStartTimestamp` and `periodSeconds` in `ConsensusValidationContext`
- Call `IsTimeToChangeTerm()` during validation to verify sufficient time has elapsed

**Option 2: Add timing validation to `ProcessNextTerm()`**
- Before executing economic actions, verify term period timing using state variables
- Assert that `NeedToChangeTerm()` returns true with current round information

**Recommended Implementation:**
```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Check term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // NEW: Verify term period timing
    if (!validationContext.BaseRound.NeedToChangeTerm(
        validationContext.BlockchainStartTimestamp,
        validationContext.CurrentTermNumber,
        validationContext.PeriodSeconds))
        return new ValidationResult { Message = "Term period has not elapsed." };

    return new ValidationResult { Success = true };
}
```

This requires extending `ConsensusValidationContext` to include the necessary timing parameters.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up an AEDPoS test environment with multiple miners
2. Configuring a term period (e.g., 7 days)
3. Having a miner submit a `NextTerm` transaction on day 3 with:
   - `TermNumber = currentTerm + 1`
   - `RoundNumber = currentRound + 1`
   - Properly structured Round data with null InValues
4. Observing that the transaction succeeds despite insufficient time elapsed
5. Verifying that treasury release, mining reward donation, and election snapshot occur prematurely

The test would demonstrate that `ValidateBeforeExecution()` passes all checks and `ProcessNextTerm()` executes successfully without any timing validation, proving that the term period invariant is not enforced on-chain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-243)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }

    /// <summary>
    ///     If periodSeconds == 7:
    ///     1, 1, 1 => 0 != 1 - 1 => false
    ///     1, 2, 1 => 0 != 1 - 1 => false
    ///     1, 8, 1 => 1 != 1 - 1 => true => term number will be 2
    ///     1, 9, 2 => 1 != 2 - 1 => false
    ///     1, 15, 2 => 2 != 2 - 1 => true => term number will be 3.
    /// </summary>
    /// <param name="blockchainStartTimestamp"></param>
    /// <param name="termNumber"></param>
    /// <param name="blockProducedTimestamp"></param>
    /// <param name="periodSeconds"></param>
    /// <returns></returns>
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L173-174)
```csharp
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
