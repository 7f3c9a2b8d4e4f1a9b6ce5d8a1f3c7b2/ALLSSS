# Audit Report

## Title
Early Loop Termination in GetAvailableSymbolToPayTxFee Prevents Primary Token Fallback for Delegations

## Summary
The `GetAvailableSymbolToPayTxFee()` method in the MultiToken contract contains a critical logic error where it uses `break` instead of `continue` when checking delegation sufficiency across multiple fee payment tokens. This causes the loop to terminate prematurely when an early token lacks sufficient delegation allowance, preventing evaluation of remaining tokens including the mandatory primary token. Users with valid delegations and sufficient balances in unevaluated tokens cannot pay transaction fees, resulting in denial of service for transaction execution.

## Finding Description

The vulnerability exists in the token selection logic for transaction size fee payment when delegation is configured. The `GetAvailableSymbolToPayTxFee()` method iterates through all configured tokens in `SymbolsToPayTxSizeFee` to find a suitable token for fee payment. [1](#0-0) 

When delegation is present, the code checks if each token has sufficient delegation allowance. The critical flaw exists where when this check returns false (delegation insufficient), the code executes `break`, which exits the entire loop immediately rather than continuing to check remaining tokens: [2](#0-1) 

All four tracking variables remain null when the loop breaks early, and the function returns null: [3](#0-2) 

When called from `ChargeSizeFee()`, a null return in delegation scenarios triggers immediate failure: [4](#0-3) 

The vulnerability is compounded by the protocol invariant that the primary token MUST be included in the `SymbolsToPayTxSizeFee` list: [5](#0-4) 

However, there is no ordering constraint on where the primary token appears in the list. If the list is configured as `[TOKEN_A, TOKEN_B, ELF]` and TOKEN_A lacks sufficient delegation allowance, the loop breaks before ever evaluating TOKEN_B or ELF, even if they have adequate delegation and balance.

The entry point for this vulnerability is the publicly accessible `ChargeTransactionFees()` method, which is automatically invoked by the ACS1 pre-execution plugin for every transaction: [6](#0-5) 

The delegation checking logic confirms that per-token delegation limits are supported: [7](#0-6) 

## Impact Explanation

**Severity: HIGH**

This vulnerability causes denial of service for transaction fee payment, which is a fundamental blockchain operation. The impact manifests in several critical ways:

1. **Operational DoS**: Users with valid delegation allowances and sufficient token balances cannot execute transactions because the fee charging mechanism fails prematurely. The failure occurs silently without evaluating all available tokens.

2. **Invariant Violation**: The protocol enforces that the primary token must always be available for fee payment (as evidenced by the mandatory inclusion requirement at line 642). This vulnerability breaks that invariant by potentially preventing the primary token from ever being evaluated.

3. **No Workaround**: Affected users cannot bypass this issue. The token list ordering is controlled by governance through `SetSymbolsToPayTxSizeFee()`, and individual users cannot modify it. Users with delegations set up for the primary token but not for earlier tokens in the list will be completely unable to transact.

4. **User Fund Lockup**: While user funds are not permanently lost, they become effectively unusable for transaction execution. Users cannot transfer tokens, execute contracts, or perform any blockchain operations that require transaction fees.

The severity is HIGH because it affects core protocol functionality (transaction execution), has no user-level workaround, and can impact any user utilizing the delegation feature with multi-token fee payment configurations.

## Likelihood Explanation

**Likelihood: HIGH**

All preconditions for this vulnerability are realistic and likely to occur in production environments:

1. **Multi-Token Configuration**: The protocol explicitly supports multiple tokens for size fee payment through `SetSymbolsToPayTxSizeFee()`. This is a documented feature, not an edge case.

2. **Delegation Usage**: Transaction fee delegation is a standard protocol feature that allows delegatees to pay fees on behalf of delegators. This is commonly used for sponsored transactions and improved user experience.

3. **Per-Token Delegation Limits**: The delegation system allows different allowance amounts per token, as confirmed by the delegation check logic. It is entirely realistic for a delegatee to have sufficient allowance for some tokens but not others.

4. **Arbitrary Token Ordering**: There is no enforced ordering of tokens in `SymbolsToPayTxSizeFee`. Governance can configure tokens in any order, and there's no requirement that the primary token appears first.

5. **No Special Privileges Required**: This vulnerability affects normal users performing standard transactions. No special permissions or attack setup is needed.

The combination of these realistic conditions makes this vulnerability highly likely to manifest in production, particularly in scenarios where multiple tokens are configured for fee payment flexibility and delegation is used with varying per-token limits.

## Recommendation

Change the `break` statement to `continue` on line 480 to allow the loop to evaluate all available tokens instead of terminating prematurely:

```csharp
if (delegations != null)
{
    var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
        symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
        txSizeFeeAmount, delegations);
    if (!delegationEnough) continue; // Changed from break to continue
}
```

This ensures that when a token has insufficient delegation, the algorithm skips it and evaluates the next token in the list, eventually reaching tokens with sufficient delegation (including the mandatory primary token).

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task ChargeTransactionFee_Delegation_EarlyBreak_Vulnerability_Test()
{
    // Setup: Create two tokens - SIZE (insufficient delegation) and ELF (sufficient delegation)
    await SetPrimaryTokenSymbolAsync();
    var sizeFeeSymbol = "SIZE";
    await CreateTokenAsync(DefaultSender, sizeFeeSymbol);
    
    // Issue tokens to delegatee
    await IssueTokenToUserAsync(NativeTokenSymbol, 10000, DelegateeAddress);
    await IssueTokenToUserAsync(sizeFeeSymbol, 10000, DelegateeAddress);
    
    // Configure delegation: SIZE has 0 (insufficient), ELF has 1000 (sufficient)
    var delegations = new Dictionary<string, long>
    {
        [sizeFeeSymbol] = 0,        // Insufficient for size fee
        [NativeTokenSymbol] = 1000  // Sufficient for size fee
    };
    
    var delegateInfo = new DelegateInfo
    {
        Delegations = { delegations },
        IsUnlimitedDelegate = false,
        MethodName = nameof(TokenContractContainer.TokenContractStub.Transfer),
        ContractAddress = TokenContractAddress
    };
    
    await TokenContractStubDelegate1.SetTransactionFeeDelegateInfos.SendAsync(
        new SetTransactionFeeDelegateInfosInput
        {
            DelegatorAddress = DefaultSender,
            DelegateInfoList = { delegateInfo }
        });
    
    // Configure token list with SIZE first, then ELF
    var sizeFeeSymbolList = new SymbolListToPayTxSizeFee
    {
        SymbolsToPayTxSizeFee =
        {
            new SymbolToPayTxSizeFee
            {
                TokenSymbol = sizeFeeSymbol,
                AddedTokenWeight = 1,
                BaseTokenWeight = 1
            },
            new SymbolToPayTxSizeFee
            {
                TokenSymbol = NativeTokenSymbol,
                AddedTokenWeight = 1,
                BaseTokenWeight = 1
            }
        }
    };
    
    await TokenContractImplStub.SetSymbolsToPayTxSizeFee.SendAsync(sizeFeeSymbolList);
    
    // Attempt to charge transaction fee
    var chargeTransactionFeesInput = new ChargeTransactionFeesInput
    {
        MethodName = nameof(TokenContractContainer.TokenContractStub.Transfer),
        ContractAddress = TokenContractAddress,
        TransactionSizeFee = 100
    };
    chargeTransactionFeesInput.SymbolsToPayTxSizeFee.AddRange(sizeFeeSymbolList.SymbolsToPayTxSizeFee);
    
    var result = await TokenContractStub.ChargeTransactionFees.SendAsync(chargeTransactionFeesInput);
    
    // BUG: This should succeed because ELF has sufficient delegation (1000 > 100)
    // But it fails because the loop breaks when checking SIZE token
    result.Output.Success.ShouldBe(false); // Current buggy behavior
    // Expected: result.Output.Success.ShouldBe(true); // After fix
}
```

This test proves the vulnerability by demonstrating that even with sufficient delegation for the primary token (ELF with 1000 allowance), the transaction fails when an earlier token (SIZE with 0 allowance) is evaluated first due to the premature loop termination.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L410-415)
```csharp
            //For delegation,if there is no available token,return false,no need to generate bill
            if (delegations != null && availableSymbol == null)
            {
                return false;
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L462-473)
```csharp
    private SymbolToPayTxSizeFee GetAvailableSymbolToPayTxFee(List<SymbolToPayTxSizeFee> allSymbolToTxFee,
        Address fromAddress, long txSizeFeeAmount, TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        string symbolChargedForBaseFee, long amountChargedForBaseFee, long amountChargedForBaseAllowance,
        TransactionFeeDelegations delegations = null)
    {
        SymbolToPayTxSizeFee availableSymbol = null;
        SymbolToPayTxSizeFee availableSymbolWithAnything = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalance = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalancePlusAllowance = null;

        // get 1st Allowance > size fee, else, get 1st Balance + Allowance > 0, else get 1st > 0
        foreach (var symbolToPlayTxSizeFee in allSymbolToTxFee)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L475-481)
```csharp
            if (delegations != null)
            {
                var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                    symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
                    txSizeFeeAmount, delegations);
                if (!delegationEnough) break;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L513-517)
```csharp
        availableSymbol ??= availableSymbolWithEnoughBalancePlusAllowance ??
                            availableSymbolWithEnoughBalance ?? availableSymbolWithAnything;

        return availableSymbol;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L621-642)
```csharp
        var isPrimaryTokenExist = false;
        var symbolList = new List<string>();
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty());
        Assert(!string.IsNullOrEmpty(primaryTokenSymbol.Value), "primary token does not exist");
        foreach (var tokenWeightInfo in input.SymbolsToPayTxSizeFee)
        {
            if (tokenWeightInfo.TokenSymbol == primaryTokenSymbol.Value)
            {
                isPrimaryTokenExist = true;
                Assert(tokenWeightInfo.AddedTokenWeight == 1 && tokenWeightInfo.BaseTokenWeight == 1,
                    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be 1");
            }

            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
            Assert(!symbolList.Contains(tokenWeightInfo.TokenSymbol),
                $"symbol:{tokenWeightInfo.TokenSymbol} repeat");
            AssertSymbolToPayTxFeeIsValid(tokenWeightInfo.TokenSymbol, out var addedTokenTotalSupply);
            symbolList.Add(tokenWeightInfo.TokenSymbol);
        }

        Assert(isPrimaryTokenExist, $"primary token:{primaryTokenSymbol.Value} not included");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1399-1410)
```csharp
    private bool IsDelegationEnough(string txSymbol, string baseSymbol, long cost,
        long txSizeFeeAmount, TransactionFeeDelegations delegations)
    {
        if (!delegations.IsUnlimitedDelegate)
        {
            return delegations.Delegations.ContainsKey(txSymbol) && (baseSymbol == txSymbol
                ? delegations.Delegations[txSymbol].Sub(cost)
                : delegations.Delegations[txSymbol]) >= txSizeFeeAmount;
        }

        return true;
    }
```
