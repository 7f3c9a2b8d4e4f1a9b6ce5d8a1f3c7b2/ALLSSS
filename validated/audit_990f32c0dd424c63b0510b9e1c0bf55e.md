# Audit Report

## Title
Missing Consensus Behavior Validation Allows Malicious Miner to Force Premature Term Change

## Summary
A malicious miner can force premature term transitions by providing `NextTerm` behavior when `NextRound` should be used. The on-chain validation only verifies that term numbers increment correctly but fails to re-verify the `NeedToChangeTerm` criteria, allowing invalid consensus state transitions that trigger premature elections and reward distributions.

## Finding Description

The vulnerability exists due to a critical separation between off-chain behavior determination and on-chain behavior validation:

**Off-chain Behavior Determination (Honest Flow):**

The `MainChainConsensusBehaviourProvider` determines whether to use `NextTerm` or `NextRound` behavior by calling `NeedToChangeTerm()`, which checks if at least two-thirds of miners have `ActualMiningTimes` indicating a term change is warranted based on the configured period. [1](#0-0) 

The `NeedToChangeTerm()` method enforces the two-thirds consensus threshold by counting miners whose latest `ActualMiningTimes` satisfy the term change criteria. [2](#0-1) 

**Exploitable Entry Point:**

The contract's `GetConsensusBlockExtraData` method accepts miner-provided trigger information and switches on the `Behaviour` field without validation, directly generating consensus data based on this untrusted input. [3](#0-2) 

The `Behaviour` field is a simple protobuf enum field that can be set to any value by the miner. [4](#0-3) 

**Missing On-chain Validation:**

During block validation, the `ValidateBeforeExecution` method only adds `RoundTerminateValidationProvider` for `NextTerm` behavior, without any validator that checks `NeedToChangeTerm()`. [5](#0-4) 

The `ValidationForNextTerm` method only verifies that term and round numbers increment by 1, but does NOT re-verify the consensus criteria that should trigger a term change. [6](#0-5) 

**Attack Execution:**

When validation passes, `ProcessNextTerm` executes unconditionally, performing critical state transitions including term number updates, miner list changes, reward distribution, and treasury release. [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation:**
- Forces premature term transitions, violating the AEDPoS consensus invariant that requires two-thirds miner agreement for term changes
- Disrupts the round/term state machine, causing desynchronization between expected and actual term numbers
- Triggers election processes prematurely, potentially manipulating miner selection timing to favor the attacker

**Economic Impact:**
- Term changes trigger mining reward distribution through `DonateMiningReward` and treasury release operations that are tied to term boundaries, allowing attackers to manipulate the timing of substantial economic events
- Election snapshots taken at term boundaries affect vote-weight calculations and reward allocations for subsequent terms
- The `MinersCountOfConsent` threshold calculation depends on correct term timing to ensure Byzantine fault tolerance [8](#0-7) 

**Operational Impact:**
- Honest nodes following correct consensus rules may reject blocks with manipulated term changes, causing chain forks
- Cross-chain operations and term-based contract logic operate on incorrect term values
- Miner list updates occur prematurely, affecting consensus participation

## Likelihood Explanation

**High Feasibility:**
- Attacker only needs to be an elected miner, achievable through the normal voting process
- Attack requires simple modification of client-side node software to set arbitrary `Behaviour` value in the `AElfConsensusTriggerInformation` message
- No cryptographic breaks, complex timing constraints, or race conditions required

**Low Complexity:**
- Single malicious block with wrong behavior triggers the state corruption
- The validation gap is deterministic and always exploitable when preconditions are met
- No economic costs beyond normal miner operation

**Difficult Detection:**
- Validation appears to pass successfully from an external observer's perspective
- Term number increment is mathematically valid (incrementing by 1), only the timing is premature
- Requires deep knowledge of consensus rules to detect the manipulation

## Recommendation

Add validation in `ValidationForNextTerm` to re-verify the `NeedToChangeTerm()` criteria:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Verify term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // ADD THIS: Re-verify that term change is actually warranted
    var blockchainStartTimestamp = State.BlockchainStartTimestamp.Value;
    var periodSeconds = State.PeriodSeconds.Value;
    if (!validationContext.BaseRound.NeedToChangeTerm(
        blockchainStartTimestamp, 
        validationContext.CurrentTermNumber, 
        periodSeconds))
    {
        return new ValidationResult { 
            Success = false, 
            Message = "Term change criteria not met - insufficient miner consensus." 
        };
    }
    
    return new ValidationResult { Success = true };
}
```

## Proof of Concept

The vulnerability can be demonstrated by a malicious miner:

1. Wait until elected as a miner through normal voting
2. Modify node software to override the `Behaviour` field in `AElfConsensusTriggerInformation` to `AElfConsensusBehaviour.NextTerm` regardless of what `GetConsensusCommand` returns
3. When producing a block during normal operation (when `NeedToChangeTerm()` would return false), provide the modified trigger information
4. The block validation passes because `ValidationForNextTerm` only checks term number increment
5. `ProcessNextTerm` executes, prematurely advancing the term number and triggering elections/rewards

The test would verify:
- Term number advances without meeting the two-thirds miner consensus threshold
- Reward distribution and treasury release occur prematurely
- Election snapshot is taken at the wrong time

**Notes**

This is a trust boundary violation where off-chain logic determines behavior based on consensus rules, but on-chain validation fails to re-verify those same rules. The contract treats miner-provided behavior as trusted input rather than validating it against the current consensus state. This violates the principle that smart contracts must validate all externally-provided data, especially for consensus-critical operations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L13-48)
```csharp
    private BytesValue GetConsensusBlockExtraData(BytesValue input, bool isGeneratingTransactions = false)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);

        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");

        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();

        var information = new AElfConsensusHeaderInformation();
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }
```

**File:** protobuf/aedpos_contract.proto (L329-337)
```text
message AElfConsensusTriggerInformation {
    // The miner public key.
    bytes pubkey = 1;
    // The InValue for current round.
    aelf.Hash in_value = 2;
    // The InValue for previous round.
    aelf.Hash previous_in_value = 3;
    // The behaviour of consensus.
    AElfConsensusBehaviour behaviour = 4;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```
