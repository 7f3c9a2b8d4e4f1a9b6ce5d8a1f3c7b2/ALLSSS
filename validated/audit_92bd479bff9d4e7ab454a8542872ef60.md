# Audit Report

## Title
Time Slot Validation Allows Malicious Round Crafting with Biased Mining Intervals

## Summary
The `CheckRoundTimeSlots()` validation function in the AEDPoS consensus contract uses an overly permissive 100% tolerance check, allowing mining intervals to range from 0 to 2× the base interval. A malicious extra block producer can exploit this by crafting a Round with manipulated time slots that passes validation but severely disrupts consensus through either DoS (impossibly short intervals) or significant slowdown (excessively long intervals).

## Finding Description

The AEDPoS consensus contract fails to verify that submitted Round information matches the deterministic output of `GenerateNextRoundInformation()`. Instead, it only validates mathematical properties through `CheckRoundTimeSlots()`: [1](#0-0) 

This tolerance check allows any mining interval where `|miningInterval - baseMiningInterval| <= baseMiningInterval`, meaning intervals can range from 0 to 2× the base value. The base interval itself is determined by the first two miners' time difference [2](#0-1) , giving the attacker full control.

**Attack Execution Path:**

1. When the malicious miner becomes extra block producer, the node generates legitimate consensus data via `GetConsensusExtraDataForNextRound()` [3](#0-2)  which calls `GenerateNextRoundInformation()` [4](#0-3) 

2. The attacker modifies their node software to manipulate the Round's `ExpectedMiningTime` values before block submission

3. During `ValidateBeforeExecution()`, the `TimeSlotValidationProvider` validates the Round [5](#0-4)  using only the 100% tolerance check

4. The malicious Round is stored to state via `ProcessNextRound()` [6](#0-5)  without comparing against expected generation

5. The manipulated mining interval propagates throughout consensus via `GetMiningInterval()` [7](#0-6) 

**Why Existing Protections Fail:**

The `ValidateAfterExecution()` method compares the header Round hash against the state Round hash [8](#0-7) , but this is ineffective because the state Round was already set from the same malicious transaction input during execution. This creates a circular validation that cannot detect the initial manipulation.

No constants enforce minimum or maximum bounds on mining intervals [9](#0-8) .

## Impact Explanation

**Consensus Disruption Scenarios:**

1. **DoS via Impossibly Short Intervals:** Setting the first two miners 1ms apart creates `baseMiningInterval = 1ms`. All subsequent miners must produce blocks within 0-2ms windows. Network latency alone exceeds this threshold, making block production physically impossible and halting consensus.

2. **Severe Slowdown via Extended Intervals:** Setting the first two miners 8000ms+ apart allows intervals up to 16000ms per block (vs. normal 4000ms), reducing throughput by 4× and degrading user experience.

The mining interval directly affects time slot validation [10](#0-9) , determining when each miner's production window expires.

**Affected Parties:**
- All network participants suffer consensus disruption
- Honest miners lose block rewards due to impossible time slots
- Users experience transaction delays or complete service outage
- Network security and liveness guarantees are violated

This constitutes a **HIGH** severity vulnerability as a single malicious miner can compromise consensus integrity for an entire round.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an elected miner (achievable through legitimate voting process)
- Must become the extra block producer for a round (rotates pseudo-randomly) [11](#0-10) 

**Attack Feasibility:**
- **Complexity:** LOW - Attacker modifies node software to craft Round with biased `ExpectedMiningTime` values while staying within 100% tolerance
- **Frequency:** Occurs every time the malicious miner becomes extra block producer (rotates based on signatures each round)
- **Detection:** DIFFICULT - No on-chain mechanism verifies semantic correctness, only mathematical properties

The attack is **repeatable and deterministic** - any compromised miner will eventually gain opportunity through normal protocol rotation.

**Likelihood Assessment:** MEDIUM-HIGH

## Recommendation

Implement strict semantic validation of Round information:

1. **Add Deterministic Round Verification:** In `ProcessNextRound()`, regenerate the expected Round using `GenerateNextRoundInformation()` and compare against the submitted Round:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Generate expected Round deterministically
    currentRound.GenerateNextRoundInformation(
        Context.CurrentBlockTime,
        GetBlockchainStartTimestamp(),
        out var expectedNextRound);
    
    // Verify submitted Round matches expected generation
    Assert(nextRound.GetHash(false) == expectedNextRound.GetHash(false),
        "Submitted Round does not match expected generation");
    
    // ... rest of processing
}
```

2. **Enforce Mining Interval Bounds:** Add constants for minimum/maximum acceptable mining intervals and validate them in `CheckRoundTimeSlots()`:

```csharp
private const int MinimumMiningInterval = 2000; // 2 seconds
private const int MaximumMiningInterval = 8000; // 8 seconds

public ValidationResult CheckRoundTimeSlots()
{
    // ... existing checks ...
    
    if (baseMiningInterval < MinimumMiningInterval || 
        baseMiningInterval > MaximumMiningInterval)
        return new ValidationResult { 
            Message = $"Mining interval {baseMiningInterval}ms outside acceptable range" 
        };
    
    // ... rest of validation
}
```

3. **Tighten Tolerance:** Reduce the 100% tolerance to a more reasonable value (e.g., 10-20%) to prevent extreme manipulation while allowing minor timing variations.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousExtraBlockProducer_CanDisruptConsensus_WithBiasedTimeSlots()
{
    // Setup: Initialize consensus with normal miners
    var initialMiners = GenerateInitialMiners();
    await InitializeConsensus(initialMiners);
    
    // Attacker becomes extra block producer for this round
    var maliciousProducer = initialMiners[0];
    
    // Generate legitimate Round
    var currentRound = await GetCurrentRoundInformation();
    currentRound.GenerateNextRoundInformation(
        TimestampHelper.GetUtcNow(),
        await GetBlockchainStartTimestamp(),
        out var legitimateNextRound);
    
    // Attack: Craft malicious Round with 1ms base interval
    var maliciousNextRound = legitimateNextRound.Clone();
    var firstMiner = maliciousNextRound.RealTimeMinersInformation.Values.First(m => m.Order == 1);
    var secondMiner = maliciousNextRound.RealTimeMinersInformation.Values.First(m => m.Order == 2);
    
    // Set impossibly short interval (1ms between first two miners)
    secondMiner.ExpectedMiningTime = firstMiner.ExpectedMiningTime.AddMilliseconds(1);
    
    // Recalculate subsequent miners to maintain 100% tolerance
    for (int i = 3; i <= maliciousNextRound.RealTimeMinersInformation.Count; i++)
    {
        var miner = maliciousNextRound.RealTimeMinersInformation.Values.First(m => m.Order == i);
        var prevMiner = maliciousNextRound.RealTimeMinersInformation.Values.First(m => m.Order == i - 1);
        miner.ExpectedMiningTime = prevMiner.ExpectedMiningTime.AddMilliseconds(1);
    }
    
    // Submit malicious NextRound transaction
    var result = await ExecuteConsensusTransaction(
        maliciousProducer,
        "NextRound",
        NextRoundInput.Create(maliciousNextRound, GenerateRandomNumber()));
    
    // Verify: Malicious Round passes validation and is stored
    result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var storedRound = await GetCurrentRoundInformation();
    var miningInterval = storedRound.GetMiningInterval();
    
    // Assert: Mining interval is now 1ms (impossible for honest miners)
    miningInterval.ShouldBe(1);
    
    // Demonstrate impact: Next miner cannot produce block in time
    var nextMiner = initialMiners[1];
    await AdvanceTime(TimeSpan.FromMilliseconds(2)); // Already past 1ms time slot
    
    var nextBlockResult = await ExecuteConsensusTransaction(
        nextMiner,
        "UpdateValue",
        CreateUpdateValueInput());
    
    // Verification should fail - miner missed their impossibly short time slot
    nextBlockResult.Status.ShouldBe(TransactionResultStatus.Failed);
    nextBlockResult.Error.ShouldContain("Time slot already passed");
}
```

**Notes:**

This vulnerability breaks the core security assumption that consensus validation ensures only legitimately generated Rounds can be accepted. The contract validates mathematical properties but fails to verify semantic correctness - that the submitted Round matches what the deterministic generation function would produce. This allows an elected miner to disrupt consensus without requiring any privileged keys or external attacks, making it a HIGH severity issue within the threat model of Byzantine-tolerant consensus systems.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-44)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L49-54)
```csharp
        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-178)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-36)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L44-45)
```csharp
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L1-16)
```csharp
namespace AElf.Contracts.Consensus.AEDPoS;

// ReSharper disable once InconsistentNaming
public static class AEDPoSContractConstants
{
    public const int MaximumTinyBlocksCount = 8;
    public const long InitialMiningRewardPerBlock = 12500000;
    public const long TimeToReduceMiningRewardByHalf = 126144000; // 60 * 60 * 24 * 365 * 4
    public const int SupposedMinersCount = 17;
    public const int KeepRounds = 40960;
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
    public const string SideChainShareProfitsTokenSymbol = "SHARE";
    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";
    public const string SecretSharingEnabledConfigurationKey = "SecretSharingEnabled";
}
```
