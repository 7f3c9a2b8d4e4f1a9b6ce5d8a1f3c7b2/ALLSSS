# Audit Report

## Title
Large ByteString DoS via Unconstrained OutValue and Signature Fields in Consensus Validation

## Summary
The AEDPoS consensus validation pipeline lacks size constraints on `OutValue` and `Signature` ByteString fields, validating only non-emptiness via `.Any()` instead of enforcing the expected 32-byte hash size. An elected miner can exploit this to cause resource exhaustion across all validators by embedding arbitrarily large ByteStrings (up to 100MB) in consensus block headers.

## Finding Description

The vulnerability exists in the consensus header validation logic where `OutValue` and `Signature` hash fields undergo insufficient size validation.

The `NewConsensusInformationFilled` method performs only a minimal existence check: [1](#0-0) 

This validation accepts any non-empty ByteString regardless of size, whereas legitimate consensus values are always 32-byte SHA256 hashes generated via `HashHelper.ComputeFrom`: [2](#0-1) [3](#0-2) 

While `Hash.LoadFromByteArray()` enforces 32-byte validation, it is never invoked during the validation pipeline: [4](#0-3) 

The protobuf `Hash` message definition contains no size constraint: [5](#0-4) 

**Attack Execution Path:**

1. Entry point at `ValidateConsensusBeforeExecution` triggers protobuf deserialization, allocating memory proportional to ByteString size: [6](#0-5) 

2. For `UpdateValue` behavior, `RecoverFromUpdateValue` directly assigns oversized values without size validation: [7](#0-6) [8](#0-7) 

3. The validation pipeline invokes `UpdateValueValidationProvider` which only checks `.Any()`, allowing oversized data to pass: [9](#0-8) 

4. If block execution proceeds, `ProcessUpdateValue` persists oversized values to state: [10](#0-9) 

The network layer permits messages up to 100MB: [11](#0-10) 

## Impact Explanation

**Medium Severity - Consensus Resource Exhaustion DoS**

This vulnerability enables coordinated resource consumption attacks against the consensus layer:

1. **Memory Exhaustion**: Protobuf deserialization allocates heap memory proportional to ByteString size. Within the 100MB gRPC limit, a malicious miner can embed 10-20MB per field, causing significant memory pressure.

2. **CPU Waste**: `Parser.ParseFrom()` performs expensive deserialization operations that scale with data size. Additional overhead occurs when `GetHash()` serializes the round via `ToByteArray()`: [12](#0-11) [13](#0-12) 

3. **Network Amplification**: The malicious block propagates to all validators via P2P gossip. Each validator independently parses and validates the oversized data, multiplying resource consumption network-wide.

4. **State Bloat**: If validation passes and execution proceeds, oversized values persist permanently in `State.Rounds`, causing long-term storage bloat.

The severity is Medium rather than High because:
- Attack requires elected miner access (not arbitrary attacker)
- Impact limited to resource consumption, not fund theft
- Rate-limited by attacker's block production schedule
- Eventually detectable through monitoring

However, this represents a genuine DoS vector violating the "fail fast on invalid input" principle critical to consensus systems.

## Likelihood Explanation

**Medium Likelihood**

**Attacker Capabilities Required:**
- Must achieve elected miner status through the AElf election mechanism
- Miners are elected participants, not inherently trusted roles
- Could become malicious through key compromise, intentional malfeasance, or multi-miner collusion

**Attack Complexity:**
Once miner access is obtained, execution is trivial:
1. Generate valid consensus trigger information
2. Modify `OutValue.Value` and `Signature.Value` to oversized ByteStrings (e.g., 10MB each)
3. Sign and propagate the block

The `.Any()` validation provides no protection against size manipulation, and no other size checks exist in the validation pipeline.

**Detection Characteristics:**
- Block may eventually fail post-execution hash comparison in `ValidateConsensusAfterExecution`
- Resource consumption occurs before rejection across all validating nodes
- Network anomaly detection may flag unusually large consensus messages

**Probability Assessment:** Medium - Requires elected miner compromise, but attack execution is straightforward once access is achieved.

## Recommendation

Implement strict 32-byte size validation for `OutValue` and `Signature` fields in the `NewConsensusInformationFilled` method:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Validate OutValue exists and is exactly 32 bytes
    if (minerInRound.OutValue == null || 
        minerInRound.OutValue.Value == null ||
        minerInRound.OutValue.Value.Length != AElfConstants.HashByteArrayLength)
        return false;
    
    // Validate Signature exists and is exactly 32 bytes
    if (minerInRound.Signature == null || 
        minerInRound.Signature.Value == null ||
        minerInRound.Signature.Value.Length != AElfConstants.HashByteArrayLength)
        return false;
    
    return true;
}
```

Alternatively, invoke `Hash.LoadFromByteArray()` early in the validation pipeline to leverage existing 32-byte enforcement:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    try 
    {
        // This will throw if not exactly 32 bytes
        Hash.LoadFromByteArray(minerInRound.OutValue.Value.ToByteArray());
        Hash.LoadFromByteArray(minerInRound.Signature.Value.ToByteArray());
        return true;
    }
    catch (ArgumentException)
    {
        return false;
    }
}
```

This ensures validation rejects oversized ByteStrings before resource-intensive operations occur.

## Proof of Concept

```csharp
[Fact]
public async Task ValidateConsensusBeforeExecution_Should_Reject_Oversized_OutValue()
{
    // Arrange: Create malicious consensus header with 10MB OutValue
    var oversizedBytes = new byte[10 * 1024 * 1024]; // 10MB
    new Random().NextBytes(oversizedBytes);
    
    var maliciousRound = new Round
    {
        RoundNumber = 2,
        RealTimeMinersInformation =
        {
            {
                "malicious_miner",
                new MinerInRound
                {
                    Pubkey = "malicious_miner",
                    OutValue = new Hash { Value = ByteString.CopyFrom(oversizedBytes) }, // Oversized
                    Signature = new Hash { Value = ByteString.CopyFrom(oversizedBytes) }, // Oversized
                    Order = 1
                }
            }
        }
    };
    
    var headerInfo = new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString("malicious_miner"),
        Round = maliciousRound,
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    
    var input = new BytesValue { Value = headerInfo.ToByteString() };
    
    // Act: Validate consensus before execution
    var result = await ConsensusContract.ValidateConsensusBeforeExecution.CallAsync(input);
    
    // Assert: Should reject oversized ByteStrings but currently passes due to .Any() check
    // VULNERABILITY: result.Success is TRUE when it should be FALSE
    result.Success.ShouldBeFalse("Validation should reject oversized OutValue/Signature");
    result.Message.ShouldContain("Invalid hash size");
}
```

**Notes:**
- This vulnerability is particularly concerning because it affects the pre-execution validation phase where "cheap and fast" checks should prevent resource exhaustion
- The 100MB gRPC limit allows significant abuse potential while remaining under network layer constraints
- The absence of size validation represents a deviation from the protocol's implicit 32-byte hash constraint enforced elsewhere via `Hash.LoadFromByteArray()`
- State bloat potential compounds the DoS impact if malicious blocks execute before detection

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** src/AElf.Types/Helper/HashHelper.cs (L15-18)
```csharp
        public static Hash ComputeFrom(byte[] bytes)
        {
            return Hash.LoadFromByteArray(bytes.ComputeHash());
        }
```

**File:** src/AElf.Types/Types/Hash.cs (L49-58)
```csharp
        public static Hash LoadFromByteArray(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.HashByteArrayLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            return new Hash
            {
                Value = ByteString.CopyFrom(bytes)
            };
        }
```

**File:** protobuf/aelf/core.proto (L140-143)
```text
message Hash
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-82)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-21)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-249)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

```

**File:** src/AElf.OS.Network.Grpc/GrpcConstants.cs (L28-29)
```csharp
    public const int DefaultMaxReceiveMessageLength = 100 * 1024 * 1024;
    public const int DefaultMaxSendMessageLength = 100 * 1024 * 1024;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L60-63)
```csharp
    public Hash GetHash(bool isContainPreviousInValue = true)
    {
        return HashHelper.ComputeFrom(GetCheckableRound(isContainPreviousInValue));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```
