# Audit Report

## Title
Solitary Miner Detection Logic Error Causes False Positive and Potential Chain Halt

## Summary
The `SolitaryMinerDetection()` function contains a critical logic error that incorrectly interprets the absence of miners at the start of a new round as evidence of solitary mining. This false positive blocks the only operational miner after a network partition, potentially causing complete consensus halt.

## Finding Description

The vulnerability exists in the solitary miner detection mechanism designed to prevent a single miner from continuing to mine alone. When a miner requests a consensus command via the public `GetConsensusCommand()` method [1](#0-0) , the private `GetConsensusCommand()` method invokes `SolitaryMinerDetection()` [2](#0-1) .

The root cause is a logic error at line 75 where the function checks if the current round has zero miners who have mined and treats this as evidence of solitary mining [3](#0-2) . The `GetMinedMiners()` method returns only miners where `SupposedOrderOfNextRound != 0` [4](#0-3) .

When a new round is created via `GenerateNextRoundInformation()`, new `MinerInRound` objects are instantiated without explicitly setting the `SupposedOrderOfNextRound` field [5](#0-4) . Since `SupposedOrderOfNextRound` is defined as `int32` in the protobuf definition [6](#0-5) , it defaults to 0. The field is only set when a miner produces a block through `ProcessUpdateValue()` [7](#0-6) .

**Why the bug occurs:** The logic error treats "no one has mined yet in current round" (count == 0) identically to "only this miner is mining" (solitary mining). At the start of any new round, before any miner produces a block, `GetMinedMiners()` will always return an empty list because all `SupposedOrderOfNextRound` values are still at their default of 0. The subsequent checks validate that only this specific miner mined in the previous 2 rounds [8](#0-7) , but this doesn't confirm the miner is currently mining alone—it only confirms past behavior during a network partition period.

## Impact Explanation

**Harm:** Complete consensus halt (DoS) preventing any block production.

**Scenario:**
1. During rounds N-2 and N-1, a network partition causes only MinerA to successfully produce blocks
2. Round N begins and `GenerateNextRoundInformation()` creates a new round with all `SupposedOrderOfNextRound` values at 0
3. MinerA attempts to produce the first block in round N by calling the public `GetConsensusCommand()` method
4. `SolitaryMinerDetection()` returns true, causing the method to return `InvalidConsensusCommand` [9](#0-8) , blocking MinerA from mining
5. If network issues persist and other miners remain offline/partitioned, no miner can produce blocks
6. Chain halts completely until manual intervention or network recovery

**Who is affected:** The entire blockchain network—all users, dApps, and validators lose access to a functioning chain.

**Severity justification:** HIGH - This is an operational DoS vulnerability affecting consensus integrity. While it requires specific preconditions (network partition lasting 2+ rounds), such conditions are realistic in distributed systems and the impact is catastrophic (complete chain halt).

## Likelihood Explanation

**Attacker capabilities:** No malicious attacker required—this triggers through natural network conditions.

**Preconditions:**
- Multi-miner network with more than 2 miners [10](#0-9) 
- After round 3 (checked at the same location)
- Network partition or miner downtime affecting all but one miner for 2 consecutive rounds
- The working miner continues to be the only operational miner into the next round

**Execution practicality:** The vulnerability triggers automatically through the normal consensus flow. When a miner requests a consensus command, the solitary detection runs before any block is produced in the new round.

**Feasibility conditions:** Network partitions, infrastructure failures, and miner downtime are common occurrences in distributed blockchain systems. The probability is MEDIUM—not frequent but realistic enough to warrant serious concern.

## Recommendation

The fix should distinguish between "round hasn't started yet" (count == 0 before first block) and "only this miner is mining" (count == 1 with only this miner after blocks have been produced). 

**Recommended fix:**
Replace the condition at line 75 to check if count == 1 AND only this miner is in the list, rather than checking if count == 0:

```csharp
var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
isAlone = minedMinersOfCurrentRound.Count == 1 && 
          minedMinersOfCurrentRound.Select(m => m.Pubkey).Contains(pubkey);
```

This ensures the detection only triggers when the miner is actively mining alone in the current round (after producing at least one block), not at the start of every round when no blocks have been produced yet.

## Proof of Concept

A valid test would require:
1. Setting up a multi-miner network (3+ miners)
2. Simulating rounds N-2 and N-1 where only MinerA produces blocks
3. Starting round N
4. Having MinerA call `GetConsensusCommand()` as the first action
5. Verifying that `InvalidConsensusCommand` is returned, blocking the miner
6. Confirming that if the partition continues, no blocks can be produced

The test would demonstrate that the solitary detection incorrectly triggers at the start of a new round based solely on past behavior, causing a consensus halt when the operational miner is blocked from producing the first block of the new round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-17)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L23-24)
```csharp
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L70-70)
```csharp
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L74-75)
```csharp
            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L78-92)
```csharp
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** protobuf/aedpos_contract.proto (L288-288)
```text
    int32 supposed_order_of_next_round = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-246)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusCommandProvider.cs (L23-30)
```csharp
        public static ConsensusCommand InvalidConsensusCommand => new()
        {
            ArrangedMiningTime = new Timestamp { Seconds = int.MaxValue },
            Hint = ByteString.CopyFrom(new AElfConsensusHint
            {
                Behaviour = AElfConsensusBehaviour.Nothing
            }.ToByteArray())
        };
```
