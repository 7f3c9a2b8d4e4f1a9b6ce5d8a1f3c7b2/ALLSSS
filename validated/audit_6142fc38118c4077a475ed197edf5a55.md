# Audit Report

## Title
Duplicate Initial Miner Entries Cause Consensus DoS During Evil Miner Replacement

## Summary
The Election contract stores initial miners without deduplication, and protobuf repeated field removal only eliminates the first occurrence of duplicates. When evil miner replacement selects from initial miners to fill replacement slots, duplicate pubkeys can be returned. The Consensus contract then crashes with an `ArgumentException` when attempting to add the same key twice to the round's miner map, halting the chain.

## Finding Description

The Election contract initializes `State.InitialMiners` by directly mapping the input without deduplication. [1](#0-0)  This contrasts with the Consensus contract which uses `.Distinct()` on the miner list during round generation. [2](#0-1) 

During pubkey replacement, the `Remove()` operation on protobuf repeated fields only removes the first matching entry. [3](#0-2)  If `State.InitialMiners` contains `[A, A, B]` and pubkey A is replaced, the result is `[A, B, A']` with one stale A entry remaining.

When `GetMinerReplacementInformation()` needs to fill evil miner replacement slots but has insufficient non-initial-miner candidates, it selects from initial miners using a LINQ chain without deduplication. [4](#0-3)  The method returns duplicate pubkeys in `AlternativeCandidatePubkeys`.

The Consensus contract processes replacements by iterating through the alternative candidates and calling `.Add()` to insert them into the round's miner map. [5](#0-4)  The `real_time_miners_information` field is a protobuf map type. [6](#0-5) 

When the loop attempts to add the same pubkey twice (once for each evil miner being replaced), the second `.Add()` call throws an `ArgumentException` because the key already exists in the dictionary, crashing consensus round generation and halting the chain.

## Impact Explanation

**Critical Consensus Failure:**
- The Consensus contract cannot generate new rounds, completely preventing block production
- All nodes experience identical deterministic failure due to shared state
- Chain halt persists until manual governance intervention or emergency response
- Affects entire network simultaneously with no automatic recovery mechanism

**Severity Justification:**
- Core consensus mechanism is completely disabled
- No blocks can be produced during the outage
- Business continuity is fully disrupted
- Requires coordinated emergency response to resolve

This represents a **High severity** availability impact on critical blockchain infrastructure.

## Likelihood Explanation

**Preconditions:**
1. Initial miner list contains duplicate pubkeys (configuration error during genesis setup)
2. OR prior pubkey replacement operations with duplicates creating unremoved stale entries

**Trigger Condition:**
- Evil miner detection activates (miners miss time slots or produce invalid blocks)
- Insufficient non-initial-miner candidates with adequate votes to fill all replacement slots
- System falls back to selecting from initial miners, returning duplicates

**Likelihood Assessment:**
- **Medium Likelihood**: While requiring an operational configuration error, such errors are realistic in production deployments
- No validation prevents duplicate insertion during initialization
- Once duplicates exist, the failure is deterministic when triggered
- Evil miner detection occurs periodically during normal operations
- No early warning or monitoring exists before the DoS manifests

## Recommendation

**Fix 1 - Initialization Deduplication:**
Add `.Distinct()` when storing initial miners in the Election contract:

```csharp
State.InitialMiners.Value = new PubkeyList
{
    Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)).Distinct() }
};
```

**Fix 2 - Replacement Selection Deduplication:**
Add `.Distinct()` when selecting initial miners for replacement in `GetMinerReplacementInformation()`:

```csharp
var selectedInitialMiners = State.InitialMiners.Value.Value
    .Select(k => k.ToHex())
    .Where(k => !State.BannedPubkeyMap[k])
    .Where(k => !input.CurrentMinerList.Contains(k))
    .Distinct()
    .Take(takeAmount);
```

**Fix 3 - Defensive Guard in Consensus:**
Check for duplicate keys before adding in the replacement loop:

```csharp
if (!currentRound.RealTimeMinersInformation.ContainsKey(alternativeCandidatePubkey))
{
    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
}
```

Implementing all three fixes provides defense-in-depth.

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateInitialMiners_CausesConsensusDoS_WhenReplacingEvilMiners()
{
    // Setup: Initialize Election contract with duplicate initial miners [A, A, B]
    var duplicateMinerPubkey = "04abc123..."; // Same pubkey twice
    var initInput = new InitialElectionContractInput
    {
        MinerList = { duplicateMinerPubkey, duplicateMinerPubkey, "04def456..." },
        MinersCount = 3,
        TimeEachTerm = 604800,
        MinimumLockTime = 7776000,
        MaximumLockTime = 31536000
    };
    await ElectionContractStub.InitialElectionContract.SendAsync(initInput);
    
    // Simulate: Two evil miners detected, need to replace with alternatives
    // Assume insufficient non-initial candidates, so system selects from initial miners
    var currentMiners = new[] { "04evil1...", "04evil2...", "04good..." };
    var replacementInfo = await ElectionContractStub.GetMinerReplacementInformation.CallAsync(
        new GetMinerReplacementInformationInput { CurrentMinerList = { currentMiners } }
    );
    
    // Verify: AlternativeCandidatePubkeys contains duplicates
    Assert.Equal(2, replacementInfo.AlternativeCandidatePubkeys.Count);
    Assert.Equal(duplicateMinerPubkey, replacementInfo.AlternativeCandidatePubkeys[0]);
    Assert.Equal(duplicateMinerPubkey, replacementInfo.AlternativeCandidatePubkeys[1]);
    
    // Trigger: Consensus contract attempts to process replacements
    // Expected: ArgumentException when adding duplicate key to RealTimeMinersInformation
    var exception = await Assert.ThrowsAsync<ArgumentException>(async () =>
    {
        await ConsensusContractStub.NextRound.SendAsync(/* round with replacement info */);
    });
    
    Assert.Contains("An item with the same key has already been added", exception.Message);
}
```

## Notes

This vulnerability stems from a missing defensive programming practice - the Election contract lacks deduplication during initialization, assuming trusted input. However, configuration errors in complex multi-validator setups are realistic. The protobuf `Remove()` behavior exacerbates the issue during pubkey replacements, leaving stale duplicate entries that persist indefinitely. The deterministic nature of the crash across all nodes makes this particularly severe, as manual governance intervention is required to recover.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L34-38)
```csharp
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Extensions/MinerListExtensions.cs (L16-19)
```csharp
            (from obj in miners.Pubkeys.Distinct()
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L383-391)
```csharp
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-338)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```

**File:** protobuf/aedpos_contract.proto (L243-247)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
```
