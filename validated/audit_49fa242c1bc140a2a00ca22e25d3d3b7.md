# Audit Report

## Title
Mining Order Manipulation via Unvalidated Secret Sharing Data in Consensus Transactions

## Summary
A malicious miner can manipulate the mining order of offline miners by providing crafted `RevealedInValues` in their consensus trigger information. These unvalidated values are used to set `PreviousInValue` for other miners, which subsequently affects signature calculation and mining order determination in future rounds, compromising the fairness of the consensus mechanism.

## Finding Description

The AEDPoS consensus mechanism implements a secret sharing scheme where miners reveal previous in-values to ensure randomness in mining order. However, a critical validation gap exists in how these revealed values are processed.

When a miner produces a block with UpdateValue behavior, they provide off-chain trigger information containing `RevealedInValues` - a map of miner public keys to their revealed in-values. The `UpdateLatestSecretPieces` method directly applies these values to set `PreviousInValue` for OTHER miners without any cryptographic validation: [1](#0-0) 

These manipulated values propagate through two paths:
1. **Block header path**: Included via `GetUpdateValueRound` which preserves `PreviousInValue` for all miners: [2](#0-1) 

2. **Transaction payload path**: Included via `ExtractInformationToUpdateConsensus` in the `MinersPreviousInValues` field: [3](#0-2) 

During transaction execution, `PerformSecretSharing` applies these values to the round state: [4](#0-3) 

The validation provider only checks the CURRENT miner's own `PreviousInValue` against their previous `OutValue`, not the values set for other miners: [5](#0-4) 

During NextRound transition, `SupplyCurrentRoundInformation` fills missing data for miners who didn't produce blocks. It retrieves the manipulated `PreviousInValue` and uses it to calculate their signature: [6](#0-5) 

This signature directly determines mining order through modulo arithmetic in `ApplyNormalConsensusData`: [7](#0-6) 

Finally, when generating the next round, miners are ordered by their `FinalOrderOfNextRound` values derived from these signatures: [8](#0-7) 

## Impact Explanation

This vulnerability compromises a critical consensus invariant: the fairness and unpredictability of mining order. 

**Consensus Integrity**: The AEDPoS protocol relies on cryptographic randomness from signatures to determine mining order. By manipulating the `PreviousInValue` inputs, an attacker can influence the signature calculation for offline miners, effectively controlling their positions in future rounds.

**Targeted Exploitation**: The attack specifically affects miners who are temporarily offline or slow to produce blocks, as the manipulated values are used when `SupplyCurrentRoundInformation` fills their missing data. This creates an asymmetric advantage for the attacker.

**Economic Impact**: While not enabling direct fund theft, biased mining schedules affect:
- Block production opportunities and timing
- Mining reward distribution over time
- The ability to produce consecutive blocks or control specific time slots

**Severity Assessment**: Medium-High severity because it breaks fundamental consensus fairness guarantees, though it requires miner privileges and doesn't enable immediate fund extraction.

## Likelihood Explanation

The attack is highly feasible with medium likelihood:

**Low Technical Barrier**: Any active consensus miner can execute this by modifying their node software to provide arbitrary `RevealedInValues` instead of correctly reconstructed values. No sophisticated cryptographic attacks are required.

**Frequent Attack Windows**: Miner downtime occurs regularly due to network issues, maintenance, or node failures. Each offline miner presents an opportunity for manipulation.

**Low Detection Risk**: 
- The malicious data originates from off-chain trigger information
- No on-chain validation checks these values against decrypted pieces
- Mining order has inherent variance, masking manipulation
- No events or alerts flag incorrect revealed values

**Economic Incentive**: Miners have clear motivation to gain competitive advantages in block production and reward distribution.

**No Cryptographic Protection**: The protocol accepts revealed in-values at face value without verifying they were correctly reconstructed from secret shares using `DecodeSecret`, despite having on-chain decrypted pieces available for validation.

## Recommendation

Implement cryptographic validation of `RevealedInValues` by verifying they were correctly reconstructed from on-chain decrypted pieces:

1. **Add validation in `UpdateLatestSecretPieces`**: Before accepting `RevealedInValues`, verify each one by:
   - Checking sufficient decrypted pieces exist (â‰¥ 2/3 threshold)
   - Reconstructing the in-value using `SecretSharingHelper.DecodeSecret`
   - Verifying `Hash(reconstructedInValue) == previousRound.OutValue` for that miner

2. **Reuse existing on-chain reconstruction logic**: The `RevealSharedInValues` method already implements proper reconstruction - apply similar validation to externally-provided values.

3. **Reject invalid revealed values**: If validation fails, either:
   - Ignore the invalid entries and only apply validated ones
   - Reject the entire block if any revealed value is incorrect

This ensures only cryptographically verifiable values can influence mining order calculations.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test AEDPoS network with multiple miners
2. Modifying one miner's node to provide crafted `RevealedInValues` in trigger information (arbitrary hash values instead of correctly reconstructed ones)
3. Having that miner produce an UpdateValue block while other miners are offline
4. Observing that the crafted values are accepted and stored in the round state
5. Triggering NextRound and observing `SupplyCurrentRoundInformation` uses the manipulated values
6. Verifying the affected miners' signatures and resulting mining orders differ from what they would be with correct values
7. Confirming no validation errors or rejections occur

The test would demonstrate that arbitrary `PreviousInValue` data can be injected without cryptographic verification, directly influencing consensus mining order for offline miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-52)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-199)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
