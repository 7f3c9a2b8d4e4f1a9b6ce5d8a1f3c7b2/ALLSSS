# Audit Report

## Title
Vote Target Change Denial of Service for Legacy Votes After Weight Settings Update

## Summary
Legacy votes created before the ProfitDetailId feature cannot change targets with extended profit periods (`IsResetVotingTime=true`) after governance updates vote weight calculation settings. The weight recalculation mechanism uses current settings instead of original settings, causing a shares mismatch that results in transaction failure.

## Finding Description

The vulnerability occurs when users with legacy votes attempt to change vote targets with profit period extension after governance modifies weight calculation parameters.

**Root Cause - Weight Recalculation Mismatch:**

When a vote is created, profit details are stored with shares calculated using the weight settings active at creation time. [1](#0-0) 

The weight calculation uses `VoteWeightInterestList` and `VoteWeightProportion` settings. [2](#0-1) 

When changing vote targets with `IsResetVotingTime=true`, the `ExtendVoterWelfareProfits` function is invoked. [3](#0-2) 

This function retrieves the election voting record, which recalculates the weight using CURRENT settings, not the original settings from vote creation time. [4](#0-3) 

**Lookup Failure for Legacy Votes:**

The `GetProfitDetailByElectionVotingRecord` function attempts to find the matching profit detail using two strategies. First, it tries matching by profit detail ID. For legacy votes created before the ProfitDetailId feature, this ID is null (as indicated by the code comment "in the old world, profitDetail.Id is null"). When the ID match fails, it falls back to matching by shares. [5](#0-4) 

The shares matching compares the stored shares (calculated with OLD weight settings) against the recalculated weight (using NEW settings). If governance has changed the weight settings, these values will not match, causing the function to return null.

**Transaction Failure:**

When the profit detail cannot be found, the `ExtendVoterWelfareProfits` function throws an AssertionException. [6](#0-5) 

This causes the entire `ChangeVotingOption` transaction to fail.

**Governance Can Legitimately Change Settings:**

The Parliament governance can update vote weight settings via `SetVoteWeightInterest` and `SetVoteWeightProportion` methods. [7](#0-6) 

These methods are controlled by Parliament authority. [8](#0-7) 

The test suite confirms governance can successfully modify these settings. [9](#0-8) 

## Impact Explanation

**Affected Users:** All holders of legacy votes (created before ProfitDetailId feature implementation) who attempt to change vote targets after ANY governance update to weight calculation settings.

**Concrete Harm:**
1. **Denial of Service**: The legitimate `ChangeVotingOption` feature with `IsResetVotingTime=true` becomes completely unusable for legacy votes
2. **Economic Loss**: Users are forced to either:
   - Maintain their current vote target (losing voting flexibility)
   - Use `IsResetVotingTime=false`, which proportionally reduces their remaining profit earning period, resulting in direct economic loss of expected rewards

**Severity Justification:** Medium severity because:
- It's a protocol-level DoS affecting a core governance feature
- Causes quantifiable economic loss through reduced profit periods
- Affects all legacy votes system-wide after a single governance action
- No direct fund theft, but legitimate users suffer economic harm
- Workaround exists but comes with economic penalties

## Likelihood Explanation

**Preconditions:**
1. Legacy votes exist in the system (explicitly acknowledged by code comments and fallback logic)
2. Governance updates weight settings through legitimate governance actions

**Feasibility:** HIGH
- Weight setting changes are legitimate governance operations for adjusting economic incentives
- No attacker capabilities required - triggered by honest governance actions
- Test suite confirms governance can modify these settings successfully

**Probability:** MEDIUM-HIGH
- Governance weight adjustments are economically rational during protocol evolution
- Settings may need updates to fix calculation issues or adjust incentive structures
- Once settings change, ALL legacy votes are immediately affected

## Recommendation

The issue can be fixed by storing the original weight calculation parameters (VoteWeightInterestList and VoteWeightProportion) at the time of vote creation, and using those original parameters when recalculating weight during vote target changes.

Alternative approaches:
1. **Store Original Weight**: Save the calculated weight in the vote record itself and reuse it during target changes instead of recalculating
2. **Use ProfitDetailId for All Lookups**: For legacy votes without ProfitDetailId, implement a migration mechanism to assign IDs
3. **Hybrid Fallback**: When shares don't match, search for the closest matching profit detail by shares within a tolerance range

The recommended fix is to store the original weight at vote creation time and reuse it consistently, avoiding recalculation altogether during vote target changes.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a vote with initial weight settings
2. Updating the vote weight settings via governance (SetVoteWeightInterest or SetVoteWeightProportion)
3. Attempting to change the vote target with IsResetVotingTime=true

The transaction will fail with an AssertionException because the recalculated weight no longer matches the stored shares in the profit detail, and the profit detail lookup returns null for legacy votes.

Note: While the current codebase sets ProfitDetailId for new votes [10](#0-9) , the code explicitly acknowledges legacy votes exist where profitDetail.Id is null [11](#0-10) , confirming this is a real scenario affecting production deployments.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-37)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L156-159)
```csharp
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-216)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }

    public override Empty SetVoteWeightProportion(VoteWeightProportion input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.TimeProportion > 0 && input.AmountProportion > 0, "invalid input");
        State.VoteWeightProportion.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L385-400)
```csharp
    private void AssertPerformedByVoteWeightInterestController()
    {
        if (State.VoteWeightInterestController.Value == null)
            State.VoteWeightInterestController.Value = GetDefaultVoteWeightInterestController();

        Assert(Context.Sender == State.VoteWeightInterestController.Value.OwnerAddress, "No permission.");
    }

    private AuthorityInfo GetDefaultVoteWeightInterestController()
    {
        return new AuthorityInfo
        {
            ContractAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
            OwnerAddress = GetParliamentDefaultAddress()
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L337-355)
```csharp
    private ElectionVotingRecord TransferVotingRecordToElectionVotingRecord(VotingRecord votingRecord, Hash voteId)
    {
        var lockSeconds = State.LockTimeMap[voteId];
        return new ElectionVotingRecord
        {
            Voter = votingRecord.Voter,
            Candidate = GetNewestPubkey(votingRecord.Option),
            Amount = votingRecord.Amount,
            TermNumber = votingRecord.SnapshotNumber,
            VoteId = voteId,
            LockTime = lockSeconds,
            VoteTimestamp = votingRecord.VoteTimestamp,
            WithdrawTimestamp = votingRecord.WithdrawTimestamp,
            UnlockTimestamp = votingRecord.VoteTimestamp.AddSeconds(lockSeconds),
            IsWithdrawn = votingRecord.IsWithdrawn,
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
            IsChangeTarget = votingRecord.IsChangeTarget
        };
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L1366-1381)
```csharp
    public async Task Election_VoteWeightInterestSetting_Test()
    {
        var defaultSetting = await ElectionContractStub.GetVoteWeightSetting.CallAsync(
            new Empty());
        defaultSetting.VoteWeightInterestInfos.Count.ShouldBe(3);
        defaultSetting.VoteWeightInterestInfos[0].Capital = 13200;
        defaultSetting.VoteWeightInterestInfos[0].Day = 50;

        await ExecuteProposalForParliamentTransaction(ElectionContractAddress,
            nameof(ElectionContractStub.SetVoteWeightInterest), defaultSetting);

        defaultSetting = await ElectionContractStub.GetVoteWeightSetting.CallAsync(
            new Empty());
        defaultSetting.VoteWeightInterestInfos[0].Capital.ShouldBe(13200);
        defaultSetting.VoteWeightInterestInfos[0].Day.ShouldBe(50);
    }
```
