# Audit Report

## Title
Overly Strict Validation in Secret Sharing Reconstruction Defeats Byzantine Fault Tolerance

## Summary
The `RevealSharedInValues` method in the AEDPoS consensus contract requires 100% miner participation for secret reconstruction, contradicting Shamir's Secret Sharing's 2/3 threshold design. This allows a single non-participating miner to prevent all InValue revelation, completely defeating the Byzantine fault tolerance property and enabling manipulation of the consensus randomness mechanism.

## Finding Description

The vulnerability exists in the secret sharing reconstruction validation logic. The system correctly calculates the 2/3 threshold required by Shamir's Secret Sharing scheme [1](#0-0) , but then imposes an incorrect requirement that ALL miners must provide decrypted pieces before reconstruction can proceed [2](#0-1) .

The actual reconstruction call correctly uses the calculated `minimumCount` (2/3 threshold) parameter [3](#0-2) , confirming that mathematically only 2/3 of shares are required. The Shamir's Secret Sharing implementation itself only iterates over the threshold number of shares [4](#0-3) , proving the algorithm only needs threshold shares.

The test suite demonstrates the intended behavior - reconstruction succeeds when `MinimumCount` shares are available [5](#0-4) .

When miners call `UpdateValue`, their decrypted pieces are distributed to other miners through the `PerformSecretSharing` method [6](#0-5) . The `ExtractInformationToUpdateConsensus` function correctly collects only available decrypted pieces [7](#0-6) . However, during NextRound when `RevealSharedInValues` is invoked [8](#0-7) , the overly strict validation prevents reconstruction even when sufficient shares exist.

The same bug exists in the off-chain service [9](#0-8) .

## Impact Explanation

**HIGH severity** - This vulnerability breaks a critical security property of the consensus mechanism:

1. **Consensus Integrity Degradation**: The secret sharing mechanism is designed to reveal miners' committed InValues even if they go offline or act maliciously, ensuring randomness cannot be manipulated. By requiring 100% participation instead of the 2/3 threshold, any single miner can prevent all InValue reconstruction.

2. **Byzantine Fault Tolerance Defeat**: The system was explicitly designed to tolerate up to 1/3 faulty or malicious nodes. This bug creates a single point of failure, negating the entire fault tolerance guarantee.

3. **Randomness Manipulation Risk**: Miners can hide their previously committed InValues, potentially manipulating the VRF-based random number generation that underlies consensus security.

4. **Protocol-Wide Impact**: Affects all consensus participants and any systems or applications relying on consensus randomness integrity.

## Likelihood Explanation

**VERY HIGH likelihood**:

1. **Trivial Attack Complexity**: The attacker simply omits `DecryptedPieces` from their `UpdateValue` transaction or provides only partial decryptions. No special timing, economic resources, or coordination required.

2. **Realistic Preconditions**: Attacker must be an active miner in the consensus round - a precondition expected in the threat model as the system must assume potential adversarial miners.

3. **Indistinguishable from Benign Failures**: The attack is passive (omission) and appears identical to legitimate network issues or node downtime, making detection extremely difficult.

4. **Frequent Natural Occurrence**: This condition triggers even under normal operations whenever a single miner is offline or lagging, meaning it occurs frequently without malicious intent.

## Recommendation

Change the validation logic to match the intended threshold-based design. Replace the strict count check with the minimum threshold check:

```csharp
// Current buggy code (line 36):
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// Should be:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This allows reconstruction to proceed when the 2/3 threshold is met, as intended by the Shamir's Secret Sharing scheme and validated by the test suite. Apply the same fix to the off-chain service at line 162 of `SecretSharingService.cs`.

## Proof of Concept

The vulnerability can be demonstrated by examining the code flow:

1. With 7 miners, `minimumCount = 7 * 2 / 3 = 4` (threshold for reconstruction)
2. If only 6 miners provide their `DecryptedPieces` (one miner omits theirs)
3. Line 36 check fails: `6 < 7` evaluates to true, so reconstruction is skipped
4. However, `SecretSharingHelper.DecodeSecret()` only needs 4 shares to reconstruct
5. The test at lines 52-58 of `InValueRecoveryTest.cs` confirms that reconstruction should succeed with `MinimumCount` shares

The mathematical contradiction is evident: the algorithm calculates a 2/3 threshold but enforces a 100% requirement, defeating the Byzantine fault tolerance property that Shamir's Secret Sharing was designed to provide.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L48-48)
```csharp
            for (var i = 0; i < threshold; i++)
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/InValueRecoveryTest.cs (L52-58)
```csharp
            if (decryptedValues.Count >= MinimumCount)
            {
                decryptResult = SecretSharingHelper.DecodeSecret(
                    decryptedValues.Values.ToList(),
                    Enumerable.Range(1, MinimumCount).ToList(), MinimumCount);
                break;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-28)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L162-162)
```csharp
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;
```
