# Audit Report

## Title
Mining Order Manipulation via Unvalidated FinalOrderOfNextRound in UpdateValue Blocks

## Summary

The AEDPoS consensus validation system fails to validate `FinalOrderOfNextRound` values in UpdateValue block headers, allowing malicious miners to arbitrarily manipulate the mining order for subsequent rounds. The `NextRoundMiningOrderValidationProvider` that enforces order distinctness is only applied to NextRound behavior, not UpdateValue behavior, creating a critical validation gap that breaks consensus randomness.

## Finding Description

The vulnerability exists in the consensus block validation flow for UpdateValue behavior. When an honest miner produces an UpdateValue block, the block header contains a `Round` object with `FinalOrderOfNextRound` values for all miners, calculated through proper conflict resolution in `ApplyNormalConsensusData`. However, a malicious miner can modify these values before block submission, and no validation prevents this manipulation.

**Attack Vector:**

In `ValidateBeforeExecution`, UpdateValue behavior only applies `UpdateValueValidationProvider` and `LibInformationValidationProvider`: [1](#0-0) 

In contrast, NextRound behavior includes `NextRoundMiningOrderValidationProvider`: [2](#0-1) 

The `NextRoundMiningOrderValidationProvider` validates order distinctness: [3](#0-2) 

The `UpdateValueValidationProvider` only checks OutValue/Signature fields and PreviousInValue correctness—no order validation: [4](#0-3) 

**Blind Value Recovery:**

The `RecoverFromUpdateValue` function blindly copies `FinalOrderOfNextRound` values from the provided round (block header) to the base round without any validation: [5](#0-4) 

**State Corruption:**

During execution, `ProcessUpdateValue` extracts `TuneOrderInformation` from the input and applies it directly to state, overwriting all miners' `FinalOrderOfNextRound` values: [6](#0-5) 

**Consensus Impact:**

When generating the next round, `GenerateNextRoundInformation` orders miners by their manipulated `FinalOrderOfNextRound` values, making the manipulation permanent: [7](#0-6) 

**Bypass of Intended Security:**

The honest path uses `ApplyNormalConsensusData` to calculate orders with conflict resolution: [8](#0-7) 

However, malicious miners can bypass this entirely by modifying the Round object after it's generated but before block submission.

**Why After-Execution Validation Fails:**

The `ValidateConsensusAfterExecution` method compares the header round against the current state round, but both contain the same manipulated values: [9](#0-8) 

This creates a self-referential validation where manipulated state is compared against the manipulated header that caused it—both match, so validation passes.

## Impact Explanation

**Critical Consensus Integrity Breach**: This vulnerability fundamentally breaks the AEDPoS randomized consensus mechanism. The security model assumes mining order is unpredictable and derived from cryptographic signatures. By manipulating `FinalOrderOfNextRound` values, attackers gain:

1. **Order Control**: Can position themselves as first miner (order 1) for optimal block production timing
2. **Competitive Advantage**: Control over transaction ordering for MEV extraction
3. **Penalty Avoidance**: Can adjust orders to avoid missed time slot detection
4. **Extra Block Producer Influence**: Mining order affects extra block producer selection

**Protocol Degradation**: Once one miner exploits this, competitive pressure forces other miners to follow suit, creating a race-to-exploit scenario that completely undermines consensus randomness—a core security property of AEDPoS.

**Economic Impact**: Mining order directly affects block rewards, transaction fee collection, and potential MEV opportunities. First miners in each round have timing advantages for transaction selection and ordering.

## Likelihood Explanation

**High Likelihood**: The attack is trivially executable by any active miner:

**Attacker Requirements**:
- Active miner status (achievable through staking/election mechanism)
- Modified node software to alter Round object before block submission

**Attack Complexity**: Minimal
- Single-step modification of Round data structure
- No timing constraints or race conditions
- No coordination with other miners needed
- Works on every UpdateValue block the attacker produces

**Detection**: Nearly impossible
- Manipulated blocks pass all validation checks
- No cryptographic evidence of tampering (FinalOrderOfNextRound is not signed)
- After-execution validation compares corrupted state against corrupted header
- Indistinguishable from honest blocks at the protocol level

## Recommendation

Add `NextRoundMiningOrderValidationProvider` to the UpdateValue validation flow:

```csharp
case AElfConsensusBehaviour.UpdateValue:
    validationProviders.Add(new UpdateValueValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider()); // Add this
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

Additionally, consider cryptographically binding `FinalOrderOfNextRound` values to the miner's signature to prevent post-generation tampering, or re-derive these values during validation rather than trusting header values.

## Proof of Concept

The vulnerability can be demonstrated by modifying a miner node to:

1. Generate an UpdateValue block normally via `GetConsensusExtraData`
2. Before block submission, modify the returned `AElfConsensusHeaderInformation.Round.RealTimeMinersInformation` to set attacker's `FinalOrderOfNextRound = 1` and shift other miners' orders
3. Submit the modified block
4. Observe that validation passes and the manipulated order is applied to state
5. Verify that the next round uses the manipulated mining order

The attack succeeds because no validation provider checks the integrity or distinctness of `FinalOrderOfNextRound` values for UpdateValue blocks.

## Notes

This is a **consensus-level vulnerability** that breaks the randomness guarantees of AEDPoS. The root cause is an asymmetry in validation: NextRound blocks receive order validation while UpdateValue blocks—which also set next round orders—do not. The `FinalOrderOfNextRound` field is treated as trusted input from block headers rather than being validated or re-derived, enabling trivial manipulation by any miner.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-46)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-102)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
```
