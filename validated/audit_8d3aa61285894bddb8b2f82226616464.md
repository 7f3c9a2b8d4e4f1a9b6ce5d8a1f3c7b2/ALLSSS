# Audit Report

## Title
Malicious Miner Can DoS Critical System Operations By Injecting Invalid Hex Strings Via NextRound

## Summary
A malicious current miner can inject invalid hex strings into the `RealTimeMinersInformation` dictionary when calling `NextRound`, causing unhandled exceptions in subsequent calls to `IsCurrentMiner`. This blocks critical operations including transaction fee claiming, resource token donation, and cross-chain indexing until the malicious round expires.

## Finding Description

The vulnerability exists because `NextRound` accepts and stores arbitrary string keys in `RealTimeMinersInformation` without validating their hex format.

When a miner calls `NextRound`, the method only checks if the sender is a current miner [1](#0-0) , then processes the input by converting it to a `Round` object [2](#0-1)  which directly copies the `RealTimeMinersInformation` dictionary without validation.

The validation providers check mining permissions and order counts [3](#0-2) [4](#0-3) , but never validate that the keys are valid hexadecimal strings.

The malicious round data is stored directly [5](#0-4)  without any format validation.

Later, when `IsCurrentMiner` is called, it attempts to convert addresses to pubkeys by iterating through all stored keys [6](#0-5)  and calling `ByteArrayHelper.HexStringToByteArray(k)` for each key.

The `HexStringToByteArray` method uses `Convert.ToByte(hex.Substring(i, 2), 16)` [7](#0-6)  which throws a `FormatException` for invalid hex characters, causing all operations depending on `IsCurrentMiner` to fail.

This blocks critical operations:

**Transaction Fee Claiming**: The `ClaimTransactionFees` method calls `AssertSenderIsCurrentMiner` which internally calls `IsCurrentMiner` [8](#0-7) 

**Resource Token Donation**: The `DonateResourceToken` method also calls `AssertSenderIsCurrentMiner` [9](#0-8) 

**Cross-Chain Indexing**: Cross-chain operations use `CheckCrossChainIndexingPermission` which calls `IsCurrentMiner` [10](#0-9) [11](#0-10) 

## Impact Explanation

**HIGH Severity** - The DoS affects multiple consensus-critical operations:

1. **Economic Disruption**: ALL miners lose the ability to claim transaction fees, not just the attacker, causing system-wide revenue loss
2. **Resource Token Model Break**: `DonateResourceToken` fails for the entire network, breaking the resource fee system
3. **Cross-Chain Communication Halt**: Side chains cannot index parent chain data, completely breaking cross-chain functionality
4. **Network-Wide Impact**: Affects the entire blockchain until the malicious round expires (1-2 rounds, potentially several hours)

The vulnerability breaks the core security guarantee that authorized miners can execute critical system operations, causing availability loss for essential blockchain functions.

## Likelihood Explanation

**HIGH Likelihood**:
- Attack requires only current miner status, which is achievable through normal election processes
- A single malicious or compromised miner is sufficient to execute the attack
- Attack is trivial to execute: simply add one malformed key (e.g., "xyz") to `RealTimeMinersInformation` when calling `NextRound`
- No detection mechanisms exist - the malicious data appears valid until `IsCurrentMiner` is called
- Impact is immediate and deterministic upon execution

The permission check only verifies the sender is a current miner, not the validity of the input data [1](#0-0) 

## Recommendation

Add validation to check that all keys in `RealTimeMinersInformation` are valid hexadecimal strings before storing the round. This can be done either:

1. **In the validation phase**: Add a new validation provider that checks hex format of all keys in `ProvidedRound.RealTimeMinersInformation`

2. **During input processing**: Add validation in `ProcessNextRound` before calling `AddRoundInformation`:

```csharp
// Validate hex format of all miner public keys
foreach (var key in nextRound.RealTimeMinersInformation.Keys)
{
    try 
    {
        ByteArrayHelper.HexStringToByteArray(key);
    }
    catch (FormatException)
    {
        Assert(false, $"Invalid miner public key format: {key}");
    }
}
```

Additionally, consider wrapping the `ByteArrayHelper.HexStringToByteArray` call in `ConvertAddressToPubkey` with try-catch to gracefully handle invalid keys rather than throwing unhandled exceptions.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousNextRound_BlocksIsCurrentMiner()
{
    // Setup: Initialize consensus with legitimate miners
    var initialMiners = await InitializeConsensusAsync();
    var maliciousMiner = initialMiners[0];
    
    // Create malicious NextRoundInput with invalid hex key
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation =
        {
            { "xyz", new MinerInRound { Pubkey = "xyz" } }, // Invalid hex string
            { initialMiners[1], new MinerInRound { Pubkey = initialMiners[1], OutValue = Hash.Empty } }
        }
    };
    
    // Execute malicious NextRound - should succeed with current validation
    await ConsensusContractStub.NextRound.SendAsync(maliciousInput);
    
    // Verify IsCurrentMiner now throws exception for any address
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await ConsensusContractStub.IsCurrentMiner.CallAsync(
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(maliciousMiner))
        );
    });
    
    // Verify critical operations are blocked
    await Assert.ThrowsAsync<Exception>(async () =>
    {
        await TokenContractStub.ClaimTransactionFees.SendAsync(new TotalTransactionFeesMap());
    });
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-134)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-906)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
        Context.LogDebug(() => $"Claim transaction fee. {input}");
        State.LatestTotalTransactionFeesMapHash.Value = HashHelper.ComputeFrom(input);
        foreach (var bill in input.Value)
        {
            var symbol = bill.Key;
            var amount = bill.Value;
            ModifyBalance(Context.Self, symbol, amount);
            Context.Fire(new TransactionFeeClaimed
            {
                Symbol = symbol,
                Amount = amount,
                Receiver = Context.Self
            });
            
            TransferTransactionFeesToFeeReceiver(symbol, amount);
        }

        Context.LogDebug(() => "Finish claim transaction fee.");

        return new Empty();
    }

    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-920)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```
