# Audit Report

## Title
Permanent Token Lock Due to State Corruption in TokenHolder Contract

## Summary
A critical state corruption bug in the TokenHolder contract's `UpdateTokenHolderProfitScheme` method causes permanent token locks when scheme managers transfer ownership. The method incorrectly stores updated scheme data to the transaction sender's address instead of the manager's address, creating a scenario where users cannot withdraw their locked tokens after manager transfers.

## Finding Description

The TokenHolder contract contains a state corruption vulnerability that breaks the fundamental lock/unlock invariant. When users register for profits, the contract stores scheme metadata to the wrong address, which becomes catastrophic when combined with legitimate manager operations.

**Root Cause:**

The `UpdateTokenHolderProfitScheme` method fetches the scheme ID from the Profit contract and populates the local scheme state. However, it incorrectly stores the updated scheme to `Context.Sender` instead of the `manager` parameter. [1](#0-0) 

**Execution Flow:**

1. **Scheme Creation**: Manager M creates a TokenHolder scheme, which stores an initial scheme with `SchemeId = null` at the manager's address. [2](#0-1) 

2. **User Registration**: User A calls `RegisterForProfits(schemeManager=M, amount)`. The method calls `GetValidScheme(M)` which invokes `UpdateTokenHolderProfitScheme`. [3](#0-2)  This method populates the scheme ID from the Profit contract but stores it to `Context.Sender` (User A's address) instead of the manager's address, leaving M's scheme state with `SchemeId = null`. The exception is when auto-distribute triggers, which correctly stores to `input.SchemeManager`. [4](#0-3) 

3. **Manager Transfer**: Manager M calls `ResetManager` in the Profit contract to transfer scheme ownership to address N. [5](#0-4)  This removes the scheme from M's `ManagingSchemeIds` list and adds it to N's list.

4. **Failed Withdrawal**: User A attempts to withdraw by calling `Withdraw(M)`. [6](#0-5)  The method calls `GetValidScheme(M)` which retrieves the scheme from M's address (still with `SchemeId = null`). It then calls `GetManagingSchemeIds` for manager M, which now returns an empty list because the scheme was transferred. [7](#0-6)  The `FirstOrDefault()` returns null, causing the assertion to fail with "Origin scheme not found".

The tokens remain permanently locked because `Withdraw` is the only method that unlocks tokens, and there is no administrative function to recover from this corrupted state. [8](#0-7) 

## Impact Explanation

This vulnerability results in **permanent and irreversible loss of user funds**. The severity is Critical because:

- Users' locked tokens become permanently inaccessible with no recovery mechanism
- The `Withdraw` method is the only code path that unlocks tokens in the TokenHolder contract
- All tokens locked by users of any scheme whose manager transfers ownership are affected
- No administrative function exists to unlock tokens or fix the corrupted state
- The fundamental protocol invariant "tokens that can be locked can be unlocked" is violated
- Users have no control, warning, or protection against this scenario

## Likelihood Explanation

The likelihood is **Medium-to-High** because:

**Attacker Requirements:**
- Create a TokenHolder scheme (publicly available operation)
- Have users register and lock tokens (normal protocol usage)
- Call `ResetManager` on the Profit contract (available to any scheme manager)

**Feasibility:**
- Manager transfers are legitimate operations that managers may perform for operational reasons such as restructuring, upgrading, or delegation
- No warnings, validations, or safeguards prevent managers from calling `ResetManager`
- Users have no visibility or control over manager actions
- The state corruption affects all registrations where auto-distribute doesn't trigger, which depends on threshold configuration that users cannot control

**Realistic Scenarios:**
- Malicious manager intentionally locks user funds before transferring ownership
- Honest manager accidentally triggers the bug during legitimate operational transfer
- Manager unaware that users will be permanently affected by the ownership transfer

## Recommendation

Fix the state corruption bug in `UpdateTokenHolderProfitScheme` by storing the updated scheme to the manager's address instead of `Context.Sender`:

```csharp
private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
    bool updateSchemePeriod)
{
    if (scheme.SchemeId != null && !updateSchemePeriod) return;
    var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
    {
        Manager = manager
    }).SchemeIds.FirstOrDefault();
    Assert(originSchemeId != null, "Origin scheme not found.");
    var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
    scheme.SchemeId = originScheme.SchemeId;
    scheme.Period = originScheme.CurrentPeriod;
    State.TokenHolderProfitSchemes[manager] = scheme;  // FIX: Store to manager, not Context.Sender
}
```

Additionally, consider adding validation in `ResetManager` to check if there are active beneficiaries and either prevent the transfer or provide a migration path.

## Proof of Concept

```csharp
[Fact]
public async Task PermanentTokenLockAfterManagerTransfer()
{
    // Manager creates scheme
    var manager = Accounts[0].Address;
    var user = Accounts[1].Address;
    var newManager = Accounts[2].Address;
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // User registers WITHOUT triggering auto-distribute
    var userStub = GetTokenHolderContractStub(Accounts[1].KeyPair);
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 1000
    });
    
    // Get scheme ID
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(manager);
    var schemeId = scheme.SchemeId;
    
    // Manager transfers ownership
    var profitStub = GetProfitContractStub(Accounts[0].KeyPair);
    await profitStub.ResetManager.SendAsync(new ResetManagerInput
    {
        SchemeId = schemeId,
        NewManager = newManager
    });
    
    // User attempts to withdraw - THIS WILL FAIL
    var exception = await Assert.ThrowsAsync<AssertionException>(async () =>
    {
        await userStub.Withdraw.SendAsync(manager);
    });
    
    exception.Message.ShouldContain("Origin scheme not found");
    
    // Tokens are permanently locked - no recovery possible
}
```

## Notes

The vulnerability requires that auto-distribute does not trigger during user registration, which depends on the `AutoDistributeThreshold` configuration. If auto-distribute triggers, it correctly stores the scheme to the manager's address. However, users have no control over this configuration and cannot ensure protection. The bug represents a fundamental design flaw where state updates are stored to the wrong address, violating the principle of least surprise and breaking critical invariants.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-152)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L203-205)
```csharp
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-244)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L723-743)
```csharp
    public override Empty ResetManager(ResetManagerInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only scheme manager can reset manager.");
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");

        // Transfer managing scheme id.
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
        var newManagerSchemeIds = State.ManagingSchemeIds[input.NewManager] ?? new CreatedSchemeIds();
        newManagerSchemeIds.SchemeIds.Add(input.SchemeId);
        State.ManagingSchemeIds[input.NewManager] = newManagerSchemeIds;

        scheme.Manager = input.NewManager;
        State.SchemeInfos[input.SchemeId] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-17)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }

    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }

    public MappedState<Hash, Timestamp> LockTimestamp { get; set; }
```
