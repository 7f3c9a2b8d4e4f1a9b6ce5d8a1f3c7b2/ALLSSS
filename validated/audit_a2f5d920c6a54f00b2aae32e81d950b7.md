# Audit Report

## Title
Insufficient Validation of ImpliedIrreversibleBlockHeight Enables Consensus Halt via LIB Manipulation

## Summary
The AEDPoS consensus contract lacks validation to ensure miners report `ImpliedIrreversibleBlockHeight` values close to the current block height. This allows colluding miners controlling ≥1/3 of consensus power to freeze the Last Irreversible Block (LIB) at a stale height, triggering automatic chain rollbacks that create an infinite loop preventing blockchain liveness.

## Finding Description

The consensus contract expects honest miners to set `ImpliedIrreversibleBlockHeight` to the current block height when producing blocks. [1](#0-0) 

However, the validation in `LibInformationValidationProvider` only verifies that this value does not decrease compared to the previous round, with no check enforcing proximity to `Context.CurrentHeight`. [2](#0-1) 

During block processing, the contract directly stores whatever `ImpliedIrreversibleBlockHeight` value miners provide without further verification against the current block height. [3](#0-2) 

The LIB calculation uses `LastIrreversibleBlockHeightCalculator`, which selects the value at position `(count-1)/3` from the sorted list of implied heights reported by miners who successfully mined in the current round. [4](#0-3) 

For a typical configuration of 21 miners, position (21-1)/3 = 6 (the 7th element in the sorted list). If 7 or more miners collude to report the same stale value, the LIB will be stuck at that stale height since it becomes the 7th smallest value in the sorted list.

When the current round number exceeds the LIB round number by the severe threshold (calculated as `Math.Max(8, MaximumTinyBlocksCount)`, typically 8 rounds), the blockchain enters "Severe" status. [5](#0-4) 

This triggers the `IrreversibleBlockHeightUnacceptable` event with the distance to the stale LIB. [6](#0-5) 

The event processor enqueues a chain rollback to the LIB height, discarding all blocks and state changes since then. [7](#0-6) 

Critically, the evil miner detection mechanism only identifies miners who miss time slots based on `MissedTimeSlots` count, not those reporting incorrect `ImpliedIrreversibleBlockHeight` values. [8](#0-7) 

Malicious miners who continue producing blocks normally while reporting stale `ImpliedIrreversibleBlockHeight` values face no detection or penalty, allowing the attack to continue indefinitely.

## Impact Explanation

This vulnerability enables a complete blockchain halt through repeated rollbacks:

1. **Chain Rollback**: When Severe status is reached after 8 rounds without LIB advancement, the chain automatically rolls back to the stale LIB height, discarding all blocks, transactions, and state changes produced since then.

2. **Rollback Loop**: After rollback, malicious miners continue reporting the same stale `ImpliedIrreversibleBlockHeight` values. The LIB remains frozen, causing the chain to re-enter Severe status after another 8 rounds, triggering another rollback. This creates an infinite cycle.

3. **Loss of Liveness**: The blockchain loses the fundamental ability to make forward progress. All network participants cannot execute transactions, deploy contracts, transfer tokens, or interact with the system. Economic value is frozen and the entire blockchain ecosystem becomes non-functional.

4. **Undetected Attack**: Unlike miners who miss time slots (tracked by `MissedTimeSlots` and flagged as evil miners), those reporting incorrect LIB values are never detected, allowing the attack to persist without consequence.

This represents a complete consensus failure that violates the blockchain's fundamental liveness guarantee.

## Likelihood Explanation

**Attacker Requirements:**
- Control of ≥7 out of 21 miners (approximately 1/3 of consensus power)
- Ability to modify node software to report manipulated `ImpliedIrreversibleBlockHeight` values
- Coordination among colluding miners

**Attack Complexity:**
The attack is technically straightforward. Miners modify their node software to report a fixed or slowly incrementing `ImpliedIrreversibleBlockHeight` value instead of `Context.CurrentHeight` while continuing to produce blocks normally. The validation passes because it only checks non-decrease from their previous value.

**Economic Considerations:**
Miners stake significant capital and risk reputation. However, the penalty mechanism (`TryToDetectEvilMiners`) only applies to missed time slots based on `MissedTimeSlots` count. Malicious miners producing blocks with incorrect LIB values face no explicit penalty or detection.

**Likelihood Assessment:**
Medium-Low due to the requirement for ≥1/3 miner collusion. However, the complete absence of validation, detection, and penalty mechanisms for incorrect `ImpliedIrreversibleBlockHeight` reporting makes this a realistic attack vector. Standard Byzantine Fault Tolerant systems should tolerate up to 1/3 Byzantine participants for liveness, but this vulnerability violates that guarantee through a validation gap.

## Recommendation

Implement the following safeguards:

1. **Strict Validation**: Add validation in `LibInformationValidationProvider` to ensure `ImpliedIrreversibleBlockHeight` is within a reasonable range of `Context.CurrentHeight` (e.g., within 100 blocks):
```csharp
if (Math.Abs(providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight - validationContext.CurrentHeight) > 100)
{
    validationResult.Message = "ImpliedIrreversibleBlockHeight too far from current height.";
    return validationResult;
}
```

2. **Detection Mechanism**: Extend `TryToDetectEvilMiners` to detect miners reporting stale `ImpliedIrreversibleBlockHeight` values by comparing against other miners' reports or recent block heights.

3. **Penalty System**: Apply penalties (similar to those for `MissedTimeSlots`) to miners who repeatedly report incorrect `ImpliedIrreversibleBlockHeight` values.

4. **Recovery Mechanism**: Instead of automatic rollback loops, implement a recovery process that requires manual intervention or governance action when severe status persists across multiple cycles.

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario:

1. Initialize a blockchain with 21 miners
2. Have 7 miners modify their consensus data submission to always report `ImpliedIrreversibleBlockHeight = 1000` (a fixed stale value)
3. Have remaining 14 miners report honest values (current block height)
4. Observe LIB calculation: sorted list has 7 stale values [1000, 1000, 1000, 1000, 1000, 1000, 1000] followed by 14 honest values
5. Position (21-1)/3 = 6 returns 1000 (the 7th element), freezing LIB at height 1000
6. After 8 rounds without LIB advancement, Severe status triggers
7. Chain rolls back to height 1000
8. Cycle repeats indefinitely, preventing any forward progress

The test would verify:
- `LibInformationValidationProvider` accepts stale values that don't decrease
- `LastIrreversibleBlockHeightCalculator` returns stale height with 7 malicious miners
- `IrreversibleBlockHeightUnacceptable` event fires when Severe status reached
- Chain rollback occurs via `ResetChainToLibAsync`
- `TryToDetectEvilMiners` does not flag miners reporting incorrect LIB values

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L61-64)
```csharp
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-128)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockHeightUnacceptableLogEventProcessor.cs (L54-63)
```csharp
        if (distanceToLib.DistanceToIrreversibleBlockHeight > 0)
        {
            Logger.LogDebug($"Distance to lib height: {distanceToLib.DistanceToIrreversibleBlockHeight}");
            Logger.LogDebug("Will rollback to lib height.");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var chain = await _blockchainService.GetChainAsync();
                    await _blockchainService.ResetChainToLibAsync(chain);
                }, KernelConstants.UpdateChainQueueName);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
