# Audit Report

## Title
Orphaned AssembledNftsMap Entries Enable Permanent Locking of NFTs When Assembled Tokens Are Burned

## Summary
The NFT contract's `Burn` method lacks validation to prevent burning assembled NFTs, and fails to clean up `AssembledNftsMap` entries. When a minter directly burns an assembled NFT instead of calling `Disassemble`, all component NFTs/FTs locked during assembly become permanently irrecoverable, as they remain in the contract's balance with no mechanism to retrieve them.

## Finding Description

The vulnerability exists in the `Burn` method's failure to account for assembled NFTs that contain locked components.

**The Assemble/Disassemble Pattern:**

When users create composite NFTs via `Assemble`, component NFTs are transferred to `Context.Self` (the contract address) and tracked in `AssembledNftsMap`. [1](#0-0) [2](#0-1) 

The `Disassemble` method correctly handles cleanup by: (1) burning the assembled NFT, (2) retrieving locked components from `AssembledNftsMap`, (3) transferring them back to the receiver, and (4) removing the map entry. [3](#0-2) 

**The Vulnerability:**

The `Burn` method only validates that the protocol is burnable and that the caller has sufficient balance AND is a minter. [4](#0-3)  Critically, the entire `Burn` method contains NO reference to `AssembledNftsMap` or `AssembledFtsMap` - it performs no checks to detect assembled NFTs and no cleanup of map entries.

**Why Recovery is Impossible:**

Once an assembled NFT is burned directly:
1. The NFT's balance becomes 0 [5](#0-4) 
2. The locked components remain in `Context.Self`'s balance
3. The `AssembledNftsMap` entry persists as an orphaned record
4. `Disassemble` cannot be called because it first calls `Burn`, which will fail when the balance is already 0 [6](#0-5) 
5. No emergency withdrawal or administrative rescue mechanism exists in the contract

## Impact Explanation

**HIGH severity** due to:

1. **Permanent Asset Loss**: All NFTs and FTs locked in an assembled NFT become permanently irrecoverable when the assembled NFT is burned directly. The assets remain in the contract's balance but are inaccessible by any method.

2. **No Recovery Mechanism**: The NFT contract contains no emergency withdrawal functionality or administrative override to retrieve orphaned assets.

3. **Broken Invariant**: This violates the fundamental lock/unlock correctness guarantee - assets that are locked together should always be retrievable through the proper unlock mechanism.

4. **Potential Value Loss**: Locked NFTs may have substantial value (rare collectibles, utility NFTs with access rights, etc.), and third parties who transferred valuable NFTs to a minter for assembly lose their assets permanently.

## Likelihood Explanation

**MEDIUM-HIGH probability** because:

1. **Low Attack Complexity**: A single direct call to `Burn` on an assembled NFT triggers the vulnerability - no complex transaction sequencing required.

2. **Realistic Preconditions**: 
   - The caller must be a minter (automatically true for anyone who assembled NFTs, as `Assemble` calls `PerformMint` which requires minter permission) [7](#0-6) [8](#0-7) 
   - The protocol must have `IsBurnable = true` (common configuration)
   - The caller must own the assembled NFT (natural state after assembling)

3. **High User Error Probability**: Users may not understand the critical difference between `Burn` and `Disassemble`. Natural user behavior when wanting to "destroy" an NFT is to call `Burn`, with no warning in the code or interface that this is unsafe for assembled NFTs.

4. **No Protection**: The contract provides no guard rails - `Burn` treats assembled NFTs identically to regular NFTs.

## Recommendation

Add a check in the `Burn` method to prevent burning assembled NFTs:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Add this check to prevent burning assembled NFTs
    Assert(State.AssembledNftsMap[tokenHash] == null && State.AssembledFtsMap[tokenHash] == null,
        "Cannot burn assembled NFT directly. Use Disassemble method to unlock components first.");
    
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    // ... rest of existing Burn logic
}
```

Alternatively, add automatic cleanup logic in `Burn` to handle assembled NFTs properly, though the simpler approach of requiring explicit disassembly is clearer and safer.

## Proof of Concept

```csharp
[Fact]
public async Task BurnAssembledNFT_LocksComponentsPermanently()
{
    // Setup: Create and mint NFT protocol
    var symbol = await CreateTest(); // Creates burnable NFT protocol
    await AddMinterAsync(symbol);
    
    // Mint a component NFT
    var componentTokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Owner = MinterAddress
    })).Output;
    
    // Approve and Assemble - locks the component NFT
    await TokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
    {
        Spender = NFTContractAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    var assembledTokenHash = (await MinterNFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        AssembledNfts = new AssembledNfts
        {
            Value = { [componentTokenHash.ToHex()] = 1 }
        },
        AssembledFts = new AssembledFts
        {
            Value = { ["ELF"] = 100 }
        }
    })).Output;
    
    // Verify component is locked in contract
    var contractBalance = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        TokenHash = componentTokenHash,
        Owner = NFTContractAddress
    });
    contractBalance.Balance.ShouldBe(1);
    
    // VULNERABILITY: Burn the assembled NFT directly (should fail but doesn't)
    await MinterNFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = assembledTokenId,
        Amount = 1
    });
    
    // Verify: Component NFT is now PERMANENTLY LOCKED
    // 1. Still in contract's balance
    contractBalance = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        TokenHash = componentTokenHash,
        Owner = NFTContractAddress
    });
    contractBalance.Balance.ShouldBe(1); // Still locked!
    
    // 2. Cannot call Disassemble (will fail - assembled NFT no longer exists)
    var disassembleResult = await MinterNFTContractStub.Disassemble.SendWithExceptionAsync(new DisassembleInput
    {
        Symbol = symbol,
        TokenId = assembledTokenId
    });
    disassembleResult.TransactionResult.Error.ShouldContain("No permission"); // Fails because balance = 0
    
    // 3. No way to recover the locked component NFT
    // Result: Permanent loss of assets
}
```

This test demonstrates that burning an assembled NFT directly causes permanent locking of component assets with no recovery path.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L130-130)
```csharp
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L175-175)
```csharp
        var nftMinted = PerformMint(mingInput, true);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-176)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-236)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }

        Context.Fire(new Disassembled
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            DisassembledNfts = assembledNfts ?? new AssembledNfts(),
            DisassembledFts = assembledFts ?? new AssembledFts()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L399-399)
```csharp
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```
