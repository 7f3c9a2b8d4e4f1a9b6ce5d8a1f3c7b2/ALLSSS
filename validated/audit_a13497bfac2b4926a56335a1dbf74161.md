# Audit Report

## Title
Scheme Manager Can Manipulate Minimum Lock Period by Calling CreateScheme Multiple Times

## Summary
The `CreateScheme` method in the TokenHolderContract lacks validation to prevent duplicate scheme creation. A scheme manager can call `CreateScheme` multiple times, causing the stored scheme parameters (including `MinimumLockMinutes`) to be overwritten. This allows the manager to manipulate withdrawal timing for users who have already locked tokens, either enabling premature withdrawal or extending their lock period beyond what they agreed to.

## Finding Description

The vulnerability exists because the `CreateScheme` method does not validate whether a scheme already exists for the caller. [1](#0-0) 

Each invocation of `CreateScheme` performs two critical actions:
1. Creates a new Profit scheme in the Profit contract with a unique SchemeId
2. Overwrites the `State.TokenHolderProfitSchemes[Context.Sender]` mapping with new parameters

When users lock tokens via `RegisterForProfits`, they record their lock timestamp and are registered as beneficiaries in a Profit scheme. [2](#0-1) 

The critical flaw emerges during withdrawal. The `Withdraw` method retrieves the scheme and validates the lock period using `MinimumLockMinutes`. [3](#0-2) 

The scheme is retrieved via `GetValidScheme`, which reads from `State.TokenHolderProfitSchemes[manager]`. [4](#0-3) 

The `UpdateTokenHolderProfitScheme` method then resolves the correct `SchemeId` by querying the Profit contract for the FIRST scheme created by that manager (using `.FirstOrDefault()`). [5](#0-4) 

However, while `UpdateTokenHolderProfitScheme` correctly updates the `SchemeId` field to point to the first Profit scheme (where users are actually registered), it does NOT update the `MinimumLockMinutes` field. This field retains whatever value was written during the LAST call to `CreateScheme`.

**Attack Scenario:**
1. Manager calls `CreateScheme({symbol: "ELF", minimum_lock_minutes: 100000})` - Creates Scheme A
2. User calls `RegisterForProfits` - Locks tokens at time T, registered to Scheme A, expecting 100000 minute lock
3. Manager calls `CreateScheme({symbol: "ELF", minimum_lock_minutes: 1})` - Creates Scheme B, overwrites TokenHolderProfitSchemes entry with MinimumLockMinutes=1
4. User calls `Withdraw` - GetValidScheme returns scheme with SchemeId=A (correct) but MinimumLockMinutes=1 (manipulated)
5. Withdrawal succeeds after only 1 minute instead of 100000 minutes

## Impact Explanation

This vulnerability has HIGH severity impact:

**Direct Financial Impact:**
- Users who locked tokens with the expectation of a specific minimum lock duration can have their withdrawal constraints arbitrarily modified
- If `MinimumLockMinutes` is reduced, users can withdraw immediately, violating the economic assumptions of the profit-sharing scheme
- If `MinimumLockMinutes` is increased, users are trapped beyond their originally agreed lock period, potentially indefinitely

**Economic Model Breach:**
- Profit distribution schemes depend on predictable token lock durations to ensure fair profit allocation among long-term participants
- Premature withdrawal breaks the commitment period that was used to calculate expected returns
- This undermines trust and economic incentive alignment in the TokenHolder ecosystem

**Systemic Trust Violation:**
- Users enter token locks with explicit contractual expectations about withdrawal timing based on the scheme's published `MinimumLockMinutes`
- Unilateral parameter modification by the scheme manager breaks this fundamental social contract
- The change affects ALL existing participants in the scheme simultaneously without their consent

## Likelihood Explanation

This vulnerability has HIGH likelihood:

**Trivial Exploitability:**
- The `CreateScheme` method is publicly callable without any special permissions or governance requirements
- The scheme manager (original creator) can call it at any time with standard transaction execution
- No race conditions, external dependencies, or complex preconditions are required

**Attack Complexity:**
- LOW - Requires only two simple transactions from the scheme manager's address
- No sophisticated techniques or deep protocol knowledge needed
- Could even occur accidentally if a manager attempts to "update" scheme parameters

**Realistic Preconditions:**
- Manager controls the original address used to create the scheme (normal operational assumption)
- Users have already registered and locked tokens in the scheme (the intended use case)
- No monitoring systems exist to detect parameter overwrites (no events emitted for scheme updates)

**Detection Difficulty:**
- The overwrite occurs through a normal `CreateScheme` transaction that looks identical to initial scheme creation
- No specific events indicate that existing scheme parameters have been modified
- Users only discover the manipulation when attempting withdrawal

## Recommendation

Add validation in the `CreateScheme` method to prevent duplicate scheme creation:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this address. Cannot create duplicate.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, if scheme parameter updates are intended functionality, implement a separate `UpdateScheme` method with appropriate safeguards such as:
- Requiring existing participants to opt-in or migrate
- Enforcing that `MinimumLockMinutes` can only increase, never decrease
- Adding governance controls for parameter modifications

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_Multiple_Times_Bypasses_MinimumLockPeriod_Test()
{
    // Step 1: Manager creates scheme with long lock period (100000 minutes)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100000
    });

    // Step 2: User locks tokens expecting 100000 minute lock
    var lockAmount = 1000L;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = lockAmount,
        SchemeManager = Starter
    });

    // Verify user is locked
    var lockId = State.LockIds[Starter][Starter];
    lockId.ShouldNotBeNull();

    // Step 3: Verify withdrawal fails immediately (as expected)
    var earlyWithdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(Starter);
    earlyWithdrawResult.TransactionResult.Error.ShouldContain("Cannot withdraw");

    // Step 4: ATTACK - Manager calls CreateScheme again with short lock period (1 minute)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });

    // Step 5: VULNERABILITY - User can now withdraw immediately despite original 100000 minute lock
    var balanceBeforeWithdraw = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "ELF",
        Owner = Starter
    })).Balance;

    // Withdrawal succeeds with manipulated lock period
    await TokenHolderContractStub.Withdraw.SendAsync(Starter);

    var balanceAfterWithdraw = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "ELF",
        Owner = Starter
    })).Balance;

    // User successfully withdrew despite only 1 minute passing (not 100000)
    balanceAfterWithdraw.ShouldBe(balanceBeforeWithdraw + lockAmount);
}
```

## Notes

The vulnerability stems from a fundamental architectural issue where the TokenHolder contract stores only one scheme configuration per manager address, but the Profit contract can have multiple schemes per manager. This mismatch, combined with the lack of duplicate creation checks, enables the parameter manipulation attack.

The `UpdateTokenHolderProfitScheme` method correctly resolves to the FIRST Profit scheme (where users are registered) using `.FirstOrDefault()`, but it fails to protect the `MinimumLockMinutes` parameter from being overwritten by subsequent `CreateScheme` calls.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-229)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```
