# Audit Report

## Title
Permanent Token Lock via Scheme Symbol Overwrite in TokenHolderContract

## Summary
The `CreateScheme` function in TokenHolderContract allows managers to call it multiple times, unconditionally overwriting the stored scheme's symbol. Users who registered under the original scheme have their tokens permanently locked because the `Withdraw` function queries locked amounts using the new scheme symbol instead of the original symbol, resulting in zero balance detection and irreversible lockId deletion.

## Finding Description

The vulnerability chain consists of multiple technical flaws:

**Flaw 1: No Duplicate Call Protection**
`CreateScheme` unconditionally overwrites the `TokenHolderProfitSchemes` state mapping without checking if a scheme already exists for the manager. [1](#0-0) 

Each invocation creates a distinct scheme in ProfitContract with a unique schemeId, and ProfitContract appends all schemes to the manager's scheme list. [2](#0-1) 

**Flaw 2: Symbol-Agnostic Virtual Address with Symbol-Specific Balances**
When users register, tokens are locked using the scheme's symbol at that time. The lock creates a virtual address computed from `HashHelper.ComputeFrom(Context.Sender + userAddress + lockId)` - notably WITHOUT the symbol. [3](#0-2) 

The virtual address stores balances per symbol separately, like any normal address.

**Flaw 3: Symbol Mismatch in Withdrawal**
When `Withdraw` is called after the scheme symbol has changed, `GetValidScheme` retrieves the scheme from state with the NEW symbol. [4](#0-3) 

The `UpdateTokenHolderProfitScheme` method fetches the FIRST scheme from ProfitContract using `FirstOrDefault()`, but crucially preserves the Symbol from the current state (the NEW symbol). [5](#0-4) 

**Flaw 4: Zero-Amount Unlock with Irreversible State Deletion**
`Withdraw` calls `GetLockedAmount` with the mismatched symbol, which queries the balance of that symbol at the virtual address. [6](#0-5) 

`GetLockedAmount` computes the same virtual address and returns the balance for the queried symbol. [7](#0-6) 

Since tokens were locked with Symbol A but the query uses Symbol B, the returned amount is zero. The unlock proceeds with zero amount, but critically, the lockId mapping is deleted regardless. [8](#0-7) 

**Flaw 5: No Recovery Path**
Users cannot unlock directly through MultiToken because the virtual address computation in `Unlock` uses `Context.Sender`, which would be the user's address when called directly, not the TokenHolderContract address used during locking. [9](#0-8) 

This creates different virtual addresses, making direct unlock impossible.

## Impact Explanation

**Direct Financial Loss:** Complete and permanent loss of all tokens locked under the original scheme symbol. If 1,000 users each locked 100 ELF tokens (100,000 ELF total) under a scheme with Symbol="ELF", and the manager calls `CreateScheme` again with Symbol="USDT", all 100,000 ELF become permanently irrecoverable.

**Affected Users:** Every user who called `RegisterForProfits` before the second `CreateScheme` invocation. The impact scales with scheme popularity - established schemes could trap millions in value.

**Irrecoverable Nature:** After `Withdraw` executes with zero amount, the lockId mapping is deleted from contract state. No contract method exists to restore this mapping or unlock with the original symbol. The tokens remain at the virtual address with no contract-level reference to them.

**Severity Justification:** HIGH severity because:
1. Results in complete, permanent loss of principal (not just rewards)
2. Zero recovery mechanism at contract or protocol level
3. Affects arbitrary amounts across multiple users
4. Virtual address becomes orphaned with no state references

## Likelihood Explanation

**Attack Vectors:**

*Malicious Manager:* Intentionally locks user funds by calling `CreateScheme` twice with different symbols, preventing withdrawals while retaining profit distribution control.

*Accidental Trigger:* Manager genuinely believes they can "update" their scheme's configuration (symbol, lock duration, thresholds) by calling `CreateScheme` again, not realizing it breaks existing registrations.

*Compromised Keys:* Attacker gains access to manager's private key and executes this attack to harm users.

**Execution Simplicity:**
- Requires only TWO transactions: initial `CreateScheme(Symbol="ELF")`, then second `CreateScheme(Symbol="USDT")`
- No special permissions beyond being the scheme creator
- No timing dependencies or complex state requirements
- Works regardless of how many users have registered (1 or 10,000)

**Detection Difficulty:**
- No events emitted when scheme is overwritten
- No contract warnings or validations
- Users only discover the issue upon attempting withdrawal, potentially months after the overwrite
- Blockchain state shows no obvious anomaly - the scheme simply has a different symbol

**Probability Assessment:** MEDIUM-HIGH likelihood because:
- Function name `CreateScheme` suggests single invocation, but lacks enforcement
- No documentation warns against multiple calls
- Managers may reasonably expect to "update" scheme parameters
- No UI-level protection in typical dApp frontends
- Precedent exists in Web3 of similar "update" functions being one-time-only

## Recommendation

**Immediate Fix:** Add a duplicate protection check in `CreateScheme`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager. Cannot create duplicate scheme.");
    
    // Existing logic continues...
    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput { ... });
    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme { ... };
    return new Empty();
}
```

**Alternative Approach:** If scheme updates are desired functionality, implement a dedicated `UpdateScheme` method that:
1. Validates no users have registered (TotalShares == 0)
2. Only updates allowed parameters (not the symbol, which breaks locks)
3. Explicitly documents which fields are mutable vs immutable

**Migration Plan for Affected Users:**
If this vulnerability has already been triggered on mainnet:
1. Deploy a recovery contract with privileged MultiToken unlock permissions
2. Query all lockIds for the affected scheme manager
3. For each affected user, compute their virtual address and unlock tokens with the ORIGINAL symbol
4. Transfer recovered tokens back to user addresses

## Proof of Concept

```csharp
[Fact]
public async Task ProofOfConcept_PermanentTokenLockViaSymbolOverwrite()
{
    // Setup: Manager creates initial scheme with ELF symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });

    // User registers and locks 1000 ELF tokens
    var userStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, UserKeyPairs.First());
    
    var userBalanceBefore = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddresses.First(),
        Symbol = "ELF"
    })).Balance;
    
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = 1000,
        SchemeManager = Starter
    });

    // Verify tokens are locked
    var userBalanceAfterLock = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddresses.First(),
        Symbol = "ELF"
    })).Balance;
    (userBalanceBefore - userBalanceAfterLock).ShouldBe(1000);

    // ATTACK: Manager calls CreateScheme again with different symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",  // Different symbol!
        MinimumLockMinutes = 1
    });

    // Fast forward time past minimum lock period
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(10));

    // User attempts to withdraw - this will succeed but unlock 0 tokens
    await userStub.Withdraw.SendAsync(Starter);

    // Verify user did NOT receive their tokens back
    var userBalanceAfterWithdraw = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddresses.First(),
        Symbol = "ELF"
    })).Balance;
    
    // User balance unchanged - tokens are permanently locked!
    userBalanceAfterWithdraw.ShouldBe(userBalanceAfterLock);
    
    // Verify user cannot withdraw again (lockId deleted)
    var secondWithdrawResult = await userStub.Withdraw.SendWithExceptionAsync(Starter);
    secondWithdrawResult.TransactionResult.Error.ShouldContain("Sender didn't register for profits");
    
    // Tokens are permanently lost - 1000 ELF stuck at virtual address
}
```

**Notes:**

This vulnerability breaks the fundamental security guarantee that users can withdraw their locked tokens after the minimum lock period. The root cause is the combination of: (1) stateless virtual address computation that ignores symbols, (2) stateful scheme storage that gets overwritten, and (3) irreversible lockId deletion on withdrawal attempts. The fix requires preventing duplicate `CreateScheme` calls, as the current design fundamentally cannot support scheme updates once users have registered.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-225)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L230-238)
```csharp
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L280-281)
```csharp
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-297)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L234-235)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L104-115)
```csharp
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```
