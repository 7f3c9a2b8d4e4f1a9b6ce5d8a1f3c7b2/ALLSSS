# Audit Report

## Title
Banned Miners Can Be Re-Selected As Block Producers Through Backup Selection Logic

## Summary
The `GetVictories` function's backup miner selection logic fails to verify banned status (`State.BannedPubkeyMap`) when selecting miners from the current miner list. This allows previously banned/evil miners who remain in the consensus contract's current round to be automatically re-elected as block producers for the next term when there are insufficient valid candidates, completely bypassing the evil miner detection and banning mechanism.

## Finding Description

The Election contract's `GetVictories` method determines which miners will produce blocks in the next term. During term transitions, the consensus contract calls this method to obtain the elected miner list. [1](#0-0) 

When there aren't enough valid candidates to fill all required miner positions (`diff > 0`), the function employs a backup selection mechanism that retrieves current miners from the consensus contract. [2](#0-1) 

The vulnerable code creates a fallback list from current miners who are not in the valid candidates list: [3](#0-2) 

**This line completely omits checking `State.BannedPubkeyMap[k]` to filter out banned miners.**

When a miner is marked as evil through `UpdateCandidateInformation` with `IsEvilNode=true`, the Election contract sets the ban flag [4](#0-3)  and removes them from the candidate list. [5](#0-4) 

However, this does NOT immediately remove the banned miner from the consensus contract's current round. The `GetCurrentMinerList` method simply returns miners from the current round's information: [6](#0-5) 

Additionally, the evil miner replacement logic in `GenerateNextRoundInformation` only executes within the same term, not during term transitions: [7](#0-6) 

Therefore, banned miners remain in `currentMiners` during term transitions. Since they are no longer in `validCandidates` (removed from candidate list), they pass the filter on line 66 and get added to the victories list for the next term.

**Evidence of Inconsistency:**

The codebase demonstrates clear awareness of this requirement in `GetMinerReplacementInformation`, which explicitly filters out banned initial miners: [8](#0-7) 

The `GetEvilMinersPubkeys` function confirms that current miners can indeed be banned: [9](#0-8) 

This proves the codebase IS aware that banned status checks are necessary, but the `GetVictories` backup selection logic omits this critical validation.

## Impact Explanation

**Direct Consensus Integrity Violation:**
- Banned/evil miners who were explicitly detected and marked as malicious can be automatically re-selected as block producers for the next term
- This completely undermines the evil miner detection mechanism implemented throughout the AEDPoS consensus system
- Banned miners continue producing blocks, earning mining rewards and subsidies, and potentially causing further harm to network security

**Reward Misallocation:**
- Evil miners continue receiving block production rewards, mining subsidies from the Treasury contract, and profit distributions despite being explicitly banned
- Honest alternative candidates are systematically denied their rightful block production slots
- The Profit and Treasury distribution schemes continue rewarding malicious actors who should have been excluded

**Security Compromise:**
- The consensus system's security model assumes banned miners are permanently excluded from future rounds, but this assumption is violated
- Networks with low candidate participation become vulnerable to persistent control by previously-identified malicious miners
- The evil miner replacement mechanism becomes ineffective if banned miners are immediately re-elected through the backup selection path

## Likelihood Explanation

**Feasible Preconditions:**
- Requires `State.MinersCount.Value > validCandidates.Count` (insufficient candidates with active votes)
- This scenario is highly realistic in networks with low candidate participation, during initial network stages, or following mass candidate withdrawals
- At least one current miner must be banned via `UpdateCandidateInformation(IsEvilNode=true)` or through the emergency response organization

**Execution Path:**
1. Consensus contract detects evil miner behavior and calls `UpdateCandidateInformation(IsEvilNode=true)` to ban the miner [10](#0-9) 
2. Banned miner is marked in `BannedPubkeyMap` and removed from candidate list, but remains in current consensus round
3. At next term transition, consensus contract calls `GetVictories` through `GenerateFirstRoundOfNextTerm` [11](#0-10) 
4. If insufficient valid candidates exist (`diff > 0`), backup selection logic executes without banned status check
5. Banned miner is automatically re-selected and included in the next term's miner list

**Probability Assessment:**
- **High** in networks with low candidate participation (common in early-stage blockchain networks and during bear markets)
- **Automatic** - no explicit attacker action needed; the vulnerability triggers during normal term transitions
- **Repeatable** - can occur at every subsequent term transition until the candidate pool increases sufficiently

## Recommendation

Add a banned status check in the backup selection logic of `GetVictories`:

```csharp
var backups = currentMiners.Where(k => !validCandidates.Contains(k) && !State.BannedPubkeyMap[k]).ToList();
```

This ensures consistency with other parts of the codebase that properly filter out banned miners, such as `GetMinerReplacementInformation`.

## Proof of Concept

```csharp
[Fact]
public async Task BannedMinersCanBeReelectedDuringTermTransition()
{
    // Setup: Create insufficient valid candidates scenario
    await InitializeElectionWithMinimalCandidates();
    
    // Get current miners and ban one of them
    var currentMiners = await ConsensusContract.GetCurrentMinerList.CallAsync(new Empty());
    var minerToBan = currentMiners.Pubkeys.First().ToHex();
    
    // Ban the miner via UpdateCandidateInformation
    await ConsensusContract.UpdateCandidateInformation.SendAsync(new UpdateCandidateInformationInput
    {
        Pubkey = minerToBan,
        IsEvilNode = true
    });
    
    // Verify miner is banned in Election contract
    var bannedStatus = await ElectionContract.IsPubkeyBanned.CallAsync(new StringValue { Value = minerToBan });
    bannedStatus.Value.ShouldBeTrue();
    
    // Trigger term transition with insufficient valid candidates
    await MineToNextTermAsync();
    
    // Get new victories list for next term
    var victories = await ElectionContract.GetVictories.CallAsync(new Empty());
    
    // Vulnerability: Banned miner is included in victories
    victories.Value.Select(v => v.ToHex()).ShouldContain(minerToBan);
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-50)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L66-66)
```csharp
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L96-96)
```csharp
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L107-110)
```csharp
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-299)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L148-153)
```csharp
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
```
