# Audit Report

## Title
Empty Miner List Validation Bypass Leading to Complete Blockchain Halt

## Summary
A critical logic error in the `ValidationForNextRound()` method allows malicious miners to commit rounds with zero miners to blockchain state, causing permanent consensus failure. The vulnerability stems from incorrect use of LINQ's `Any()` method on empty collections, which returns `false` and causes the validation to succeed when it should fail.

## Finding Description

The `RoundTerminateValidationProvider` validates next round information during `NextRound` and `NextTerm` consensus transitions. The validation contains a ternary operator that checks whether miners have `InValue` set: [1](#0-0) 

The logic intends to verify that no miner has `InValue` populated in the next round. However, when `RealTimeMinersInformation.Values` is an empty collection, the `Any(m => m.InValue != null)` predicate returns `false` (since there are no elements to evaluate), causing the ternary operator to return **success** instead of failure.

This validation is invoked during pre-execution validation for both `NextRound` and `NextTerm` behaviors: [2](#0-1) 

A malicious miner who passes the initial mining permission check (by being in the current round) can craft a `NextRoundInput` with empty `RealTimeMinersInformation`: [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` also fails to catch empty miner lists because both counts evaluate to zero: [4](#0-3) 

Once validation passes, the empty round is committed directly to state without any miner count validation: [5](#0-4) [6](#0-5) 

Post-execution validation does not catch this issue because it only validates round hash consistency for `UpdateValue` and `TinyBlock` behaviors, not `NextRound` or `NextTerm`: [7](#0-6) 

After the malicious empty round becomes the current round, all subsequent block production attempts fail because no miner can satisfy the `MiningPermissionValidationProvider` check against an empty miner list: [8](#0-7) 

With `BaseRound.RealTimeMinersInformation.Keys` being empty, no sender's public key can be contained in the collection, resulting in permanent blockchain halt.

## Impact Explanation

**Critical Consensus Failure**: This vulnerability breaks the fundamental invariant that every consensus round must contain at least one miner. An empty miner list renders the consensus mechanism completely non-functional.

**Permanent Blockchain Halt**: Once an empty round is committed, no miner can produce the next block because the mining permission check requires the producer to exist in the current round's miner list. With zero miners in the list, this check fails for all potential producers. The blockchain enters an unrecoverable halted state.

**Network-Wide Scope**: All network nodes synchronizing this malicious block will reach the same halted state. Normal consensus operations cannot resume without manual intervention, state rollback, or a hard fork.

**No Self-Recovery**: Unlike transient DoS attacks that resolve when the attack stops, this creates permanent damage to blockchain state that persists indefinitely.

## Likelihood Explanation

**Low Barrier to Entry**: The attacker only needs to be an active miner in the current round, which is achievable through the standard election process. No special privileges or compromised keys are required.

**Deterministic Exploit**: The attack is straightforward to execute:
1. Wait for a mining time slot (normal miner operation)
2. Construct a `NextRoundInput` or `NextTermInput` with empty `RealTimeMinersInformation`
3. Produce the block with this malicious extra data

**No Complex Preconditions**: The attack requires no race conditions, no specific blockchain state (beyond being a miner), and no coordination with other actors.

**Validation Bypass is Guaranteed**: The logical error ensures that empty miner lists will always pass validation. The bug is deterministic, not probabilistic.

**Detection Difficulty**: The malicious block appears valid during pre-execution validation. Post-execution validation also passes. Only after the block is committed does the damage manifest, at which point it's too late to prevent.

## Recommendation

Add explicit validation to ensure `RealTimeMinersInformation` is not empty:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // Validate that miner list is not empty
    if (extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Next round must contain at least one miner." };
    
    // Validate that InValue fields are null
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task EmptyMinerListBypass_CausesBlockchainHalt()
{
    // Setup: Initialize consensus with normal miners
    var initialMiners = GenerateInitialMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Attacker is a valid miner in current round
    var attackerKeyPair = initialMiners[0];
    
    // Attacker crafts malicious NextRoundInput with EMPTY miner list
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = { }, // Empty!
        TermNumber = 1,
        RandomNumber = ByteString.CopyFrom(GenerateRandomBytes())
    };
    
    // Execute NextRound - validation should fail but doesn't due to bug
    var result = await ExecuteNextRoundAs(attackerKeyPair, maliciousNextRound);
    result.Status.ShouldBe(TransactionResultStatus.Mined); // Bug: succeeds
    
    // Verify empty round was committed
    var currentRound = await GetCurrentRound();
    currentRound.RealTimeMinersInformation.Count.ShouldBe(0);
    
    // Attempt to produce next block - ALL miners fail
    foreach (var miner in initialMiners)
    {
        var nextBlockResult = await TryProduceBlockAs(miner);
        nextBlockResult.Status.ShouldBe(TransactionResultStatus.Failed);
        nextBlockResult.Error.ShouldContain("is not a miner"); // MiningPermissionValidationProvider fails
    }
    
    // Blockchain is permanently halted - no miner can produce blocks
}
```

## Notes

This vulnerability affects both mainchain and sidechain deployments. The fix must be applied to the `RoundTerminateValidationProvider` to add explicit non-empty validation before checking individual miner properties. The empty collection edge case bypasses the intended validation logic due to LINQ's `Any()` semantics on empty enumerables.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
