# Audit Report

## Title
Missing Signature Correctness Validation in UpdateValue Allows Mining Order Manipulation

## Summary
The AEDPoS consensus contract accepts arbitrary signature values in `UpdateValue` operations without validating they match the protocol-specified calculation `previousRound.CalculateSignature(previousInValue)`. Since signatures directly determine mining order in subsequent rounds through modulo arithmetic, malicious miners can manipulate their block production schedule to gain unfair advantages in rewards and transaction ordering influence.

## Finding Description

The vulnerability exists in the signature validation flow for consensus `UpdateValue` operations. When miners produce blocks, they submit an `UpdateValueInput` containing a signature field that should be deterministically calculated from their previous round's in-value and all miners' signatures from the previous round.

**Signature Generation (Honest Path):**

The correct signature calculation occurs during block production: [1](#0-0) 

This signature is then included in the round data and extracted for the transaction: [2](#0-1) 

**Missing Validation:**

However, when the `UpdateValue` transaction is processed, the provided signature is blindly accepted without verification: [3](#0-2) 

The validation provider only checks that the signature field is non-empty, not that it's correctly calculated: [4](#0-3) 

The previous in-value is validated (that it hashes to the previous out-value), but the signature itself is never compared against the expected value: [5](#0-4) 

**Impact on Mining Order:**

The signature directly determines each miner's position in the next round through modulo arithmetic: [6](#0-5) 

**Attack Execution:**

Since miners control both the block header consensus extra data and the UpdateValue transaction parameter, they can:
1. Calculate which signature value (as int64) modulo miner count gives their desired position
2. Set both the header's `Round.Signature` and transaction's `UpdateValueInput.Signature` to that value
3. Submit the block with modified signature
4. Pass all validations since none check signature correctness
5. Gain their chosen position in the next round's mining schedule

The `ValidateConsensusAfterExecution` only ensures consistency between header and final state, but neither validates the signature is correctly calculated: [7](#0-6) 

## Impact Explanation

This vulnerability breaks the **fairness and unpredictability** guarantees of the AEDPoS consensus mechanism. The signature is designed to be deterministic based on all miners' inputs, creating a fair distribution of mining opportunities. By allowing arbitrary signatures, the protocol permits:

1. **Disproportionate Block Rewards** - Miners can position themselves to mine more frequently, gaining larger shares of block production rewards
2. **Transaction Ordering Influence** - More frequent block production grants greater control over transaction inclusion and ordering
3. **Potential Collusion** - Multiple malicious miners could coordinate signature manipulation to dominate the mining schedule

While this doesn't enable direct fund theft, it fundamentally undermines consensus integrity - a critical protocol invariant. The impact is categorized as **Medium to High** because it allows systematic gaming of the consensus mechanism by any authorized miner.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible because:

**Attacker Capabilities:** Any authorized miner in the current round can execute this attack with no additional privileges required beyond normal mining rights.

**Attack Complexity:** Low - The miner simply needs to:
- Determine their desired mining position (1 to N)
- Calculate: `targetModuloResult = desiredPosition - 1`  
- Find any signature value where: `GetAbsModulus(signature.ToInt64(), minersCount) == targetModuloResult`
- Submit UpdateValue with this crafted signature

**Feasibility Conditions:**
- Attacker must be an authorized miner (standard consensus threat model assumption)
- No special preconditions or state requirements
- Can be executed on every block produced

**Detection Constraints:** The attack is completely silent - no validation failures or events indicate signature manipulation. The VRF verification validates the `random_number` field (used for random hash generation), which is separate from the `Signature` field used for order calculation: [8](#0-7) 

The signature correctness is never verified anywhere in the codebase.

## Recommendation

Add signature correctness validation to the `UpdateValueValidationProvider`:

```csharp
private bool ValidateSignatureCorrectness(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;
    
    var providedSignature = extraData.Round.RealTimeMinersInformation[publicKey].Signature;
    if (providedSignature == null || providedSignature == Hash.Empty) 
        return true;
    
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    if (previousInValue == null || previousInValue == Hash.Empty) 
        return true;
    
    // Verify signature matches expected calculation
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    return providedSignature == expectedSignature;
}
```

Then call this validation in the `ValidateHeaderInformation` method:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    if (!NewConsensusInformationFilled(validationContext))
        return new ValidationResult { Message = "Incorrect new Out Value." };

    if (!ValidatePreviousInValue(validationContext))
        return new ValidationResult { Message = "Incorrect previous in value." };
    
    if (!ValidateSignatureCorrectness(validationContext))
        return new ValidationResult { Message = "Signature does not match expected calculation." };

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

A test demonstrating this vulnerability would:
1. Setup a round with multiple miners
2. Have an attacker miner calculate a signature value that gives them position 1 (first in next round)
3. Submit UpdateValue with the crafted signature instead of the correctly calculated one
4. Verify the transaction succeeds (no validation failure)
5. Verify the attacker's `SupposedOrderOfNextRound` reflects their chosen position
6. Confirm no other validation catches this manipulation

The test would show that arbitrary signature values are accepted and directly affect mining order without any correctness validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L38-38)
```csharp
            Signature = minerInRound.Signature,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L76-78)
```csharp
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
