# Audit Report

## Title
Unvalidated Secret Reconstruction in RevealSharedInValues Allows Consensus State Corruption

## Summary
The `RevealSharedInValues()` function reconstructs miners' InValues from DecryptedPieces using Shamir's Secret Sharing without validating that the reconstructed secret matches the original OutValue hash. A malicious miner can provide corrupted DecryptedPieces that cause incorrect PreviousInValue storage, leading to consensus state corruption when these values are used to generate miner signatures.

## Finding Description

The vulnerability exists in the AEDPoS consensus secret sharing mechanism where miners commit to random InValues via OutValue hashes (OutValue = Hash(InValue)) and later reveal them for verification. The secret sharing allows recovery if miners go offline, but the reconstruction lacks critical validation.

**Complete Attack Flow:**

1. **DecryptedPieces Storage Without Validation**: When miners submit UpdateValue transactions, `PerformSecretSharing` adds their DecryptedPieces directly to the round state without any validation. [1](#0-0) 

2. **Unvalidated Secret Reconstruction**: The `RevealSharedInValues` function extracts DecryptedPieces and reconstructs InValues using `SecretSharingHelper.DecodeSecret`. [2](#0-1) 

3. **No Error Detection**: The `DecodeSecret` implementation performs Lagrange interpolation which always succeeds mathematically, even with corrupted inputs, providing no error detection mechanism. [3](#0-2) 

4. **Missing Critical Validation**: The reconstructed value is stored directly as PreviousInValue without verifying that Hash(reconstructed_secret) equals the original OutValue from the previous round. [4](#0-3) 

5. **Insufficient Validation Coverage**: The `UpdateValueValidationProvider` only validates the sender's own PreviousInValue against their own previous OutValue, not the revealed values of other miners recovered through secret sharing. [5](#0-4) 

6. **Corrupted Value Usage**: The unvalidated PreviousInValue is later used in `SupplyCurrentRoundInformation` to auto-fill consensus data for miners who failed to produce blocks. [6](#0-5) 

7. **Signature Chain Corruption**: The `CalculateSignature` method uses the corrupted PreviousInValue, XORing it with all previous signatures to generate the miner's signature, breaking the cryptographic chain. [7](#0-6) 

The security guarantee violated is **consensus integrity through verifiable secret sharing**. The AEDPoS consensus relies on the InValue/OutValue commitment scheme for verifiable randomness. When using secret sharing for recovery, the system MUST validate reconstructed secrets against the original commitments. This validation is completely absent.

## Impact Explanation

**Critical Consensus State Corruption**: The corrupted PreviousInValue leads to incorrect signature calculations in `SupplyCurrentRoundInformation`. These signatures are fundamental to AEDPoS consensus - they determine mining order through XOR operations and form the cryptographic chain ensuring randomness and unpredictability.

**Affected Parties**:
- All miners in the consensus set (signature chain integrity compromised)
- The entire consensus mechanism's verifiable randomness property
- Miners who fail to produce blocks have their InValue/Signature fields auto-filled using potentially corrupted values

**Severity Justification - Critical**:
1. Directly violates consensus integrity invariant requiring correct round transitions and miner schedule
2. Compromises the verifiable randomness property that prevents miners from predicting or manipulating mining order
3. Can cause consensus state divergence between honest nodes if they process corrupted values differently
4. Corrupted signatures propagate through subsequent rounds via the XOR-based signature calculation mechanism
5. Affects the core security property of the consensus algorithm

The minimum threshold for reconstruction is 2/3 of miners. [8](#0-7)  If any of the shares used in reconstruction are corrupted, the entire result is incorrect with no indication of failure - this is a fundamental property of Shamir's Secret Sharing without verification commitments.

## Likelihood Explanation

**Attacker Capabilities Required**:
- Must be a miner in the current consensus round (standard participant role)
- Can submit UpdateValue transactions (normal miner privilege)
- No additional permissions or sophisticated attacks needed

**Attack Complexity**: Low
- Attacker simply provides arbitrary byte arrays as DecryptedPiece values in their UpdateValue transaction
- No cryptographic attack needed
- The attack is deterministic - corrupted shares in the reconstruction set always produce corrupted output

**Feasibility**: High
- The validation service checks multiple providers during UpdateValue but none validate the reconstructed PreviousInValue values for other miners. [9](#0-8) 
- If an attacker's corrupted DecryptedPiece is among the first 2/3 used for reconstruction, the entire secret is incorrectly reconstructed
- The scheme has no built-in error correction - Lagrange interpolation always produces a result

**Detection Difficulty**: High
- `DecodeSecret` completes successfully regardless of input validity
- The incorrect PreviousInValue is stored normally in round state
- Corruption only manifests when signatures don't match expected values in subsequent consensus operations
- Root cause analysis is difficult as the error is silent

## Recommendation

Add validation in `RevealSharedInValues` to verify that reconstructed secrets match the original OutValue commitments:

```csharp
var revealedInValue =
    HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Validate reconstructed secret against committed OutValue
var expectedOutValue = previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue;
Assert(revealedInValue == expectedOutValue, 
    $"Reconstructed InValue does not match committed OutValue for miner {publicKeyOfAnotherMiner}");

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

This ensures that only correctly reconstructed secrets are stored as PreviousInValue. If reconstruction fails due to corrupted shares, the assertion will prevent consensus state corruption.

Alternatively, implement Verifiable Secret Sharing (VSS) with cryptographic commitments to detect invalid shares before reconstruction, though this would be a more substantial protocol change.

## Proof of Concept

```csharp
[Fact]
public async Task CorruptedDecryptedPieces_CausesIncorrectPreviousInValueReconstruction()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeAEDPoSConsensus();
    await ProduceNormalBlocks(2); // Advance to establish secret sharing state
    
    var targetMinerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var maliciousMinerKeyPair = InitialCoreDataCenterKeyPairs[1];
    
    // Get current round and target miner's OutValue commitment
    var currentRound = await GetCurrentRoundInformation();
    var targetMinerInfo = currentRound.RealTimeMinersInformation[targetMinerKeyPair.PublicKey.ToHex()];
    var committedOutValue = targetMinerInfo.OutValue;
    
    // Malicious miner provides CORRUPTED DecryptedPiece for target miner
    var corruptedDecryptedPiece = new byte[] { 0xFF, 0xFF, 0xFF, /* garbage data */ };
    
    var updateValueInput = new UpdateValueInput
    {
        // ... other valid fields ...
        DecryptedPieces = {
            { targetMinerKeyPair.PublicKey.ToHex(), ByteString.CopyFrom(corruptedDecryptedPiece) }
        }
    };
    
    // Submit UpdateValue with corrupted piece - NO VALIDATION OCCURS
    var result = await MinerUpdateValue(maliciousMinerKeyPair, updateValueInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Succeeds!
    
    // Advance to next round to trigger RevealSharedInValues
    await ProduceBlocksUntilNextRound();
    
    // Verify: Reconstructed PreviousInValue is INCORRECT but was stored anyway
    var nextRound = await GetCurrentRoundInformation();
    var reconstructedPreviousInValue = nextRound.RealTimeMinersInformation[targetMinerKeyPair.PublicKey.ToHex()].PreviousInValue;
    
    // The vulnerability: reconstructedPreviousInValue != Hash(correct InValue)
    // Therefore: HashHelper.ComputeFrom(reconstructedPreviousInValue) != committedOutValue
    // But it was stored without validation!
    reconstructedPreviousInValue.ShouldNotBeNull();
    
    // Demonstrate: If target miner fails to produce blocks, corrupted value is used for signature
    // This breaks consensus signature chain integrity
    var signature = currentRound.CalculateSignature(reconstructedPreviousInValue);
    signature.ShouldNotBe(Hash.Empty); // Signature is calculated using corrupted data
}
```

**Notes**

This vulnerability represents a critical gap in the AEDPoS consensus secret sharing implementation. While Shamir's Secret Sharing is mathematically sound for secret reconstruction, it provides no inherent verification that reconstructed secrets are correct. The system has the necessary components for verification (the OutValue commitments) but fails to use them. Any miner can silently corrupt the PreviousInValue of other miners, breaking the verifiable randomness property that is fundamental to consensus security.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```
