# Audit Report

## Title
Missing Signature Validation Allows Consensus Schedule Manipulation

## Summary
The AEDPoS consensus contract fails to validate that miner-submitted signatures are correctly calculated according to the protocol formula `previousRound.CalculateSignature(previousInValue)`. This allows malicious miners to provide arbitrary signature values, manipulating their mining order in subsequent rounds and controlling extra block producer selection, thereby compromising consensus fairness and randomness.

## Finding Description

The vulnerability exists across multiple components of the signature validation flow:

**1. Insufficient Validation:** The `UpdateValueValidationProvider.NewConsensusInformationFilled()` method only verifies that the Signature field exists and is non-empty, without validating correctness: [1](#0-0) 

**2. Correct Signature Calculation:** The protocol defines signature calculation as XORing the inValue with all miners' signatures from the previous round: [2](#0-1) 

**3. Legitimate Block Production:** During honest block production, signatures are correctly calculated using this method: [3](#0-2) 

**4. Vulnerable Assignment:** When processing UpdateValue transactions, the signature from user input is directly assigned without validation: [4](#0-3) 

**5. Order Manipulation Impact:** The signature directly determines the miner's order in the next round through modulus calculation: [5](#0-4) 

**6. Extra Block Producer Control:** The first miner's signature determines who becomes the extra block producer in the next round: [6](#0-5) 

**7. Ineffective After-Execution Validation:** The after-execution validation only checks round hash equality, which fails to detect manipulated signatures since they're already stored in state: [7](#0-6) 

## Impact Explanation

**Consensus Schedule Manipulation (HIGH):** A malicious miner can compute different signature values to obtain any desired mining order from 1 to minersCount in the next round. The formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1` means attackers can try various Hash values until finding one producing their preferred position.

**Extra Block Producer Control (HIGH):** If positioned as order 1 in the current round, the attacker's manipulated signature directly determines the next round's extra block producer, who receives additional mining rewards. This creates direct financial incentive for the attack.

**Consensus Randomness Violation (CRITICAL):** The signature mechanism is fundamental to AEDPoS's cryptographic randomness for schedule determination. Allowing arbitrary signatures completely undermines this security guarantee, breaking a core consensus invariant.

**Multi-Miner Collusion (HIGH):** Multiple coordinating malicious miners could systematically manipulate mining schedules across rounds, concentrating block production and rewards while excluding honest miners from favorable positions.

## Likelihood Explanation

**Reachable Entry Point (CERTAIN):** UpdateValue is the standard public method called by all miners during normal block production: [8](#0-7) 

**Feasible Preconditions (CERTAIN):** The attacker only needs to be a valid miner in the current validator set, which is normal operational state. No special permissions or timing requirements exist.

**Execution Practicality (TRIVIAL):** A malicious miner simply modifies their node to provide arbitrary Signature and SupposedOrderOfNextRound values in UpdateValueInput instead of using legitimately calculated values. The ExtractInformationToUpdateConsensus method shows these fields are directly copied from round state: [9](#0-8) 

**Economic Rationality (HIGH):** The attack costs nothing (just providing different hash values) but provides concrete benefits through improved mining positions and potential extra block producer selection with associated rewards.

**Detection Constraints (UNDETECTABLE):** Since no validation compares provided signatures against expected calculations, the attack appears completely legitimate to all network participants.

## Recommendation

Add cryptographic validation to verify the signature matches the expected calculation:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    if (minerInRound.PreviousInValue == null || minerInRound.PreviousInValue == Hash.Empty)
        return true; // First round or no previous value
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(minerInRound.PreviousInValue);
    
    if (minerInRound.Signature != expectedSignature)
        return false;
    
    return true;
}
```

Similarly validate that SupposedOrderOfNextRound matches what would be calculated from the signature:

```csharp
var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
var expectedOrder = GetAbsModulus(minerInRound.Signature.ToInt64(), minersCount) + 1;

if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
    return false;
```

## Proof of Concept

A malicious miner can exploit this vulnerability through the following steps:

1. When their turn arrives to mine a block, instead of using the legitimate consensus extra data generation flow
2. Construct UpdateValueInput with arbitrary Signature value (e.g., Hash.Empty, or any computed hash)
3. Calculate desired SupposedOrderOfNextRound by trying different signatures until finding one producing preferred order
4. Submit UpdateValue transaction with these manipulated values
5. The transaction passes validation since only existence checks are performed
6. The manipulated signature gets stored in state, affecting next round's mining schedule
7. If miner was first in current round, their signature determines next round's extra block producer

The attack succeeds because no validation compares the provided signature against `previousRound.CalculateSignature(previousInValue)`, allowing complete manipulation of consensus scheduling randomness.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L88-93)
```csharp
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-102)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L35-43)
```csharp
        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
```
