# Audit Report

## Title
Missing Authorization Check Allows Multiple Miners to Concurrently Trigger Round Transitions

## Summary
The AEDPoS consensus contract lacks proper authorization validation during `NextRound` transitions. While an extra block producer role is deterministically calculated and authorization logic exists via `IsCurrentMiner()`, this check is never enforced during block validation. Any miner whose time slot has passed can produce a `NextRound` block, enabling multiple miners to simultaneously trigger competing round transitions at the same height, creating consensus forks at every round boundary.

## Finding Description

The vulnerability exists in the consensus validation flow where round transition authorization is incomplete.

When `ValidateBeforeExecution` processes `NextRound` behavior, it applies several validation providers but none verify the sender is the designated extra block producer: [1](#0-0) 

**MiningPermissionValidationProvider** only checks miner list membership, not the extra block producer role: [2](#0-1) 

**TimeSlotValidationProvider** for new rounds (NextRound) only validates time slot structure, not WHO can create the round: [3](#0-2) 

**RoundTerminateValidationProvider** only checks round number increments by 1: [4](#0-3) 

An `IsCurrentMiner()` method exists with proper extra block producer authorization logic: [5](#0-4) 

However, this authorization check is never invoked during `ValidateBeforeExecution()`. It's only used by other contracts (TokenContract, CrossChainContract) for different purposes.

The consensus behavior provider allows ANY miner whose time slot has passed to obtain NextRound behavior: [6](#0-5) 

The `PreCheck()` method during transaction execution only validates miner list membership: [7](#0-6) 

`EnsureTransactionOnlyExecutedOnceInOneBlock()` only prevents multiple consensus transactions within the SAME block, not competing blocks at the same height: [8](#0-7) 

Each competing block at height N reads from parent state (height N-1), so they all see `LatestExecutedHeight = N-1` and pass this check independently.

The extra block producer is deterministically calculated but this designation is never enforced: [9](#0-8) 

## Impact Explanation

**Consensus Integrity Violation**: Multiple miners can simultaneously produce valid NextRound blocks at the same height, creating competing forks where:
- Each fork successfully transitions to round N+1
- Potentially different `ExtraBlockProducerOfPreviousRound` values
- Different miner arrangements and timestamps
- Conflicting consensus state

**Affected Parties**:
- All network participants experience increased fork frequency and delayed finality
- The deterministic extra block producer mechanism becomes meaningless
- Cross-chain bridges may receive conflicting state proofs
- Applications face unpredictable state and delayed transaction confirmation

**Severity**: This breaks the fundamental consensus invariant of deterministic round transitions and miner schedule integrity. The extra block producer role exists in the design but lacks enforcement, allowing any miner past their time slot to trigger round transitions.

## Likelihood Explanation

**Reachable Entry Point**: Any miner can produce blocks containing consensus transactions via the public `NextRound` method.

**Feasible Preconditions**:
1. Round nearing completion with all regular time slots passed
2. Multiple miners simultaneously query `GetConsensusCommand` and receive NextRound behavior
3. Network latency allows multiple miners to produce blocks before one becomes canonical

**Attack Complexity**: None - this occurs naturally without malicious intent. At every round boundary when multiple miners' time slots have passed, they can all legitimately request NextRound commands and produce competing blocks. Network partitions or latency variations exacerbate this.

**Probability**: High during normal operation. Each round termination (occurring continuously throughout blockchain operation) presents this race condition. Geographically distributed miners or varying network conditions increase the likelihood of concurrent NextRound block production.

## Recommendation

Add extra block producer authorization during NextRound validation. In `ValidateBeforeExecution`, when processing `NextRound` behavior, add a validation provider that:

1. Checks if current time is within the extra block mining time slot (after last miner's expected time)
2. Verifies the sender is the designated extra block producer for the current round
3. Uses logic similar to `IsCurrentMiner()` to authorize round termination

Alternatively, invoke `IsCurrentMiner()` during the PreCheck phase for NextRound transactions:

```csharp
// In PreCheck() for NextRound behavior
if (behaviour == AElfConsensusBehaviour.NextRound || behaviour == AElfConsensusBehaviour.NextTerm)
{
    if (!IsCurrentMiner(_processingBlockMinerPubkey))
        return false;
}
```

This ensures only the authorized miner at the appropriate time can trigger round transitions, preventing the race condition.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test network with multiple miners
2. Advancing to near the end of a round where all miners' time slots have passed
3. Having multiple miners simultaneously call `GetConsensusCommand` - all receive NextRound behavior
4. Each miner produces a block with NextRound transaction at the same height
5. All blocks pass `ValidateBeforeExecution` since none check extra block producer authorization
6. Multiple competing NextRound blocks exist at the same height, creating a fork

The test would verify that validation accepts NextRound blocks from multiple different miners at the same height, when only the designated extra block producer should be authorized.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```
