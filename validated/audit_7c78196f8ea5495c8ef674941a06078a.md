# Audit Report

## Title
Division by Zero Vulnerability in Miner Count Calculation Due to Insufficient Validation in SetMinerIncreaseInterval

## Summary
The `SetMinerIncreaseInterval` method contains insufficient validation that allows governance to set `State.MinerIncreaseInterval.Value` to zero or negative values, causing a `DivideByZeroException` in critical consensus operations. This results in permanent blockchain denial-of-service with no built-in recovery mechanism.

## Finding Description

**Root Cause - Insufficient Validation:**

The `SetMinerIncreaseInterval` method only validates that the new value is less than or equal to the current value, but does not require the value to be positive. [1](#0-0) 

The validation check `input.Value <= State.MinerIncreaseInterval.Value` prevents increases but allows zero and negative values. There is no check requiring `input.Value > 0`.

**Division by Zero Locations:**

When `State.MinerIncreaseInterval.Value` is zero, division operations in two critical methods throw exceptions:

1. In `GetAutoIncreasedMinersCount()`: [2](#0-1) 

2. In `GetMinersCount()`: [3](#0-2) 

Both methods perform `.Div(State.MinerIncreaseInterval.Value)` which throws when the divisor is zero.

**Division Method Behavior:**

The `Div` extension method performs standard C# division without zero-checks: [4](#0-3) 

This throws `DivideByZeroException` as confirmed by unit tests: [5](#0-4) 

**Critical Call Paths:**

The vulnerable `GetMinersCount()` is called in three critical operations:

1. **Term transitions** via `UpdateMinersCountToElectionContract()`: [6](#0-5) 

2. **Block processing** during consensus round transitions: [7](#0-6) 

3. **Governance operations** in `SetMaximumMinersCount()`: [8](#0-7) 

**Why Recovery is Impossible:**

Once `MinerIncreaseInterval` is set to zero, the validation logic prevents setting it back to a positive value because the assertion requires `input.Value <= State.MinerIncreaseInterval.Value`. If current value is 0, any positive value fails this check, creating a permanent unrecoverable state.

**Initialization Does Not Prevent Attack:**

While the contract is initialized with a valid default value: [9](#0-8) 

The vulnerability arises from the ability to modify this value to zero after initialization through governance action.

## Impact Explanation

**Severity: CRITICAL - Complete Blockchain Denial-of-Service**

Once `State.MinerIncreaseInterval.Value` is set to zero, all subsequent blockchain operations fail:

1. **Consensus Halted**: Term transitions fail when `UpdateMinersCountToElectionContract()` calls `GetMinersCount()`, preventing new consensus terms from starting
2. **Block Production Stops**: `ProcessConsensusInformation` fails during normal block processing when `ProcessNextRound` or `ProcessNextTerm` call `GetMinersCount()`
3. **Governance Paralyzed**: `SetMaximumMinersCount()` also calls `GetMinersCount()`, so governance cannot execute any recovery actions
4. **Permanent State**: The validation logic prevents setting the value back to positive (requires `input <= current`), making recovery impossible without hard fork

This breaks the core consensus security guarantee that the blockchain can continue producing blocks and processing transactions. The entire protocol becomes non-operational with no built-in recovery mechanism.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Prerequisites:**
- Requires governance approval from `MaximumMinersCountController` (Parliament default organization by default)

**Feasibility:**
The vulnerability can be triggered through:
1. **Human error**: Governance accidentally submits proposal with value 0 instead of intended value
2. **Malicious proposal**: If governance is compromised or approves an attack proposal
3. **No safeguards**: No bounds checking, timelock, or emergency pause mechanism exists

**Attack Complexity: LOW**
- Single governance transaction required
- No complex state manipulation
- No additional economic cost beyond normal governance process

**Evidence of Oversight:**
The test coverage only validates preventing increases, not zero/negative values: [10](#0-9) 

The test attempts to increase the interval (which fails), and decrease it successfully, but there is no test for zero or negative values.

While requiring governance approval is a barrier, the lack of validation combined with potential for human error makes this a realistic threat to protocol availability.

## Recommendation

Add a positive value check in the `SetMinerIncreaseInterval` method:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Additionally, add comprehensive test coverage for edge cases including zero and negative values.

## Proof of Concept

```csharp
[Fact]
public async Task SetMinerIncreaseInterval_ZeroValue_CausesConsensusFailure()
{
    // Setup: Initialize contracts and reach normal state
    InitialContracts();
    await BlockMiningService.MineBlockToNextTermAsync();
    InitialAcs3Stubs();
    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
    
    var defaultOrganizationAddress = 
        await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());

    // Attack: Set MinerIncreaseInterval to zero via governance
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = 0 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganizationAddress
    });

    // Verify: Consensus operations now throw DivideByZeroException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await BlockMiningService.MineBlockToNextTermAsync(); // Triggers GetMinersCount()
    });
    
    exception.InnerException.ShouldBeOfType<DivideByZeroException>();
}
```

## Notes

This vulnerability represents a critical flaw in parameter validation that can lead to permanent protocol unavailability. The issue is particularly severe because:

1. **No escape mechanism**: Once triggered, there is no contract-level recovery path
2. **Wide impact surface**: Affects all consensus operations, not just isolated functionality
3. **Test gap**: The absence of tests for boundary conditions indicates this scenario was not considered during development
4. **Governance dependency**: While requiring governance approval reduces immediate risk, it doesn't eliminate the threat from human error or coordinated malicious action

The fix is straightforward (add positive value validation), but the consequences of this oversight are severe, warranting CRITICAL severity classification.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-137)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L22-32)
```csharp
    public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
    {
        Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        State.PeriodSeconds.Value = input.IsTermStayOne
            ? int.MaxValue
            : input.PeriodSeconds;

        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;

```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L121-146)
```csharp
        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
```
