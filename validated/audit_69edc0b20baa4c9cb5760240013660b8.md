# Audit Report

## Title
Integer Overflow in Miner Count Auto-Increase Calculation Leading to Consensus Failure

## Summary
The AEDPoS consensus contract performs an unsafe cast from `long` to `int` when calculating auto-increased miner counts, without overflow protection or minimum bound validation on the `MinerIncreaseInterval` parameter. This allows governance to trigger immediate division-by-zero DoS by setting the interval to 0, or cause integer overflow that produces negative miner counts after extended blockchain operation, corrupting consensus state across the system.

## Finding Description

The vulnerability exists in two critical calculation methods that determine the number of active miners in the consensus system.

**Location 1** - `GetAutoIncreasedMinersCount()` performs an unchecked cast: [1](#0-0) 

**Location 2** - `GetMinersCount()` has identical vulnerable pattern: [2](#0-1) 

The calculation produces a `long` value from SafeMath operations (`Div` and `Mul` on `long` return `long` values): [3](#0-2) 

However, the explicit `(int)` cast performs unchecked conversion that silently wraps on overflow. The checked arithmetic in SafeMath's `Add` operation cannot prevent this because the corruption occurs BEFORE the Add: [4](#0-3) 

**Root Cause: Missing Validation**

The `SetMinerIncreaseInterval` method lacks minimum bound validation: [5](#0-4) 

The validation only enforces `input.Value <= State.MinerIncreaseInterval.Value` (decreasing only), with no check for positive values or minimum bounds. The initialization also lacks validation: [6](#0-5) 

**Propagation to Election Contract**

The corrupted miner count propagates through `SetMaximumMinersCount`: [7](#0-6) 

The Election contract stores the value without validation: [8](#0-7) 

This negative miner count then corrupts `GetVictories()` where `.Take(negative_value)` returns an empty list: [9](#0-8) 

The constant `SupposedMinersCount` is defined as 17: [10](#0-9) 

## Impact Explanation

**HIGH Impact - Complete Consensus Failure**

**Scenario 1: Division by Zero DoS**
If governance sets `MinerIncreaseInterval = 0`, any subsequent call to `GetAutoIncreasedMinersCount()`, `GetMinersCount()`, or `GetMaximumMinersCount()` will trigger `DivideByZeroException` since SafeMath's `Div` operation throws on division by zero. This completely breaks consensus operations that depend on these methods, halting block production and freezing the blockchain.

**Scenario 2: Integer Overflow State Corruption**
With `MinerIncreaseInterval = 1` second after 34.08 years of operation:
- Elapsed time: 1,073,741,824 seconds (2^30)
- Calculation: (1,073,741,824 / 1) Ã— 2 = 2,147,483,648
- Exceeds `Int32.MaxValue` (2,147,483,647) by 1
- Cast wraps to `Int32.MinValue` (-2,147,483,648)
- Final result: 17 + (-2,147,483,648) = -2,147,483,631

This negative miner count corrupts consensus state across:
- AEDPoS consensus contract's miner count calculations
- Election contract's `MinersCount` state variable
- `GetVictories()` returns empty miner list via `.Take(negative)` 
- Round generation fails with zero validators
- Block production becomes impossible

The protocol cannot function with invalid miner counts, causing complete consensus liveness failure where validators cannot produce blocks and the entire blockchain becomes inoperable.

## Likelihood Explanation

**MEDIUM Likelihood - Governance-Triggered with Multiple Paths**

**Attacker Capabilities**: Requires Parliament/governance authorization to call `SetMinerIncreaseInterval`. This is the normal operational state of the protocol, not a privileged compromise.

**Scenario 1 (Division by Zero)**: 
- Complexity: LOW
- Single governance proposal to set `MinerIncreaseInterval = 0`
- Immediate consensus failure on next miner count calculation
- No special timing or conditions required

**Scenario 2 (Integer Overflow)**:
- Complexity: MEDIUM
- Requires either:
  - Natural occurrence after 34+ years of operation with small intervals
  - Aggressive reduction of `MinerIncreaseInterval` through multiple governance proposals
- Less immediate but more insidious as overflow is silent

**Feasibility**: Governance control of Parliament is the normal operational state. The default interval (31,536,000 seconds = 1 year) provides initial protection, but this can be circumvented through legitimate governance actions. No monitoring exists for suspicious `MinerIncreaseInterval` values or calculations approaching overflow thresholds.

**Detection Constraints**: The overflow is completely silent until the cast completes, and there are no alerts or bounds checking to detect approaching critical values.

## Recommendation

Add comprehensive validation to prevent invalid `MinerIncreaseInterval` values:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value >= MinimumMinerIncreaseInterval, "Interval below minimum threshold.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Can only decrease interval.");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Add overflow-safe miner count calculation using checked arithmetic:

```csharp
private int GetAutoIncreasedMinersCount()
{
    if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;
    
    var elapsedSeconds = (Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds;
    var intervalCount = elapsedSeconds.Div(State.MinerIncreaseInterval.Value);
    var increment = intervalCount.Mul(2);
    
    // Use checked cast to detect overflow
    int safeIncrement;
    checked
    {
        safeIncrement = (int)increment;
    }
    
    return AEDPoSContractConstants.SupposedMinersCount.Add(safeIncrement);
}
```

Add validation in Election contract's `UpdateMinersCount`:

```csharp
public override Empty UpdateMinersCount(UpdateMinersCountInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
        "Only consensus contract can update miners count.");
    Assert(input.MinersCount > 0, "Miners count must be positive.");
    State.MinersCount.Value = input.MinersCount;
    SyncSubsidyInfoAfterReduceMiner();
    return new Empty();
}
```

## Proof of Concept

This vulnerability can be demonstrated with a test that sets `MinerIncreaseInterval = 0` and observes the division-by-zero exception:

```csharp
[Fact]
public async Task DivisionByZero_MinerIncreaseInterval_Test()
{
    // Setup: Initialize consensus contract with Parliament governance
    await InitializeContracts();
    
    // Create proposal to set MinerIncreaseInterval to 0
    var proposal = await CreateParliamentProposal(
        ConsensusContractAddress,
        nameof(AEDPoSContractContainer.AEDPoSContractStub.SetMinerIncreaseInterval),
        new Int64Value { Value = 0 }
    );
    
    // Approve and release proposal
    await ApproveAndReleaseProposal(proposal);
    
    // Attempt to call GetMaximumMinersCount - should throw DivideByZeroException
    var exception = await Assert.ThrowsAsync<DivideByZeroException>(async () =>
    {
        await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    });
    
    // Verify consensus is broken - cannot calculate miner counts
    Assert.Contains("Attempted to divide by zero", exception.Message);
}
```

## Notes

This vulnerability represents a critical input validation failure where governance can inadvertently break consensus by setting invalid parameters. While it requires governance action, this is NOT about "trusting governance" - the contracts should enforce protocol invariants regardless of who calls them. The lack of bounds checking allows the system to enter invalid states that violate fundamental consensus assumptions (positive miner counts), leading to complete blockchain liveness failure.

The immediate division-by-zero scenario is more likely than the 34-year overflow, but both demonstrate the same underlying issue: unsafe arithmetic operations without proper validation or overflow protection in critical consensus calculations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L34-40)
```csharp
    public static int Add(this int a, int b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-90)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }

    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L22-32)
```csharp
    public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
    {
        Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        State.PeriodSeconds.Value = input.IsTermStayOne
            ? int.MaxValue
            : input.PeriodSeconds;

        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;

```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
