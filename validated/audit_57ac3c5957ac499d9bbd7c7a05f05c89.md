# Audit Report

## Title
Time-of-Check-Time-of-Use Vulnerability: Removed Proposers Can Still Release Approved Proposals

## Summary
The Referendum, Parliament, and Association governance contracts validate proposer whitelist membership only at proposal creation time, not at release time. This TOCTOU vulnerability allows proposers removed from the ProposerWhiteList to still release previously created approved proposals, enabling unauthorized governance execution and bypassing organizational access controls.

## Finding Description

All three ACS3 governance contracts implement a flawed authorization model where proposer whitelist validation occurs only at proposal creation, not at release.

**Referendum Contract:**
At proposal creation, the contract validates whitelist membership by calling `AssertIsAuthorizedProposer()` [1](#0-0) 

The authorization check verifies the proposer is in the organization's ProposerWhiteList [2](#0-1) 

Organizations can update their ProposerWhiteList at any time [3](#0-2) 

However, at release time, the contract ONLY validates that the caller is the original proposer, without re-checking current whitelist membership [4](#0-3) 

**Parliament Contract:**
Parliament follows the same pattern - whitelist check at creation [5](#0-4) 

With authorization validation in the helper method [6](#0-5) 

But no whitelist re-validation at release [7](#0-6) 

**Association Contract:**
Association follows the identical flawed pattern - whitelist check at creation [8](#0-7) 

Authorization validation checks the ProposerWhiteList [9](#0-8) 

No whitelist re-validation at release [10](#0-9) 

This breaks the security guarantee that organizations can revoke proposal release rights by removing proposers from the whitelist. Once a proposal is created and approved, the stored `proposal.Proposer` address retains release rights indefinitely, even after whitelist removal.

The ClearProposal mechanism cannot mitigate this issue as it only works for expired proposals [11](#0-10) 

## Impact Explanation

**Medium-High Severity** due to:

1. **Unauthorized Governance Execution**: Proposers removed from whitelists (for malicious behavior, compromise, or policy changes) retain the ability to execute approved proposals with full organization authority

2. **Governance Bypass**: Organizations cannot revoke proposal release rights from problematic proposers. This undermines the core access control mechanism that whitelists are designed to provide

3. **Potential for Malicious Actions**: Released proposals execute with organization authority via `SendVirtualInlineBySystemContract` and can:
   - Transfer funds from organization-controlled addresses
   - Modify critical contract configurations
   - Execute arbitrary contract methods specified in the proposal

4. **Scope of Impact**: Affects ALL organizations using Referendum, Parliament, or Association governance contracts across the entire AElf ecosystem

**Mitigating Factors**:
- Proposals still require threshold approval from voters/organization members before release
- Organizations can use `ClearProposal()` to remove expired proposals
- The proposer must have been legitimately whitelisted initially

## Likelihood Explanation

**Medium-High Likelihood** because:

1. **Common Operational Pattern**: Organizations regularly update ProposerWhiteLists to:
   - Remove compromised accounts after security incidents
   - Revoke access from departed team members
   - Respond to detected malicious behavior
   - Update governance policies and membership

2. **Low Attack Complexity**: 
   - Single `Release()` transaction with proposal ID
   - No complex state manipulation required
   - Works consistently across all three governance contracts

3. **Realistic Attack Scenario**:
   - Attacker gains legitimate whitelist membership
   - Creates multiple proposals while authorized
   - Proposals receive voter approval
   - Organization detects issue and removes attacker from whitelist
   - Attacker retains ability to release all approved proposals

4. **Economic Rationality**: For a malicious actor anticipating removal, the rational strategy is to create numerous proposals before removal, as each provides persistent execution capability

5. **Detection Difficulty**: Removed proposers still have valid `proposal.Proposer` status stored in state, making it difficult to identify at-risk proposals

## Recommendation

Add whitelist validation at proposal release time. Modify the `Release()` method in all three contracts to re-check current whitelist membership:

**For Referendum and Association:**
```csharp
public override Empty Release(Hash input)
{
    var proposal = GetValidProposal(input);
    Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
    
    // Add re-validation of current whitelist status
    AssertIsAuthorizedProposer(proposal.OrganizationAddress, Context.Sender);
    
    var organization = State.Organizations[proposal.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
    // ... rest of release logic
}
```

**For Parliament:**
```csharp
public override Empty Release(Hash proposalId)
{
    var proposalInfo = GetValidProposal(proposalId);
    Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
    
    // Add re-validation of current authorization status
    AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, Context.Sender);
    
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of release logic
}
```

This ensures that proposers must maintain whitelist membership throughout the entire proposal lifecycle, from creation through release.

## Proof of Concept

```csharp
[Fact]
public async Task TOCTOU_RemovedProposerCanStillReleaseApprovedProposal()
{
    // Setup: Create organization with proposer whitelist
    var proposer = Accounts[1].Address;
    var voter = Accounts[2].Address;
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { proposer } },
        TokenSymbol = "ELF"
    };
    
    var orgAddress = await ReferendumContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    
    // Step 1: Proposer creates proposal while in whitelist
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = orgAddress.Output,
        ContractMethodName = "Transfer",
        ToAddress = TokenContractAddress,
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        Params = new TransferInput { To = voter, Symbol = "ELF", Amount = 100 }.ToByteString()
    };
    
    var proposalId = await ReferendumContractStub.CreateProposal.SendAsync(proposalInput);
    
    // Step 2: Proposal gets approved
    await ReferendumContractStub.Approve.SendAsync(proposalId.Output);
    
    // Step 3: Organization removes proposer from whitelist
    var newWhitelist = new ProposerWhiteList { Proposers = { } }; // Empty whitelist
    await ReferendumContractStub.ChangeOrganizationProposerWhiteList.SendAsync(newWhitelist);
    
    // Step 4: Removed proposer can STILL release the approved proposal
    // This should fail but succeeds - demonstrating the vulnerability
    var releaseResult = await ReferendumContractStub.Release.SendAsync(proposalId.Output);
    
    // Verify proposal was released successfully despite proposer removal
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify proposal is removed from state (indicating successful release)
    var proposal = await ReferendumContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ProposalId.ShouldBeNull(); // Proposal removed after release
}
```

## Notes

This vulnerability represents a fundamental flaw in the authorization lifecycle model. The intended security guarantee is that removing a proposer from the whitelist should revoke all their proposal-related privileges. However, the current implementation only enforces whitelist membership at proposal creation, treating the stored `proposal.Proposer` field as a permanent authorization token.

The fix is straightforward: re-validate whitelist membership at release time using the existing `AssertIsAuthorizedProposer()` helper method. This ensures consistent enforcement of access control throughout the proposal lifecycle.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-58)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-65)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-111)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```
