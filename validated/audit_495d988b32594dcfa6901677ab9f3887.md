# Audit Report

## Title
Missing Pubkey Uniqueness Validation in RealTimeMinersInformation Allows Consensus DoS

## Summary
The AEDPoS consensus contract accepts external Round objects via `NextRound` without validating that `RealTimeMinersInformation` dictionary values have unique `Pubkey` fields. A malicious miner can submit a Round with duplicate Pubkey entries, causing immediate chain halt when subsequent miners attempt block generation through `ExtractInformationToUpdateConsensus`, which calls `ToDictionary` on non-unique keys and throws an `ArgumentException`.

## Finding Description

The protocol defines `RealTimeMinersInformation` as `map<string, MinerInRound>` where the map keys should equal their corresponding `MinerInRound.Pubkey` values. [1](#0-0)  Internal code generation maintains this invariant by using `nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound { Pubkey = minerInRound.Pubkey, ... }`. [2](#0-1) 

However, when accepting external Round objects via `NextRound`, the validation providers only check round numbers, term numbers, and InValue nullity. [3](#0-2) [4](#0-3)  No validation enforces that map keys match Pubkey fields or that Pubkey values are unique across the dictionary values.

**Critical Failure Point:**

When miners generate consensus transactions for `UpdateValue` behavior, the system calls `ExtractInformationToUpdateConsensus`, which creates three dictionaries using `RealTimeMinersInformation.Values.Where(...).ToDictionary(m => m.Pubkey, ...)`. [5](#0-4)  If duplicate Pubkey values exist in the collection, `ToDictionary` throws an `ArgumentException` per standard .NET behavior, preventing the generation of consensus transactions required for block production.

This method is invoked during the normal consensus flow when generating transactions. [6](#0-5) 

**Secondary Issue:**

The `GetSortedImpliedIrreversibleBlockHeights` function filters miners by `specificPublicKeys.Contains(i.Pubkey)`. [7](#0-6)  If duplicate Pubkeys exist, multiple entries match the filter, inflating the heights list used in LIB calculations. [8](#0-7) 

## Impact Explanation

**Primary Impact - Consensus DoS:**

Once a malicious Round with duplicate Pubkeys is stored via `AddRoundInformation`, [9](#0-8)  all subsequent miners attempting to produce blocks with `UpdateValue` behavior will fail when their consensus module calls `ExtractInformationToUpdateConsensus`. The thrown `ArgumentException` prevents block generation, resulting in complete chain halt affecting all network participants.

**Secondary Impact - LIB Manipulation:**

Before the DoS manifests, the duplicate entries can cause double-counting in the LIB calculation. This could advance the Last Irreversible Block height prematurely, violating the 2/3+ consensus assumption and potentially affecting cross-chain operations dependent on accurate LIB finality. [10](#0-9) 

**Severity:** High - A single malicious or buggy miner can halt the entire blockchain with one transaction.

## Likelihood Explanation

**Attacker Capabilities:**

The attacker must be a current miner, which is validated by `PreCheck()`. [11](#0-10)  The attacker needs access to produce blocks at the appropriate time to submit `NextRound`.

**Attack Complexity:**

Low - The attacker crafts a `NextRoundInput` where `RealTimeMinersInformation` contains entries with duplicate `Pubkey` values (e.g., two different map keys pointing to MinerInRound objects with the same Pubkey). The public `NextRound` method [12](#0-11)  accepts this input, and the malformed Round passes all existing validation checks and is persisted to state.

**Feasibility:**

Blockchain consensus typically assumes up to 1/3 Byzantine miners. This vulnerability requires only ONE malicious or buggy miner, well within standard threat models. Additionally, this could occur accidentally through buggy client software, making it both a malicious attack vector and an operational risk.

**Detection:**

The attack is detected immediately when the next block production fails, but by then the malformed state is persisted, requiring manual intervention or rollback to restore chain operation.

## Recommendation

Add validation in the `NextRound` and `NextTerm` processing flow to enforce the invariant that:
1. All `RealTimeMinersInformation` dictionary keys must equal their corresponding `MinerInRound.Pubkey` values
2. All `Pubkey` values must be unique across the dictionary

Suggested implementation in a new validation provider:

```csharp
public class PubkeyUniquenessValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var round = validationContext.ExtraData.Round;
        
        // Check all keys match their value's Pubkey
        foreach (var kvp in round.RealTimeMinersInformation)
        {
            if (kvp.Key != kvp.Value.Pubkey)
                return new ValidationResult { Message = "RealTimeMinersInformation key does not match Pubkey value." };
        }
        
        // Check for duplicate Pubkey values
        var pubkeys = round.RealTimeMinersInformation.Values.Select(m => m.Pubkey).ToList();
        if (pubkeys.Count != pubkeys.Distinct().Count())
            return new ValidationResult { Message = "Duplicate Pubkey values detected in RealTimeMinersInformation." };
            
        return new ValidationResult { Success = true };
    }
}
```

Add this provider to the validation list for both `NextRound` and `NextTerm` behaviors in `AEDPoSContract_Validation.cs`.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithDuplicatePubkeys_ShouldHaltConsensus()
{
    // Setup: Initialize consensus with initial miners
    var initialMiners = GenerateMiners(3);
    await InitializeConsensus(initialMiners);
    
    // Malicious miner crafts NextRoundInput with duplicate Pubkey values
    var currentRound = await GetCurrentRound();
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        // Create two entries with SAME Pubkey value but different keys
        RealTimeMinersInformation = 
        {
            ["key1"] = new MinerInRound { Pubkey = "duplicatePubkey", Order = 1, ... },
            ["key2"] = new MinerInRound { Pubkey = "duplicatePubkey", Order = 2, ... },
            ["key3"] = new MinerInRound { Pubkey = initialMiners[2], Order = 3, ... }
        },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Malicious miner submits NextRound - should succeed
    var result = await ConsensusContract.NextRound(maliciousNextRound);
    result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Next miner tries to generate consensus transaction
    var exception = await Assert.ThrowsAsync<ArgumentException>(async () =>
    {
        await ConsensusContract.GenerateConsensusTransactions(nextMinerTriggerInfo);
    });
    
    // Verify: Chain halted due to ArgumentException in ToDictionary
    exception.Message.ShouldContain("An item with the same key has already been added");
}
```

**Notes:**

This vulnerability represents a critical consensus integrity issue. The lack of validation on externally-provided Round objects allows violation of a core protocol invariant (Pubkey uniqueness), leading to complete chain halt. The fix is straightforward - add validation to enforce the invariant before persisting the Round to state. The issue could manifest either through malicious activity or accidental bugs in consensus client implementations, making it both a security and operational risk.

### Citations

**File:** protobuf/aedpos_contract.proto (L34-34)
```text
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-33)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
