# Audit Report

## Title
NFT Contract Governance Bypass - Method Fee Management Silently Non-Functional

## Summary
The NFT contract declares ACS1 interface implementation but provides empty implementations of `SetMethodFee()` and `ChangeMethodFeeController()` governance methods. Parliament proposals to adjust NFT fees will execute successfully without errors but produce zero state changes, permanently hardcoding the Create method fee at 100 ELF and completely bypassing governance control.

## Finding Description

The NFT contract explicitly declares ACS1 implementation through its protobuf service definition, which exposes all four ACS1 governance methods to external callers. [1](#0-0) 

However, the governance setter methods are implemented as no-ops. The `SetMethodFee()` method simply returns an empty object without performing any state modifications. [2](#0-1) 

Similarly, `ChangeMethodFeeController()` returns empty without updating controller authority. [3](#0-2) 

The contract state file completely lacks the infrastructure required for fee governance. The entire NFTContractState class contains no `TransactionFees` or `MethodFeeController` state variables. [4](#0-3) 

In contrast, proper ACS1 implementations like the Election contract include these state variables. [5](#0-4) 

And implement `SetMethodFee()` with actual state updates. [6](#0-5) 

The NFT contract's `GetMethodFee()` returns a hardcoded 100 ELF (100_00000000 base units) for the Create method. [7](#0-6) 

And `GetMethodFeeController()` returns an empty AuthorityInfo instead of the Parliament default organization. [8](#0-7) 

This violates the ACS1 standard documentation, which explicitly states that contracts using hardcoded fees should NOT implement the other governance interfaces. [9](#0-8) 

The AElf fee charging mechanism queries `GetMethodFee()` during pre-execution to determine charges, meaning the hardcoded value will always be enforced regardless of governance attempts. [10](#0-9) 

## Impact Explanation

**Governance Authority Bypass**: Parliament governance over NFT contract fees is completely non-functional. When governance participants create proposals to adjust NFT fees through the standard workflow, the `SetMethodFee()` method executes successfully but produces zero state changes, leaving fees at the hardcoded 100 ELF value.

**Operational Rigidity**: The Create method fee remains permanently at 100 ELF (10,000,000,000 base units), modifiable only via contract upgrade. This prevents dynamic fee adjustment based on ELF token price volatility, governance response to spam attacks, or evolutionary fee structures.

**Trust Violation**: The principle of least surprise is violated. The contract publicly exposes governance interfaces through its ACS1 declaration that suggest fee adjustability, misleading governance participants into believing they have control when they have none. This violates the ACS1 standard specification that explicitly forbids exposing non-functional governance interfaces.

**Severity: Medium** - No funds are directly at risk and no unauthorized state changes occur. However, a core governance mechanism is completely bypassed for a fee-generating system contract, violating the Authorization & Governance standard. The issue impacts protocol operational flexibility and governance system integrity through silent failure of documented governance interfaces.

## Likelihood Explanation

**Immediate Exploitability**: This gap exists in production code today. Any governance participant can observe the ACS1 methods in the NFT contract interface and follow the standard Parliament proposal workflow to experience successful execution with zero effect.

**Attack Complexity: Trivial** - No special privileges needed beyond normal governance participation. The "attack" is simply normal governance operation that silently fails.

**Detection Difficulty**: The silent failure makes this particularly insidious. Transactions execute successfully (status: Mined) with no errors or reverts. No events indicate ineffectiveness. Only manual query of `GetMethodFee()` reveals unchanged fees. [11](#0-10) 

The test suite contains zero ACS1 governance validation for the NFT contract, confirming this functionality has never been tested or verified.

**Probability: High** - As governance participants discover the NFT contract implements ACS1, attempts to adjust fees are inevitable and will uniformly fail silently.

## Recommendation

The NFT contract should either:

1. **Implement proper ACS1 governance** by adding the required state infrastructure and functional implementations of `SetMethodFee()` and `ChangeMethodFeeController()`, OR

2. **Remove the governance interfaces** by not declaring `option (aelf.base) = "acs1.proto"` and only implementing `GetMethodFee()` to return hardcoded values, as recommended by the ACS1 documentation for contracts with non-adjustable fees.

The recommended fix is option 1, implementing proper governance by adding to `NFTContractState.cs`:

```csharp
public MappedState<string, MethodFees> TransactionFees { get; set; }
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

And implementing `SetMethodFee()` and `ChangeMethodFeeController()` following the pattern used in the Election contract.

## Proof of Concept

```csharp
[Fact]
public async Task NFT_SetMethodFee_SilentFailure_Test()
{
    // Attempt to set method fee through governance
    var newFee = new MethodFees
    {
        MethodName = "Create",
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 200_00000000 } }
    };
    
    // This call succeeds without error
    await NFTContractStub.SetMethodFee.SendAsync(newFee);
    
    // But querying the fee still returns hardcoded 100 ELF
    var actualFee = await NFTContractStub.GetMethodFee.CallAsync(new StringValue { Value = "Create" });
    
    // Silent failure: fee unchanged despite successful SetMethodFee call
    actualFee.Fees[0].BasicFee.ShouldBe(100_00000000); // Still hardcoded value
    actualFee.Fees[0].BasicFee.ShouldNotBe(200_00000000); // Governance change ignored
}
```

This test demonstrates that `SetMethodFee()` executes successfully but has zero effect on the returned fee value, confirming the silent governance bypass.

### Citations

**File:** protobuf/nft_contract.proto (L20-20)
```text
    option (aelf.base) = "acs1.proto";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L13-16)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-42)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-46)
```csharp
ï»¿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L58-63)
```csharp
    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public SingletonState<VoteWeightInterestList> VoteWeightInterestList { get; set; }
    public SingletonState<VoteWeightProportion> VoteWeightProportion { get; set; }
    public SingletonState<AuthorityInfo> VoteWeightInterestController { get; set; }

    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L11-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** docs-sphinx/reference/acs/acs1.rst (L276-277)
```text
This implementation can modify the transaction fee only by upgrading the
contract, without implementing the other three interfaces.
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-39)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractTests.cs (L1-274)
```csharp
using System.Threading.Tasks;
using AElf.Contracts.MultiToken;
using AElf.Types;
using Google.Protobuf.WellKnownTypes;
using Shouldly;
using Xunit;

namespace AElf.Contracts.NFT;

public partial class NFTContractTests : NFTContractTestBase
{
    private const string BaseUri = "ipfs://aelf/";

    [Fact]
    public async Task<string> CreateTest()
    {
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "ELF",
            Amount = 1_00000000_00000000,
            To = DefaultAddress
        });
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "ELF",
            Amount = 1_00000000_00000000,
            To = MinterAddress
        });

        var executionResult = await NFTContractStub.Create.SendAsync(new CreateInput
        {
            BaseUri = BaseUri,
            Creator = DefaultAddress,
            IsBurnable = true,
            Metadata = new Metadata
            {
                Value =
                {
                    { "Description", "Stands for the human race." }
                }
            },
            NftType = NFTType.VirtualWorlds.ToString(),
            ProtocolName = "HUMAN",
            TotalSupply = 1_000_000_000 // One billion
        });
        var symbol = executionResult.Output.Value;

        symbol.Length.ShouldBe(11);

        var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue
        {
            Value = symbol
        });
        protocolInfo.Symbol.ShouldBe(symbol);
        protocolInfo.Metadata.Value.ShouldContainKey("Description");
        protocolInfo.Creator.ShouldBe(DefaultAddress);
        protocolInfo.NftType.ShouldBe(NFTType.VirtualWorlds.ToString());
        protocolInfo.TotalSupply.ShouldBe(1_000_000_000);

        var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
        {
            Symbol = symbol
        });

        tokenInfo.Decimals.ShouldBe(0);
        tokenInfo.Symbol.ShouldBe(symbol);
        tokenInfo.Issuer.ShouldBe(DefaultAddress);
        tokenInfo.ExternalInfo.Value["Description"].ShouldBe("Stands for the human race.");
        tokenInfo.ExternalInfo.Value["aelf_nft_type"].ShouldBe("VirtualWorlds");
        tokenInfo.ExternalInfo.Value["aelf_nft_base_uri"].ShouldBe(BaseUri);

        return symbol;
    }

    [Fact]
    public async Task<(string, Hash)> MintTest()
    {
        var symbol = await CreateTest();
        await AddMinterAsync(symbol);

        var tokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
        {
            Symbol = symbol,
            Alias = "could be anything",
            Metadata = new Metadata
            {
                Value =
                {
                    { "Special Property", "A Value" }
                }
            },
            Owner = DefaultAddress,
            Uri = $"{BaseUri}foo"
        })).Output;

        {
            var nftInfo = await NFTContractStub.GetNFTInfoByTokenHash.CallAsync(tokenHash);
            nftInfo.Creator.ShouldBe(DefaultAddress);
            nftInfo.Minters.ShouldContain(MinterAddress);
        }

        {
            var nftInfo = await NFTContractStub.GetNFTInfo.CallAsync(new GetNFTInfoInput
            {
                Symbol = symbol,
                TokenId = 1
            });
            nftInfo.Creator.ShouldBe(DefaultAddress);
            nftInfo.Minters.ShouldContain(MinterAddress);
        }

        {
            var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue
            {
                Value = symbol
            });
            protocolInfo.Metadata.Value.ShouldNotContainKey("Special Property");
        }

        return (symbol, tokenHash);
    }

    [Fact(Skip = "Dup in TransferTest")]
    public async Task<string> MintMultiTokenTest()
    {
        var symbol = await CreateTest();
        await AddMinterAsync(symbol);

        await MinterNFTContractStub.Mint.SendAsync(new MintInput
        {
            Symbol = symbol,
            Alias = "could be anything",
            Metadata = new Metadata
            {
                Value =
                {
                    { "Max Health Points", "0" },
                    { "Max Mana Points", "0" },
                    { "Skill Points", "0" },
                    { "Level", "0" },
                    { "Experience", "0" }
                }
            },
            Quantity = 100,
            Uri = $"{BaseUri}foo"
        });

        return symbol;
    }

    [Fact]
    public async Task<string> TransferTest()
    {
        var symbol = await MintMultiTokenTest();
        await MinterNFTContractStub.Transfer.SendAsync(new TransferInput
        {
            To = User1Address,
            Symbol = symbol,
            TokenId = 1,
            Amount = 10
        });

        {
            var balance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User1Address,
                Symbol = symbol,
                TokenId = 1
            })).Balance;
            balance.ShouldBe(10);
        }

        {
            var balance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = MinterAddress,
                Symbol = symbol,
                TokenId = 1
            })).Balance;
            balance.ShouldBe(90);
        }

        return symbol;
    }

    [Fact]
    public async Task ApproveTest()
    {
        var symbol = await TransferTest();

        await MinterNFTContractStub.Approve.SendAsync(new ApproveInput
        {
            Spender = DefaultAddress,
            Symbol = symbol,
            TokenId = 1,
            Amount = 10
        });

        {
            var allowance = (await NFTContractStub.GetAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = MinterAddress,
                Spender = DefaultAddress,
                Symbol = symbol,
                TokenId = 1
            })).Allowance;
            allowance.ShouldBe(10);
        }

        await NFTContractStub.TransferFrom.SendAsync(new TransferFromInput
        {
            To = User1Address,
            Symbol = symbol,
            TokenId = 1,
            Amount = 9,
            From = MinterAddress
        });

        {
            var balance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User1Address,
                Symbol = symbol,
                TokenId = 1
            })).Balance;
            balance.ShouldBe(19);
        }
    }

    [Fact]
    public async Task AssembleTest()
    {
        var (symbol, tokenHash) = await MintTest();

        await TokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
        {
            Spender = NFTContractAddress,
            Symbol = "ELF",
            Amount = long.MaxValue
        });

        await NFTContractStub.Assemble.SendAsync(new AssembleInput
        {
            Symbol = symbol,
            AssembledNfts = new AssembledNfts
            {
                Value = { [tokenHash.ToHex()] = 1 }
            },
            AssembledFts = new AssembledFts
            {
                Value = { ["ELF"] = 100 }
            },
            Metadata = new Metadata
            {
                Value =
                {
                    ["Advanced Property"] = "whatever"
                }
            }
        });
    }

    private async Task AddMinterAsync(string symbol)
    {
        await NFTContractStub.AddMinters.SendAsync(new AddMintersInput
        {
            Symbol = symbol,
            MinterList = new MinterList
            {
                Value = { MinterAddress }
            }
        });
    }
}
```
