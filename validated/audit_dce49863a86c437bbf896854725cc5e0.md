# Audit Report

## Title
Partial Miner Replacement Causes isMinerListChanged Flag to Be Set Incorrectly, Allowing Banned Miners to Continue Mining

## Summary
When the Election contract returns fewer alternative candidates than evil miners during miner replacement, the consensus contract processes only partial replacements but incorrectly sets `isMinerListChanged=true`. This leaves banned miners active in the consensus round while triggering side effects designed for complete miner list changes, including disabling secret sharing and bypassing certain mining permission checks.

## Finding Description

The vulnerability exists in the miner replacement logic within `GenerateNextRoundInformation()`. The replacement loop iterates based on `minerReplacementInformation.AlternativeCandidatePubkeys.Count` rather than the total count of evil miners that need to be replaced. [1](#0-0) 

The Election contract's `GetMinerReplacementInformation()` method can return mismatched counts when the candidate pool is insufficient. It explicitly takes the minimum count between available candidates and evil miners, and even with initial miner fallback, may not provide enough alternatives. [2](#0-1) 

**Root Cause:** The consensus contract assumes a 1-to-1 correspondence between evil miners and alternatives. When `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`, only the first N evil miners (where N = AlternativeCandidatePubkeys.Count) are replaced, but `isMinerListChanged` is unconditionally set to `true` if any alternatives exist, even though some banned miners remain active.

**Why Existing Protections Fail:**

1. The `MiningPermissionValidationProvider` only checks if a pubkey exists in `RealTimeMinersInformation`, not whether it's banned: [3](#0-2) 

2. The `IsCurrentMiner` method skips the miner list membership check when `IsMinerListJustChanged=true`: [4](#0-3) 

3. The flag is directly propagated to the next round, setting `IsMinerListJustChanged=true`: [5](#0-4) 

## Impact Explanation

**Consensus Integrity Violation:**
- Banned miners who should be removed remain active and can produce blocks
- The unreplaced banned miner retains their time slot, order, and block production privileges
- This violates the core security invariant that evil miners must be excluded from consensus participation

**Secret Sharing Disruption:**
When `IsMinerListJustChanged=true`, the secret sharing mechanism is disabled: [6](#0-5) 

This is intended for legitimate miner list changes but occurs even when banned miners remain, potentially breaking the random number generation mechanism critical for consensus security.

**Altered Consensus Behavior:**
The `IsMinerListJustChanged` flag affects multiple consensus logic paths including extra block producer selection and miner validation. Unreplaced evil miners may gain or lose block production opportunities incorrectly due to the flag being set when the miner list change is incomplete.

**Severity:** HIGH - Banned miners continue participating in consensus despite being marked as evil, directly undermining the protocol's security model and miner accountability mechanism.

## Likelihood Explanation

**Reachable Entry Point:** The vulnerability is triggered through the normal consensus flow when `ProcessNextRound` calls `GenerateNextRoundInformation` during round transitions: [7](#0-6) 

**Feasible Preconditions:**
1. Main chain operation (checked during execution)
2. Same term operation (not transitioning to new term)
3. Multiple miners flagged as evil in `BannedPubkeyMap`
4. Limited candidate pool - election snapshot has fewer qualified candidates than evil miners
5. Initial miners either banned or already in the current miner list

**Execution Practicality:**
This scenario naturally occurs when:
- Network has a small candidate pool (common in side chains or early mainnet phases)
- Multiple miners violate consensus rules simultaneously (e.g., mass downtime event)
- Initial miners have also been compromised or banned

**Economic Rationality:** No attack cost required - this is a natural failure mode when legitimate banning mechanisms encounter insufficient replacement candidates. It represents a protocol design flaw rather than an exploitable attack vector.

**Probability:** MEDIUM - More likely in smaller networks with limited candidates or during security incidents involving multiple miners, but not an everyday occurrence on established networks with healthy candidate pools.

## Recommendation

Add validation to ensure complete miner replacement before setting the `isMinerListChanged` flag:

```csharp
if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
{
    // Validate we have enough alternatives for all evil miners
    if (minerReplacementInformation.AlternativeCandidatePubkeys.Count < 
        minerReplacementInformation.EvilMinerPubkeys.Count)
    {
        Context.LogDebug(() => 
            $"Insufficient alternatives: {minerReplacementInformation.AlternativeCandidatePubkeys.Count} " +
            $"available for {minerReplacementInformation.EvilMinerPubkeys.Count} evil miners");
        // Do not set isMinerListChanged = true in this case
        // Or handle partial replacement differently
    }
    else
    {
        for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
        {
            // ... existing replacement logic ...
        }
        isMinerListChanged = true;
    }
}
```

Alternatively, modify the Election contract's `GetMinerReplacementInformation` to guarantee returning equal counts, or implement a grace period mechanism where partially-banned miner lists are handled without triggering the `IsMinerListJustChanged` side effects.

## Proof of Concept

```csharp
// Test demonstrating partial miner replacement with flag incorrectly set
[Fact]
public async Task PartialMinerReplacement_LeavesEvilMinerActive()
{
    // Setup: 3 evil miners, but only 2 alternative candidates available
    var currentMiners = new[] { "miner1", "miner2", "miner3", "miner4", "miner5" };
    var evilMiners = new[] { "miner1", "miner2", "miner3" };
    var alternatives = new[] { "candidate1", "candidate2" }; // Only 2 alternatives
    
    // Mark miners as evil in Election contract
    foreach (var evilMiner in evilMiners)
    {
        await ElectionContractStub.UpdateCandidateInformation.SendAsync(
            new UpdateCandidateInformationInput 
            { 
                Pubkey = evilMiner, 
                IsEvilNode = true 
            });
    }
    
    // Trigger next round generation
    var result = await AEDPoSContractStub.NextRound.SendAsync(nextRoundInput);
    
    // Verify vulnerability:
    // 1. Only miner1 and miner2 should be replaced, miner3 remains
    var newRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.RealTimeMinersInformation.Keys.ShouldContain("miner3"); // Evil miner still present!
    newRound.RealTimeMinersInformation.Keys.ShouldContain("candidate1");
    newRound.RealTimeMinersInformation.Keys.ShouldContain("candidate2");
    
    // 2. IsMinerListJustChanged flag is incorrectly set to true
    newRound.IsMinerListJustChanged.ShouldBeTrue(); // Flag set despite incomplete replacement
    
    // 3. Banned miner can still produce blocks
    var isCurrentMiner = await AEDPoSContractStub.IsCurrentMiner.CallAsync(
        Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray("miner3")));
    isCurrentMiner.Value.ShouldBeTrue(); // Banned miner passes validation!
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-144)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-342)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-14)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```
