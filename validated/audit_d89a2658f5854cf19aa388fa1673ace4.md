# Audit Report

## Title
Unvalidated LIB Height/Round Correspondence in NextRound and NextTerm Transitions Enables State Corruption

## Summary
The AEDPoS consensus contract lacks LIB correspondence validation for `NextRound` and `NextTerm` behaviors, allowing malicious miners to inject mismatched `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` pairs that corrupt consensus state and trigger operational disruption.

## Finding Description

The AEDPoS consensus contract implements differential validation logic across consensus behaviors. The `LibInformationValidationProvider` validates that LIB values do not regress: [1](#0-0) 

However, this validator is **only** applied to `UpdateValue` behavior during validation pipeline assembly: [2](#0-1) 

For `NextRound` and `NextTerm` behaviors, the validation pipeline excludes `LibInformationValidationProvider`: [3](#0-2) 

In contrast to `UpdateValue` which recalculates LIB using `LastIrreversibleBlockHeightCalculator` and sets the correct correspondence: [4](#0-3) 

The `NextRound` and `NextTerm` behaviors accept LIB values from input and convert them directly via `ToRound()`: [5](#0-4) 

These values are then stored directly to state without correspondence validation: [6](#0-5) [7](#0-6) 

The validators for `NextRound` only check mining order and round number increment, not LIB correspondence: [8](#0-7) [9](#0-8) 

An attacker can provide round number 1 when the actual round at that height was 50, and this mismatch will be accepted and stored.

## Impact Explanation

**Operational DoS Impact:** The corrupted LIB values directly affect `GetMaximumBlocksCount`, which evaluates blockchain mining status by calculating the difference between current round and LIB round: [10](#0-9) [11](#0-10) 

By providing an artificially low `ConfirmedIrreversibleBlockRoundNumber` (e.g., 1 instead of actual 50), an attacker forces a large `currentRoundNumber - libRoundNumber` difference, triggering:

**Abnormal status**: Reduces maximum blocks per miner via false crisis formula: [12](#0-11) 

**Severe status**: Limits all miners to 1 block each and fires `IrreversibleBlockHeightUnacceptable` event: [13](#0-12) 

**Persistence:** The corrupted values propagate to subsequent rounds since `GenerateNextRoundInformation` copies them forward: [14](#0-13) 

The corruption persists until corrected through an honest miner submitting NextRound with correct values or through UpdateValue transactions that recalculate LIB.

**State Integrity Break:** The consensus state contains a critical inconsistency where `ConfirmedIrreversibleBlockRoundNumber` does not correspond to the actual round at `ConfirmedIrreversibleBlockHeight`, violating the fundamental invariant that these fields must be synchronized.

## Likelihood Explanation

**Attacker Capabilities:** Any miner can call `NextRound` since the only permission check is miner list membership: [15](#0-14) 

While the extra block producer typically terminates rounds: [16](#0-15) 

There is no validator enforcing that only the extra block producer can call `NextRound`.

**Attack Complexity:** Low. The attack sequence:
1. Attacker waits for opportunity to produce a block with `NextRound` behavior
2. Off-chain, constructs `NextRoundInput` with all legitimate values except `ConfirmedIrreversibleBlockRoundNumber` set to an artificially low value (e.g., 1)
3. Produces a NextRound block containing a transaction with this modified input
4. Validation passes because `LibInformationValidationProvider` is not in the validation pipeline
5. Corrupted values stored to state via `AddRoundInformation`

**Detection:** The attack manifests when `GetMaximumBlocksCount` returns incorrect values, causing false Abnormal/Severe status. However, by this point the state corruption has occurred.

**Economic Rationality:** The attack cost is minimal (one block production opportunity). Motivations include disrupting chain operations or creating chaos for secondary attacks.

## Recommendation

Add `LibInformationValidationProvider` to the validation pipeline for `NextRound` and `NextTerm` behaviors:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

Additionally, implement a correspondence validator that verifies `ConfirmedIrreversibleBlockRoundNumber` matches the actual round at `ConfirmedIrreversibleBlockHeight` by checking historical round data.

## Proof of Concept

```csharp
[Fact]
public async Task LIB_RoundNumber_Mismatch_NextRound_Attack()
{
    // Setup: Initialize consensus with multiple rounds
    await InitializeConsensusContract();
    await ProduceNormalBlocks(50); // Progress to round 50
    
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(50, currentRound.RoundNumber);
    
    // Attack: Malicious miner crafts NextRoundInput with corrupted LIB round number
    var maliciousNextRound = currentRound.GenerateNextRoundInformation(
        TimestampHelper.GetUtcNow(), 
        await ConsensusStub.GetBlockchainStartTimestamp.CallAsync(new Empty()));
    
    // Set LIB round number to 1 (instead of 49)
    maliciousNextRound.ConfirmedIrreversibleBlockRoundNumber = 1;
    maliciousNextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
    
    var maliciousInput = NextRoundInput.Create(maliciousNextRound, Hash.Empty);
    
    // Execute attack
    await ConsensusStub.NextRound.SendAsync(maliciousInput);
    
    // Verify state corruption
    var corruptedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(1, corruptedRound.ConfirmedIrreversibleBlockRoundNumber); // Corrupted value stored
    Assert.Equal(51, corruptedRound.RoundNumber); // Round progressed
    
    // Verify operational impact
    var maxBlocksCount = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    Assert.Equal(1, maxBlocksCount.Value); // Severe status triggered, limited to 1 block
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-20)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-34)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L25-28)
```csharp
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L35-37)
```csharp
        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-55)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L61-64)
```csharp
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
```
