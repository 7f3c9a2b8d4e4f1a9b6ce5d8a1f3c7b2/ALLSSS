# Audit Report

## Title
Secret Sharing Revealed In Values Discarded and Recomputed on Every Call, Wasting Gas

## Summary
The `RevealSharedInValues()` function performs expensive cryptographic secret sharing reconstruction during NextRound consensus transitions, but writes the revealed in values to a non-persisted in-memory copy of the current round. These values are completely discarded, breaking the anti-withholding protection mechanism and wasting gas on every call.

## Finding Description

During NextRound consensus transitions, the contract attempts to reconstruct miners' previous in values via Shamir's Secret Sharing to prevent withholding attacks. However, the implementation contains a critical flaw in the execution flow.

The `GetConsensusExtraDataForNextRound` method first creates `nextRound` via `GenerateNextRoundInformation` [1](#0-0) , then calls `RevealSharedInValues(currentRound, pubkey)` [2](#0-1) .

The `GenerateNextRoundInformation` method creates new `MinerInRound` objects with only `Pubkey`, `Order`, `ExpectedMiningTime`, `ProducedBlocks`, and `MissedTimeSlots` fields—it does NOT copy `PreviousInValue` fields [3](#0-2) .

The `RevealSharedInValues` function performs expensive cryptographic operations and writes revealed in values to `currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue` [4](#0-3) . The cryptographic reconstruction uses `SecretSharingHelper.DecodeSecret` with Lagrange interpolation [5](#0-4) .

However, these modifications are never persisted because the method returns `nextRound` (created before `RevealSharedInValues` was called), not the modified `currentRound` [6](#0-5) . The returned `nextRound` is converted to `NextRoundInput` which simply copies `RealTimeMinersInformation` as-is [7](#0-6) , and eventually persisted via `AddRoundInformation` [8](#0-7)  which stores the round to state [9](#0-8) .

Both public entry points `GetConsensusExtraData` and `GenerateConsensusTransactions` [10](#0-9)  call the same internal method, causing the computation to be repeated with each invocation.

## Impact Explanation

**Consensus Security Impact**: The secret sharing mechanism is a critical security feature designed to prevent miners from withholding their in values, which are essential for consensus randomness generation. When the revealed in values are discarded, miners who don't reveal their in values during the current round cannot be held accountable through secret sharing reconstruction during the NextRound transition. This completely breaks the anti-withholding protection for NextRound scenarios.

**Gas Waste Impact**: Every NextRound transition wastes significant gas performing secret sharing reconstruction. The computation involves iterating through all miners [11](#0-10) , reconstructing orders from decrypted pieces, and performing expensive cryptographic operations via `SecretSharingHelper.DecodeSecret`, all of which produces no useful result since the output is immediately discarded.

**Repeated Call Impact**: Since `GetConsensusExtraData` and `GenerateConsensusTransactions` are public ACS4 methods, they can be called multiple times for the same round during normal consensus operation. Each invocation retrieves a fresh copy of `currentRound` from state and recomputes the entire secret sharing reconstruction from scratch, multiplying the gas waste.

## Likelihood Explanation

**Reachability**: The issue is triggered on every NextRound consensus transition through the public ACS4 methods which are standard entry points called by the consensus system during normal block production flow.

**Frequency**: NextRound transitions occur regularly at the end of each consensus round when the extra block producer generates the transition block. With secret sharing enabled (checked via configuration contract [12](#0-11) ), every such transition wastes gas on this broken computation.

**Preconditions**: The only precondition is that secret sharing must be enabled via the configuration contract, which is the intended production mode for preventing in value withholding attacks. No special attacker capabilities or privileges are required—this is a design flaw that manifests during normal consensus operation.

## Recommendation

The fix requires ensuring the revealed `PreviousInValue` fields are persisted. After calling `RevealSharedInValues(currentRound, pubkey)`, copy the revealed values from `currentRound` to `nextRound` before returning:

```csharp
RevealSharedInValues(currentRound, pubkey);

// Copy revealed PreviousInValue fields to nextRound
foreach (var minerInfo in currentRound.RealTimeMinersInformation)
{
    if (nextRound.RealTimeMinersInformation.ContainsKey(minerInfo.Key) &&
        minerInfo.Value.PreviousInValue != null && 
        minerInfo.Value.PreviousInValue != Hash.Empty)
    {
        nextRound.RealTimeMinersInformation[minerInfo.Key].PreviousInValue = 
            minerInfo.Value.PreviousInValue;
    }
}
```

Alternatively, update `GenerateNextRoundInformation` to copy `PreviousInValue` fields when creating new `MinerInRound` objects, or call `RevealSharedInValues(nextRound, pubkey)` instead of using `currentRound`.

## Proof of Concept

The vulnerability can be demonstrated by tracing execution during a NextRound transition with secret sharing enabled:

1. Call `GetConsensusExtraData` or `GenerateConsensusTransactions` with NextRound behavior
2. Observe `GetConsensusExtraDataForNextRound` creates `nextRound` at line 176
3. Observe `RevealSharedInValues` modifies `currentRound.RealTimeMinersInformation[miner].PreviousInValue`
4. Observe method returns `nextRound` which does not contain the revealed values
5. Verify `ProcessNextRound` persists `nextRound` via `AddRoundInformation`
6. Confirm revealed values are not present in the persisted state by querying the stored round

The wasted computation can be verified by monitoring gas consumption during NextRound transitions with secret sharing enabled versus disabled, showing unnecessary cryptographic operations that produce no state changes.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L198-203)
```csharp
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L25-53)
```csharp
        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L9-22)
```csharp
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L105-105)
```csharp
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-74)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }

    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
```
