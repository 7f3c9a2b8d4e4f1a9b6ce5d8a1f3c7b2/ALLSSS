# Audit Report

## Title
Decimal Overflow in Bancor Price Calculation Causes Permanent DoS When Extreme Connector Weight Ratios Are Used

## Summary
The TokenConverter contract's Bancor pricing implementation lacks validation on connector weight ratios, allowing configurations that cause decimal overflow during exponential calculations. This results in permanent denial-of-service of token conversion functionality once connectors are activated, as activated connectors cannot be reconfigured.

## Finding Description

The vulnerability exists in the interaction between the Bancor formula and the exponential power calculation implementation.

The `Exp` function computes a power series expansion up to the 20th term, repeatedly calling `Pow(y, iteration)` where y represents the argument to the exponential function. [1](#0-0) 

The `Pow` function implements left-to-right binary exponentiation using repeated squaring operations. [2](#0-1) 

**Root Cause:** In the Bancor pricing formulas, the argument `y` passed to `Exp` is computed as `(weight_ratio) * Ln(balance_ratio)`. [3](#0-2) [4](#0-3) 

Individual connector weights are validated to be strictly between 0 and 1. [5](#0-4) 

However, there is no validation on the **ratio** between two connector weights. If one connector has weight 0.95 and another has weight 0.003, the ratio is approximately 317. Combined with a moderate trade (e.g., 50% of connector balance giving Ln(2) ≈ 0.693), this produces y ≈ 220. Computing 220^20 via binary exponentiation causes intermediate squared values to exceed `decimal.MaxValue` (≈7.9×10^28).

C# decimal arithmetic always throws `OverflowException` on overflow, regardless of checked/unchecked context. AElf enforces this through build-time validation and patching. [6](#0-5) 

**Permanence:** Once connectors are activated, the `UpdateConnector` method explicitly prevents any modifications including weight changes. [7](#0-6) 

Both `Buy` and `Sell` operations directly call the vulnerable Bancor calculations without exception handling. [8](#0-7) [9](#0-8) 

Note that the try-catch block in `GetAmountToPayFromReturn` only applies when weights are equal, not when they differ. [10](#0-9) 

## Impact Explanation

**HIGH Severity** - This vulnerability causes complete and permanent denial-of-service:

1. **Operational DoS**: All `Buy` and `Sell` transactions revert with `OverflowException`, making token conversion impossible
2. **Liquidity Lock**: Tokens deposited in affected connectors cannot be converted back, effectively locking user funds  
3. **Irrecoverable**: The restriction on updating activated connectors means the DoS is permanent without contract migration
4. **Economic Damage**: Loss of core protocol functionality disrupts the token economy

While funds are not directly stolen, the complete loss of conversion capability and locked liquidity constitutes severe protocol failure.

## Likelihood Explanation

**LOW-MEDIUM Probability**

**Preconditions:**
1. Connector controller (Parliament governance) configures weights with problematic ratio (>300:1)
2. Connectors are activated via `EnableConnector`
3. User submits trade with moderate amount

**Feasibility:**
- Extreme ratios like 0.9999:0.0001 are technically valid per current validation
- Even moderate-looking values (0.95:0.003) can trigger overflow
- Configuration could occur through proposal typos or poor understanding of ratio implications
- However, governance testing would likely catch obvious misconfigurations
- The lack of validation represents a missing safeguard against honest mistakes

The primary risk is inadequate input validation rather than malicious exploitation.

## Recommendation

Add validation to prevent dangerous weight ratios during connector configuration:

```csharp
private void AssertValidWeightRatio(decimal weight1, decimal weight2)
{
    var maxRatio = 100m; // Maximum safe ratio
    var ratio = Math.Max(weight1 / weight2, weight2 / weight1);
    Assert(ratio <= maxRatio, $"Weight ratio {ratio} exceeds maximum safe ratio of {maxRatio}");
}
```

Apply this check in `AddPairConnector` and `UpdateConnector` methods before accepting weight configurations. This provides defense-in-depth against configuration errors.

## Proof of Concept

```csharp
[Fact]
public async Task ExtremeWeightRatio_Causes_Overflow_DoS()
{
    // Setup: Create connector with extreme weight ratio
    var tokenSymbol = "VULN";
    await CreateTokenAsync(tokenSymbol);
    
    var pairConnector = new PairConnectorParam
    {
        ResourceConnectorSymbol = tokenSymbol,
        ResourceWeight = "0.95",  // High weight
        NativeWeight = "0.003",   // Low weight (ratio ~317:1)
        NativeVirtualBalance = 1_000_000_00000000
    };
    
    await ExecuteProposalForParliamentTransaction(
        TokenConverterContractAddress,
        nameof(TokenConverterContractImplStub.AddPairConnector),
        pairConnector);
    
    // Enable connector
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 100_000_000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 100_000_000
    });
    
    // Attempt trade - should revert with OverflowException
    var buyResult = await DefaultStub.Buy.SendWithExceptionAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = 50_000_000  // 50% trade triggers overflow
    });
    
    buyResult.TransactionResult.Error.ShouldContain("Overflow");
    
    // Verify permanent DoS - cannot update activated connector
    var updateResult = await ExecuteProposalForParliamentTransactionWithException(
        TokenConverterContractAddress,
        nameof(TokenConverterContractImplStub.UpdateConnector),
        new Connector { Symbol = tokenSymbol, Weight = "0.5" });
    
    updateResult.Error.ShouldContain("connector can not be updated because it has been activated");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L51-53)
```csharp
        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L80-94)
```csharp
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** src/AElf.CSharp.CodeOps/Validators/Method/UncheckedMathValidator.cs (L10-43)
```csharp
public class UncheckedMathValidator : IValidator<MethodDefinition>, ITransientDependency
{
    private readonly HashSet<OpCode> _uncheckedOpCodes = new HashSet<OpCode>
    {
        OpCodes.Add,
        OpCodes.Sub,
        OpCodes.Mul
    };
        
    public bool SystemContactIgnored => false;

    public IEnumerable<ValidationResult> Validate(MethodDefinition method, CancellationToken ct)
    {
        if (ct.IsCancellationRequested)
            throw new ContractAuditTimeoutException();
            
        if (!method.HasBody)
            return Enumerable.Empty<ValidationResult>();

        var errors = new List<ValidationResult>();
            
        foreach (var instruction in method.Body.Instructions)
        {
            if (!_uncheckedOpCodes.Contains(instruction.OpCode))
                continue;
                
            errors.Add(
                new UncheckedMathValidationResult( $"{method.Name} contains unsafe OpCode " + instruction.OpCode)
                    .WithInfo(method.Name, method.DeclaringType.Namespace, method.DeclaringType.Name, null));
        }
            
        return errors;
    }
}
```
