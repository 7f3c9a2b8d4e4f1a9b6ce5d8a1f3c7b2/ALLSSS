# Audit Report

## Title
Race Condition in Consensus Order Assignment Leads to Duplicate Mining Orders and Broken Round Schedule

## Summary
Multiple miners can be assigned identical `FinalOrderOfNextRound` values when they concurrently produce blocks based on the same on-chain state. The conflict resolution logic runs off-chain independently for each miner, and on-chain processing lacks uniqueness validation, allowing duplicate `Order` values in the next round. This breaks the AEDPoS consensus invariant that all miners must have unique mining order positions.

## Finding Description

The vulnerability exists in the interaction between off-chain order calculation and on-chain state updates within the AEDPoS consensus mechanism:

**Off-chain Conflict Resolution:**
Each miner independently calculates their `supposedOrderOfNextRound` based on their signature modulo the miner count. When conflicts are detected (another miner already has that `FinalOrderOfNextRound`), the conflicting miner is reassigned to the next available order slot. [1](#0-0) 

**On-chain State Update:**
When processing `UpdateValue` transactions, the contract directly applies the miner's `SupposedOrderOfNextRound` to `FinalOrderOfNextRound` and then applies the `TuneOrderInformation` dictionary to update other miners' orders. [2](#0-1) 

**Missing Validation:**
The `NextRoundMiningOrderValidationProvider` only validates count equality using `.Distinct()` on `MinerInRound` objects (which checks object references, not `FinalOrderOfNextRound` values), and this validator is only applied to `NextRound` behavior, not `UpdateValue` behavior where the vulnerability occurs. [3](#0-2) [4](#0-3) 

The `UpdateValueValidationProvider` only checks that new consensus information is filled and previous in values are correct, with no uniqueness validation. [5](#0-4) 

**Race Condition Scenario:**
1. Miner A has already mined with `FinalOrderOfNextRound = 2`
2. Miners B and C both calculate `supposedOrderOfNextRound = 2` (their signatures modulo N both equal 1)
3. B produces a block: detects conflict with A, reassigns A→3, sets B=2, includes `TuneOrderInformation = {A: 3}`
4. C produces a block before seeing B's block: detects same conflict with A, reassigns A→3, sets C=2, includes `TuneOrderInformation = {A: 3}`
5. On-chain processing: B's block executes (A→3, B=2), then C's block executes (A→3 [no change], C=2)
6. Result: Both B and C have `FinalOrderOfNextRound = 2`

**Impact on Next Round:**
When generating the next round, miners are ordered by `FinalOrderOfNextRound`, and the `occupiedOrders` list is created by selecting all miners' `FinalOrderOfNextRound` values. With duplicate values, this list contains duplicates (e.g., [2, 2, 3]), causing `ableOrders` to miscalculate available slots. [6](#0-5) 

Both miners with duplicate orders receive the same `Order` value in the next round, resulting in identical `ExpectedMiningTime` values, causing them to compete for the same time slot.

## Impact Explanation

**Consensus Integrity Breakdown:**
- Two or more miners receive identical `Order` and `ExpectedMiningTime` values in the next round
- Multiple miners attempt to produce blocks at the same time slot, creating conflicts and potential forks
- Valid order positions remain unassigned, creating gaps in the mining schedule
- The deterministic time-slot allocation critical to AEDPoS consensus is broken
- Round transitions become unpredictable as duplicate-order miners race to produce blocks
- Extra block producer calculation and continuous mining prevention logic may malfunction due to unexpected duplicate orders

**Affected Parties:**
- All miners in the affected round experience schedule corruption
- Network consensus becomes unreliable as block production timing is compromised
- Chain progress may stall or fork if duplicate-order miners create conflicting blocks simultaneously
- The miner count invariant is violated: not all orders from 1 to N are uniquely assigned

This is a **HIGH severity** issue as it directly compromises the integrity of the consensus mechanism, which is fundamental to blockchain security.

## Likelihood Explanation

**Trigger Conditions:**
- No special privileges required - any miner producing blocks can trigger this naturally
- Occurs when multiple miners' signatures modulo N result in the same value (probability ~1/N for any two miners)
- These miners must produce blocks based on the same on-chain state (before seeing each other's blocks)
- Network latency between nodes increases the probability of this race condition

**Attack Complexity: LOW**
- This can occur without malicious intent through natural network conditions
- Requires only normal block production operations
- No special timing or coordination needed beyond typical network latency
- Can occur repeatedly across multiple rounds

**Probability:**
- With N miners, the probability of two miners getting the same signature modulo value in the same round is approximately 1/N
- For a 3-miner network, this is approximately 33% probability per round when two miners produce blocks concurrently
- For larger networks, while individual collision probability decreases, the number of potential collisions increases
- Expected occurrence: potentially multiple times per day on active chains with typical network latency

**Real-World Feasibility:**
- Network latency is normal in distributed systems
- Miners in different geographic locations naturally have propagation delays
- The vulnerability can manifest during normal operations without any attack
- No detection or prevention mechanisms exist to identify duplicate orders before they're committed

## Recommendation

Implement on-chain uniqueness validation for `FinalOrderOfNextRound` values when processing `UpdateValue` transactions:

1. **Add validation in ProcessUpdateValue:**
   Before applying `TuneOrderInformation`, verify that no other miner already has the target order value. If a conflict is detected, reject the transaction or reassign to a different order on-chain.

2. **Enhance NextRoundMiningOrderValidationProvider:**
   Check for actual uniqueness of `FinalOrderOfNextRound` values, not just object distinctness:
   ```csharp
   var finalOrders = providedRound.RealTimeMinersInformation.Values
       .Where(m => m.FinalOrderOfNextRound > 0)
       .Select(m => m.FinalOrderOfNextRound)
       .ToList();
   if (finalOrders.Count != finalOrders.Distinct().Count())
   {
       validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
       return validationResult;
   }
   ```

3. **Apply validation to UpdateValue behavior:**
   Add the enhanced `NextRoundMiningOrderValidationProvider` to the validation providers list for `UpdateValue` behavior in `ValidateBeforeExecution`.

4. **Add on-chain conflict detection:**
   When applying `TuneOrderInformation`, check if the reassignment would create a duplicate with another miner who has already set their `FinalOrderOfNextRound` in the current round.

## Proof of Concept

This vulnerability requires integration testing with multiple nodes to simulate the race condition. A proof of concept would:

1. Deploy a test network with 3 miners (A, B, C)
2. Have miner A produce a block with `FinalOrderOfNextRound = 2`
3. Arrange for miners B and C to have signatures that modulo to the same value
4. Have B and C produce blocks concurrently before seeing each other's blocks
5. Verify that both B and C end up with `FinalOrderOfNextRound = 2` after on-chain processing
6. Trigger next round generation and observe duplicate `Order` values
7. Confirm that `occupiedOrders` contains [2, 2, 3] and `ableOrders` only contains [1]

The test would demonstrate that two miners receive identical mining order positions, violating the consensus invariant and causing schedule conflicts in the next round.

---

## Notes

This vulnerability is particularly dangerous because:
1. It can occur naturally without malicious intent through normal network conditions
2. No validation exists to prevent or detect it before damage occurs
3. The corrupted state is permanently committed on-chain
4. It directly impacts the core consensus mechanism's ability to maintain deterministic block production
5. The probability increases with network latency, making it more likely in geographically distributed networks

The fix requires careful consideration of how to handle conflicts detected on-chain, as simple rejection might create availability issues if legitimate conflicts occur frequently.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-260)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-41)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```
