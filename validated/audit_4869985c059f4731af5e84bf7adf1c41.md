# Audit Report

## Title
Hash.Empty Bypass in Consensus Behavior Determination Allows Miners to Manipulate Block Production Logic

## Summary
The AEDPoS consensus contract fails to validate that `OutValue` contains cryptographically valid hash data, allowing miners to submit `Hash.Empty` (32 zero bytes). The validation uses `.Any()` which only verifies byte array length, not content, enabling malicious miners to bypass proper consensus behavior assignment and avoid cryptographic commitments required for randomness generation and secret sharing.

## Finding Description

The vulnerability exists in the consensus validation logic where miners must provide cryptographic commitments through an InValue/OutValue mechanism where `OutValue = Hash(InValue)`.

**Validation Weakness:**
The validation checks whether OutValue has been filled but does not verify the hash contains non-zero values. [1](#0-0) 

This validation checks that `OutValue != null` and `OutValue.Value.Any()` returns true. Since `Hash.Empty` is defined as 32 zero bytes [2](#0-1) , it passes the `.Any()` check (which returns true for any non-empty collection, regardless of byte values).

**Behavior Determination Bypass:**
The consensus behavior logic determines mining behavior based on whether OutValue has been set. [3](#0-2) 

When a miner submits `OutValue = Hash.Empty`, the condition `_minerInRound.OutValue == null` evaluates to false (Hash.Empty is not null), causing `HandleMinerInNewRound` to be skipped. The miner is incorrectly treated as having already produced blocks in the current round.

**PreviousInValue Escape Hatch:**
The validation explicitly allows `previousInValue == Hash.Empty` without verifying the cryptographic relationship. [4](#0-3) 

This enables miners to perpetually use Hash.Empty across rounds without proper validation.

**State Storage Without Validation:**
The OutValue from input is stored directly into state without checking if it equals Hash.Empty. [5](#0-4) 

**Expected Behavior:**
The legitimate consensus flow shows OutValue should always be computed as the hash of InValue. [6](#0-5) 

Hash.Empty is only used legitimately as a sentinel value for `PreviousInValue` during first round initialization. [7](#0-6) 

There are no legitimate assignments of `OutValue = Hash.Empty` in the codebase, confirming it should never occur as an OutValue.

**Attack Path:**
1. Malicious miner crafts UpdateValueInput with `OutValue = Hash.Empty`
2. Validation passes (Hash.Empty has 32 bytes, `.Any()` returns true)
3. Behavior check incorrectly treats miner as having mined (OutValue != null)
4. State stores Hash.Empty as OutValue
5. Next round, miner provides `previousInValue = Hash.Empty` (explicitly allowed by line 46)
6. Cycle repeats indefinitely without proper cryptographic commitments

## Impact Explanation

**Consensus Integrity Violation:**
The AEDPoS protocol relies on verifiable cryptographic commitments through OutValue/InValue pairs for randomness generation. By accepting Hash.Empty, miners can:
- Avoid making proper cryptographic commitments
- Skip contributing entropy to random number generation used for block producer selection
- Break the threshold secret sharing mechanism designed to recover InValues for randomness

**Behavior Manipulation:**
The `HandleMinerInNewRound` method determines critical consensus behaviors (UPDATE_VALUE, TINY_BLOCK, NEXT_ROUND). [8](#0-7) 

Bypassing this logic allows miners to:
- Produce blocks outside proper behavior assignments
- Disrupt round transition timing
- Affect irreversible block height calculations

**Randomness Weakness:**
The signature calculation aggregates all miners' signatures for next round ordering. [9](#0-8) 

Miners using Hash.Empty contribute no entropy to this calculation, weakening randomness quality for consensus decisions.

**Affected Parties:**
- All network participants depending on consensus integrity
- Smart contracts relying on consensus randomness
- Cross-chain operations requiring secure random values
- Block reward distribution mechanisms

## Likelihood Explanation

**Entry Point Accessibility:**
The UpdateValue method is accessible to any registered miner through the public contract interface. Authorization is validated only to ensure the sender is a current miner. [10](#0-9) 

Any participant can become a registered miner through standard election/staking mechanisms, making this exploitable by untrusted actors.

**No On-Chain Protection:**
No validation prevents Hash.Empty submission. The absence of any `OutValue = Hash.Empty` assignments in the production codebase confirms this should never occur legitimately.

**Attack Simplicity:**
Exploitation requires only modifying the consensus client to submit Hash.Empty instead of computing proper hashes. No cryptographic attacks, timing manipulation, or special network conditions are needed.

**No Punishment Mechanism:**
Evil miner detection only tracks missed time slots. [11](#0-10) 

Since miners submitting Hash.Empty are still producing blocks (not missing slots), they avoid detection and punishment.

## Recommendation

Add explicit validation to reject `Hash.Empty` as OutValue:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Reject Hash.Empty as OutValue
    if (minerInRound.OutValue == Hash.Empty)
        return false;
        
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
}
```

Additionally, consider validating that the current OutValue is not Hash.Empty when processing updates, not just the previous round's relationship.

## Proof of Concept

```csharp
[Fact]
public async Task HashEmpty_Bypass_Vulnerability_Test()
{
    // Setup: Become a miner and wait for mining slot
    var minerKeyPair = SampleKeyPairs.KeyPairs[0];
    var consensusStub = GetConsensusContractTester(minerKeyPair);
    
    // Get current round to determine proper mining behavior
    var currentRound = await consensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerPubkey = minerKeyPair.PublicKey.ToHex();
    
    // Craft malicious UpdateValueInput with Hash.Empty as OutValue
    var maliciousInput = new UpdateValueInput
    {
        OutValue = Hash.Empty,  // Should be Hash(InValue) but using Hash.Empty
        Signature = HashHelper.ComputeFrom("fake_signature"),
        PreviousInValue = Hash.Empty,
        RoundId = currentRound.RoundId,
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        SupposedOrderOfNextRound = 1,
        ImpliedIrreversibleBlockHeight = 1
    };
    
    // Execute malicious UpdateValue - should fail but will pass due to vulnerability
    var result = await consensusStub.UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Vulnerability: passes validation
    
    // Verify Hash.Empty was stored as OutValue
    var updatedRound = await consensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    updatedRound.RealTimeMinersInformation[minerPubkey].OutValue.ShouldBe(Hash.Empty);
    
    // Verify behavior bypass: OutValue != null prevents HandleMinerInNewRound
    // Miner is now incorrectly treated as having mined when they used invalid crypto
}
```

## Notes

Hash.Empty is intentionally used as a sentinel value for `PreviousInValue` in first-round initialization, but should **never** appear as an `OutValue`. The validation's use of `.Any()` to check byte array content is insufficientâ€”it only verifies the array is non-empty, not that it contains valid cryptographic hash data. This allows the all-zeros Hash.Empty to bypass validation designed to ensure miners make proper cryptographic commitments for consensus security.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** src/AElf.Types/Types/Hash.cs (L13-14)
```csharp
        public static readonly Hash Empty = LoadFromByteArray(Enumerable.Range(0, AElfConstants.HashByteArrayLength)
            .Select(x => byte.MinValue).ToArray());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-56)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L92-115)
```csharp
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L245-245)
```csharp
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-67)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L35-35)
```csharp
            minerInRound.PreviousInValue = Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```
