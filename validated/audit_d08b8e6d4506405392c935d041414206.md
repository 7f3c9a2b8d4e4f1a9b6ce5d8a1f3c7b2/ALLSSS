# Audit Report

## Title
Parliament Proposal Release Failure Due to Miner List Changes Between Voting and Execution

## Summary
The Parliament contract's `IsReleaseThresholdReached()` method evaluates vote thresholds using the CURRENT miner list at release time rather than the historical miner list when votes were cast. When consensus term transitions change the miner composition between voting and release, previously valid votes from departed miners are excluded from threshold calculations, causing legitimately approved proposals to permanently fail release.

## Finding Description

The vulnerability exists in the Parliament contract's vote threshold validation logic. When a proposal is released, the `Release()` method calls `IsReleaseThresholdReached()` to verify approval thresholds have been met. [1](#0-0) 

The core issue is that `IsReleaseThresholdReached()` retrieves the CURRENT miner list from the consensus contract at the moment of release: [2](#0-1) 

The current miner list retrieval queries the consensus contract for real-time miner information: [3](#0-2) 

This current miner list is then used to filter ALL votes (approvals, rejections, abstentions) using LINQ's `.Contains()` predicate: [4](#0-3) 

The miner list changes during consensus term transitions as the AEDPoS consensus updates the active miner set through elections: [5](#0-4) 

The current miner list is retrieved from the current round's real-time miner information: [6](#0-5) 

**Broken Invariant:** Votes are immutable once cast and stored permanently in the proposal as repeated address fields: [7](#0-6) 

However, their validity for threshold calculations changes dynamically based on current consensus state, violating the expectation that approved proposals remain releasable.

**Execution Scenario:**
1. At Term N: Miner set = {A, B, C, D, E} (5 miners)
2. Proposal created with default threshold 6667/10000 (66.67%): [8](#0-7) 
3. Miners A, B, C, D approve → 4/5 = 80% ≥ 66.67% (threshold reached)
4. Term transition occurs via `NextTerm`, new miner set = {B, C, F, G, H}
5. Proposer calls `Release()`
6. `IsReleaseThresholdReached()` filters approvals: only B and C remain valid
7. Threshold check: 2/5 = 40% < 66.67% → **FAILS**
8. Transaction reverts with "Not approved"

The proposal cannot be released even though it legitimately achieved approval threshold. If the proposal expires, it becomes permanently lost: [9](#0-8) 

## Impact Explanation

**HIGH Severity - Governance Denial of Service**

This vulnerability causes critical governance failures:

1. **Legitimately Approved Proposals Become Unreleasable**: Proposals that achieved proper approval thresholds at voting time can no longer be released, breaking the fundamental governance guarantee that approved proposals can be executed.

2. **System-Critical Operations Blocked**: The default organization handles system upgrades and critical configuration changes via Parliament governance.

3. **Emergency Response Disruption**: The Emergency Response Organization (with 90% threshold) is equally affected: [10](#0-9) 

4. **Governance Deadlock**: Expired proposals are permanently cleared with no recovery mechanism, forcing restart of entire approval process.

5. **Misleading View State**: The `GetProposal()` method also uses current miner list, so its `ToBeReleased` flag can fluctuate based on consensus state: [11](#0-10) 

## Likelihood Explanation

**HIGH Likelihood - Occurs During Normal Operations**

This issue requires no attacker action and manifests during routine system operation:

1. **Regular Term Transitions**: Consensus terms transition periodically, updating the miner list through democratic elections.

2. **Natural Voting Duration**: Contentious or important proposals often require days to gather sufficient miner approvals, making it highly likely that voting periods span term boundaries.

3. **Guaranteed Miner Rotation**: The Election contract regularly updates miner composition through term transitions, ensuring miner sets change across terms.

4. **No Special Privileges Required**: Any proposer using standard Parliament governance will encounter this issue if their proposal's voting period crosses a term transition where any approving miners leave the active set.

5. **Silent Failure Mode**: The issue is invisible until release is attempted. Proposers see `ToBeReleased = true` during voting, then unexpectedly fail at release time with no clear indication of the root cause.

## Recommendation

Store the miner list snapshot at the time of proposal creation or first vote, and use that historical snapshot for all threshold calculations. Modify `IsReleaseThresholdReached()` to accept a stored miner list rather than querying the current list:

```csharp
private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
{
    // Use stored miner list from proposal creation/voting time
    var parliamentMembers = proposal.ValidMinerList; // New field
    var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
    if (isRejected)
        return false;

    var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
    if (isAbstained)
        return false;

    return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
}
```

Add `ValidMinerList` field to `ProposalInfo` and populate it during proposal creation.

## Proof of Concept

```csharp
[Fact]
public async Task ProposalRelease_FailsAfterMinerListChange_Test()
{
    // Setup: Initialize contracts with 5 miners
    InitializeContracts();
    
    // Step 1: Create proposal with default organization at Term N
    var proposalId = await ParliamentContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty()),
            ToAddress = TokenContractAddress,
            ContractMethodName = nameof(TokenContractStub.Transfer),
            Params = new TransferInput { To = Tester, Amount = 100, Symbol = "ELF" }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(30)
        });
    
    // Step 2: Get 4 out of 5 miners to approve (80% > 66.67%)
    for (int i = 0; i < 4; i++)
    {
        var minerStub = GetParliamentContractTester(InitialMinersKeyPairs[i]);
        await minerStub.Approve.SendAsync(proposalId.Output);
    }
    
    // Verify proposal is ready to release
    var proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ToBeReleased.ShouldBeTrue(); // 4/5 = 80% >= 66.67%
    
    // Step 3: Simulate term transition with miner list change
    // Miners {0,1,2,3,4} → {1,2,5,6,7} (only miners 1 and 2 remain)
    await ConsensusContractStub.NextTerm.SendAsync(new NextTermInput
    {
        // Configure new miner list with only 2 of the original approvers
        // This simulates the natural rotation through elections
    });
    
    // Step 4: Attempt to release proposal
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(proposalId.Output);
    
    // VULNERABILITY: Release fails even though proposal had 80% approval
    // Only 2/5 votes count now (40% < 66.67%) because other miners left
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Proposal remains stuck and will eventually expire
    proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ToBeReleased.ShouldBeFalse(); // Flag changed despite no new votes
}
```

**Notes**

This vulnerability represents a fundamental flaw in the temporal consistency of governance voting. The Parliament contract design assumes miner lists remain stable between voting and execution, but the AEDPoS consensus system guarantees periodic miner rotation through democratic elections. This creates an unavoidable race condition where legitimately approved proposals can become unreleasable through normal system operations, effectively breaking the governance mechanism's core functionality.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L137-137)
```csharp
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L225-248)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = Validate(proposal) && IsReleaseThresholdReached(proposal, organization),
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-102)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }

    private bool IsVoteThresholdReached(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-256)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
```

**File:** protobuf/parliament_contract.proto (L131-136)
```text
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-5)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
```
