# Audit Report

## Title
NFT Token Hash Collision via Ambiguous String Concatenation Enables Cross-Protocol Denial of Service and State Corruption

## Summary
The NFT contract's `CalculateTokenHash` function concatenates symbol and tokenId without a delimiter, enabling hash collisions across different protocols. This vulnerability allows attackers to either permanently block legitimate NFT mints (DoS) or corrupt NFT state across protocols, depending on the `IsTokenIdReuse` configuration.

## Finding Description

The root cause lies in the `CalculateTokenHash` implementation which performs simple string concatenation without any delimiter between the symbol and tokenId: [1](#0-0) 

NFT protocol symbols are generated with a 2-letter prefix followed by a variable-length random number. The minimum random number length is defined as 9 digits: [2](#0-1) 

The symbol generation concatenates the 2-letter NFT type prefix with the random number: [3](#0-2) 

As more protocols are created, the random number length dynamically increases to accommodate more unique symbols: [4](#0-3) 

Users can specify arbitrary tokenId values when minting, with the system auto-generating only when tokenId is 0: [5](#0-4) 

**Collision Example:**
- Protocol A with symbol "AR123456789" (2-letter prefix + 9-digit number) minting tokenId 999 produces hash of string "AR123456789999"
- Protocol B with symbol "AR1234567899" (2-letter prefix + 10-digit number) minting tokenId 99 produces hash of string "AR123456789999"
- Both produce identical hashes despite representing completely different NFTs from different protocols

The collision detection checks if the tokenHash already exists in storage but does not distinguish between same-protocol reuse versus cross-protocol collision: [6](#0-5) 

When `IsTokenIdReuse` is false, this assertion fails causing DoS. When `IsTokenIdReuse` is true, the assertion is bypassed entirely and both protocols modify the same state storage locations.

All critical NFT state maps are keyed exclusively by the tokenHash: [7](#0-6) 

This affects all NFT operations including transfers [8](#0-7) , transferFrom [9](#0-8) , burns [10](#0-9) , approvals [11](#0-10) , and balance queries [12](#0-11) .

## Impact Explanation

**Denial of Service Impact:**
When a protocol with a shorter symbol (e.g., "AR123456789") mints a specific tokenId first, any subsequent protocol whose symbol creates a collision (e.g., "AR1234567899") is permanently blocked from minting that tokenId. The assertion error message is misleading as it states "Token id {tokenId} already exists" when in reality only the hash collision exists across different protocols. This blocks legitimate protocol operators from utilizing specific tokenId ranges.

**State Corruption Impact:**
When `IsTokenIdReuse=true`, the collision check is bypassed and both protocols write to the same storage locations:
- `State.NftInfoMap[tokenHash]` stores conflated metadata from both NFTs
- `State.BalanceMap[tokenHash]` mixes balances across different protocols  
- `State.AllowanceMap[tokenHash]` conflates approval permissions between unrelated NFTs

This results in:
- Incorrect NFT metadata returned by `GetNFTInfo` queries
- Wrong balance amounts via `GetBalance` calls
- Misrouted transfer operations affecting unintended NFTs across protocols
- Incorrect burn operations potentially destroying the wrong assets
- Mixed allowance permissions creating unauthorized transfer capabilities between unrelated protocols

**Severity Justification:**
This is HIGH/CRITICAL severity because:
1. Breaks the fundamental invariant that each (symbol, tokenId) pair must be globally unique
2. Enables systematic DoS against new protocols as the ecosystem scales and symbol lengths increase
3. Corrupts core state storage affecting all NFT operations across the contract
4. Requires only mint permission (obtainable by anyone creating their own protocol or being added as a minter)
5. Impact probability increases as more protocols are created and symbol lengths grow beyond 9 digits

## Likelihood Explanation

**Attacker Requirements:**
- Mint permission on at least one NFT protocol (obtainable by creating their own protocol via the public `Create` method or being added as a minter to an existing protocol)
- Ability to calculate collision pairs (straightforward arithmetic: for symbol S of length N, find symbol S' of length N+1 where S + tokenId1 == S' + tokenId2)
- Ability to monitor on-chain protocol creation events (publicly observable via `NFTProtocolCreated` events)
- No special privileges, governance control, or system contract access required

**Attack Feasibility:**
The attack is highly feasible because:
1. Symbol generation is deterministic and fully observable on-chain through protocol creation events
2. Collision calculation is simple arithmetic - no complex computation required
3. Attacker can frontrun protocol creation or strategically mint colliding tokenIds after observing new protocols
4. No special timing windows required beyond standard transaction ordering
5. Collision probability increases systematically as ecosystem scales with more 10+ digit symbols

**Detection Difficulty:**
- Hash collisions appear as legitimate mint transactions with no obvious indicators
- Error messages don't reveal cross-protocol collision nature
- No on-chain monitoring currently exists to detect this attack pattern
- Victims may not realize their DoS is caused by collision from another unrelated protocol

The cost-benefit strongly favors the attacker as the attack cost is minimal (only gas fees for minting) while the potential gain includes blocking competitors' protocols or causing widespread state corruption affecting multiple protocols.

## Recommendation

Add a delimiter between symbol and tokenId in the hash calculation to prevent ambiguous concatenation. Replace the current implementation with:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}-{tokenId}");
}
```

Alternatively, use a more robust approach with separate hashing:
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    var symbolHash = HashHelper.ComputeFrom(symbol);
    var tokenIdHash = HashHelper.ComputeFrom(tokenId);
    return HashHelper.ConcatAndCompute(symbolHash, tokenIdHash);
}
```

This ensures that different (symbol, tokenId) pairs always produce different hashes, eliminating the collision vulnerability. Additionally, consider adding explicit validation to check both tokenHash uniqueness AND (symbol, tokenId) pair uniqueness.

## Proof of Concept

```csharp
[Fact]
public void TestNFTHashCollision_CrossProtocol_DoS()
{
    // Create Protocol A with 9-digit random number
    var protocolASymbol = "AR123456789"; // 2-char prefix + 9 digits
    CreateProtocol(protocolASymbol, isTokenIdReuse: false);
    
    // Protocol A mints tokenId 999
    // This creates hash of "AR123456789999"
    MintNFT(protocolASymbol, tokenId: 999);
    
    // Create Protocol B with 10-digit random number (as ecosystem grows)
    var protocolBSymbol = "AR1234567899"; // 2-char prefix + 10 digits
    CreateProtocol(protocolBSymbol, isTokenIdReuse: false);
    
    // Protocol B attempts to mint tokenId 99
    // This tries to create hash of "AR123456789999" - SAME HASH!
    // Expected: DoS - mint fails with misleading error
    var exception = Assert.Throws<AssertionException>(() => 
        MintNFT(protocolBSymbol, tokenId: 99)
    );
    
    // Verify DoS: Protocol B is permanently blocked from this tokenId
    Assert.Contains("Token id 99 already exists", exception.Message);
    
    // Demonstrate the collision
    var hashA = CalculateTokenHash("AR123456789", 999);
    var hashB = CalculateTokenHash("AR1234567899", 99);
    Assert.Equal(hashA, hashB); // COLLISION CONFIRMED
}
```

**Notes:**
This vulnerability is a structural design flaw in the tokenHash calculation mechanism. The ambiguous string concatenation creates a mathematical certainty of collisions as the NFT ecosystem scales. The issue affects both DoS scenarios (when IsTokenIdReuse=false) and state corruption scenarios (when IsTokenIdReuse=true), with increasing likelihood as more protocols are created with longer symbol lengths.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L23-23)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L59-59)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L84-84)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L297-297)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L392-393)
```csharp
        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-30)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L34-35)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var balance = State.BalanceMap[tokenHash][input.Owner];
```
