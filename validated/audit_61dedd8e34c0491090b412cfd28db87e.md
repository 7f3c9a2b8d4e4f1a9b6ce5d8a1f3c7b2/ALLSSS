# Audit Report

## Title
Missing Validation Allows Consensus DoS via Zero FinalOrderOfNextRound Values

## Summary
The AEDPoS consensus contract's `ProcessUpdateValue` method accepts miner-provided `UpdateValueInput` containing `SupposedOrderOfNextRound` and `TuneOrderInformation` values without validating they fall within the valid range [1, minersCount]. This allows malicious miners to set `FinalOrderOfNextRound` to 0, corrupting consensus state and causing an unrecoverable denial-of-service that blocks all future round progressions.

## Finding Description

The vulnerability exists in the consensus data processing flow where miner-submitted order values are trusted without validation.

**Root Cause - Missing Input Validation:**

The `UpdateValue` RPC method is publicly accessible to all miners during normal block production. [1](#0-0) 

In `ProcessUpdateValue`, the `SupposedOrderOfNextRound` from `UpdateValueInput` is directly assigned to both `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` fields without any range validation. [2](#0-1) 

Additionally, `TuneOrderInformation` allows setting arbitrary `FinalOrderOfNextRound` values for any miner in the dictionary without bounds checking. [3](#0-2) 

**Inadequate Validation Provider:**

The `UpdateValueValidationProvider` only validates cryptographic fields (OutValue, Signature) and PreviousInValue correctness, but does NOT check mining order values. [4](#0-3) 

**Late Detection Creates DoS:**

The issue is only detected when `NextRoundMiningOrderValidationProvider` executes during round transition attempts. [5](#0-4) 

This validator checks that miners with `FinalOrderOfNextRound > 0` equals miners with `OutValue != null`. If a miner has `FinalOrderOfNextRound = 0` but has mined (OutValue present), the counts mismatch and validation fails, blocking the round transition.

**Expected Behavior Bypassed:**

By design, `ApplyNormalConsensusData` calculates proper values in range [1, minersCount] using the signature hash. [6](#0-5) 

The `GetAbsModulus` helper ensures the calculation produces values in valid range by returning `Math.Abs((int)longValue % intValue)`, which when incremented produces [1, minersCount]. [7](#0-6) 

However, miners control the `UpdateValueInput` message structure and can bypass this calculation by submitting arbitrary values directly. [8](#0-7) 

**Attack Execution Flow:**
1. Malicious miner modifies their node software to generate `UpdateValueInput` with `SupposedOrderOfNextRound = 0`
2. Submits via public `UpdateValue` method during their mining slot
3. Contract accepts and commits the invalid value to state without validation
4. When any miner attempts `NextRound`, validation fails due to count mismatch
5. Round transition permanently blocked - no new rounds can begin
6. Blockchain consensus halted until governance intervention

## Impact Explanation

**Severity: High (Consensus DoS)**

This vulnerability enables complete denial-of-service of the blockchain's consensus mechanism:

- **Direct Impact**: Chain cannot transition to next round, halting all block production
- **Scope**: Affects all network participants - no transactions can be processed
- **Recovery**: No built-in contract method to reset corrupted `FinalOrderOfNextRound` values; requires governance intervention or chain restart
- **Persistence**: State corruption persists until manually corrected

**Attack Efficiency:**
- Single malicious miner can cause DoS by corrupting their own `FinalOrderOfNextRound`
- Alternatively, a miner could use `TuneOrderInformation` to corrupt other miners' values
- Attack cost is minimal - just requires modified node software

**Parties Affected:**
- All users cannot submit transactions
- DApps experience complete service outage
- Economic activity on chain stops entirely
- Validator rewards cannot be distributed

## Likelihood Explanation

**Likelihood: Medium-High**

**Feasibility Factors:**

*Technical Complexity:* Low
- Miners run their own node software on their infrastructure
- Modifying `UpdateValueInput` generation is straightforward code change
- No complex cryptographic or multi-step exploitation required

*Entry Point:* Public and Accessible
- `UpdateValue` is the standard public method miners call when producing blocks
- Called during normal consensus operation, no special permissions needed beyond being a miner

*Economic Considerations:*
- Miners typically have economic incentive to maintain chain operation
- However, malicious actors, competing chains, or extortionists could exploit
- Attack provides leverage for ransom/extortion scenarios
- Griefing competitors in multi-chain ecosystems

**Detection:** Attack is undetectable until NextRound is attempted, by which time state is already corrupted.

## Recommendation

Add input validation to `ProcessUpdateValue` to ensure order values are within valid range:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate SupposedOrderOfNextRound is within valid range
    Assert(updateValueInput.SupposedOrderOfNextRound >= 1 && 
           updateValueInput.SupposedOrderOfNextRound <= minersCount,
           "Invalid SupposedOrderOfNextRound value.");
    
    // Validate all TuneOrderInformation values
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
               "Invalid FinalOrderOfNextRound value in TuneOrderInformation.");
    }
    
    // Continue with existing logic...
}
```

Additionally, consider adding validation in `UpdateValueValidationProvider` to catch invalid order values before state modification.

## Proof of Concept

```csharp
[Fact]
public async Task ConsensusDoS_ZeroOrderValue_Test()
{
    // Setup: Initialize consensus with first round
    await InitializeCandidates(EconomicContractsTestConstants.InitialCoreDataCenterCount);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Miner produces a block with malicious UpdateValueInput
    var maliciousMiner = firstRound.RealTimeMinersInformation.Values.First();
    var currentKeyPair = InitialCoreDataCenterKeyPairs.First(p => p.PublicKey.ToHex() == maliciousMiner.Pubkey);
    KeyPairProvider.SetKeyPair(currentKeyPair);
    BlockTimeProvider.SetBlockTime(maliciousMiner.ExpectedMiningTime);
    
    var tester = GetAEDPoSContractStub(currentKeyPair);
    var randomNumber = await GenerateRandomProofAsync(currentKeyPair);
    
    // Create malicious UpdateValueInput with SupposedOrderOfNextRound = 0
    var maliciousInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = HashHelper.ComputeFrom("signature"),
        RoundId = firstRound.RoundId,
        PreviousInValue = Hash.Empty,
        ActualMiningTime = BlockTimeProvider.GetBlockTime(),
        SupposedOrderOfNextRound = 0, // MALICIOUS: Zero value
        ImpliedIrreversibleBlockHeight = 1,
        RandomNumber = ByteString.CopyFrom(randomNumber)
    };
    
    // Attack: Submit malicious update - this should pass without validation
    var result = await tester.UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify state corruption
    var corruptedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    corruptedRound.RealTimeMinersInformation[maliciousMiner.Pubkey].FinalOrderOfNextRound.ShouldBe(0);
    
    // Attempt NextRound - should fail due to validation error
    BlockTimeProvider.SetBlockTime(maliciousMiner.ExpectedMiningTime.AddSeconds(100));
    var nextRoundInfo = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
        new AElfConsensusTriggerInformation
        {
            Behaviour = AElfConsensusBehaviour.NextRound,
            Pubkey = ByteString.CopyFrom(currentKeyPair.PublicKey)
        }.ToBytesValue());
    
    var nextRoundInput = NextRoundInput.Parser.ParseFrom(nextRoundInfo.ToConsensusHeaderInformation().Round.ToByteArray());
    nextRoundInput.RandomNumber = ByteString.CopyFrom(await GenerateRandomProofAsync(currentKeyPair));
    
    // DoS confirmed: NextRound permanently blocked
    var nextRoundResult = await tester.NextRound.SendAsync(nextRoundInput);
    nextRoundResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    nextRoundResult.TransactionResult.Error.ShouldContain("Invalid FinalOrderOfNextRound");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```
