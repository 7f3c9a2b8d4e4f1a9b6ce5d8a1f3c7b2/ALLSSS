# Audit Report

## Title
Unbounded Proposal Spam Attack on Organizations with Disabled Proposer Authority

## Summary
The Parliament contract contains a critical authorization flaw that allows any address to create unlimited proposals for organizations configured with `ProposerAuthorityRequired = false`. Two system-critical organizations (Emergency Response Organization and Side Chain Lifetime Controller) are initialized with this vulnerable configuration, enabling state bloat attacks and governance disruption without effective rate limiting or mandatory transaction fees.

## Finding Description

The vulnerability originates in the proposal authorization logic. The `AssertIsAuthorizedProposer` function uses an OR condition that short-circuits when `ProposerAuthorityRequired` is false, bypassing all other authorization checks: [1](#0-0) 

When `!organization.ProposerAuthorityRequired` evaluates to true (i.e., the flag is false), the entire assertion passes regardless of whitelist status or parliament membership, allowing **any address** to create proposals.

The `CreateProposal` method relies solely on this flawed authorization check: [2](#0-1) 

Two critical system organizations are created with this vulnerable configuration during initialization:

**Emergency Response Organization** - explicitly created with `ProposerAuthorityRequired = false`: [3](#0-2) 

**Cross-Chain Side Chain Lifetime Controller** - also created with `ProposerAuthorityRequired = false`: [4](#0-3) 

**Why Existing Protections Fail:**

1. **No Rate Limiting**: The contract state contains no per-address or per-organization tracking mechanisms to limit proposal creation frequency: [5](#0-4) 

2. **Weak Duplicate Prevention**: While duplicate proposal IDs are rejected, the ID generation allows attackers to create unique proposals by varying input fields: [6](#0-5) 

Attackers can vary title, description, or token fields. Length limits are generous (10,710 characters total): [7](#0-6) 

3. **Transaction Fees Not Enforced**: The `GetMethodFee` implementation returns state that may be null if not configured by governance: [8](#0-7) 

4. **Reactive Cleanup Only**: Proposals can only be cleared after expiration, not preventing spam creation: [9](#0-8) 

## Impact Explanation

**State Bloat (HIGH)**: Each proposal is stored permanently in the `State.Proposals` map until manually cleared after expiration. An attacker can create thousands of proposals (limited only by gas costs and optional transaction fees), with each proposal consuming storage for metadata (up to 10,710 characters), addresses, timestamps, and vote lists. This causes unbounded state growth affecting all full nodes in the network, increasing storage costs and synchronization times.

**Query Performance Degradation (MEDIUM)**: Multiple view methods iterate over proposal IDs without pagination in O(n) complexity: [10](#0-9) 

As spam proposals accumulate, legitimate users, Parliament members, indexing services, and automated governance systems must process increasingly large datasets, degrading response times and operational efficiency.

**Governance Disruption (MEDIUM)**: Legitimate proposals become difficult to monitor and process when buried among spam proposals. This affects Parliament members' ability to efficiently review and vote on critical governance decisions, potentially delaying emergency responses or cross-chain operations. Indexing services and governance dashboards face increased operational costs to filter and display relevant proposals.

The combination of these impacts on critical governance infrastructure, unbounded scaling potential, and minimal attacker resource requirements justifies **HIGH severity**.

## Likelihood Explanation

**Attacker Requirements**: Any address with sufficient balance for transaction gas costs. No special permissions, whitelist membership, or parliament authority required.

**Attack Complexity**: LOW - The attack is straightforward:
1. Query `GetEmergencyResponseOrganizationAddress` to obtain the vulnerable organization address (publicly accessible)
2. Call `CreateProposal` repeatedly with varying inputs (e.g., different titles, descriptions, or tokens)
3. Each call creates a unique proposal ID and stores it permanently in state

**Economic Barriers**: Transaction fees are configurable by governance and may be:
- Unset initially (GetMethodFee returns null state)
- Set to zero
- Set to amounts economically insufficient to deter determined attackers

Even with reasonable fees (e.g., 0.01 ELF per proposal), creating 10,000 spam proposals would cost only ~100 ELF, which may be economically rational for attackers seeking governance disruption, protocol reputation damage, or competitive advantage.

**Feasibility**: The vulnerable organizations exist by default in system initialization code, making this attack vector immediately available on any AElf mainchain or sidechain running these contracts without additional setup required.

## Recommendation

Implement multi-layered spam prevention mechanisms:

1. **Add Rate Limiting**: Introduce per-address proposal creation limits within time windows, even for organizations with `ProposerAuthorityRequired = false`. Store timestamps and counters in contract state.

2. **Enforce Minimum Transaction Fees**: Set mandatory non-zero transaction fees for `CreateProposal` during contract initialization, ensuring economic costs for spam attacks.

3. **Implement Proposal Caps**: Add maximum active proposal limits per organization, requiring cleanup of expired proposals before creating new ones.

4. **Enhanced Authorization**: Consider requiring at least parliament membership (even when `ProposerAuthorityRequired = false`) or implementing a reputation system to distinguish legitimate participants.

5. **Automated Cleanup**: Implement automatic proposal expiration and cleanup mechanisms rather than relying on manual `ClearProposal` calls.

Example mitigation for rate limiting:
```csharp
// Add to ParliamentState.cs
public MappedState<Address, long> LastProposalTime { get; set; }
public MappedState<Address, int> ProposalCountInWindow { get; set; }

// Modify AssertIsAuthorizedProposer in Parliament_Helper.cs
private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
{
    var organization = State.Organizations[organizationAddress];
    Assert(organization != null, "No registered organization.");
    
    // Rate limiting check
    var lastTime = State.LastProposalTime[proposer];
    var currentTime = Context.CurrentBlockTime.Seconds;
    if (currentTime - lastTime < RateLimitWindow)
    {
        var count = State.ProposalCountInWindow[proposer];
        Assert(count < MaxProposalsPerWindow, "Rate limit exceeded.");
        State.ProposalCountInWindow[proposer] = count + 1;
    }
    else
    {
        State.ProposalCountInWindow[proposer] = 1;
        State.LastProposalTime[proposer] = currentTime;
    }
    
    // Existing authorization logic
    Assert(
        !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
        (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
        "Unauthorized to propose.");
}
```

## Proof of Concept

```csharp
[Fact]
public async Task UnboundedProposalSpamAttack()
{
    // Get Emergency Response Organization address (ProposerAuthorityRequired = false)
    var emergencyOrgAddress = await ParliamentContractStub.GetEmergencyResponseOrganizationAddress.CallAsync(new Empty());
    
    // Any address can spam proposals
    var attackerStub = GetParliamentContractTester(Accounts[10].KeyPair); // Random attacker
    
    // Create 100 spam proposals by varying title field
    for (int i = 0; i < 100; i++)
    {
        var proposalInput = new CreateProposalInput
        {
            OrganizationAddress = emergencyOrgAddress,
            ToAddress = TokenContractAddress,
            ContractMethodName = nameof(TokenContractStub.Transfer),
            Params = new TransferInput().ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            Title = $"Spam Proposal #{i}", // Varying title creates unique proposal IDs
            Description = "Spam proposal to bloat state"
        };
        
        // All proposals succeed - no authorization failure
        var result = await attackerStub.CreateProposal.SendAsync(proposalInput);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
    
    // Verify state bloat: all 100 spam proposals stored
    // Parliament members now must sift through spam to find legitimate proposals
    // State growth is unbounded as attacker can continue indefinitely
}
```

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L220-253)
```csharp
    private Hash GenerateProposalId(CreateProposalInput input)
    {
        return Context.GenerateId(Context.Self, input.Token ?? HashHelper.ComputeFrom(input));
    }

    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L286-347)
```csharp
    public override ProposalIdList GetNotVotedProposals(ProposalIdList input)
    {
        var result = new ProposalIdList();
        foreach (var proposalId in input.ProposalIds)
        {
            var proposal = State.Proposals[proposalId];
            if (proposal == null || !Validate(proposal) || CheckProposalAlreadyVotedBy(proposal, Context.Sender))
                continue;
            result.ProposalIds.Add(proposalId);
        }

        return result;
    }

    public override ProposalIdList GetNotVotedPendingProposals(ProposalIdList input)
    {
        var result = new ProposalIdList();
        var currentParliament = GetCurrentMinerList();
        foreach (var proposalId in input.ProposalIds)
        {
            var proposal = State.Proposals[proposalId];
            if (proposal == null || !Validate(proposal) || CheckProposalAlreadyVotedBy(proposal, Context.Sender))
                continue;
            var organization = State.Organizations[proposal.OrganizationAddress];
            if (organization == null || !IsProposalStillPending(proposal, organization, currentParliament))
                continue;
            result.ProposalIds.Add(proposalId);
        }

        return result;
    }

    public override ProposalIdList GetReleaseThresholdReachedProposals(ProposalIdList input)
    {
        var result = new ProposalIdList();
        foreach (var proposalId in input.ProposalIds)
        {
            var proposal = State.Proposals[proposalId];
            if (proposal == null || !Validate(proposal))
                continue;
            var organization = State.Organizations[proposal.OrganizationAddress];
            if (organization == null || !IsReleaseThresholdReached(proposal, organization))
                continue;
            result.ProposalIds.Add(proposalId);
        }

        return result;
    }
    
    public override ProposalIdList GetAvailableProposals(ProposalIdList input)
    {
        var result = new ProposalIdList();
        foreach (var proposalId in input.ProposalIds)
        {
            var proposal = State.Proposals[proposalId];
            if (proposal == null || !Validate(proposal))
                continue;
            result.ProposalIds.Add(proposalId);
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L601-611)
```csharp
        State.ParliamentContract.CreateOrganizationBySystemContract.Send(
            new CreateOrganizationBySystemContractInput
            {
                OrganizationCreationInput = new Parliament.CreateOrganizationInput
                {
                    ProposalReleaseThreshold = proposalReleaseThreshold,
                    ProposerAuthorityRequired = false,
                    ParliamentMemberProposingAllowed = true
                },
                OrganizationAddressFeedbackMethod = nameof(SetInitialSideChainLifetimeControllerAddress)
            });
```

**File:** contract/AElf.Contracts.Parliament/ParliamentState.cs (L11-29)
```csharp
public class ParliamentState : ContractState
{
    public MappedState<Address, Organization> Organizations { get; set; }

    public BoolState Initialized { get; set; }

    public SingletonState<Address> DefaultOrganizationAddress { get; set; }

    internal AEDPoSContractContainer.AEDPoSContractReferenceState ConsensusContract { get; set; }
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }
    internal ElectionContractContainer.ElectionContractReferenceState ElectionContract { get; set; }
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
    public MappedState<string, MethodFees> TransactionFees { get; set; }

    public SingletonState<ProposerWhiteList> ProposerWhiteList { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }

    public SingletonState<Address> EmergencyResponseOrganizationAddress { get; set; }
}
```

**File:** contract/AElf.Contracts.Parliament/ParliamentConstants.cs (L3-8)
```csharp
public static class ParliamentConstants
{
    public const int MaxLengthForTitle = 255;
    public const int MaxLengthForDescription = 10200;
    public const int MaxLengthForProposalDescriptionUrl = 255;
}
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L34-44)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(ApproveMultiProposals))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };

        return State.TransactionFees[input.Value];
    }
```
