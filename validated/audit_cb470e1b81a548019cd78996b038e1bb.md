# Audit Report

## Title
Critical Consensus DoS via Integer Division Precision Loss in Mining Interval Validation

## Summary
The AEDPoS consensus contract contains a critical validation gap that allows any active miner to permanently brick the blockchain by injecting rounds with sub-8ms mining intervals. The `TinyBlockSlotInterval` calculation uses integer division that produces 0ms for intervals below 8ms, causing all mining execution timeouts to become 0ms. The validation in `CheckRoundTimeSlots()` only enforces `MiningInterval > 0` rather than `>= 8`, enabling this attack during any `NextRound` transition.

## Finding Description

The vulnerability originates in the `TinyBlockSlotInterval` property calculation: [1](#0-0) 

This divides `MiningInterval` by 8 using integer division. When `MiningInterval` is 1-7ms, the result is 0ms, which cascades to all mining limits: [2](#0-1) [3](#0-2) 

**Validation Failure**: The `CheckRoundTimeSlots()` method only validates mining interval is greater than 0: [4](#0-3) 

**Attack Path**:

1. A malicious miner calls the public `NextRound` method with a crafted `NextRoundInput`: [5](#0-4) 

2. The only permission check verifies the sender is in the miner list: [6](#0-5) 

3. Round validation uses `TimeSlotValidationProvider` which calls the insufficient `CheckRoundTimeSlots()`: [7](#0-6) 

4. The malicious round is stored without additional interval bounds validation: [8](#0-7) 

5. Future rounds inherit the broken interval via `GetMiningInterval()`: [9](#0-8) 

This calculates the interval from the stored `ExpectedMiningTime` values, perpetuating the 1-7ms interval across all subsequent rounds.

The 0ms mining limits are used in consensus command strategies: [10](#0-9) [11](#0-10) 

## Impact Explanation

**Complete Chain Denial of Service**: When mining limits reach 0ms, miners receive zero execution time for block production. The `LimitMillisecondsOfMiningBlock` field with value 0 is passed to the mining service, causing block execution to be cancelled immediately or timeout instantly.

**Concrete Damage**:
- All miners receive 0ms to execute transactions, causing immediate cancellation or timeout
- Blocks cannot contain user transactions, only minimal system operations
- Network throughput drops to zero - chain becomes completely unusable
- **Permanent damage**: No self-recovery mechanism exists; future rounds perpetually inherit the broken 1-7ms interval through `GetMiningInterval()`
- Requires emergency intervention: hard fork or chain restart from backup state
- All staked assets, locked tokens, and in-flight transactions become frozen

**Affected Parties**: All network participants - miners cannot produce valid blocks, users cannot submit transactions, dApps cease functioning, economic activity halts.

## Likelihood Explanation

**Attack Complexity: LOW**
- Requires only being an active miner (one of 17-21 elected block producers on mainchain)
- Can execute during any `NextRound` transition when it's the attacker's turn
- Simple execution: manually construct `NextRoundInput` with `ExpectedMiningTime` values 5ms apart instead of the default 4000ms interval
- No special cryptographic operations or complex state manipulation needed

**Feasibility: HIGH**
- Entry point is the public `NextRound` consensus method accessible to all miners
- Precondition is realistic: attacker only needs to be elected as a miner through normal election process
- No economic barriers - attack cost is minimal (single transaction gas fee)
- Attack succeeds immediately upon transaction execution without requiring multiple steps

**Detection Limitations**:
- Attack is detectable (sudden drop to zero user transactions per block)
- Attacker identity is known (transaction sender is recorded)
- However, damage occurs atomically - by the time it's detected, chain is already bricked
- Post-detection doesn't prevent or reverse the impact

**Probability: HIGH** - Any of the typically 17-21 mainchain miners can execute this attack at any time during their NextRound turn.

## Recommendation

Add a minimum mining interval validation in `CheckRoundTimeSlots()`:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    // FIX: Enforce minimum interval to prevent division-by-zero in TinyBlockSlotInterval
    const int MinimumMiningInterval = 8; // Must be >= TinyBlocksCount
    if (baseMiningInterval < MinimumMiningInterval)
        return new ValidationResult { Message = $"Mining interval must be at least {MinimumMiningInterval}ms.\n{this}" };

    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval =
            (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

Alternatively, add a constant in `AEDPoSContractConstants.cs`:
```csharp
public const int MinimumMiningInterval = 8;
```

And reference it in the validation.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_InjectsSubEightMsInterval_CausesZeroMiningLimits()
{
    // Setup: Initialize consensus with normal miners
    var miners = await InitializeConsensusWithMinersAsync();
    var maliciousMiner = miners.First();
    
    // Attacker crafts NextRoundInput with 5ms intervals
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RandomNumber = GenerateRandomNumber()
    };
    
    var currentTime = TimestampHelper.GetUtcNow();
    foreach (var miner in miners.Select((m, i) => new { Miner = m, Index = i }))
    {
        maliciousNextRound.RealTimeMinersInformation.Add(miner.Miner, new MinerInRound
        {
            Pubkey = miner.Miner,
            Order = miner.Index + 1,
            ExpectedMiningTime = currentTime.AddMilliseconds(5 * (miner.Index + 1)) // 5ms intervals!
        });
    }
    
    // Execute attack
    var result = await maliciousMiner.ExecuteConsensusContractMethodWithMiningAsync(
        nameof(ConsensusContract.NextRound),
        maliciousNextRound);
    
    result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify damage: Get mining interval and verify it's 5ms
    var newRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var miningInterval = newRound.GetMiningInterval();
    miningInterval.ShouldBe(5); // Malicious interval injected
    
    // Verify TinyBlockSlotInterval becomes 0
    var tinyBlockSlotInterval = miningInterval / 8; // Integer division
    tinyBlockSlotInterval.ShouldBe(0); // BUG: Division by 8 results in 0
    
    // Verify mining limits are all 0
    var defaultBlockMiningLimit = tinyBlockSlotInterval * 3 / 5;
    var lastTinyBlockMiningLimit = tinyBlockSlotInterval / 2;
    
    defaultBlockMiningLimit.ShouldBe(0); // CRITICAL: 0ms execution time
    lastTinyBlockMiningLimit.ShouldBe(0); // CRITICAL: 0ms execution time
    
    // Chain is now permanently bricked - all miners get 0ms to produce blocks
}
```

## Notes

This vulnerability breaks a critical consensus invariant: miners must have sufficient time to execute transactions. The standard 4000ms mining interval with 8 tiny blocks gives each tiny block 500ms, with mining limits of 300ms (default) or 250ms (last block). With a sub-8ms interval, these limits become 0ms, making block production impossible.

The attack is particularly severe because:
1. It's permanent - future rounds inherit the broken interval via `GetMiningInterval()`
2. It's atomic - damage occurs in a single transaction
3. It requires only miner privileges (obtainable through normal election)
4. No recovery mechanism exists in the contract

The fix is straightforward: enforce a minimum mining interval of 8ms (or higher, e.g., 1000ms for practical safety) in the `CheckRoundTimeSlots()` validation method.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-42)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L49-49)
```csharp
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L54-54)
```csharp
        protected int LastTinyBlockMiningLimit => TinyBlockSlotInterval.Div(2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L39-39)
```csharp
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L48-50)
```csharp
                    LimitMillisecondsOfMiningBlock = IsLastTinyBlockOfCurrentSlot()
                        ? LastTinyBlockMiningLimit
                        : DefaultBlockMiningLimit
```
