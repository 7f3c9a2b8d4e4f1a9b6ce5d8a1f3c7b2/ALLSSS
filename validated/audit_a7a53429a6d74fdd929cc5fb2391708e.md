# Audit Report

## Title
Uninitialized TokenHolderContract Reference Causes Side Chain Dividend Pool DoS

## Summary
The `InitialProfitSchemeForSideChain()` function silently returns when TokenHolder contract is not deployed, leaving `State.TokenHolderContract.Value` uninitialized. This causes all subsequent `Donate()` calls to fail with `NullReferenceException`, completely disabling the side chain dividend pool functionality.

## Finding Description

When a side chain initializes with `IsSideChain = true`, the consensus contract calls `InitialProfitSchemeForSideChain()` during initialization. [1](#0-0) 

If the TokenHolder contract is not deployed, `GetContractAddressByName` returns null, and the function logs a debug message and returns early without setting `State.TokenHolderContract.Value` or throwing an exception. [2](#0-1) 

The contract reference is only initialized when the address retrieval succeeds. [3](#0-2) 

The public `Donate()` method then uses the uninitialized `State.TokenHolderContract.Value` in two critical places without null checks: as the `Spender` parameter in an Approve call [4](#0-3)  and when calling `ContributeProfits.Send()`. [5](#0-4) 

The contract exhibits inconsistent null handling. While `Donate()` calls `EnsureTokenContractAddressSet()` for lazy initialization of the Token contract reference, [6](#0-5)  no equivalent `EnsureTokenHolderContractAddressSet()` method exists in the helper methods file. [7](#0-6) 

Additionally, the internal `Release()` method properly checks for null before using `State.TokenHolderContract.Value`, [8](#0-7)  demonstrating awareness of the potential null state, yet this protection is absent in `Donate()`.

The private `GetSideChainDividendPoolScheme()` method also lacks null checking before calling `State.TokenHolderContract.GetScheme.Call()`, [9](#0-8)  affecting view methods `GetSymbolList()` and `GetUndistributedDividends()`. [10](#0-9) 

## Impact Explanation

This vulnerability causes complete denial-of-service of the side chain dividend pool functionality. All `Donate()` calls will fail with a `NullReferenceException` when attempting to use the null contract reference. View methods `GetSymbolList()` and `GetUndistributedDividends()` will also fail for the same reason.

The severity is assessed as **MEDIUM** because:
- **No direct fund loss**: Transactions fail and revert before any token transfers are finalized
- **Complete functional DoS**: The entire dividend pool mechanism becomes unusable
- **Configuration-dependent**: Only affects side chains where TokenHolder contract was not deployed during initialization (an acknowledged scenario based on the code comment acknowledging this possibility)
- **Permanent until upgrade**: Cannot be fixed without contract upgrade or proper reinitialization

Affected parties include all side chains in this configuration state, users attempting to donate to the dividend pool, and applications querying dividend pool information.

## Likelihood Explanation

The likelihood is **MEDIUM** based on:

**Attacker Capabilities**: No special privileges required - the `Donate()` method is public and callable by any user.

**Attack Complexity**: Trivial - simply call `Donate()` with valid parameters. No complex transaction sequencing or special conditions required beyond the initial misconfiguration.

**Feasibility Conditions**: The side chain must have been initialized with `IsSideChain = true`, and the TokenHolder contract must not have been deployed or `GetContractAddressByName` returned null during initialization. The code explicitly acknowledges this as a possible scenario.

**Detection**: This would be immediately detected upon the first `Donate()` call attempt, making it more of a deployment/configuration issue than a runtime exploit. However, the likelihood depends entirely on side chain deployment practices - if operators properly deploy all required contracts, this issue won't manifest.

## Recommendation

Add proper null checking and lazy initialization for the TokenHolder contract reference:

1. **Create an `EnsureTokenHolderContractAddressSet()` helper method** similar to the existing pattern for Token, Election, and Parliament contracts.

2. **Call this method at the start of `Donate()`** before any usage of `State.TokenHolderContract.Value`.

3. **Add null checking in `GetSideChainDividendPoolScheme()`** to prevent view method failures.

4. **Consider throwing an explicit error** during initialization if TokenHolder is required but not deployed, rather than silently continuing.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Initialize a side chain consensus contract without deploying the TokenHolder contract
2. Verify that `InitialProfitSchemeForSideChain()` returns early and `State.TokenHolderContract.Value` remains null
3. Call the public `Donate()` method with valid parameters
4. Observe the transaction fails with `NullReferenceException` when trying to use `State.TokenHolderContract.Value`

The vulnerability is directly exploitable by any user calling the public `Donate()` method on a misconfigured side chain, resulting in complete DoS of the dividend pool functionality.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L35-35)
```csharp
        if (input.IsSideChain) InitialProfitSchemeForSideChain(input.PeriodSeconds);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L18-25)
```csharp
        var tokenHolderContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName);
        // No need to continue if Token Holder Contract didn't deployed.
        if (tokenHolderContractAddress == null)
        {
            Context.LogDebug(() => "Token Holder Contract not found, so won't initial side chain dividends pool.");
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L27-27)
```csharp
        State.TokenHolderContract.Value = tokenHolderContractAddress;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L39-39)
```csharp
        EnsureTokenContractAddressSet();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L52-57)
```csharp
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            Spender = State.TokenHolderContract.Value
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L59-64)
```csharp
        State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
        {
            SchemeManager = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L104-104)
```csharp
        if (State.TokenHolderContract.Value == null) return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L136-161)
```csharp
    public override SymbolList GetSymbolList(Empty input)
    {
        return new SymbolList
        {
            Value =
            {
                GetSideChainDividendPoolScheme().ReceivedTokenSymbols
            }
        };
    }

    public override Dividends GetUndistributedDividends(Empty input)
    {
        var scheme = GetSideChainDividendPoolScheme();
        return new Dividends
        {
            Value =
            {
                scheme.ReceivedTokenSymbols.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
            }
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L165-169)
```csharp
        if (State.SideChainDividendPoolSchemeId.Value == null)
        {
            var tokenHolderScheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
            State.SideChainDividendPoolSchemeId.Value = tokenHolderScheme.SchemeId;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L140-159)
```csharp
    private void EnsureTokenContractAddressSet()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    }

    private void EnsureElectionContractAddressSet()
    {
        if (State.ElectionContract.Value == null)
            State.ElectionContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
    }

    private void EnsureParliamentContractAddressSet()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    }
```
