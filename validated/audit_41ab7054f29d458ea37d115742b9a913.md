# Audit Report

## Title
Specific Delegation Permanently Shadows General Delegation After Delegatee Removal

## Summary
The transaction fee delegation system fails to properly fall back from specific delegation to general delegation when all delegatees are removed. An empty `TransactionFeeDelegatees` object (not null) is stored in state after removal, preventing the null coalescing operator from triggering the fallback to general delegation. This causes permanent DoS of transaction fee delegation for specific contract methods even when valid general delegations exist.

## Finding Description

The vulnerability exists in the delegation state management and fallback logic within the MultiToken contract's transaction fee delegation system.

**Root Cause - Unconditional Storage of Empty Objects:**

In `SetTransactionFeeDelegateInfos`, when a delegatee is removed due to empty delegations, the code removes the delegatee from the `Delegatees` dictionary but then unconditionally stores the parent `existDelegateeInfoList` object back to state. If this was the last delegatee, an empty `TransactionFeeDelegatees` object with an empty `Delegatees` dictionary is persisted. [1](#0-0) 

The same issue occurs in the removal helper method where the empty `delegateeInfo` is stored back to state after removing the last delegatee. [2](#0-1) 

**Broken Fallback Logic:**

The fee charging logic uses the null coalescing operator to fall back from specific to general delegation. [3](#0-2) 

The critical flaw: When `TransactionFeeDelegateInfoMap` returns an empty `TransactionFeeDelegatees` object, the `??` operator only checks for null, so it returns the empty object instead of falling back to the general delegation map. The subsequent foreach loop finds no entries and returns false without ever consulting the general delegation.

The same broken pattern exists in the delegation charging method. [4](#0-3) 

**Execution Flow:**

1. User establishes general delegation via `SetTransactionFeeDelegations`
2. User creates specific delegation for a contract method via `SetTransactionFeeDelegateInfos`
3. User removes all delegatees from specific delegation
4. Empty `TransactionFeeDelegatees` object stored in `TransactionFeeDelegateInfoMap[delegator][contract][method]`
5. Future transactions fail to charge from delegation because:
   - Specific delegation returns empty object (not null)
   - `?.Delegatees` returns empty dictionary (not null)
   - `??` operator doesn't trigger fallback
   - General delegation never consulted
   - Transaction fee charging fails

## Impact Explanation

**Severity: Medium/High - Permanent DoS of Transaction Fee Delegation**

This vulnerability creates a permanent denial-of-service condition for the transaction fee delegation feature:

1. **Transaction Failure:** Users who rely on delegation to pay transaction fees will be unable to execute transactions for specific contract methods, even when they have valid general delegations with sufficient funds.

2. **Permanent State Corruption:** Once an empty `TransactionFeeDelegatees` object is stored for a specific contract/method combination, that path is permanently "poisoned." The empty object persists in state and blocks all future fallback attempts to general delegation.

3. **No Recovery Path:** Users cannot recover from this state without a contract upgrade. Simply setting up new general or specific delegations won't fix the issue because the empty object will continue to shadow the general delegation.

4. **Protocol Reliability Impact:** This breaks the expected delegation hierarchy where specific delegations should only override general delegations when they contain valid delegatees. Empty specific delegations should allow fallback to general delegation.

While this doesn't directly lead to fund theft, it creates a permanent availability issue for critical protocol functionality (transaction fee payment).

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability can be triggered through normal, legitimate delegation management operations without any malicious intent:

**Accessible Entry Points:**
- `SetTransactionFeeDelegateInfos` - Public method for creating/updating specific delegations
- `RemoveTransactionFeeDelegateeInfos` - Public method for removing specific delegations
- `RemoveTransactionFeeDelegatorInfos` - Public method for delegatees to remove themselves

**Realistic Scenarios:**
1. A user tests specific delegations for a new dApp and later removes them, expecting fallback to general delegation
2. A delegatee becomes unavailable and the user removes them, intending to rely on general delegation temporarily
3. Users clean up old specific delegations thinking they're optimizing their delegation setup
4. Multiple delegatees are removed one by one until none remain

**No Special Requirements:**
- No privileged access required
- No attack cost
- No complex preconditions
- Purely a consequence of normal state management

Users naturally create and remove delegations as they test different configurations, manage delegatee relationships, respond to delegatee availability changes, and clean up unused delegations.

## Recommendation

The issue can be fixed in multiple ways:

**Option 1: Delete empty objects instead of storing them**
In both `SetTransactionFeeDelegateInfos` and `RemoveTransactionFeeDelegateInfo`, check if the `Delegatees` dictionary is empty after removal, and if so, delete the map entry instead of storing it:

```csharp
if (existDelegateeInfoList.Delegatees.Count == 0)
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        [delegateInfo.MethodName] = null;
}
else
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        [delegateInfo.MethodName] = existDelegateeInfoList;
}
```

**Option 2: Check for empty dictionaries in fallback logic**
Modify the null coalescing pattern to also check for empty dictionaries:

```csharp
var delegationInfo = 
    State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees;
if (delegationInfo == null || delegationInfo.Count == 0)
{
    delegationInfo = State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;
}
```

Option 1 is recommended as it prevents storing unnecessary empty objects in state and is cleaner.

## Proof of Concept

```csharp
[Fact]
public async Task DelegationFallback_FailsAfterRemovingAllSpecificDelegatees_Test()
{
    await Initialize();
    
    // Step 1: Set up general delegation
    var generalDelegations = new Dictionary<string, long>
    {
        [NativeToken] = 1000
    };
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput
        {
            DelegatorAddress = User1Address,
            Delegations = { generalDelegations }
        });
    
    // Step 2: Set up specific delegation for a contract method
    var specificDelegations = new Dictionary<string, long>
    {
        [NativeToken] = 500
    };
    var delegateInfo = new DelegateInfo
    {
        ContractAddress = BasicFunctionContractAddress,
        MethodName = "TestMethod",
        Delegations = { specificDelegations },
        IsUnlimitedDelegate = false
    };
    await TokenContractStub.SetTransactionFeeDelegateInfos.SendAsync(
        new SetTransactionFeeDelegateInfosInput
        {
            DelegatorAddress = User1Address,
            DelegateInfoList = { delegateInfo }
        });
    
    // Step 3: Remove all delegatees from specific delegation
    await TokenContractStubUser.RemoveTransactionFeeDelegateeInfos.SendAsync(
        new RemoveTransactionFeeDelegateeInfosInput
        {
            DelegateeAddress = DefaultAddress,
            DelegateTransactionList = {
                new DelegateTransaction
                {
                    ContractAddress = BasicFunctionContractAddress,
                    MethodName = "TestMethod"
                }
            }
        });
    
    // Step 4: Try to charge transaction fee - should fall back to general delegation but fails
    var chargeResult = await TokenContractStub.ChargeTransactionFees.SendAsync(
        new ChargeTransactionFeesInput
        {
            ContractAddress = BasicFunctionContractAddress,
            MethodName = "TestMethod",
            TransactionSizeFee = 100
        });
    
    // Vulnerability: This should succeed using general delegation, but fails
    // because empty specific delegation object blocks the fallback
    chargeResult.Output.Success.ShouldBe(false); // This demonstrates the bug
    // Expected: chargeResult.Output.Success.ShouldBe(true);
}
```

## Notes

This vulnerability affects the delegation hierarchy design where specific delegations are meant to override general delegations only when they contain valid delegatees. The root cause is storing empty objects in state instead of null, combined with null coalescing operators that cannot distinguish between null and empty collections. This is a protocol design flaw that requires a contract upgrade to fix properly.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L233-245)
```csharp
            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }

            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                [delegateInfo.MethodName] = existDelegateeInfoList;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L379-386)
```csharp
            var delegateeInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                    delegateTransaction.MethodName];
            if (delegateeInfo == null || !delegateeInfo.Delegatees.ContainsKey(delegateeAddress)) continue;
            delegateeInfo.Delegatees.Remove(delegateeAddress);
            toCancelTransactionList.Value.Add(delegateTransaction);
            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                delegateTransaction.MethodName] = delegateeInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L100-115)
```csharp
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L174-176)
```csharp
        var delegationInfo =
            State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees ?? 
            State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;
```
