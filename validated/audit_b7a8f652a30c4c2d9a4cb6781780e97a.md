# Audit Report

## Title
Sponsor Can Manipulate Voting Timing Through Unrestricted Snapshot Control

## Summary
The `TakeSnapshot()` function in the Vote contract allows sponsors to take snapshots at arbitrary times without enforcing the declared `StartTimestamp` and `EndTimestamp` parameters. This enables sponsors to close all voting snapshots immediately after registration, effectively denying voters their expected voting period and undermining governance fairness for any direct usage of the Vote contract.

## Finding Description

The Vote contract's `TakeSnapshot()` function performs only three validations: sponsor authorization, snapshot count limits, and snapshot sequencing. [1](#0-0) 

Critically absent are any time-based validations. The function never checks whether `Context.CurrentBlockTime` falls within the declared `[StartTimestamp, EndTimestamp]` period, nor does it enforce any minimum duration between snapshots.

During registration, the contract validates and stores these timestamps, explicitly checking that `EndTimestamp > StartTimestamp`. [2](#0-1)  The proto documentation describes these fields as "The start time of the voting" and "The end time of the voting". [3](#0-2) 

However, these timestamps are never enforced during operations. The `AssertValidVoteInput` function validates snapshot numbers but includes no time constraints. [4](#0-3) 

**Attack Scenario:**
1. Sponsor registers a voting item with `StartTimestamp=now`, `EndTimestamp=now+30days`, `TotalSnapshotNumber=10`
2. Registration succeeds with `CurrentSnapshotNumber=1`
3. Sponsor immediately calls `TakeSnapshot(1)` through `TakeSnapshot(9)` in rapid succession
4. After 9 calls, `CurrentSnapshotNumber=10`, and voting is "ended"
5. Any subsequent vote attempt fails with "Current voting item already ended"
6. All snapshots closed within seconds/minutes instead of the declared 30-day period

Test evidence confirms this behavior is possible. [5](#0-4) 

The Election contract (primary consumer) mitigates this by controlling TakeSnapshot timing through consensus mechanisms and setting timestamps to extreme values (MIN/MAX). [6](#0-5)  However, the Vote contract is public infrastructure, and any direct usage remains vulnerable to timing manipulation.

## Impact Explanation

**Severity: MEDIUM** - Governance manipulation without direct fund loss.

This vulnerability enables several governance attacks:

1. **Immediate Closure**: Sponsors can register seemingly fair voting periods then immediately close all snapshots, creating dead voting items that deny all participation rights

2. **Strategic Manipulation**: Sponsors can monitor voting results in real-time and close snapshots at opportune moments to achieve desired outcomes

3. **Expectation Violation**: The documented timestamps create legitimate expectations. Voters planning participation based on these parameters are denied their rights when sponsors arbitrarily manipulate timing

While this doesn't cause direct fund loss or supply inflation, governance manipulation is a recognized security issue in blockchain systems. The Vote contract establishes documented expectations through proto definitions and registration validations, then fails to enforce them.

The primary use case (Election contract) implements its own protections, but the Vote contract remains public infrastructure. Any third-party contracts, DAOs, or governance systems using it directly face this vulnerability.

## Likelihood Explanation

**Likelihood: HIGH** - Trivially executable with strong incentives.

**Attacker Profile:**
- Requires only legitimate sponsor role (anyone can register voting items)
- No special privileges beyond standard sponsor rights
- Direct access to public `TakeSnapshot()` method

**Attack Complexity:** 
Extremely low - a simple loop calling `TakeSnapshot()` with sequential snapshot numbers. No complex preconditions, race conditions, or cryptographic challenges required.

**Economic Motivation:**
- Cost: Only standard gas fees
- Benefit: Complete control over voting timeline and outcome manipulation
- Strong incentive for any sponsor with conflicts of interest in voting results

Any sponsor with vested interest in voting outcomes possesses both means and motive to exploit this vulnerability.

## Recommendation

Add temporal validation to `TakeSnapshot()` to enforce declared time constraints:

```csharp
public override Empty TakeSnapshot(TakeSnapshotInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");
    
    // NEW: Enforce time constraints
    Assert(Context.CurrentBlockTime >= votingItem.StartTimestamp, 
        "Cannot take snapshot before voting start time.");
    Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, 
        "Cannot take snapshot after voting end time.");
    
    // NEW: Enforce minimum time between snapshots
    if (votingItem.TotalSnapshotNumber > 1)
    {
        var minimumSnapshotDuration = votingItem.EndTimestamp
            .Seconds.Sub(votingItem.StartTimestamp.Seconds)
            .Div(votingItem.TotalSnapshotNumber);
        var expectedSnapshotTime = votingItem.CurrentSnapshotStartTimestamp
            .AddSeconds(minimumSnapshotDuration);
        Assert(Context.CurrentBlockTime >= expectedSnapshotTime,
            "Minimum snapshot duration not elapsed.");
    }
    
    Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    
    // ... rest of function
}
```

Alternatively, if timestamps are meant to be informational only, update proto documentation to clarify this and remove the `EndTimestamp > StartTimestamp` validation that implies enforcement.

## Proof of Concept

```csharp
[Fact]
public async Task VoteContract_SnapshotTiming_Manipulation_Test()
{
    // Register voting item with 100-day duration and 10 snapshots
    var votingItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 10);
    
    // Verify declared 100-day period
    (votingItem.EndTimestamp.ToDateTime() - votingItem.StartTimestamp.ToDateTime())
        .TotalDays.ShouldBe(100);
    votingItem.TotalSnapshotNumber.ShouldBe(10);
    
    // Attacker immediately takes all snapshots in rapid succession
    for (long i = 1; i < 10; i++)
    {
        var result = await TakeSnapshot(votingItem.VotingItemId, i);
        result.Status.ShouldBe(TransactionResultStatus.Mined); // All succeed
    }
    
    // Voting is now "ended" within seconds, not 100 days
    var voter = Accounts[11].KeyPair;
    var voteResult = await VoteWithException(voter, votingItem.VotingItemId, 
        votingItem.Options[0], 100);
    
    voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult.Error.Contains("Current voting item already ended").ShouldBeTrue();
    
    // Time elapsed is minimal, not the declared 100 days
    var actualTimeElapsed = TimestampHelper.GetUtcNow() - votingItem.StartTimestamp;
    actualTimeElapsed.Seconds.ShouldBeLessThan(60); // Less than 1 minute
}
```

## Notes

This vulnerability is technically valid but has important context:

1. **Election Contract Protection**: The primary production use case (Election contract) is protected because it controls snapshot timing through consensus mechanisms and sets timestamps to extreme values (MIN/MAX infinity)

2. **Public Infrastructure**: The Vote contract is public infrastructure that documents specific behavior (time-bound voting) but fails to enforce it, creating false expectations

3. **Design Question**: The lack of enforcement despite validation suggests this may be a design oversight rather than intentional flexibility. The timestamps serve no purpose if not enforced - why validate `EndTimestamp > StartTimestamp` during registration if these values are never checked?

4. **Impact Scope**: While the main Election usage is protected, any third-party contracts, DAOs, or direct Vote contract usage remains vulnerable to timing manipulation

The severity is MEDIUM because governance manipulation is a real security concern, even without direct fund loss. The likelihood is HIGH because execution is trivial for any sponsor.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** protobuf/vote_contract.proto (L88-91)
```text
    // The start time of the voting.
    google.protobuf.Timestamp start_timestamp = 1;
    // The end time of the voting.
    google.protobuf.Timestamp end_timestamp = 2;
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L92-102)
```csharp
        //voting item have been out of date
        {
            var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
            await TakeSnapshot(registerItem.VotingItemId, 1);

            var voter = Accounts[11].KeyPair;
            var voteResult =
                await VoteWithException(voter, registerItem.VotingItemId, registerItem.Options[0], 100);
            voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
            voteResult.Error.Contains("Current voting item already ended").ShouldBeTrue();
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L60-76)
```csharp
        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
        State.VoteContract.Register.Send(votingRegisterInput);

        State.MinerElectionVotingItemId.Value = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(votingRegisterInput),
            HashHelper.ComputeFrom(Context.Self));

        State.VotingEventRegistered.Value = true;
        return new Empty();
    }
```
