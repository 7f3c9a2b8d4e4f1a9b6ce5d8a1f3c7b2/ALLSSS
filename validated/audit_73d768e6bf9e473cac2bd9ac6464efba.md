# Audit Report

## Title
RemoveNFTType Breaks Cross-Chain Synchronization for Active NFT Protocols

## Summary
The `RemoveNFTType()` function fails to validate whether active NFT protocols depend on the NFT type being removed. When Parliament removes an NFT type while protocols with that type's short name prefix exist, subsequent `CrossChainCreate()` calls permanently fail, breaking cross-chain synchronization for all affected protocols.

## Finding Description

The vulnerability exists in the `RemoveNFTType()` function which only performs basic validation before removing NFT type mappings. [1](#0-0) 

The function validates Parliament authorization, checks the short name length (2 characters), and verifies the type exists in the mapping. However, it proceeds to remove entries from both `NFTTypeFullNameMap` and `NFTTypeShortNameMap` without checking if any protocols in `State.NftProtocolMap` use this NFT type.

NFT protocol symbols are generated by concatenating the 2-character short name with a random number. [2](#0-1) 

When protocols are created, they are stored with their full symbol as the key. [3](#0-2) 

The critical breakage occurs in `CrossChainCreate()`, which extracts the 2-character short name from the protocol symbol and looks it up in `NFTTypeFullNameMap`. [4](#0-3) 

Specifically, if the NFT type has been removed, the lookup returns null, causing an assertion failure that prevents cross-chain protocol synchronization.

**Root Cause:** No validation exists to check if protocols with symbols starting with the short name being removed exist in `State.NftProtocolMap`. Blockchain smart contract state mappings don't support efficient prefix-based iteration, making this check architecturally challenging but necessary for data integrity.

**Why Existing Protections Fail:**
- Parliament authorization only validates governance authority, not operational safety
- Existence check only validates the type is in the mapping, not whether it's actively referenced
- No cross-reference validation between NFT type mappings and protocol storage

## Impact Explanation

**Cross-Chain Integrity Violation:**
- All NFT protocols with the removed type's short name prefix become permanently unable to synchronize to side chains
- `CrossChainCreate()` will fail with assertion: "Full name of {shortName} not found"
- Breaks AElf's fundamental multi-chain architecture guarantee for NFT protocols

**Affected Parties:**
- Protocol creators who issued NFTs with the removed type on the main chain cannot expand to side chains
- Users attempting cross-chain NFT operations face permanent failures
- Side chains cannot receive legitimate NFT protocol synchronization from main chain

**Severity Justification: CRITICAL**
- Permanent operational DoS of cross-chain functionality - no automatic recovery
- Even re-adding the NFT type requires Parliament to manually identify all affected protocols
- Violates the invariant that successfully created protocols should be cross-chain syncable
- No built-in mechanism to detect this issue before governance action is taken

## Likelihood Explanation

**Governance Scenario:** This requires Parliament default organization authority, representing legitimate governance rather than a malicious attacker.

**Attack Complexity: LOW**
- Single transaction: `RemoveNFTType(shortName)`
- No complex preconditions or multi-step exploitation

**Realistic Feasibility:**
- Parliament may legitimately deprecate old NFT type categories as the protocol evolves
- May consolidate naming schemes or remove types that appear unused
- Without tooling to query protocol dependencies, removal appears safe
- Common operational governance pattern in mature protocols

**Probability Assessment: HIGH**
- No visibility provided to Parliament about protocol dependencies on specific NFT types
- Legitimate "cleanup" governance actions performed without awareness of downstream breakage
- Cross-chain synchronization failures may not be immediately detected since they occur during protocol expansion to new chains, not during normal main chain operations

## Recommendation

Add validation in `RemoveNFTType()` to prevent removal of NFT types that are actively referenced by existing protocols. While blockchain state mappings don't support efficient prefix-based iteration, the contract should maintain a reference count or dependency mapping:

1. **Add a reference counter:** Track how many protocols use each NFT type short name
2. **Increment on Create:** When `Create()` is called, increment the reference count for the used NFT type
3. **Check on RemoveNFTType:** Only allow removal if the reference count is zero
4. **Alternative approach:** Maintain a separate mapping of short names to protocol count, updated during protocol creation

Additionally, consider implementing a deprecation mechanism rather than immediate removal, allowing existing protocols to continue functioning while preventing new protocols from using deprecated types.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveNFTType_BreaksCrossChainCreate_Test()
{
    // Step 1: Create NFT protocol on mainchain with "Art" type (short name "AR")
    var createResult = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = "ipfs://test/",
        Creator = DefaultAddress,
        IsBurnable = true,
        NftType = NFTType.Art.ToString(), // This uses "AR" as short name
        ProtocolName = "TEST_PROTOCOL",
        TotalSupply = 1000000
    });
    var protocolSymbol = createResult.Output.Value;
    
    // Verify protocol was created and symbol starts with "AR"
    protocolSymbol.Substring(0, 2).ShouldBe("AR");
    
    // Step 2: Parliament removes the "AR" NFT type
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    var proposalId = await CreateProposalAsync(
        NFTContractAddress,
        defaultParliament,
        nameof(NFTContractStub.RemoveNFTType),
        new StringValue { Value = "AR" }
    );
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // Step 3: Attempt to CrossChainCreate the protocol on a sidechain
    // This simulates the token already being created via CrossChainCreateToken
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = protocolSymbol
        });
    });
    
    // Verify the failure is due to missing NFT type mapping
    exception.Message.ShouldContain("Full name of AR not found");
}
```

**Notes:**
- This vulnerability represents a gap in referential integrity validation between NFT type mappings and protocol storage
- The issue occurs specifically during cross-chain operations, making it less immediately visible than mainchain-only failures
- Parliament's legitimate governance authority does not include visibility into which protocols depend on specific NFT types
- The fix requires architectural changes to track protocol dependencies on NFT types

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L53-53)
```csharp
        State.NftProtocolMap[symbol] = protocolInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```
