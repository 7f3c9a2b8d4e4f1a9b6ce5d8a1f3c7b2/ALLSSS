# Audit Report

## Title
CachedDelayTotalShares Corruption via RemoveSubScheme in Delayed Distribution Schemes

## Summary
The `RemoveSubScheme` method fails to update `CachedDelayTotalShares` when removing a sub-scheme from a parent scheme with delayed distribution enabled, causing remaining beneficiaries to receive less than their entitled share of profits in future distribution periods.

## Finding Description

The Profit contract maintains a `CachedDelayTotalShares` map to track total shares for future distribution periods when delayed distribution is enabled (`DelayDistributePeriodCount > 0`). [1](#0-0) 

When distributing profits with delay enabled, the system caches current `TotalShares` for a future period and retrieves the cached value for the current period to use as the denominator in profit calculations: [2](#0-1) 

**Root Cause:** The `RemoveSubScheme` method updates `TotalShares` at line 152 but completely omits updating `CachedDelayTotalShares`: [3](#0-2) 

This creates an inconsistency because other methods correctly maintain cached shares:

1. `RemoveBeneficiary` correctly iterates through all cached periods and subtracts removed shares: [4](#0-3) 

2. `ClaimProfits` also correctly updates all cached periods when removing expired profit details: [5](#0-4) 

The Treasury contract actively uses `RemoveSubScheme` via its `ResetWeight` helper method: [6](#0-5) 

Furthermore, CitizenWelfare scheme is created with `DelayDistributePeriodCount = 1`: [7](#0-6) 

## Impact Explanation

When a sub-scheme with X shares is removed from a parent scheme with `DelayDistributePeriodCount = N`, the cached shares for the next N periods remain inflated by X shares. During profit distribution for those periods, the calculation uses the stale cached total as the denominator instead of the actual reduced value.

**Concrete Example:**
- Period 2: Parent has Sub-A (50 shares) + Sub-B (50 shares) = 100 total. Distribute 1000 tokens → caches TotalShares=100 for Period 5 (delay=3)
- Period 3: Manager calls `RemoveSubScheme` to remove Sub-A → `TotalShares` becomes 50 but `CachedDelayTotalShares[5]` stays at 100
- Period 5: Distribute 1000 tokens → uses cached 100 instead of actual 50 → Sub-B receives (50/100) × 1000 = 500 tokens instead of (50/50) × 1000 = 1000 tokens

The missing 500 tokens remain in the period's virtual address, effectively lost to the intended beneficiary. This violates the critical invariant of profit share calculation accuracy.

## Likelihood Explanation

`RemoveSubScheme` is a public method callable by the scheme manager with no additional authorization requirements beyond manager status. The Treasury contract's `ResetWeight` method demonstrates this is used in production for legitimate weight adjustments: [8](#0-7) 

**Feasible Preconditions:**
1. Scheme created with `DelayDistributePeriodCount > 0` (CitizenWelfare uses delay=1)
2. Sub-schemes added and profits distributed (normal operation)
3. Manager calls `RemoveSubScheme` for weight adjustments (legitimate operation)

This is triggered during normal operations when Treasury administrators adjust dividend pool or miner reward weight settings via `SetDividendPoolWeightSetting` or `SetMinerRewardWeightSetting`. No sophisticated attack is required - the bug manifests from legitimate administrative actions.

## Recommendation

Update `RemoveSubScheme` to maintain `CachedDelayTotalShares` consistency, similar to how `RemoveBeneficiary` handles it. After line 152, add:

```csharp
if (scheme.DelayDistributePeriodCount > 0)
{
    var currentPeriod = scheme.CurrentPeriod;
    for (var period = currentPeriod; period < currentPeriod.Add(scheme.DelayDistributePeriodCount); period++)
    {
        if (scheme.CachedDelayTotalShares.ContainsKey(period))
        {
            scheme.CachedDelayTotalShares[period] = scheme.CachedDelayTotalShares[period].Sub(shares.Shares);
        }
    }
}
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task RemoveSubScheme_ShouldUpdateCachedDelayTotalShares()
{
    // Create parent scheme with delay=3
    var parentSchemeId = await CreateSchemeWithDelay(delayPeriodCount: 3);
    
    // Add two sub-schemes with 50 shares each
    var subSchemeA = await CreateScheme();
    var subSchemeB = await CreateScheme();
    await AddSubScheme(parentSchemeId, subSchemeA, shares: 50);
    await AddSubScheme(parentSchemeId, subSchemeB, shares: 50);
    // TotalShares = 100
    
    // Period 2: Distribute profits (caches TotalShares=100 for period 5)
    await DistributeProfits(parentSchemeId, period: 2, amount: 1000);
    
    // Period 3: Remove subSchemeA
    await RemoveSubScheme(parentSchemeId, subSchemeA);
    // TotalShares now = 50, but CachedDelayTotalShares[5] still = 100
    
    // Period 5: Distribute profits
    await DistributeProfits(parentSchemeId, period: 5, amount: 1000);
    
    // SubSchemeB should receive 1000 (100% as only beneficiary)
    // But actually receives 500 (50% due to stale cached shares)
    var profitAmount = await GetSchemeProfit(subSchemeB);
    
    // This assertion will FAIL, proving the bug
    Assert.Equal(1000, profitAmount); // Expected: 1000, Actual: 500
}
```

### Citations

**File:** protobuf/profit_contract.proto (L156-157)
```text
    // Record the scheme's current total share for deferred distribution of benefits, period -> total shares.
    map<int64, int64> cached_delay_total_shares = 11;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L793-797)
```csharp
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L64-64)
```csharp
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L490-503)
```csharp
    private void ResetSubSchemeToTreasury(DividendPoolWeightSetting newWeightSetting)
    {
        var oldWeightSetting = State.DividendPoolWeightSetting.Value ?? new DividendPoolWeightSetting();
        var parentSchemeId = State.TreasuryHash.Value;
        // Register or reset `MinerReward` to `Treasury`
        ResetWeight(parentSchemeId, State.RewardHash.Value,
            oldWeightSetting.MinerRewardWeight, newWeightSetting.MinerRewardWeight);
        // Register or reset `BackupSubsidy` to `Treasury`
        ResetWeight(parentSchemeId, State.SubsidyHash.Value,
            oldWeightSetting.BackupSubsidyWeight, newWeightSetting.BackupSubsidyWeight);
        // Register or reset `CitizenWelfare` to `Treasury`
        ResetWeight(parentSchemeId, State.WelfareHash.Value,
            oldWeightSetting.CitizenWelfareWeight, newWeightSetting.CitizenWelfareWeight);
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L520-540)
```csharp
    private void ResetWeight(Hash parentSchemeId, Hash subSchemeId, int oldWeight,
        int newWeight)
    {
        if (oldWeight == newWeight)
            return;

        // old weight equals 0 indicates the subScheme has not been registered
        if (oldWeight > 0)
            State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
            {
                SchemeId = parentSchemeId,
                SubSchemeId = subSchemeId
            });

        State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
        {
            SchemeId = parentSchemeId,
            SubSchemeId = subSchemeId,
            SubSchemeShares = newWeight
        });
    }
```
