# Audit Report

## Title
Conflict Resolution Failure in ApplyNormalConsensusData Causes Duplicate Mining Orders and Consensus Breakdown

## Summary
The conflict resolution mechanism in `ApplyNormalConsensusData()` fails to guarantee unique `FinalOrderOfNextRound` values when all mining orders are occupied. This allows duplicate order assignments to persist through normal block production, breaking the fundamental consensus invariant and causing chain halt or permanent fork when the next round is generated.

## Finding Description

The vulnerability exists in the conflict resolution logic that handles `FinalOrderOfNextRound` collisions during consensus data updates. [1](#0-0) 

When a miner produces a block, their new `supposedOrderOfNextRound` is calculated from their signature hash. If this conflicts with another miner's existing `FinalOrderOfNextRound`, the conflict resolution loop attempts to find an available order for the conflicted miner. However, the loop checks if ANY miner currently holds each candidate order, including the conflicted miner's own current order and the current block producer's old order (which will be overwritten at line 44).

When all orders 1 through N are occupied, the loop exhausts all candidates without finding a free slot. The conflicted miner retains their original order, then the current miner is unconditionally assigned the same conflicting order, creating duplicates.

This vulnerability is compounded by multiple protection failures:

**1. TuneOrderInformation Propagation Failure:** [2](#0-1) 

The mechanism only broadcasts miners where `FinalOrderOfNextRound != SupposedOrderOfNextRound`. Since unresolved conflicts leave miners with matching values, other nodes never learn about the duplicate.

**2. Validation Bypass:** [3](#0-2) 

`NextRoundMiningOrderValidationProvider` only runs for `NextRound` behavior, not for `UpdateValue` behavior where duplicates are created.

**3. Ineffective Duplicate Detection:** [4](#0-3) 

The `.Distinct()` operates on `MinerInRound` objects (protobuf-generated with full field comparison), not on `FinalOrderOfNextRound` values, failing to detect duplicate orders. [5](#0-4) 

**4. State Persistence:** [6](#0-5) 

The duplicate values are persisted to on-chain state via `RecoverFromUpdateValue`, where they remain until next round generation.

**5. Signature Variance by Height:** [7](#0-6) 

When miners produce multiple blocks without a `PreviousInValue`, a fake value is generated using `pubkey + CurrentHeight`, ensuring each block produces different signatures and different supposed orders, making conflicts probabilistic but regular.

## Impact Explanation

When `GenerateNextRoundInformation` processes the current round with duplicate `FinalOrderOfNextRound` values: [8](#0-7) 

**Critical Failures:**

1. **Duplicate Mining Schedules:** Both miners receive `Order = FinalOrderOfNextRound` and identical `ExpectedMiningTime`, scheduling simultaneous block production that violates time-slot consensus rules.

2. **Order Slot Corruption:** The `occupiedOrders` list contains duplicate values, reducing `ableOrders` count. If miners who didn't mine need orders from the reduced pool, `ableOrders[i]` throws `IndexOutOfRangeException`, halting consensus.

3. **Non-deterministic Round Generation:** The `OrderBy(m => m.FinalOrderOfNextRound)` with duplicates relies on dictionary iteration order, which can vary across nodes after serialization/deserialization, causing different nodes to generate different next rounds and permanently forking the chain.

**Severity: HIGH** - Breaks the fundamental consensus invariant that each miner has a unique mining order and time slot. Results in chain halt or permanent fork, affecting all network participants.

## Likelihood Explanation

**Trigger Conditions:**
1. All N miners have produced at least one block (orders 1-N occupied)
2. A miner produces an additional block in the same round (common via tiny blocks)
3. Their new signature-derived order conflicts with existing miner
4. All other orders occupied, so conflict resolution fails

**Attack Complexity: LOW**
- Happens during normal block production (UpdateValue/TinyBlock behavior)
- No special permissions required beyond being a miner
- Signature calculation naturally varies per block height
- Tiny block production is standard protocol behavior

**Probability: MEDIUM-HIGH** - In active rounds where all miners participate, preconditions are frequently met. The hash-based order calculation makes conflicts probabilistic but regular as miners produce multiple blocks per round.

## Recommendation

Fix the conflict resolution loop to properly handle the case when all orders are occupied:

1. **Immediate Fix:** Before assigning `supposedOrderOfNextRound` to the current miner, verify it's not already occupied after conflict resolution. If still occupied, force reassign the conflicted miner to a wraparound order or handle the collision deterministically.

2. **Proper Validation:** Add `NextRoundMiningOrderValidationProvider` to the validation chain for `UpdateValue` behavior, not just `NextRound`.

3. **Fix Duplicate Detection:** Change the validation to check for duplicate `FinalOrderOfNextRound` values explicitly:
```csharp
var distinctOrderCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

4. **Enhanced TuneOrderInformation:** Ensure all order assignments (not just those where FinalOrderOfNextRound != SupposedOrderOfNextRound) are properly synchronized across nodes.

## Proof of Concept

A test would simulate:
1. Initialize a round with N miners, all having produced blocks (orders 1-N occupied)
2. Miner A produces another block with a signature hash that calculates to an order already held by Miner B
3. Call `ApplyNormalConsensusData` with this conflicting order
4. Verify that both Miner A and Miner B now have the same `FinalOrderOfNextRound`
5. Call `GenerateNextRoundInformation` and observe either `IndexOutOfRangeException` or duplicate mining time assignments
6. Demonstrate that different nodes can generate different next rounds due to non-deterministic ordering

The vulnerability is directly reachable through the consensus block production flow and would manifest in production environments with active mining participation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-44)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-96)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-44)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
```
