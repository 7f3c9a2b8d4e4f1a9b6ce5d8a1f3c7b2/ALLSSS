# Audit Report

## Title
Missing RoundId Validation Allows Bypass of Time Slot Checks for UpdateValue and TinyBlock Behaviors

## Summary
The AEDPoS consensus validation mechanism fails to enforce RoundId matching for UpdateValue and TinyBlock behaviors, allowing malicious miners to bypass time slot validation by crafting blocks with mismatched RoundIds. This enables miners to produce blocks outside their assigned time slots, fundamentally breaking the AEDPoS time slot mechanism.

## Finding Description

The vulnerability exists in the consensus validation flow where `ValidateBeforeExecution` processes UpdateValue and TinyBlock behaviors without validating that the provided Round's RoundId matches the base Round's RoundId from chain state. [1](#0-0) 

When these behaviors are processed, the code calls `RecoverFromUpdateValue` or `RecoverFromTinyBlock` to update the base round with miner information, but these recovery methods only update miner-level fields (OutValue, Signature, PreviousInValue, ImpliedIrreversibleBlockHeight, ActualMiningTimes, order information) and never modify `ExpectedMiningTime` values. [2](#0-1) 

This means `BaseRound.RoundId` (calculated from the original `ExpectedMiningTime` values) remains unchanged. [3](#0-2)  An attacker can provide a Round with different `ExpectedMiningTime` values to create a RoundId mismatch, where `ProvidedRound` comes from the block's extra data. [4](#0-3) 

The critical bypass occurs in `TimeSlotValidationProvider`. When RoundIds don't match, it treats the block as a "new round" and only calls `CheckRoundTimeSlots()` instead of `CheckMinerTimeSlot()`. [5](#0-4) 

The `CheckMinerTimeSlot()` method validates that a miner's `ActualMiningTimes` fall within their assigned time slot window by checking against `ExpectedMiningTime` and the mining interval. [6](#0-5) 

However, `CheckRoundTimeSlots()` only validates structural properties (evenly spaced time slots, positive intervals) and does NOT validate whether the current miner is mining within their assigned slot. [7](#0-6) 

Furthermore, `ProcessUpdateValue` never validates that the input's `round_id` field matches the current round's RoundId. [8](#0-7) 

The protobuf documentation explicitly states that the `round_id` field exists "To ensure the values to update will be apply to correct round by comparing round id," but no such comparison exists in the code. [9](#0-8) 

The after-execution validation does not prevent this attack because `RecoverFromUpdateValue` modifies the current round object in-place and returns it, making both sides of the hash comparison reference the same object. [10](#0-9) 

## Impact Explanation

This vulnerability has **HIGH** severity impact:

**Consensus Integrity Compromise**: Malicious miners can produce blocks outside their assigned time slots, fundamentally breaking the AEDPoS time slot mechanism. This allows miners to produce blocks when other miners should have exclusive mining rights, leading to unfair block production where attackers can produce more blocks than their allocated share.

**Denial of Service**: Attackers can continuously produce blocks during other miners' time slots, potentially blocking legitimate miners from producing blocks during their assigned windows and disrupting orderly round progression and consensus liveness.

**Chain Stability**: Multiple miners producing blocks simultaneously (outside time slot constraints) can cause chain forks, breaking the assumption that only one miner mines at a given time, potentially leading to consensus deadlocks or chain reorganizations.

This directly violates the core security invariant of "correct round transitions and time-slot validation" that is fundamental to AEDPoS consensus security.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of exploitation:

**Attacker Requirements**: The attacker must be a valid miner in the current round, validated by `PreCheck`. [11](#0-10)  This is a realistic constraint as any current miner can exploit this vulnerability.

**Attack Complexity: LOW**
1. Craft a Round object with modified `ExpectedMiningTime` values (to trigger RoundId mismatch)
2. Ensure `ExpectedMiningTime` values are evenly spaced to pass `CheckRoundTimeSlots()`
3. Set `ActualMiningTime` to any desired time (including outside assigned slot)
4. Generate valid `OutValue`/`Signature` for UpdateValue behavior
5. Sign and submit the block

**Detection Difficulty**: The block appears valid from an external perspective (signed by a legitimate miner). Only detailed round validation logic analysis reveals the bypass. Mining permission validation only checks if sender is in the miner list. [12](#0-11) 

**Economic Cost**: Only requires standard block production resources with no special infrastructure or tokens needed beyond being a miner.

## Recommendation

Add explicit RoundId validation in `ValidateBeforeExecution` before calling recovery methods:

```csharp
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    // Validate RoundId match before recovery
    if (extraData.Round.RoundId != baseRound.RoundId)
        return new ValidationResult { Success = false, Message = "Round ID mismatch." };
    
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
}

if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
{
    // Validate RoundId match before recovery
    if (extraData.Round.RoundId != baseRound.RoundId)
        return new ValidationResult { Success = false, Message = "Round ID mismatch." };
    
    baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
}
```

Additionally, add validation in `ProcessUpdateValue` to compare the `round_id` field:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Validate round_id matches
    Assert(updateValueInput.RoundId == currentRound.RoundIdForValidation, 
        "Round ID does not match current round.");
    
    // ... rest of processing
}
```

Fix the after-execution validation by cloning the round before recovery to enable proper hash comparison.

## Proof of Concept

A valid miner can exploit this by:

1. Obtaining current round information with miners and their ExpectedMiningTime values
2. Creating a new Round object with all ExpectedMiningTime values shifted by a fixed offset (maintaining even spacing)
3. Setting their own ActualMiningTime to a time outside their assigned slot
4. Generating valid consensus data (OutValue, Signature)
5. Submitting the UpdateValue transaction with this crafted Round

The validation will:
- See RoundId mismatch (due to different ExpectedMiningTime sum)
- Only validate that time slots are evenly spaced (passes)
- Never validate that ActualMiningTime is within the miner's assigned slot
- Allow the block to be produced outside the legitimate time slot

This breaks the fundamental time slot enforcement mechanism of AEDPoS consensus, enabling denial of service against other miners and potential chain stability issues.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-47)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }

    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-31)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L199-200)
```text
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
