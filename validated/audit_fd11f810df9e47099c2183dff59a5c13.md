# Audit Report

## Title
LIB Height Manipulation via Ineffective Validation of ImpliedIrreversibleBlockHeight in UpdateValue

## Summary
The `LibInformationValidationProvider` validation executes after `RecoverFromUpdateValue` has already overwritten the base round's `ImpliedIrreversibleBlockHeight` with the provided value, making the validation check ineffective. This allows malicious miners to submit arbitrary implied irreversible block heights, enabling ≥1/3 colluding miners to manipulate the LIB calculation and halt finality progression.

## Finding Description

**Root Cause - Validation Order Flaw:**

In `ValidateBeforeExecution`, the method retrieves the current round from state, then calls `RecoverFromUpdateValue` to merge provided consensus data into the base round **before** running validation providers: [1](#0-0) 

The critical flaw occurs at line 47 where `RecoverFromUpdateValue` is invoked before the validation context is created (line 52-60) and before validation providers execute (line 98).

The `RecoverFromUpdateValue` method unconditionally overwrites the base round's `ImpliedIrreversibleBlockHeight`: [2](#0-1) 

Line 19 performs the destructive overwrite: `minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight`.

After this modification, the validation context uses the already-modified `baseRound`. The `ProvidedRound` property accesses the original data from `ExtraData.Round`: [3](#0-2) 

When `LibInformationValidationProvider` executes, it compares the miner's `ImpliedIrreversibleBlockHeight` from `baseRound` against `providedRound`: [4](#0-3) 

The check at lines 25-26 is now ineffective because both `baseRound[pubkey].ImpliedIrreversibleBlockHeight` and `providedRound[pubkey].ImpliedIrreversibleBlockHeight` contain the **same** value after the overwrite. The intended validation `baseRound > providedRound` becomes `newValue > newValue`, which always evaluates to false and passes validation.

**Exploitation Path:**

1. The honest implementation sets `ImpliedIrreversibleBlockHeight = Context.CurrentHeight`: [5](#0-4) 

2. A malicious miner can craft their own consensus extra data with artificially low `ImpliedIrreversibleBlockHeight` (e.g., 0 or any value below current height).

3. The validation fails to detect this due to the order bug.

4. `ProcessUpdateValue` stores the fake value in state: [6](#0-5) 

Line 248 stores: `minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight`.

5. In the next round, `LastIrreversibleBlockHeightCalculator` retrieves these values from the previous round: [7](#0-6) 

Line 25 retrieves implied heights from the previous round, and line 32 selects the LIB using `libHeight = impliedIrreversibleHeights[(count-1)/3]`. This selects the element at index `⌊(count-1)/3⌋` from the sorted list.

6. The sorting mechanism retrieves values from miners who participated in the current round: [8](#0-7) 

7. If ≥ `⌊(count-1)/3⌋ + 1` miners collude to provide artificially low values, they can control the selected LIB height, as their low values will occupy the lower indices of the sorted array.

## Impact Explanation

**Consensus Integrity Violation:**

The LIB (Last Irreversible Block) height can be manipulated to freeze or slow its advancement. While the forward-only check at line 272 of `ProcessUpdateValue` prevents LIB from moving backward, it does not prevent the LIB from being artificially frozen at a low value while block production continues normally.

**Byzantine Fault Tolerance Compromise:**

For a network with n miners:
- With n=7: `⌊(7-1)/3⌋ = 2`, requiring 3+ colluding miners (43%) to control the LIB
- With n=21: `⌊(21-1)/3⌋ = 6`, requiring 7+ colluding miners (33%) to control the LIB

This is at the edge of or exceeds standard BFT 1/3 Byzantine tolerance.

**Operational Impact:**

1. **Finality DoS**: Blocks cannot become irreversible, preventing transaction finality guarantees
2. **Cross-chain operations blocked**: Cross-chain indexing and verification depend on LIB heights for security, so frozen LIB advancement blocks cross-chain transfers and message passing
3. **System-wide degradation**: Applications and smart contracts relying on finality guarantees cannot confirm critical transactions (e.g., high-value transfers, governance actions)

**Affected Parties:**
- All network participants depending on finality
- Cross-chain bridge users and operators
- DeFi protocols requiring transaction finality
- Smart contracts with irreversibility-dependent logic

## Likelihood Explanation

**Attacker Requirements:**
- Control of ≥1/3 of active miners
- Coordination among colluding miners
- Modification of mining software to bypass honest consensus transaction generation

**Feasibility Assessment:**

While miners are elected and economically incentivized through staking, creating barriers to collusion, the 1/3 threshold is achievable in scenarios such as:
- Compromised mining pools controlling multiple validator nodes
- Nation-state level attacks targeting blockchain infrastructure
- Economic incentives from competitors to disrupt cross-chain operations
- Coordinated attacks during periods of low miner participation

**Detection:**
The attack is observable - LIB height stops advancing while block production continues. Monitoring systems can detect the discrepancy between current block height and LIB height, and forensic analysis can identify which miners submitted abnormally low implied heights.

**Economic Rationality:**
While direct financial gain may be limited (no immediate fund theft), motivations include:
- Disrupting competitor chains in cross-chain ecosystems
- Market manipulation (shorting tokens dependent on chain operations)
- Censorship (preventing finality of specific transactions)
- Extortion (demanding payment to restore normal operations)

The attack requires medium execution complexity - miner collusion but no sophisticated cryptographic exploits.

## Recommendation

**Fix the Validation Order:**

Move the `RecoverFromUpdateValue` call to **after** validation, or create a separate validation context that uses the unmodified base round. The recommended fix:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // ... early return logic ...

    // Create validation context with UNMODIFIED baseRound
    var validationContext = new ConsensusValidationContext
    {
        BaseRound = baseRound,  // Original unmodified state
        CurrentTermNumber = State.CurrentTermNumber.Value,
        CurrentRoundNumber = State.CurrentRoundNumber.Value,
        PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
        LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
        ExtraData = extraData
    };

    // Run validation FIRST
    var validationProviders = new List<IHeaderInformationValidationProvider> { /* ... */ };
    var service = new HeaderInformationValidationService(validationProviders);
    var validationResult = service.ValidateInformation(validationContext);
    
    if (validationResult.Success == false)
        return validationResult;

    // ONLY modify baseRound AFTER validation passes
    if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
        baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

    if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
        baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

    return validationResult;
}
```

**Alternative Fix:**

Add explicit bounds checking on `ImpliedIrreversibleBlockHeight` to ensure it cannot be lower than reasonable values:

```csharp
// In LibInformationValidationProvider
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    var providedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    var baseHeight = baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    
    // Ensure provided height is reasonable (not artificially low)
    if (baseHeight > providedHeight ||
        providedHeight < baseRound.ConfirmedIrreversibleBlockHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanManipulateLIBHeight_ByProvidingLowImpliedHeight()
{
    // Setup: Initialize consensus with 7 miners
    var miners = await InitializeConsensusWithMiners(7);
    var maliciousMiner = miners[0];
    
    // Advance to round 2 so we have previous round data for LIB calculation
    await ProduceNormalBlocks(miners, roundsToAdvance: 2);
    
    // Record current LIB height
    var libBeforeAttack = (await ConsensusStub.GetCurrentLibInformation.CallAsync(new Empty())).LibHeight;
    var currentHeight = await GetCurrentBlockHeight();
    
    // Attack: Malicious miner creates UpdateValue with artificially low ImpliedIrreversibleBlockHeight
    var maliciousUpdateValue = new UpdateValueInput
    {
        OutValue = GenerateOutValue(),
        Signature = GenerateSignature(),
        PreviousInValue = Hash.Empty,
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        ImpliedIrreversibleBlockHeight = 1, // Artificially low value instead of currentHeight
        // ... other fields ...
    };
    
    // Execute the malicious UpdateValue transaction
    await ConsensusStub.UpdateValue.SendAsync(maliciousUpdateValue);
    
    // Have 2 more malicious miners do the same (total 3 out of 7 = 43%)
    for (int i = 1; i < 3; i++)
    {
        await miners[i].ConsensusStub.UpdateValue.SendAsync(CreateMaliciousUpdateValue(1));
    }
    
    // Complete the round with honest miners
    for (int i = 3; i < 7; i++)
    {
        await miners[i].ProduceNormalBlock();
    }
    
    // Advance to next round and check LIB
    await ProduceNormalBlocks(miners, roundsToAdvance: 1);
    
    var libAfterAttack = (await ConsensusStub.GetCurrentLibInformation.CallAsync(new Empty())).LibHeight;
    var newHeight = await GetCurrentBlockHeight();
    
    // Assert: LIB should have advanced proportionally with block height, but it didn't
    // Expected: libAfterAttack should be close to newHeight
    // Actual: libAfterAttack is artificially low due to manipulation
    Assert.True(newHeight - libAfterAttack > 100, 
        $"LIB manipulation successful: Height advanced to {newHeight} but LIB stuck at {libAfterAttack}");
    Assert.True(libAfterAttack < libBeforeAttack + 10,
        "LIB advancement was significantly slowed by malicious miners");
}
```

## Notes

This vulnerability directly compromises the Last Irreversible Block (LIB) finality mechanism in AEDPoS consensus. The root cause is a logic error in the validation sequencing where state modification occurs before validation, rendering the `LibInformationValidationProvider` check ineffective.

The attack requires miner collusion at approximately the 1/3 Byzantine threshold, which is considered the edge case for BFT security. While this makes the attack non-trivial, it is within the realm of possibility for motivated adversaries, especially given the potential for operational disruption of cross-chain bridges and finality-dependent applications.

The recommended fix is straightforward: reorder the validation logic to preserve the original state during validation checks, or add explicit bounds validation on the `ImpliedIrreversibleBlockHeight` field to prevent artificially low values from being accepted.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-60)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-40)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L6-35)
```csharp
public class LibInformationValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L9-34)
```csharp
    private class LastIrreversibleBlockHeightCalculator
    {
        private readonly Round _currentRound;
        private readonly Round _previousRound;

        public LastIrreversibleBlockHeightCalculator(Round currentRound, Round previousRound)
        {
            _currentRound = currentRound;
            _previousRound = previousRound;
        }

        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L8-20)
```csharp
public partial class Round
{
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);

    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
}
```
