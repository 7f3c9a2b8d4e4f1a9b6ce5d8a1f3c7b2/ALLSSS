# Audit Report

## Title
Token Hash Collision Vulnerability via Symbol Manipulation Enables NFT Data Corruption

## Summary
The NFT contract's `CalculateTokenHash()` function uses naive string concatenation without a separator, allowing different (symbol, tokenId) pairs to produce identical token hashes. An attacker can exploit the `CrossChainCreate` method's insufficient symbol validation to register NFT protocols with crafted symbols that generate hash collisions, causing complete NFT data corruption and ownership integrity loss.

## Finding Description

The vulnerability exists in the token hash calculation mechanism used to uniquely identify NFTs. The `CalculateTokenHash()` function performs simple string concatenation without any separator: [1](#0-0) 

This creates a critical ambiguity where different (symbol, tokenId) pairs produce identical hash inputs:
- Symbol "AR-12" + tokenId 3 → "AR-123" → Hash("AR-123")
- Symbol "AR-1" + tokenId 23 → "AR-123" → Hash("AR-123")

The attack exploits three key weaknesses:

**1. MultiToken allows NFT symbols with hyphens**

The MultiToken contract's symbol validation explicitly permits hyphens followed by digits in NFT symbols: [2](#0-1) [3](#0-2) 

The regex pattern `^[a-zA-Z0-9]+(-[0-9]+)?$` explicitly permits symbols like "AR-12" or "AR-1". These symbols are valid NFT tokens within a collection when the collection "AR-0" exists.

**2. CrossChainCreate accepts hyphenated symbols with minimal validation**

The NFT contract's `CrossChainCreate` method only validates that the first 2 characters match a registered NFT type, without preventing hyphenated symbols from being registered as NFT protocols: [4](#0-3) 

The validation at lines 89-93 only checks if the NFT type short name exists in the mapping, but doesn't enforce that protocol symbols follow the format generated by the normal `Create()` method (which produces symbols like "AR123456789" without hyphens): [5](#0-4) 

**3. All NFT state uses tokenHash as the key**

All critical NFT state mappings use the colliding tokenHash as their primary key. When a collision occurs, the `PerformMint` function's behavior causes state corruption: [6](#0-5) 

When the second protocol's NFT is minted with a colliding hash, `nftInfo` is not null (contains data from the first protocol), so the code enters the else branch (lines 433-437) and incorrectly merges the data. It adds quantity and minters but does NOT update the symbol and tokenId fields, leaving the NFTInfo with incorrect metadata that mixes data from both protocols.

## Impact Explanation

This vulnerability breaks the fundamental invariant that each NFT must have a globally unique identifier. The concrete harms include:

**1. NFT Metadata Corruption**: The `State.NftInfoMap[tokenHash]` stores critical NFT information (symbol, tokenId, metadata, quantity, URI, alias, minters). When a collision occurs, the second mint incorrectly merges data from two distinct NFTs, causing permanent data loss where the NFTInfo retains the first protocol's symbol and tokenId but combines quantities and minters from both.

**2. Balance Manipulation**: `State.BalanceMap[tokenHash][owner]` combines balances from different NFT protocols. Users holding "AR-12 tokenId 3" would see their balance merged with "AR-1 tokenId 23", enabling theft through transfer operations as the system treats them as the same asset.

**3. Allowance Confusion**: `State.AllowanceMap[tokenHash][owner][spender]` causes approvals granted for one NFT to affect an entirely different NFT from a different protocol, breaking access control guarantees.

**4. Assembly Data Corruption**: `State.AssembledNftsMap[tokenHash]` and `State.AssembledFtsMap[tokenHash]` mix data from different assembled NFTs, causing disassembly operations to return wrong assets to users.

**5. Loss of Ownership Integrity**: All NFT operations (Transfer, Burn, Approve) use the tokenHash as the key. Operations on one NFT unintentionally affect another unrelated NFT, enabling attackers to manipulate or destroy NFTs they don't own.

This is a HIGH severity vulnerability because it completely undermines NFT uniqueness and ownership integrity across the entire protocol, corrupting the fundamental state layer.

## Likelihood Explanation

**Attack Prerequisites**:
1. Attacker creates "AR-0" collection in MultiToken on a source chain (requires obtaining one Seed NFT for symbol "AR")
2. Attacker creates "AR-12" and "AR-1" as NFT tokens within that collection (no additional Seeds required)
3. Attacker uses cross-chain mechanisms to bring these tokens to a destination chain
4. Attacker calls `CrossChainCreate` to register both "AR-12" and "AR-1" as separate NFT protocols
5. Attacker mints NFTs with calculated tokenIds that produce hash collisions

**Attack Complexity**: MEDIUM-LOW
- The collision is deterministic and can be pre-calculated mathematically
- Once a single Seed NFT is obtained (available through legitimate token creation mechanisms), creating multiple NFT tokens within a collection is straightforward
- No timing dependencies, race conditions, or complex state manipulation required
- Standard contract calls execute the entire attack

**Feasibility**: HIGH
- MultiToken's symbol validation explicitly allows hyphens in NFT symbols as shown in the regex pattern
- `CrossChainCreate` only validates the first 2 characters match a registered NFT type and doesn't enforce symbol format restrictions
- No on-chain detection mechanism exists to prevent collisions
- Collisions are permanent once created

**Operational Constraints**: MINIMAL
- Attack requires cross-chain operations but these are standard protocol features
- Multiple protocols can be affected simultaneously
- The vulnerability is exploitable at any time after deployment

**Overall Likelihood**: MEDIUM-HIGH - While obtaining Seed NFTs and performing cross-chain operations requires initial setup, the attack itself is deterministic and has guaranteed success once prerequisites are met.

## Recommendation

Implement a separator in the `CalculateTokenHash` function to ensure globally unique token hashes. The fix should modify the concatenation to include a delimiter that cannot appear in valid tokenIds:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}#{tokenId}");
}
```

Additionally, `CrossChainCreate` should enforce that NFT protocol symbols follow the expected format (alphanumeric prefix followed by numeric suffix without hyphens) to align with the symbols generated by the normal `Create()` method:

```csharp
// In CrossChainCreate method, add validation:
var nftTypeShortName = input.Symbol.Substring(0, 2);
Assert(input.Symbol.Length > 2 && !input.Symbol.Contains('-'), 
    "Invalid NFT protocol symbol format");
```

## Proof of Concept

```csharp
// This test demonstrates the hash collision vulnerability
[Fact]
public async Task HashCollision_CorruptsNFTState()
{
    // Step 1: On source chain, create AR-0 collection and AR-12, AR-1 NFTs in MultiToken
    // (Assuming these exist and are brought to destination chain via CrossChainCreateToken)
    
    // Step 2: Register both as NFT protocols via CrossChainCreate
    await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput { Symbol = "AR-12" });
    await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput { Symbol = "AR-1" });
    
    // Step 3: Mint from first protocol
    var hash1 = await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = "AR-12",
        TokenId = 3,  // Will create hash of "AR-123"
        Owner = User1Address,
        Quantity = 10
    });
    
    // Step 4: Mint from second protocol with collision
    var hash2 = await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = "AR-1",
        TokenId = 23,  // Will create hash of "AR-123" - COLLISION!
        Owner = User2Address,
        Quantity = 5
    });
    
    // Verify collision: both should produce same tokenHash
    hash1.Output.ShouldBe(hash2.Output);
    
    // Verify corruption: NFTInfo has wrong symbol/tokenId but combined quantity
    var nftInfo = await NFTContractStub.GetNFTInfoByTokenHash.CallAsync(hash1.Output);
    nftInfo.Symbol.ShouldBe("AR-12");  // Still first protocol's symbol
    nftInfo.TokenId.ShouldBe(3);       // Still first protocol's tokenId
    nftInfo.Quantity.ShouldBe(15);     // But combined quantity from both mints!
    
    // Verify balance corruption: User2's balance is stored under User1's intended NFT hash
    var balance = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = User2Address,
        Symbol = "AR-1",
        TokenId = 23
    });
    balance.Balance.ShouldBe(5);  // User2 has balance, but under wrong NFT identity
}
```

## Notes

This vulnerability exploits the architectural gap between how MultiToken allows NFT symbols (hyphenated patterns for collection items like "AR-12") and how the NFT contract expects protocol symbols (non-hyphenated patterns like "AR123456789"). The `CrossChainCreate` method bridges these two systems but lacks validation to prevent hyphenated MultiToken NFT symbols from being registered as NFT protocols, enabling the hash collision attack.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-437)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");

        var quantity = input.Quantity > 0 ? input.Quantity : 1;
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;

        // Inherit from protocol info.
        var nftMetadata = protocolInfo.Metadata.Clone();
        if (input.Metadata != null)
            foreach (var pair in input.Metadata.Value)
                if (!nftMetadata.Value.ContainsKey(pair.Key))
                    nftMetadata.Value[pair.Key] = pair.Value;

        if (nftInfo == null)
        {
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
        }
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L18-21)
```csharp
    private static bool IsValidSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L19-19)
```csharp
    public const char NFTSymbolSeparator = '-';
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-93)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```
