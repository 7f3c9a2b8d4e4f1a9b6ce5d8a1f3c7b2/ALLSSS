# Audit Report

## Title
Insufficient Validation Allows Duplicate Mining Orders in Consensus Round Transitions

## Summary
The `NextRoundMiningOrderValidationProvider` fails to properly validate uniqueness of `FinalOrderOfNextRound` values due to calling `Distinct()` on entire `MinerInRound` protobuf objects rather than on the specific order field. This allows malicious miners to propose consensus rounds with duplicate mining orders, violating the core AEDPoS invariant of unique, deterministic time slots per miner. [1](#0-0) 

## Finding Description

The validation logic attempts to ensure miners have unique next-round orders by filtering miners with `FinalOrderOfNextRound > 0` and calling `Distinct()` to count unique entries. However, `MinerInRound` is a protobuf-generated message with 17 fields including a unique `pubkey` field. [2](#0-1) 

When `Distinct()` is called on `MinerInRound` objects, protobuf's default equality comparison checks ALL fields. Since each miner has a unique `pubkey`, two miners with identical `FinalOrderOfNextRound` values but different pubkeys will be considered distinct objects, allowing the validation to pass incorrectly.

**Execution Path:**

1. A miner calls the public `NextRound` method with a malicious `NextRoundInput` containing duplicate `FinalOrderOfNextRound` values [3](#0-2) 

2. During block validation, `ValidateBeforeExecution` is invoked, which adds `NextRoundMiningOrderValidationProvider` for NextRound behavior validation [4](#0-3) 

3. The flawed validation passes even with duplicate orders because `Distinct()` compares entire objects

4. The malicious round is persisted to state via `ProcessNextRound` which calls `AddRoundInformation` [5](#0-4) 

5. When the next round is generated, the logic in `GenerateNextRoundInformation` assumes `FinalOrderOfNextRound` values are unique [6](#0-5) 

The `occupiedOrders` calculation expects unique values. With duplicates, the logic for assigning remaining orders to miners who didn't mine becomes incorrect, corrupting the consensus schedule. Some miners get duplicate orders while other order slots remain unassigned.

## Impact Explanation

This vulnerability breaks a fundamental AEDPoS consensus invariant: **each miner must have a unique, deterministic time slot**.

With duplicate `FinalOrderOfNextRound` values:
- Multiple miners are assigned the same mining order
- Scheduling ambiguity creates conflicts when miners attempt to produce blocks simultaneously
- The consensus mechanism cannot deterministically resolve who should mine at each time slot
- This can lead to consensus forks, block production failures, and network instability
- All network participants suffer from degraded consensus reliability and compromised finality guarantees

While normal block production includes conflict resolution logic in `ApplyNormalConsensusData`, a malicious NextRound proposal with pre-set duplicate orders bypasses this protection entirely. [7](#0-6) 

**Severity: Critical** - Directly undermines core consensus schedule integrity.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an authorized miner in the consensus set
- Authorization is checked only by verifying presence in current or previous miner list [8](#0-7) 

**Attack Complexity:** Low
- Simply craft a `NextRoundInput` with duplicate `FinalOrderOfNextRound` assignments using the `NextRoundInput.Create` helper or by directly constructing the message [9](#0-8) 

- No complex cryptographic operations or timing requirements
- The flawed validation will accept the malicious structure

**Opportunity Frequency:**
Round transitions occur regularly in normal consensus operation. Each round, miners can propose NextRound transitions. Over time, a malicious miner will have regular opportunities to exploit this.

**Detection:** None - The validation specifically intended to catch this scenario fails silently.

**Probability: Medium-High** - While requiring miner status, the exploit is straightforward and opportunities occur regularly through normal consensus rotation.

## Recommendation

Fix the validation logic to check uniqueness of the `FinalOrderOfNextRound` field values rather than the entire `MinerInRound` objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Project to the field value
    .Distinct()
    .Count();
```

This ensures that duplicate `FinalOrderOfNextRound` values are properly detected and rejected, regardless of other field differences.

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateMiningOrders_ShouldFail_ButPasses()
{
    // Setup: Get current round with 5 miners
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var minersWhoMined = currentRound.RealTimeMinersInformation.Values
        .Where(m => m.OutValue != null).ToList();
    
    // Create malicious NextRoundInput with DUPLICATE orders
    var maliciousNextRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber
    };
    
    // Assign duplicate order (order=1) to first two miners
    var minersList = minersWhoMined.Take(2).ToList();
    foreach (var miner in minersList)
    {
        maliciousNextRound.RealTimeMinersInformation[miner.Pubkey] = new MinerInRound
        {
            Pubkey = miner.Pubkey,
            FinalOrderOfNextRound = 1,  // DUPLICATE ORDER
            OutValue = Hash.FromString("dummy")
        };
    }
    
    // Add remaining miners with unique orders
    var order = 3;
    foreach (var miner in minersWhoMined.Skip(2))
    {
        maliciousNextRound.RealTimeMinersInformation[miner.Pubkey] = new MinerInRound
        {
            Pubkey = miner.Pubkey,
            FinalOrderOfNextRound = order++,
            OutValue = Hash.FromString("dummy")
        };
    }
    
    var input = NextRoundInput.Create(maliciousNextRound, ByteString.CopyFromUtf8("randomNumber"));
    
    // This should fail validation but will actually succeed
    var result = await ConsensusContract.NextRound.SendAsync(input);
    
    // Bug: Transaction succeeds despite duplicate mining orders
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify the corruption: Two miners have the same order
    var storedRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var ordersCount = storedRound.RealTimeMinersInformation.Values
        .Select(m => m.Order)
        .Distinct()
        .Count();
    
    // ordersCount will be less than total miners, proving the invariant is broken
    ordersCount.ShouldBeLessThan(storedRound.RealTimeMinersInformation.Count);
}
```

## Notes

The vulnerability exists because C# LINQ's `Distinct()` method uses the default equality comparer for the type. For protobuf-generated messages from Google.Protobuf library, equality is implemented by comparing all fields recursively. The fix requires projecting to just the field of interest (`FinalOrderOfNextRound`) before calling `Distinct()`, ensuring only the order values are compared for uniqueness, not the entire miner objects.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L280-301)
```text
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-44)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```
