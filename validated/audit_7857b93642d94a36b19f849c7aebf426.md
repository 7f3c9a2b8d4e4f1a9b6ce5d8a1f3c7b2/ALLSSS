# Audit Report

## Title
Last Irreversible Block (LIB) Advancement Halts in Two-Miner Networks With Single Round Participation Gap

## Summary
In a 2-miner AEDPoS network, the LIB calculation mechanism requires both miners to have participated in two consecutive rounds for finality to advance. If either miner misses a single round, the LIB calculator fails its consensus threshold check and returns zero, preventing irreversible block height advancement until two consecutive rounds of full participation occur.

## Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method which calculates LIB height based on a cross-round consensus requirement. [1](#0-0) 

The core issue stems from the filtering logic that requires miners to have participated in BOTH the current and previous rounds. The method first retrieves miners who mined in the current round, then uses their pubkeys to filter implied irreversible heights from the previous round. [2](#0-1) 

For a 2-miner network, `MinersCountOfConsent` is calculated as `(2 * 2 / 3) + 1 = 2`, requiring both miners. [3](#0-2) 

The `GetMinedMiners()` method returns only miners where `SupposedOrderOfNextRound != 0`, which is set during normal consensus data processing. [4](#0-3)  Miners who miss their time slot will not have this field set. [5](#0-4) 

When the consensus threshold check fails, `libHeight = 0` is returned and no `IrreversibleBlockFound` event is fired. [6](#0-5) 

**Concrete Scenario:**
- Round N: Miners A and B both mine successfully
- Round N+1: Only Miner A mines (B misses the round)
- Round N+2: Both miners A and B mine
- During Round N+2 LIB calculation: `GetMinedMiners()` returns [A, B], but `GetSortedImpliedIrreversibleBlockHeights([A, B])` on Round N+1 only finds A's data (since B didn't mine in N+1), returning 1 height
- Check: 1 < 2 fails, `libHeight = 0`

The contract allows 2-miner configurations without validation during initialization. [7](#0-6) 

## Impact Explanation

**Operational Impact:**
- **Finality Halted**: LIB advancement stops until two consecutive rounds of 100% miner participation occur
- **Cross-Chain Operations Affected**: Cross-chain mechanisms relying on LIB for merkle path validation and synchronization are blocked
- **State Pruning Disabled**: Node state cleanup operations depending on LIB advancement cannot proceed
- **Self-Recovering But Fragile**: System recovers after sustained participation, but any intermittent issues cause repeated failures

**Severity: Medium**
The chain continues producing blocks (safety preserved), but the complete halt of finality advancement represents a liveness failure affecting transaction irreversibility guarantees and dependent systems. While self-recovering, the requirement for sustained 100% participation in 2-miner networks creates operational fragility.

## Likelihood Explanation

**In 2-Miner Networks: High**
- No minimum miner count validation prevents this configuration
- Any operational issue (network delays, maintenance, hardware failures) triggers the condition
- No attacker requiredâ€”normal operational events cause it
- Recovery requires multiple consecutive rounds of perfect participation

**In Production Networks: Low to Medium**
The protocol defines `SupposedMinersCount = 17`, suggesting production deployments should use more miners. [8](#0-7)  However, this is not enforced as a minimum requirement during initialization, leaving 2-miner networks as a valid but fragile configuration primarily suited for testing environments.

## Recommendation

**Option 1: Enforce Minimum Miner Count**
Add validation during initialization to require a minimum of 3 miners (or higher) to ensure the consensus mechanism functions properly with realistic participation patterns.

**Option 2: Adjust LIB Calculation for Small Networks**
Modify the LIB calculation to use a sliding window approach or adjust `MinersCountOfConsent` calculation for networks with fewer than a threshold number of miners.

**Option 3: Documentation**
If 2-miner networks are intentionally allowed only for testing, add clear documentation and runtime warnings about the finality limitations.

**Recommended Fix (Option 1):**
In `FirstRound()` and `InitialAElfConsensusContract()`, add validation:
```csharp
Assert(input.RealTimeMinersInformation.Count >= 3, 
    "Minimum 3 miners required for reliable LIB advancement.");
```

## Proof of Concept

This scenario can be tested by:
1. Initializing a 2-miner AEDPoS network
2. Having both miners successfully mine in Round 1
3. Having only Miner A mine in Round 2 (Miner B misses)
4. Having both miners mine in Round 3
5. Verifying that during Round 3's `ProcessUpdateValue`, the LIB calculation returns 0 because Round 2 only contains Miner A's implied height
6. Confirming no `IrreversibleBlockFound` event is fired
7. Having both miners mine in Round 4
8. Verifying LIB finally advances because Round 3 has both miners' data

The key assertion is that `impliedIrreversibleHeights.Count` will be 1 (not 2) when filtering Round N+1 by miners who participated in Round N+2, causing the consensus threshold check to fail.

## Notes

This is a valid liveness issue in the AEDPoS consensus implementation. While the system is self-recovering and the chain continues to produce blocks, the fragility of LIB advancement in 2-miner networks represents a design limitation that should be addressed through either minimum miner count enforcement or adjusted consensus threshold calculations for small networks. The vulnerability is most relevant for test/development deployments but could theoretically affect any network configured with exactly 2 miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
