# Audit Report

## Title
Parliament Contract State Bloat DOS via Immediate-Expiration Proposals

## Summary
The Parliament contract's `CreateProposal()` function lacks minimum expiration time validation, allowing authorized proposers to create proposals that expire within seconds. This causes uncontrolled state bloat in the `State.Proposals` mapping, with expired proposals requiring manual one-by-one cleanup via `ClearProposal()`, creating an asymmetric attack-defense cost ratio that degrades contract performance.

## Finding Description

The vulnerability exists in the proposal expiration validation logic. When `CreateProposal()` is called, it invokes `CreateNewProposal()` which validates the proposal through `Validate(proposal)`. [1](#0-0) 

The validation function calls `CheckProposalNotExpired()` to verify expiration time: [2](#0-1) 

The critical flaw is in the expiration check implementation: [3](#0-2) 

This validation only verifies that `Context.CurrentBlockTime < proposal.ExpiredTime` without enforcing any minimum duration. An attacker can set `ExpiredTime = CurrentBlockTime + 1 second`, which passes validation but expires almost immediately.

**Why Existing Protections Fail:**

1. **No Minimum Duration**: The check allows any future timestamp, including those just 1 second away, creating proposals that expire before they can be meaningfully processed.

2. **Manual One-by-One Cleanup**: Expired proposals must be removed individually: [4](#0-3) 

3. **No Rate Limiting**: The proposal creation flow has no restrictions on frequency or concurrent proposals per proposer.

4. **Storage Accumulation**: Each proposal is stored in the state mapping with significant size: [5](#0-4) 

With string field limits defined as: [6](#0-5) 

5. **Authorization Preconditions**: Proposers are authorized if organization allows open proposing or they are parliament members: [7](#0-6) 

## Impact Explanation

**Concrete Harm:**
- Uncontrolled growth of the `State.Proposals` mapping through accumulation of expired proposals
- Each malicious proposal consumes 200-11,000 bytes of storage (minimum: hashes + addresses; maximum: with full 255-byte title, 10,200-byte description, 255-byte URL)
- Degraded contract read/write performance as state size increases
- Increased node storage requirements and synchronization costs across the network
- Asymmetric defense cost: attacker can batch multiple `CreateProposal()` calls efficiently, but defender must invoke `ClearProposal()` once per proposal

**Affected Parties:**
- Organizations configured with `ProposerAuthorityRequired=false` (allowing anyone to propose)
- Organizations where attacker holds parliament member status and `ParliamentMemberProposingAllowed=true`
- All network participants experience degraded performance from bloated contract state

**Severity Justification (Medium):**
- Requires specific preconditions (organization configuration or parliament membership)
- Transaction fees via ACS1 can increase attack cost if properly configured: [8](#0-7) 
- Manual cleanup mechanism exists but is operationally inefficient
- Does not directly steal funds or break consensus, but significantly degrades operational capabilities over time

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an authorized proposer through one of three paths: (1) organization with `ProposerAuthorityRequired=false`, (2) in proposer whitelist, or (3) parliament member when `ParliamentMemberProposingAllowed=true`
- Requires transaction fees to be low or unconfigured to make attack economically viable
- Can efficiently batch multiple proposal creations

**Attack Execution:**
- Low complexity: Simply call `CreateProposal()` repeatedly with `ExpiredTime = Context.CurrentBlockTime + 1`
- Validation passes because `CurrentBlockTime < ExpiredTime` evaluates to true
- Proposals expire within seconds but persist in state indefinitely until manual cleanup
- Cleanup requires defender to call `ClearProposal()` individually for each proposal

**Feasibility Assessment:**
- Realistic for organizations with open proposing policies
- Realistic for malicious actors who become parliament members
- Attack becomes expensive only if transaction fees are properly configured by governance
- Detection is straightforward (high volume of expired proposals), but mitigation is tedious

**Probability:** Medium - depends on organization configuration and fee settings, but authorization paths are realistic in governance systems

## Recommendation

Implement a minimum proposal duration requirement to prevent immediate-expiration spam:

```csharp
private bool CheckProposalNotExpired(ProposalInfo proposal)
{
    const long MinimumProposalDuration = 3600; // 1 hour minimum in seconds
    var minimumExpiredTime = Context.CurrentBlockTime.AddSeconds(MinimumProposalDuration);
    
    return proposal.ExpiredTime != null && 
           Context.CurrentBlockTime < proposal.ExpiredTime &&
           proposal.ExpiredTime >= minimumExpiredTime;
}
```

Additionally, consider implementing:
- Batch cleanup functionality allowing multiple proposals to be cleared in one transaction
- Rate limiting on proposal creation per proposer per time period
- Ensure transaction fees are properly configured via ACS1 to make spam attacks economically prohibitive

## Proof of Concept

```csharp
// Test demonstrating state bloat attack
[Fact]
public async Task ProposalStateBloatAttack_WithMinimalExpiration()
{
    // Setup: Create organization with ProposerAuthorityRequired=false
    var organizationAddress = await CreateOpenOrganization();
    
    // Attack: Create 100 proposals with 1-second expiration
    var attackerAddress = SampleAddress.AddressList[0];
    var currentTime = TimestampHelper.GetUtcNow();
    
    for (int i = 0; i < 100; i++)
    {
        var proposalInput = new CreateProposalInput
        {
            OrganizationAddress = organizationAddress,
            ToAddress = SampleAddress.AddressList[1],
            ContractMethodName = "Transfer",
            ExpiredTime = currentTime.AddSeconds(1), // Expires in 1 second
            Params = ByteString.Empty,
            Title = new string('A', 255), // Max length
            Description = new string('B', 10200), // Max length
            ProposalDescriptionUrl = new string('C', 255) // Max length
        };
        
        var result = await ParliamentContractStub.CreateProposal.SendAsync(proposalInput);
        Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined);
    }
    
    // Verify: All proposals created and stored
    // Each proposal ~11KB, total ~1.1MB of state bloat
    // Proposals immediately expired but persist in State.Proposals mapping
    
    // Defense requires 100 individual ClearProposal() calls
}
```

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L229-244)
```csharp
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
```

**File:** contract/AElf.Contracts.Parliament/ParliamentConstants.cs (L4-7)
```csharp
{
    public const int MaxLengthForTitle = 255;
    public const int MaxLengthForDescription = 10200;
    public const int MaxLengthForProposalDescriptionUrl = 255;
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```
