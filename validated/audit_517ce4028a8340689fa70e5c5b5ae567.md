# Audit Report

## Title
Unprotected Dictionary Access in UpdateValueValidationProvider Causes KeyNotFoundException During Consensus Validation

## Summary
The `UpdateValueValidationProvider` performs unprotected dictionary accesses on attacker-controlled consensus data without verifying key existence. Any valid miner can craft malicious block headers that trigger `KeyNotFoundException` during validation, disrupting consensus validation across all network nodes.

## Finding Description

The vulnerability exists in the consensus validation flow where block headers are validated before execution. The entry point is the public method `ValidateConsensusBeforeExecution` [1](#0-0)  which parses attacker-controlled block header data and calls `ValidateBeforeExecution`.

During validation of `UpdateValue` behavior blocks, the validation system creates a `ConsensusValidationContext` where `ProvidedRound` property returns `ExtraData.Round` from the block header [2](#0-1) . This data structure is fully attacker-controlled.

The `UpdateValueValidationProvider` is added to the validation pipeline for `UpdateValue` behavior [3](#0-2) . The provider's `NewConsensusInformationFilled` method directly accesses the dictionary without checking key existence [4](#0-3) .

Additional unprotected accesses exist in `ValidatePreviousInValue` [5](#0-4)  where the code accesses `extraData.Round.RealTimeMinersInformation[publicKey]` after only checking if the key exists in `PreviousRound`, not in the `ProvidedRound` being accessed.

**Why existing protections fail:**

The `MiningPermissionValidationProvider` validates the sender is a miner, but only checks against `BaseRound` (from state), not `ProvidedRound` (from block data) [6](#0-5) .

The `RecoverFromUpdateValue` method has protection [7](#0-6)  but this is called before validation providers run [8](#0-7)  and only returns early without enforcing that `ProvidedRound` must contain the sender's pubkey or marking validation as failed.

The validation service stops on first failure [9](#0-8) , but `MiningPermissionValidationProvider` passes before reaching the vulnerable `UpdateValueValidationProvider`.

## Impact Explanation

**Operational DoS Impact:**
- Any valid miner can produce a block with `Behaviour = AElfConsensusBehaviour.UpdateValue` where the consensus extra data (`ExtraData.Round`) excludes their own pubkey from `RealTimeMinersInformation`
- When other nodes validate this block, an unhandled `KeyNotFoundException` is thrown during the validation phase
- This disrupts block validation across all nodes receiving the malicious block
- Repeated attacks can cause consensus delays or validation failures network-wide

**Affected Parties:**
- All validating nodes in the network (not just the attacker)
- Consensus integrity and block production continuity

**Severity Justification:**
- High severity due to ability to disrupt consensus validation operations
- Any current miner can exploit (low attacker privilege requirement)
- Causes unhandled exceptions that could crash or hang validation processes
- Can be repeated to create sustained denial of service
- Affects critical consensus infrastructure

## Likelihood Explanation

**Attacker Capabilities:**
- Must be a valid miner in the current round (achievable through normal election process)
- Can craft arbitrary consensus extra data in produced blocks
- No economic cost beyond normal block production

**Attack Complexity:**
- Low complexity: Simply craft a `Round` object that omits the producer's own pubkey from `RealTimeMinersInformation`
- The provided round structure is not validated to ensure it contains the sender's pubkey
- Attack is deterministic and requires no special timing or race conditions

**Feasibility Conditions:**
- Entry point is public and called by blockchain infrastructure during block validation
- No special permissions needed beyond being an active miner
- Attack is immediately repeatable

**Detection:**
- Would appear as `KeyNotFoundException` in node validation logs
- Network would see blocks rejected during validation
- Determining malicious intent vs. implementation bugs may be difficult initially

**Probability:**
High likelihood - the vulnerability is trivially exploitable by any active miner with no validation preventing the malicious data structure. The attack surface is exposed through normal consensus operations.

## Recommendation

Add `ContainsKey` checks before all dictionary accesses in `UpdateValueValidationProvider`:

**In `NewConsensusInformationFilled` method:**
```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    // Add key existence check
    if (!validationContext.ProvidedRound.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey))
        return false;
        
    var minerInRound =
        validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
}
```

**In `ValidatePreviousInValue` method:**
```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

    // Add key existence check for ProvidedRound
    if (!extraData.Round.RealTimeMinersInformation.ContainsKey(publicKey)) return false;

    if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    if (previousInValue == Hash.Empty) return true;

    return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
}
```

Alternatively, modify `RecoverFromUpdateValue` to return a validation result or throw an exception when the pubkey is missing from `providedRound`, rather than silently returning.

## Proof of Concept

```csharp
[Fact]
public async Task UpdateValueValidation_MissingPubkeyInProvidedRound_ThrowsKeyNotFoundException()
{
    // Arrange: Get a valid miner and create malicious consensus data
    var miners = await AEDPoSContractStub.GetCurrentMinerList.CallAsync(new Empty());
    var attackerPubkey = miners.Pubkeys.First();
    
    // Create a Round object that excludes the attacker's pubkey
    var maliciousRound = new Round
    {
        RoundNumber = 1,
        RealTimeMinersInformation = { }
        // Intentionally empty - attacker's pubkey is missing
    };
    
    var consensusHeaderInfo = new AElfConsensusHeaderInformation
    {
        SenderPubkey = attackerPubkey,
        Round = maliciousRound,
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    
    var input = new BytesValue 
    { 
        Value = consensusHeaderInfo.ToByteString() 
    };
    
    // Act & Assert: Validation should throw KeyNotFoundException
    await Assert.ThrowsAsync<KeyNotFoundException>(async () =>
    {
        await AEDPoSContractStub.ValidateConsensusBeforeExecution.CallAsync(input);
    });
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L29-32)
```csharp
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-45)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ValidationService.cs (L18-23)
```csharp
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result =
                headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }
```
