# Audit Report

## Title
Missing Access Control in EnableConnector Allows Balance Manipulation Leading to Connector Undercollateralization

## Summary
The `EnableConnector` function lacks access control and relies on manipulable state when calculating required base token deposits via `GetNeededDeposit()`. An attacker can transfer resource tokens to the TokenConverter contract before or during the enabling process, artificially inflating the contract's token balance. This causes the deposit calculation to return zero or insufficient amounts, resulting in undercollateralized connectors where late sellers cannot withdraw their base tokens.

## Finding Description

The vulnerability exists in `EnableConnector` [1](#0-0)  which lacks the `AssertPerformedByConnectorController()` access control check present in other administrative functions like `UpdateConnector` [2](#0-1) , `AddPairConnector` [3](#0-2) , and `SetFeeRate` [4](#0-3) .

The `GetNeededDeposit` function reads the current token balance from state [5](#0-4)  and calculates `amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert`. If the `balance` is artificially inflated through external token transfers, this calculation produces zero or artificially low values for tokens requiring backing.

When `EnableConnector` executes, it directly sets `DepositBalance` to the calculated `needDeposit.NeedAmount` [6](#0-5)  without validation. This creates an undercollateralized connector where the resource token balance in the contract far exceeds the available base token reserves.

The undercollateralization manifests when users attempt to sell resource tokens. The `Sell` function attempts to transfer base tokens [7](#0-6)  and decrements `DepositBalance`. When `DepositBalance` is insufficient, these transactions fail, preventing late sellers from exiting their positions.

**Attack Flow:**
1. Attacker obtains resource tokens (e.g., 500,000 tokens of a 1,000,000 total supply)
2. Attacker transfers these tokens to TokenConverter contract address
3. Legitimate user (or attacker themselves) calls `EnableConnector` with `AmountToTokenConvert = 500,000`
4. `GetNeededDeposit` calculates: 1,000,000 - 500,000 - 500,000 = 0 tokens need backing
5. `needDeposit.NeedAmount = 0`
6. `DepositBalance` set to 0 while 1,000,000 resource tokens are tradeable
7. Early buyers purchase resource tokens at artificially low prices (low reserves in Bancor formula)
8. When buyers attempt to sell, insufficient `DepositBalance` causes transaction failures

## Impact Explanation

This vulnerability breaks the fundamental collateralization invariant of the TokenConverter system. The `DepositBalance` represents actual base token reserves that back resource tokens [8](#0-7) . When this reserve is set to zero or insufficient values while resource tokens exist in the contract, the Bancor pricing mechanism [9](#0-8)  uses artificially low reserve balances, enabling early buyers to drain resource tokens at undervalued prices.

**Direct User Fund Loss:**
- Late sellers cannot withdraw base tokens because `DepositBalance` is depleted
- The base token transfer in `Sell` will fail when insufficient reserves exist
- Users holding resource tokens are effectively locked in with no exit path

**Protocol Impact:**
- Connector becomes insolvent - cannot fulfill withdrawal obligations
- Resource tokens sold at massive discounts (loss to original enabler)
- Protocol reputation and trust severely damaged

The severity is HIGH because this causes direct, measurable user fund loss through insolvency.

## Likelihood Explanation

**Entry Point:** `EnableConnector` is publicly callable with no authorization checks, as confirmed by test cases that directly invoke it without governance setup [10](#0-9) .

**Preconditions:**
1. Connector pair added via governance (realistic - normal protocol operation)
2. Resource tokens exist and are transferable (always true for standard tokens)
3. Attacker has access to resource tokens (can acquire from market or hold natively)

**Execution:**
The attack requires either:
- MEV frontrunning: Monitor mempool for `EnableConnector` transactions and frontrun with token transfer
- Direct manipulation: Attacker themselves calls `EnableConnector` after transferring tokens

Both scenarios are technically feasible on AElf blockchain with standard transaction ordering.

**Economic Consideration:**
While the attacker loses the transferred tokens, this is NOT a "self-harm only" scenario because:
- It causes direct harm to OTHER users (late sellers)
- It breaks protocol invariants (undercollateralization)
- Potential profit scenarios exist (shorting the token, collusion with early buyers)
- Can be executed as pure griefing attack

The likelihood is MEDIUM-HIGH given the lack of access control and the manipulable state reading pattern.

## Recommendation

**Immediate Fix:**
Add access control to `EnableConnector`:
```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    AssertPerformedByConnectorController(); // Add this check
    var fromConnector = State.Connectors[input.TokenSymbol];
    // ... rest of function
}
```

**Additional Protections:**
1. Validate that contract's resource token balance is zero or minimal before enabling
2. Add a check that connectors are not already enabled (prevent re-enabling)
3. Implement minimum deposit requirements based on `VirtualBalance` ratios
4. Consider using a snapshot mechanism or committed values rather than current balance
5. Add events and monitoring for abnormal balance states before connector activation

**Enhanced Version:**
```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    AssertPerformedByConnectorController();
    
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    // Prevent re-enabling
    Assert(!fromConnector.IsPurchaseEnabled && !toConnector.IsPurchaseEnabled,
        "Connector already enabled");
    
    // Validate unexpected balance
    var currentBalance = State.TokenContract.GetBalance.Call(
        new GetBalanceInput { Owner = Context.Self, Symbol = input.TokenSymbol }).Balance;
    Assert(currentBalance == 0 || currentBalance <= input.AmountToTokenConvert,
        "Unexpected token balance in contract");
    
    var needDeposit = GetNeededDeposit(input);
    
    // Enforce minimum deposit
    Assert(needDeposit.NeedAmount > 0 || input.AmountToTokenConvert == GetTotalSupply(input.TokenSymbol),
        "Insufficient backing deposit");
    
    // ... rest of function
}
```

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_Balance_Manipulation_Undercollateralization_Test()
{
    // Setup: Initialize converter and create token
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "VULN";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Issue 1M tokens total supply
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 1_000_000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    // Attack: Transfer 500k tokens to converter contract BEFORE enabling
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = TokenConverterContractAddress,
        Symbol = tokenSymbol,
        Amount = 500_000
    });
    
    // Now enable with remaining 500k tokens
    var enableInput = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 500_000
    };
    
    // Check needed deposit - should be 0 due to manipulation
    var deposit = await DefaultStub.GetNeededDeposit.CallAsync(enableInput);
    deposit.NeedAmount.ShouldBe(0); // Vulnerability: no deposit required!
    deposit.AmountOutOfTokenConvert.ShouldBe(0); // Manipulated to zero
    
    // Enable connector with ZERO backing
    await DefaultStub.EnableConnector.SendAsync(enableInput);
    
    // Verify: 1M tokens in contract but DepositBalance is 0
    var contractBalance = await GetBalanceAsync(tokenSymbol, TokenConverterContractAddress);
    contractBalance.ShouldBe(1_000_000);
    
    var depositBalance = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    // DepositBalance should include backing, but VirtualBalance is constant parameter
    // Real reserves (DepositBalance) is 0 - UNDERCOLLATERALIZED
    
    // Impact: Early buyer can drain tokens cheaply, late sellers cannot exit
}
```

## Notes

This vulnerability fundamentally breaks the TokenConverter's collateralization guarantee. The combination of missing access control and reliance on manipulable state (current token balance) allows creation of insolvent connectors. While the attacker incurs a cost (lost tokens), the impact extends to innocent users who cannot withdraw, making this a valid HIGH severity issue rather than a self-harm scenario.

The fix requires both immediate access control addition and longer-term architectural improvements to prevent balance manipulation attacks.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L186-194)
```csharp
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-267)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
        var feeRate = AssertedDecimal(input.Value);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L67-73)
```csharp
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L377-399)
```csharp
    public async Task EnableConnector_Success_Test()
    {
        await DefaultStub.Initialize.SendAsync(new InitializeInput
        {
            FeeRate = "0.005"
        });
        var tokenSymbol = "NETT";
        await CreateTokenAsync(tokenSymbol);
        await AddPairConnectorAsync(tokenSymbol);
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Amount = 99_9999_0000,
            To = DefaultSender,
            Symbol = tokenSymbol
        });
        var toBeBuildConnectorInfo = new ToBeConnectedTokenInfo
        {
            TokenSymbol = tokenSymbol,
            AmountToTokenConvert = 99_9999_0000
        };
        var deposit = await DefaultStub.GetNeededDeposit.CallAsync(toBeBuildConnectorInfo);
        deposit.NeedAmount.ShouldBe(100);
        await DefaultStub.EnableConnector.SendAsync(toBeBuildConnectorInfo);
```
