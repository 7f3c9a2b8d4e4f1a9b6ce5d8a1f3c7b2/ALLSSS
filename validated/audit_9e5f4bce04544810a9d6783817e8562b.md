# Audit Report

## Title
Treasury Accepts Unfavorable Prices Due to Missing Slippage Protection on Token Conversion

## Summary
The Treasury contract converts donated non-native tokens to native tokens without implementing slippage protection. When `ConvertToNativeToken` calls `TokenConverterContract.Sell`, it omits the `ReceiveLimit` parameter, which defaults to 0 and bypasses the price validation check. This allows the Treasury to accept arbitrarily unfavorable exchange rates, resulting in direct financial losses on every convertible token donation.

## Finding Description
The vulnerability exists in the token conversion flow when non-native tokens are donated to the Treasury. The `Donate` method is a public function with no access controls that determines if a donated token can be converted to the native token and triggers the conversion. [1](#0-0) 

The critical flaw occurs in the `ConvertToNativeToken` private method, which performs the actual conversion by calling the TokenConverter's `Sell` method. This call only passes the `Symbol` and `Amount` parameters, completely omitting the `ReceiveLimit` parameter: [2](#0-1) 

The `ReceiveLimit` parameter in the `SellInput` message is specifically designed to provide slippage protection. According to the protocol definition, it represents the minimum amount of base tokens that must be received, with the comment "And 0 is no limit": [3](#0-2) 

In the TokenConverter's `Sell` method implementation, the price validation check uses an OR condition that bypasses validation when `ReceiveLimit` equals 0: [4](#0-3) 

Since the first condition `input.ReceiveLimit == 0` evaluates to true when no limit is set, the entire assertion passes regardless of the actual exchange rate received. This means the Treasury will accept any price the Bancor formula calculates, no matter how unfavorable.

The Bancor pricing formula is deterministic and directly depends on connector balances, making it predictable and manipulable through trades: [5](#0-4) 

## Impact Explanation
This vulnerability results in direct financial loss to the Treasury, which is a critical protocol component holding significant value for distribution to miners, voters, and other stakeholders.

**Direct Financial Loss**: On every donation of convertible non-native tokens, the Treasury accepts whatever exchange rate exists at the moment of execution, with zero protection against:
- Deliberately manipulated prices (attacker front-runs with trades to worsen the rate)
- Normal market volatility (price moves unfavorably between donation initiation and execution)
- Large donation slippage (no minimum received amount means accepting poor rates on large conversions)

**Cumulative Impact**: The losses compound over time, directly reducing:
- Mining rewards available for distribution
- Subsidy pools for candidates
- Welfare rewards for citizens/voters
- Overall protocol economic sustainability

The Treasury is the primary dividend pool scheme that distributes rewards to miners, candidates, and voters as documented in the contract, making any financial loss critical to protocol operations. [6](#0-5) 

## Likelihood Explanation
**High Likelihood** - The vulnerability is easily exploitable because:

1. **Public Entry Point**: The `Donate` method has no access controls beyond basic amount validation - anyone can trigger token donations and conversions. The method intentionally accepts donations from any address, only requiring token approval. [7](#0-6) 

2. **Deterministic Price Calculation**: The Bancor formula is completely deterministic and publicly calculable. Anyone can predict the exact impact of trades on conversion rates by reading connector balances on-chain.

3. **No Price Protection**: The complete absence of slippage protection means the Treasury accepts ANY rate calculated by the Bancor formula, making it vulnerable to both malicious price manipulation and normal market volatility.

4. **Repeatable Exploitation**: The attack can be executed on every donation transaction, making this a persistent drain on Treasury resources rather than a one-time exploit.

5. **Low Attack Barriers**: 
   - No privileged access required
   - Anyone can trade on TokenConverter to influence prices
   - Simple timing or direct donation triggering enables exploitation

## Recommendation
The `ConvertToNativeToken` method should implement slippage protection by setting a minimum acceptable `ReceiveLimit` before calling `TokenConverter.Sell`. This can be achieved by:

1. **Calculate Expected Return**: Before conversion, query the current Bancor price to calculate the expected amount of native tokens to receive
2. **Apply Slippage Tolerance**: Set a reasonable slippage tolerance (e.g., 1-5%) below the expected return
3. **Pass ReceiveLimit**: Include the calculated minimum amount as the `ReceiveLimit` parameter in the `SellInput`

Example fix for the `ConvertToNativeToken` method:
```csharp
private void ConvertToNativeToken(string symbol, long amount)
{
    // Calculate expected return with slippage protection
    var pairConnector = State.TokenConverterContract.GetPairConnector.Call(new TokenSymbol { Symbol = symbol });
    var expectedReturn = CalculateExpectedReturn(pairConnector, amount);
    var minReceiveAmount = expectedReturn.Mul(95).Div(100); // 5% slippage tolerance

    State.TokenContract.Approve.Send(new ApproveInput
    {
        Spender = State.TokenConverterContract.Value,
        Symbol = symbol,
        Amount = amount
    });

    State.TokenConverterContract.Sell.Send(new SellInput
    {
        Symbol = symbol,
        Amount = amount,
        ReceiveLimit = minReceiveAmount // Add slippage protection
    });

    Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
    {
        Symbol = Context.Variables.NativeSymbol
    });
}
```

## Proof of Concept
A test case demonstrating the vulnerability would:
1. Set up a TokenConverter pair with known connector balances
2. Manipulate the price by executing trades to move the connector balances unfavorably
3. Call `Treasury.Donate` with a convertible token
4. Verify the Treasury receives significantly less native tokens than expected due to the manipulated price
5. Compare this to a protected scenario where `ReceiveLimit` is properly set and the transaction reverts with "Price not good."

The test would show that without slippage protection, the Treasury accepts the unfavorable manipulated price, while with proper `ReceiveLimit` validation, the transaction would fail, protecting Treasury funds.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L18-39)
```csharp
/// <summary>
///     The Treasury is the largest profit scheme in AElf main chain.
///     Actually the Treasury is our Dividends Pool.
///     Income of the Treasury is mining rewards
///     (AEDPoS Contract will:
///     1. transfer ELF tokens to general ledger of Treasury every time we change term (7 days),
///     the amount of ELF should be based on blocks produced during last term. 1,000,000 * 1250000 ELF,
///     then release the Treasury;
///     2. Release Treasury)
///     3 sub profit schemes:
///     (Mining Reward for Miners) - 3
///     (Subsidy for Candidates / Backups) - 1
///     (Welfare for Electors / Voters / Citizens) - 1
///     3 sub profit schemes for Mining Rewards:
///     (Basic Rewards) - 4
///     (Welcome Rewards) - 1
///     (Flexible Rewards) - 1
///     3 incomes:
///     1. 20% total supply of elf, from consensus contract
///     2. tx fees.
///     3. resource consumption of developer's contracts.
/// </summary>
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L174-208)
```csharp
    public override Empty Donate(DonateInput input)
    {
        Assert(input.Amount > 0, "Invalid amount of donating. Amount needs to be greater than 0.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        var isNativeSymbol = input.Symbol == Context.Variables.NativeSymbol;
        var canExchangeWithNativeSymbol =
            isNativeSymbol ||
            State.TokenConverterContract.IsSymbolAbleToSell
                .Call(new StringValue { Value = input.Symbol }).Value;

        if (Context.Sender != Context.Self)
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = Context.Self,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = "Donate to treasury."
            });

        var needToConvert = !isNativeSymbol && canExchangeWithNativeSymbol;
        if (needToConvert)
        {
            ConvertToNativeToken(input.Symbol, input.Amount);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L667-686)
```csharp
    private void ConvertToNativeToken(string symbol, long amount)
    {
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.TokenConverterContract.Value,
            Symbol = symbol,
            Amount = amount
        });

        State.TokenConverterContract.Sell.Send(new SellInput
        {
            Symbol = symbol,
            Amount = amount
        });

        Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
        {
            Symbol = Context.Variables.NativeSymbol
        });
    }
```

**File:** protobuf/token_converter_contract.proto (L135-143)
```text
message SellInput {
    // The token symbol you want to sell.
    string symbol = 1;
    // The amount you want to sell.
    int64 amount = 2;
    // Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned.
    // And 0 is no limit.
    int64 receive_limit = 3;
}
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-180)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L24-54)
```csharp
    ///     Get token return:
    ///     Return = (1 - (fromConnectorBalance / (fromConnectorBalance + paidAmount))
    ///     ^(fromConnectorWeight/toConnectorWeight))*toConnectorBalance
    /// </summary>
    /// <param name="fromConnectorBalance"></param>
    /// <param name="fromConnectorWeight"></param>
    /// <param name="toConnectorBalance"></param>
    /// <param name="toConnectorWeight"></param>
    /// <param name="paidAmount"></param>
    /// <returns></returns>
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```
