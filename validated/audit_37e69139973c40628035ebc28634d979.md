# Audit Report

## Title
IsUserContract Flag Manipulation via Incorrect Update Path Bypasses ACS Requirements

## Summary
User contract authors can permanently bypass required ACS (AElf Contract Standard) security validations by updating their contracts through the standard contract update path (`ProposeUpdateContract`) instead of the user contract update path (`UpdateUserSmartContract`). This permanently flips the `IsUserContract` flag to false, exempting the contract from all future user contract validation requirements.

## Finding Description

The AElf Genesis contract provides two distinct update paths:
1. **Standard path**: `ProposeUpdateContract` → `UpdateSmartContract` 
2. **User contract path**: `UpdateUserSmartContract` → `PerformUpdateUserSmartContract`

The vulnerability exists because `ProposeUpdateContract` does not validate whether a contract is a user contract and should be using the user contract update path. When a user contract author calls `ProposeUpdateContract`, the authorization check passes because the method allows contract authors [1](#0-0) , but the method creates a `ContractCodeCheckInput` without an `IsUserContract` field [2](#0-1) .

The `ContractCodeCheckInput` protobuf message does not include an `IsUserContract` field [3](#0-2) . When `ProposeContractCodeCheck` fires the `CodeCheckRequired` event, the `IsUserContract` field remains unset and defaults to false in protobuf [4](#0-3) .

The code check service uses this flag to determine whether to enforce user contract ACS requirements. When `isUserContract` is false, it uses an empty `RequiredAcs` list, completely bypassing user contract validation [5](#0-4) .

After code check approval, `UpdateSmartContract` is called with a hardcoded `false` parameter [6](#0-5) , which unconditionally overwrites the `IsUserContract` flag in contract state [7](#0-6) .

**Attack Execution:**
1. User contract author calls `ProposeUpdateContract` (has authorization as contract author)
2. Parliament governance approves the proposal (normal for contract updates)
3. Code check processes with `IsUserContract = false`, bypassing user contract ACS requirements
4. `UpdateSmartContract` permanently sets `info.IsUserContract = false`
5. All future updates continue without user contract validation

## Impact Explanation

This vulnerability undermines the fundamental security model for user contracts in AElf. User contracts are designed to enforce stricter ACS validation requirements to ensure code quality and security standards.

**Concrete harms:**
- User contracts can deploy code violating required ACS standards (e.g., ACS12 User Contract Standard)
- Malicious or vulnerable code can be introduced without proper validation
- The bypass is **permanent** - the flag persists across all subsequent updates
- Completely breaks the trust model for user contract security
- Affects all users and systems interacting with the compromised contract
- No visibility into the flag manipulation during governance review

The authorization check validates identity but not whether the update path matches the contract type, enabling this bypass.

## Likelihood Explanation

**Likelihood: High**

**Required capabilities:**
- Must be the contract author (stored in ContractInfo.Author)
- Must obtain Parliament governance approval

**Why this is realistic:**
- Contract authors routinely update contracts for maintenance and features
- The wrong update path can be used accidentally (developer confusion) or intentionally (malicious bypass)
- Both `ProposeUpdateContract` and `UpdateUserSmartContract` appear to be legitimate update methods
- Governance reviewers cannot detect the flag manipulation without deep knowledge of Genesis contract internals
- The `CodeCheckReleaseMethod` parameter determines the path, but this is not visible to reviewers
- No warnings, documentation, or UI guidance distinguishes when each method should be used
- The vulnerability is silent - no errors or events indicate the contract type is changing

## Recommendation

Add validation in `ProposeUpdateContract` to prevent user contracts from using the standard update path:

```csharp
public override Hash ProposeUpdateContract(ContractUpdateInput input)
{
    var proposedContractInputHash = CalculateHashFromInput(input);
    RegisterContractProposingData(proposedContractInputHash);

    var contractAddress = input.Address;
    var info = State.ContractInfos[contractAddress];
    Assert(info != null, "Contract not found.");
    
    // ADD THIS CHECK:
    Assert(!info.IsUserContract, "User contracts must use UpdateUserSmartContract method.");
    
    AssertAuthorityByContractInfo(info, Context.Sender);
    AssertContractVersion(info.ContractVersion, input.Code, info.Category);
    // ... rest of method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task UserContract_CanBypass_ACSValidation_Via_ProposeUpdateContract()
{
    // Setup: Deploy a user contract on side chain
    StartSideChain("ELF");
    await AddZeroContractToProposerWhiteListAsync();
    
    var userContractDeploymentInput = new UserContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory, 
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
    };

    var deployResult = await SideChainTester.ExecuteContractWithMiningAsync(
        SideBasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.DeployUserSmartContract), 
        userContractDeploymentInput);
    
    var proposalId = ProposalCreated.Parser.ParseFrom(
        deployResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed).ProposalId;
    
    await ApproveWithMinersAsync(SideChainTester, SideParliamentAddress, proposalId);
    
    var releaseResult = await ReleaseUserContractProposal(proposalId);
    var contractAddress = ContractDeployed.Parser.ParseFrom(
        releaseResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).NonIndexed).Address;
    
    // Verify it's initially a user contract
    var info1 = await GetContractInfo(contractAddress);
    info1.IsUserContract.ShouldBeTrue();
    
    // EXPLOIT: Update using ProposeUpdateContract instead of UpdateUserSmartContract
    var updateInput = new ContractUpdateInput
    {
        Address = contractAddress,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenHolder")).Value)
    };
    
    var updateResult = await SideChainTester.ExecuteContractWithMiningAsync(
        SideBasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.ProposeUpdateContract), 
        updateInput);
    
    // Check that CodeCheckRequired event has IsUserContract = false
    var codeCheckEvent = CodeCheckRequired.Parser.ParseFrom(
        updateResult.Logs.First(l => l.Name.Contains(nameof(CodeCheckRequired))).NonIndexed);
    codeCheckEvent.IsUserContract.ShouldBeFalse(); // ❌ Bypass detected!
    
    // Complete the update through governance
    proposalId = ProposalCreated.Parser.ParseFrom(
        updateResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed).ProposalId;
    await ApproveWithMinersAsync(SideChainTester, SideParliamentAddress, proposalId);
    
    releaseResult = await ReleaseCodeCheckProposal(proposalId);
    
    // VERIFY: IsUserContract flag permanently flipped to false
    var info2 = await GetContractInfo(contractAddress);
    info2.IsUserContract.ShouldBeFalse(); // ❌ Permanent bypass confirmed!
    info2.Version.ShouldBe(2);
    
    // All future updates now bypass user contract validation
}
```

## Notes

This vulnerability affects the core security model for user contracts in AElf. The issue stems from the architectural decision to have separate update paths but insufficient validation to enforce their proper usage. The protobuf message structure for `ContractCodeCheckInput` not including an `IsUserContract` field means the standard update path cannot correctly signal user contract status, leading to the default false value bypassing validation requirements.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L110-110)
```csharp
        info.IsUserContract = isUserContract;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L209-216)
```csharp
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = info.Category,
                    IsSystemContract = info.IsSystemContract
                }.ToByteString(),
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L266-272)
```csharp
        Context.Fire(new CodeCheckRequired
        {
            Code = ExtractCodeFromContractCodeCheckInput(input),
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = input.IsSystemContract
        });
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L334-334)
```csharp
        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);
```

**File:** protobuf/acs0.proto (L209-222)
```text
message ContractCodeCheckInput{
    // The byte array of the contract code to be checked.
    bytes contract_input = 1;
    // Whether the input contract is to be deployed or updated.
    bool is_contract_deployment = 2;
    // Method to call after code check complete(DeploySmartContract or UpdateSmartContract).
    string code_check_release_method = 3;
    // The id of the proposed contract.
    aelf.Hash proposed_contract_input_hash = 4;
    // The category of contract code(0: C#).
    sint32 category = 5;
    // Indicates if the contract is the system contract.
    bool is_system_contract = 6;
}
```

**File:** src/AElf.Kernel.CodeCheck/Application/CodeCheckService.cs (L37-40)
```csharp
        if (isUserContract)
        {
            requiredAcs = await _requiredAcsProvider.GetRequiredAcsInContractsAsync(blockHash, blockHeight);
        }
```
