# Audit Report

## Title
Unbounded OrganizationMemberList Size Enables Execution Limit DoS on Association Governance Operations

## Summary
The Association contract lacks validation for the maximum size of `OrganizationMemberList`, allowing creation of organizations with thousands of members constrained only by the 128KB state limit. During proposal release operations, O(m×n) complexity in membership verification causes transactions to exceed AElf's 15,000 branch count execution threshold, resulting in permanent denial-of-service of affected organizations' governance functions.

## Finding Description

The vulnerability stems from missing size validation in organization creation combined with quadratic-complexity membership checks during proposal operations.

**Missing Size Validation:**
The `Validate()` function checks that `OrganizationMemberList` is not empty and contains no duplicates, but imposes no maximum size limit [1](#0-0) . The `AssociationConstants` file only defines limits for string fields with no member count restrictions [2](#0-1) . Organizations are constrained only by the 128KB state size limit [3](#0-2) , which permits approximately 3,500 addresses.

**O(n) Membership Checks:**
The `Contains()` method uses protobuf's `RepeatedField.Contains()` [4](#0-3) , which has O(n) complexity, iterating through all members for each check.

**O(m×n) Complexity in Release:**
During proposal release, `IsReleaseThresholdReached()` performs three critical checks [5](#0-4) :

1. `IsProposalRejected()` executes `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)` [6](#0-5) 
2. `IsProposalAbstained()` executes `proposal.Abstentions.Count(organization.OrganizationMemberList.Contains)` [7](#0-6) 
3. `CheckEnoughVoteAndApprovals()` executes `proposal.Approvals.Count(organization.OrganizationMemberList.Contains)` [8](#0-7) 

Each `Count(predicate)` operation iterates through all votes (m) and for each vote calls `Contains()` which iterates through all members (n), resulting in m×n iterations per check.

**Branch Limit Exceeded:**
AElf enforces a 15,000 branch count execution limit [9](#0-8)  that throws `RuntimeBranchThresholdExceededException` when exceeded [10](#0-9) . The patching system injects branch counting before all backward jumps (loops) [11](#0-10) , and tests confirm that foreach loops with 14,999 iterations succeed while 15,000 iterations fail [12](#0-11) .

With just 50 votes and 300 members, a single check reaches 15,000 branches (50 × 300 = 15,000), causing immediate transaction failure.

**Unrestricted Creation:**
Anyone can create organizations via the public `CreateOrganization()` method [13](#0-12) , which only validates through the flawed `Validate()` function. Additionally, `AddMember()` can incrementally add members post-creation [14](#0-13) .

## Impact Explanation

**Complete Governance DoS:**
Organizations with excessive member counts become permanently unusable. The `Release()` function will always fail when checking `IsReleaseThresholdReached()` [15](#0-14)  due to the O(m×n) complexity exceeding the 15,000 branch limit.

**Permanent State:**
No recovery mechanism exists. Once an organization exceeds safe size limits, all proposals become unreleasable regardless of approval status. Members waste transaction fees voting on proposals that can never execute.

**Affected Parties:**
- Organization members unable to execute governance decisions
- Protocols depending on Association organizations for authorization
- Well-intentioned large organizations accidentally creating unusable structures

**Attack Scenarios:**
1. **Malicious DoS**: Attacker creates dysfunctional organization, tricks users into joining/voting
2. **Protocol Sabotage**: If system functions use Association organizations, attacker creates permanent DoS vector
3. **Accidental DoS**: Legitimate organizations with 1,000+ members unknowingly render themselves unusable

**Severity Justification:** Medium - Complete breakdown of governance functionality with no recovery path, though funds are not directly stolen or locked.

## Likelihood Explanation

**Attacker Requirements:**
- Public access to `CreateOrganization()` (no permissions required)
- Transaction fees for organization creation
- List of addresses to populate member list (can be attacker-controlled or arbitrary)

**Attack Complexity:** Low
1. Construct `CreateOrganizationInput` with large member list
2. Call `CreateOrganization()`
3. Organization immediately dysfunctional for proposal release

**Numerical Analysis:**
- 50 votes × 300 members = 15,000 branches (exactly at limit for ONE check)
- 17 votes × 900 members = 15,300 branches (exceeds limit in first check)
- 100 votes × 150 members = 15,000 branches (exactly at limit for ONE check)

**Economic Feasibility:**
- Attack cost: One transaction fee
- Attack benefit: Permanent governance DoS
- Cost-to-impact ratio highly favorable for griefing/sabotage

**Detection:** Organizations with >500 members should be considered high-risk, but no contract-level prevention exists.

## Recommendation

Add maximum member count validation to prevent creation of organizations that cannot function:

```csharp
private bool Validate(Organization organization)
{
    const int MaxOrganizationMembers = 100; // Safe limit based on branch threshold
    
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate() ||
        organization.OrganizationMemberList.Count() > MaxOrganizationMembers)
        return false;
    // ... rest of validation
}
```

Additionally, optimize membership checks by using a HashSet for O(1) lookups instead of O(n) linear searches, or implement early-exit logic in the release threshold checks.

## Proof of Concept

```csharp
[Fact]
public async Task Test_LargeOrganization_Release_DoS()
{
    // Create organization with 300 members
    var memberList = new OrganizationMemberList();
    for (int i = 0; i < 300; i++)
    {
        memberList.OrganizationMembers.Add(GenerateAddress());
    }
    
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(
        new CreateOrganizationInput
        {
            OrganizationMemberList = memberList,
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 1,
                MinimalVoteThreshold = 1
            },
            ProposerWhiteList = new ProposerWhiteList { Proposers = { DefaultSender } }
        });
    
    // Create and approve proposal
    var proposalId = await CreateProposalAsync(organizationAddress.Output);
    
    // Have 50 members vote
    for (int i = 0; i < 50; i++)
    {
        await ApproveProposalAsync(proposalId, memberList.OrganizationMembers[i]);
    }
    
    // Attempt release - should fail with RuntimeBranchThresholdExceededException
    // 50 votes × 300 members = 15,000 branches in first check alone
    var result = await AssociationContractStub.Release.SendWithExceptionAsync(proposalId);
    result.TransactionResult.Error.ShouldContain("RuntimeBranchThresholdExceededException");
}
```

**Notes:**

The vulnerability is mathematically certain due to the quadratic complexity of the membership verification algorithm combined with the fixed 15,000 branch execution limit. Even moderate-sized organizations (300 members with 50 votes) will exceed this threshold during proposal release operations. The issue is exacerbated by the lack of any maximum size validation during organization creation, allowing creation of organizations that are fundamentally incapable of releasing proposals. This represents a critical design flaw in the Association governance system that results in permanent denial-of-service with no recovery mechanism.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationConstants.cs (L1-8)
```csharp
namespace AElf.Contracts.Association;

public static class AssociationConstants
{
    public const int MaxLengthForTitle = 255;
    public const int MaxLengthForDescription = 10200;
    public const int MaxLengthForProposalDescriptionUrl = 255;
}
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-36)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
    }
```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/CallAndBranchCounts/Patcher.cs (L78-93)
```csharp
    private void InsertBranchCountForAllBranches(ILProcessor processor)
    {
        static bool IsValidInstruction(Instruction instruction)
        {
            var targetInstruction = (Instruction) instruction.Operand;
            return targetInstruction.Offset < instruction.Offset; // What does this mean?
        }

        foreach (var instruction in AllBranchingInstructions.Where(IsValidInstruction))
        {
            var jumpingDestination = (Instruction) instruction.Operand;
            var callBranchCountMethod = processor.Create(OpCodes.Call, _proxy.BranchCountMethod);
            processor.InsertBefore(jumpingDestination, callBranchCountMethod);
            instruction.Operand = callBranchCountMethod;
        }
    }
```

**File:** test/AElf.Contracts.TestContract.Tests/PatchedContractSecurityTests.cs (L428-434)
```csharp
            await TestBasicSecurityContractStub.TestForeachInfiniteLoop.SendAsync(new ListInput
                { List = { new int[14999] } });
            var txResult =
                await TestBasicSecurityContractStub.TestForeachInfiniteLoop.SendWithExceptionAsync(
                    new ListInput { List = { new int[15000] } });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
