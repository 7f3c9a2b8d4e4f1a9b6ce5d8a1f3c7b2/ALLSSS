# Audit Report

## Title
Mining Order Manipulation via Unvalidated TuneOrderInformation in UpdateValue

## Summary
A malicious miner can manipulate the mining order for the next consensus round by providing arbitrary `FinalOrderOfNextRound` values through consensus block header data. The `ProcessUpdateValue` method applies `TuneOrderInformation` to state without validation, allowing attackers to control mining positions and disrupt the consensus schedule.

## Finding Description

The AEDPoS consensus mechanism allows miners to tune the mining order for the next round to resolve conflicts when multiple miners calculate the same supposed order. However, the validation pipeline fails to verify that these tuned orders are legitimate.

The `ProcessUpdateValue` method directly applies `TuneOrderInformation` from the input without validating that the order values are necessary or correctly calculated: [1](#0-0) 

The intended behavior, shown in `ExtractInformationToUpdateConsensus`, is that `TuneOrderInformation` should only contain miners whose `FinalOrderOfNextRound` differs from `SupposedOrderOfNextRound` due to conflict resolution: [2](#0-1) 

However, no validation enforces this constraint. The validation pipeline for UpdateValue behavior includes:

1. `UpdateValueValidationProvider` which only validates cryptographic fields (OutValue, Signature, PreviousInValue): [3](#0-2) 

2. `NextRoundMiningOrderValidationProvider` exists to validate `FinalOrderOfNextRound` consistency, but is ONLY added for NextRound behavior, not UpdateValue: [4](#0-3) 

3. During validation, `RecoverFromUpdateValue` blindly copies `FinalOrderOfNextRound` values without checking their legitimacy: [5](#0-4) 

When the next round is generated, `GenerateNextRoundInformation` uses the manipulated `FinalOrderOfNextRound` values to determine mining order: [6](#0-5) 

The `UpdateValue` method is public and accepts `UpdateValueInput` which includes the tune_order_information field: [7](#0-6) 

## Impact Explanation

This vulnerability breaks a critical consensus invariant: **miner schedule integrity**. The AEDPoS consensus guarantees that mining order is determined by cryptographic randomness (signature-based calculation), ensuring fair and unpredictable block producer rotation.

A malicious miner can:
- Set their own `FinalOrderOfNextRound` to 1 to mine first in the next round, gaining priority access to transactions and extra block producer benefits
- Manipulate other miners' orders to disadvantage competitors or create favorable time slots  
- Create duplicate order values (e.g., multiple miners with order 1), causing the next round generation logic to produce invalid mining schedules
- Set invalid orders (e.g., orders > miner count), potentially causing issues when `GenerateNextRoundInformation` calculates available orders

The impact severity is **HIGH** because:
- All miners in the network suffer from unfair schedule manipulation
- The network loses consensus fairness and predictability
- Transaction ordering can be manipulated if the attacker consistently mines first
- The core consensus mechanism's integrity is compromised without requiring cryptographic attacks

## Likelihood Explanation

**Attacker Capabilities**: Must be a legitimate miner with mining permissions. This is a realistic precondition in a DPoS system where miners are elected but may have economic incentives to gain unfair advantages.

**Attack Complexity**: LOW. A malicious miner modifies their local block production code to manipulate `FinalOrderOfNextRound` values in the consensus header before producing blocks. No cryptographic challenges, complex state manipulation, or additional privileges are required beyond normal mining operations.

**Economic Rationality**: High probability of exploitation because:
- No additional cost beyond normal mining operations
- Potential benefits include mining first (capturing MEV, extra rewards) or disadvantaging competitors
- Detection is difficult as manipulation occurs within consensus data

**Execution Practicality**: The attack is directly executable by any miner through modification of local consensus data generation.

## Recommendation

Add `NextRoundMiningOrderValidationProvider` to the validation pipeline for UpdateValue behavior, not just NextRound. This validator checks that miners with `FinalOrderOfNextRound > 0` match miners with `OutValue != null`, ensuring only miners who produced blocks can set next round orders.

Modify the validation setup in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.UpdateValue:
    validationProviders.Add(new UpdateValueValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider()); // Add this
    break;
```

Additionally, consider adding specific validation to verify that `TuneOrderInformation` entries only exist for actual order conflicts (where `FinalOrderOfNextRound != SupposedOrderOfNextRound`).

## Proof of Concept

A test would demonstrate:
1. A miner producing a block with UpdateValue behavior
2. Setting arbitrary `FinalOrderOfNextRound` values in `TuneOrderInformation`  
3. The block being validated and accepted
4. The next round using the manipulated mining order
5. Verification that `NextRoundMiningOrderValidationProvider` is not invoked for UpdateValue

The test would show the manipulated orders are applied to state and used in subsequent round generation without rejection by the validation pipeline.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-87)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
