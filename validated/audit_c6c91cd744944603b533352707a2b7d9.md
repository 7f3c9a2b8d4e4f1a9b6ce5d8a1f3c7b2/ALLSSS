# Audit Report

## Title
Approved Proposals Can Be Cleared Before Execution Due to Missing Release Threshold Check

## Summary
The `ClearProposal` function in Parliament, Association, and Referendum contracts allows anyone to permanently delete fully approved proposals after expiration without validating approval status. This breaks the fundamental governance invariant that approved proposals should be executable, creating a race condition where legitimate governance decisions can be destroyed before execution.

## Finding Description

The `ClearProposal` method in all three governance contracts only validates expiration without checking whether the proposal reached its release threshold:

**Parliament Contract:** [1](#0-0) 

**Association Contract:** [2](#0-1) 

**Referendum Contract:** [3](#0-2) 

All three contracts implement comprehensive approval validation through `IsReleaseThresholdReached`:

**Parliament approval check:** [4](#0-3) 

**Association approval check:** [5](#0-4) 

**Referendum approval check:** [6](#0-5) 

The `Release` method correctly validates both non-expiration and approval status:

**Parliament Release:** [7](#0-6) 

**Association Release:** [8](#0-7) 

**Referendum Release:** [9](#0-8) 

However, `Release` can only be called on non-expired proposals because `GetValidProposal` enforces expiration checks:

**Parliament validation:** [10](#0-9) 

**Association validation:** [11](#0-10) 

**Referendum validation:** [12](#0-11) 

This creates an unrecoverable race condition:
1. Proposal created with standard 1-day expiration [13](#0-12) 
2. Members vote and proposal reaches release threshold (ToBeReleased = true)
3. If expiration occurs before proposer calls `Release`, the proposal can NEVER be released
4. Anyone can then call `ClearProposal` and permanently delete the approved proposal

Test evidence confirms expired proposals can be cleared, but no tests validate the approved+expired scenario:

**Association test only validates expiration, not approval status:** [14](#0-13) 

## Impact Explanation

**High Impact on Governance Integrity:**

- **Broken Governance Invariant:** The semantic guarantee that approved proposals (ToBeReleased = true) can be executed is violated. Proposals that successfully reach consensus become permanently unexecutable and deletable after expiration.

- **Complete Loss of Governance Work:** All voting effort, time, and consensus-building resources are wasted. Stakeholders who participated believing their approved decision would execute find their work nullified with no recovery path.

- **No Recovery Mechanism:** Deleted proposals cannot be restored. The entire governance process must restart: create new proposal, wait for voting period, re-collect all votes.

- **Griefing Attack Vector:** Malicious actors can deliberately prevent legitimate governance by monitoring for approved proposals and calling `ClearProposal` immediately after expiration. This is especially impactful for contentious proposals where adversaries want to block governance decisions.

- **DoS of Time-Sensitive Governance:** Emergency responses, urgent parameter adjustments, or time-critical system upgrades can be indefinitely delayed by forcing repeated proposal recreation.

- **System-Wide Impact:** Affects all three core governance mechanisms (Parliament for consensus governance, Association for multi-signature governance, Referendum for token-weighted governance).

## Likelihood Explanation

**Moderate-to-High Likelihood:**

**Zero Privilege Required:**
- `ClearProposal` is publicly callable by any address
- No authorization checks beyond expiration validation
- Zero economic cost beyond gas fees

**Realistic Operational Scenarios:**

1. **Network Congestion:** High transaction volume delays the proposer's `Release` transaction past the 1-day expiration window.

2. **Proposer Unavailability:** Proposer's monitoring infrastructure fails, or proposer is temporarily offline during the critical release window.

3. **Strategic Vote Timing:** Final approval vote arrives near expiration, leaving insufficient time for proposer to call `Release` before expiration.

4. **Key Management Issues:** Proposer experiences temporary key access issues during the narrow execution window.

5. **Deliberate Adversarial Action:** Opponents monitor blockchain state and immediately call `ClearProposal` upon expiration.

**Narrow Execution Window:**
- Standard 1-day expiration creates limited window between final approval and expiration
- Any delay results in permanent proposal loss
- Proposer must actively monitor and execute within this window

**Low Attack Complexity:**
- Single function call: `ClearProposal(proposalId)`
- No complex state manipulation required
- Easily automated via blockchain monitoring

## Recommendation

Add approval status validation to `ClearProposal` to prevent deletion of approved proposals:

```csharp
public override Empty ClearProposal(Hash input)
{
    var proposal = State.Proposals[input];
    Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
    
    // Prevent clearing approved proposals
    var organization = State.Organizations[proposal.OrganizationAddress];
    Assert(!IsReleaseThresholdReached(proposal, organization), "Cannot clear approved proposal");
    
    State.Proposals.Remove(input);
    return new Empty();
}
```

Alternative solution: Implement a grace period after approval where approved proposals remain executable for a fixed duration (e.g., 7 days) regardless of the original expiration time, allowing proposers sufficient time to execute approved decisions.

## Proof of Concept

```csharp
[Fact]
public async Task ApprovedProposal_CanBeCleared_AfterExpiration()
{
    // Create organization
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 2,
        minimalVoteThreshold: 2,
        maximalAbstentionThreshold: 1,
        maximalRejectionThreshold: 1
    );
    
    // Create proposal with 1 day expiration
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Vote to reach approval threshold
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    
    // Verify proposal is approved (ToBeReleased = true)
    var proposalOutput = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    Assert.True(proposalOutput.ToBeReleased);
    
    // Time passes, proposal expires
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddDays(2));
    
    // Release now fails due to expiration
    var releaseResult = await AssociationContractStub.Release.SendWithExceptionAsync(proposalId);
    Assert.Contains("Invalid proposal", releaseResult.TransactionResult.Error);
    
    // Anyone can clear the approved proposal
    var clearResult = await AssociationContractStub.ClearProposal.SendAsync(proposalId);
    Assert.Equal(TransactionResultStatus.Mined, clearResult.TransactionResult.Status);
    
    // Proposal is permanently deleted
    var deletedProposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    Assert.Equal(new ProposalOutput(), deletedProposal);
}
```

## Notes

This vulnerability represents a fundamental design flaw in the governance proposal lifecycle. The semantic meaning of `ToBeReleased = true` (visible via `GetProposal`) is that the proposal CAN be released, but after expiration this becomes false - the proposal can neither be released NOR can it be protected from deletion. This breaks the reasonable expectation that once governance consensus is reached, the decision should be executable. The issue affects all three governance systems identically, indicating a systemic design oversight rather than an isolated implementation bug.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTestBase.cs (L179-179)
```csharp
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L494-496)
```csharp
        //Clear expire proposal
        var result = await associationContractStub.ClearProposal.SendAsync(proposalId);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
```
