# Audit Report

## Title
Unauthorized Admin Takeover via AnnounceElectionFor Allows Arbitrary Public Key Hijacking

## Summary
The `AnnounceElectionFor` function in the Election contract lacks authorization checks, allowing any caller to register arbitrary public keys as candidates and assign themselves (or any address) as the admin. This breaks the fundamental security invariant that only the owner of a public key should be able to register it as a candidate.

## Finding Description

The `AnnounceElectionFor` function accepts an arbitrary `pubkey` string and optional `admin` address without verifying that the caller has permission to announce election for that public key. [1](#0-0) 

The function directly assigns the provided admin parameter (defaulting to `Context.Sender`) as the candidate admin without any consent mechanism from the public key owner. [2](#0-1) 

The internal validation only checks pubkey eligibility status (not initial miner, not already announced, not banned) but never validates caller authorization. [3](#0-2) 

**Contrast with Secure Implementation:**

The alternative `AnnounceElection(Address input)` method uses cryptographic signature verification (`Context.RecoverPublicKey()`) to ensure only the private key owner can announce. [4](#0-3) 

This secure pattern is completely missing from `AnnounceElectionFor`, creating the authorization bypass.

## Impact Explanation

**1. Unauthorized Administrative Control**

An attacker gains full admin privileges over candidates they don't own. Admin control includes:

- **Ability to quit election:** The `QuitElection` method enforces that only the admin can quit. [5](#0-4) 

- **Ability to replace the candidate's public key:** The `ReplaceCandidatePubkey` method requires admin authorization. [6](#0-5) 

- **Ability to set profit receivers:** The Treasury contract's `SetProfitsReceiver` validates that the caller is the candidate admin. [7](#0-6) 

**2. Permanent Registration DoS**

Once a pubkey is announced as a candidate, re-announcement is blocked while `IsCurrentCandidate` is true. [8](#0-7) 

The legitimate owner can never register their public key because the attacker has already registered it. Even after the attacker quits (which sets `IsCurrentCandidate = false`), they can immediately re-announce, creating a persistent griefing attack. [9](#0-8) 

**3. Election and Consensus Manipulation**

- Attacker can strategically quit elections to manipulate the miner selection process during term changes
- Voters may vote for hijacked candidates believing they're legitimate, locking tokens for candidates controlled by attackers
- The data center ranking system can be manipulated by controlling when candidates participate

## Likelihood Explanation

**Attacker Capabilities Required:**
- 100,000 ELF for the candidate lock
- Ability to call a public contract method
- Knowledge of target public key hex strings

**Attack Complexity: TRIVIAL**
- Single transaction call with two parameters: arbitrary pubkey and attacker's address as admin
- No special timing, race conditions, or complex state setup required

**Economic Cost: MINIMAL**

The attacker locks 100,000 ELF but retrieves it when quitting. The sponsor (attacker) receives the refund. [10](#0-9) 

The sponsor is recorded during announcement and receives the refund. [11](#0-10) 

Net cost is zero plus transaction fees, making this economically viable for persistent attacks.

**Probability: HIGH** - The vulnerability is easily discoverable, trivial to exploit, and economically rational for attackers seeking to manipulate elections or grief legitimate candidates.

## Recommendation

Add signature verification to `AnnounceElectionFor` to ensure the caller has consent from the public key owner. The method should either:

1. Require a signature from the public key owner proving consent for the admin assignment, or
2. Be restricted to trusted contracts/addresses that can verify ownership off-chain, or
3. Enforce that the `admin` parameter must equal `Address.FromPublicKey(pubkeyBytes)` to ensure the candidate retains control

Example fix:
```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
    var candidateAddress = Address.FromPublicKey(pubkeyBytes);
    
    // Require admin to be the candidate's own address
    Assert(input.Admin == candidateAddress, "Admin must be the candidate's address.");
    
    // Rest of implementation...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_Hijack_Attack_Test()
{
    // Victim's keypair - attacker knows the public key but not private key
    var victimKeyPair = ValidationDataCenterKeyPairs[0];
    
    // Attacker's keypair
    var attackerKeyPair = ValidationDataCenterKeyPairs[1];
    
    // Attacker calls AnnounceElectionFor with victim's pubkey and attacker as admin
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = victimKeyPair.PublicKey.ToHex(),
        Admin = Address.FromPublicKey(attackerKeyPair.PublicKey) // Attacker sets themselves as admin
    });
    
    // Verify attacker is the admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    admin.ShouldBe(Address.FromPublicKey(attackerKeyPair.PublicKey));
    
    // Verify victim cannot announce their own pubkey
    var victimStub = GetElectionContractTester(victimKeyPair);
    var result = await victimStub.AnnounceElection.SendAsync(
        Address.FromPublicKey(victimKeyPair.PublicKey));
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("already announced election");
}
```

## Notes

The vulnerability represents a fundamental authorization bypass in the election system. The `AnnounceElectionFor` method was likely intended to allow sponsors to pay for candidate registration fees, but the lack of consent verification means it can be abused to hijack arbitrary public keys. This breaks the core security assumption that only the private key owner controls their candidate registration.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L240-249)
```csharp
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L252-254)
```csharp
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```
