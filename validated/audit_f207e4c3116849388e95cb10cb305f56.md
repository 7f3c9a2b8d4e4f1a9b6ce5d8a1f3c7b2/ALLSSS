# Audit Report

## Title
Division by Zero Vulnerability in SetMinerIncreaseInterval Causes Permanent Consensus DoS

## Summary
The `SetMinerIncreaseInterval()` function in the AEDPoS consensus contract lacks validation to prevent setting the miner increase interval to zero. [1](#0-0)  This allows governance to inadvertently or maliciously set the value to zero, causing `DivideByZeroException` in critical consensus operations. Once set to zero, the value cannot be increased due to the assertion logic, resulting in permanent blockchain halt during term transitions.

## Finding Description

The vulnerability exists in the validation logic of `SetMinerIncreaseInterval()`. The function only validates that the new value must be less than or equal to the current value, but fails to enforce a lower bound check greater than zero. [2](#0-1)  When the current value is the default 31,536,000 seconds, [3](#0-2)  zero passes the validation check.

This zero value causes division by zero in two critical locations:

1. In `GetAutoIncreasedMinersCount()`, which performs division to calculate auto-increased miner counts using `.Div(State.MinerIncreaseInterval.Value)`. [4](#0-3) 

2. In `GetMinersCount()`, which uses the same division operation. [5](#0-4) 

The `SafeMath.Div()` extension method performs simple division without exception handling (`return a / b`), which will throw `DivideByZeroException` when the divisor is zero. [6](#0-5) 

The `GetMinersCount()` function is called during critical consensus operations including term transitions via `UpdateMinersCountToElectionContract()`. [7](#0-6) [8](#0-7)  It is also called during first round transitions in consensus processing. [9](#0-8) 

## Impact Explanation

**Critical Consensus Availability Breach:**
Once `MinerIncreaseInterval` is set to zero, any subsequent call to `GetMinersCount()` or `GetMaximumMinersCount()` during consensus operations will throw `DivideByZeroException`, causing transaction reversion. This prevents the blockchain from transitioning to new consensus terms, effectively halting block production.

**Irreversible State:**
The assertion logic only permits non-increasing values. [2](#0-1)  Once set to zero, there is no mechanism through the same function to restore it to a positive value, making this a permanent denial of service with no built-in recovery path.

**Affected Critical Operations:**
- Public view method `GetMaximumMinersCount()` becomes unusable [10](#0-9) 
- Consensus term transitions via `ProcessNextTerm()` fail completely [11](#0-10) 
- Miner count synchronization to the Election contract breaks
- All consensus miners lose the ability to produce blocks once the current term completes

This represents a complete breakdown of the consensus availability guarantee.

## Likelihood Explanation

**Permission Requirements:**
Execution requires the `MaximumMinersCountController` (defaulting to the Parliament contract's default organization) to approve and execute the call. [12](#0-11) 

**Attack Feasibility:**
- **Low Complexity:** Requires only a single governance proposal and approval through Parliament
- **Accidental Trigger:** Could occur through configuration errors or parameter mistakes during legitimate governance operations (e.g., someone thinking 0 means "disable auto-increase")
- **Malicious Trigger:** Could be exploited by compromised governance or a malicious majority coalition
- **No Economic Barrier:** Only requires standard governance proposal fees

**Test Evidence:**
The existing test suite demonstrates that the function accepts decreasing values without any lower bound validation, confirming the vulnerability is exploitable. [13](#0-12) 

The vulnerability is fully executable under normal AElf contract semantics without requiring any extraordinary conditions.

## Recommendation

Add a lower bound validation to ensure `MinerIncreaseInterval` cannot be set to zero or negative values. The fix should be applied at line 61:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SetMinerIncreaseInterval_ToZero_CausesConsensusFailure()
{
    // Setup: Initialize contracts and advance to a new term
    InitialContracts();
    await BlockMiningService.MineBlockToNextTermAsync();
    
    InitialAcs3Stubs();
    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
    
    var defaultOrganizationAddress = 
        await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Execute governance proposal to set MinerIncreaseInterval to zero
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = 0 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganizationAddress
    });
    
    // Verify the value was set to zero
    var interval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
    interval.Value.ShouldBe(0);
    
    // Attempt to call GetMaximumMinersCount - should throw DivideByZeroException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    });
    exception.Message.ShouldContain("DivideByZeroException");
    
    // Attempt term transition - should fail with DivideByZeroException
    var termTransitionException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await BlockMiningService.MineBlockToNextTermAsync();
    });
    termTransitionException.Message.ShouldContain("division by zero");
}
```

## Notes

This vulnerability demonstrates a critical missing validation in a privileged governance function. While the function requires Parliament approval (a trusted role), the lack of lower bound validation allows an honest governance mistake to cause permanent, irreversible consensus failure. The vulnerability is especially dangerous because:

1. **No recovery mechanism**: The assertion logic prevents increasing the value once set to zero
2. **Immediate impact**: Public view methods fail immediately after the change
3. **Delayed catastrophic failure**: The full consensus DoS manifests during the next term transition
4. **Realistic trigger**: An operator might mistakenly think `0` means "disable auto-increase feature" rather than understanding it as a divisor in calculations

The fix is simple but critical: add a positive value check before accepting the new interval value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L72-78)
```csharp
    public override Int32Value GetMaximumMinersCount(Empty input)
    {
        return new Int32Value
        {
            Value = Math.Min(GetAutoIncreasedMinersCount(), State.MaximumMinersCount.Value)
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L13-13)
```csharp
    public long MinerIncreaseInterval { get; set; } = 31536000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L128-128)
```csharp
                var minersCount = GetMinersCount(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L108-147)
```csharp
    [Fact]
    public async Task SetMinerIncreaseIntervalTest()
    {
        InitialContracts();
        await BlockMiningService.MineBlockToNextTermAsync();

        InitialAcs3Stubs();
        await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
        var minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        
        var defaultOrganizationAddress =
            await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());

        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
    }
```
