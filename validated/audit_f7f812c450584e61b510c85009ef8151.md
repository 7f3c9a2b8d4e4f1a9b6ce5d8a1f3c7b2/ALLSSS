# Audit Report

## Title
Quadratic Voting Implementation Broken - All Votes Cost Same Amount Due to Incorrect Vote Count Tracking

## Summary
The quadratic voting mechanism is fundamentally broken because `QuadraticVotesCountMap` uses unique `VoteId` values as keys that change with every vote. This causes every vote to start with a fresh counter at zero, defeating the core purpose of quadratic voting where subsequent votes should cost progressively more tokens.

## Finding Description

The quadratic voting implementation tracks vote counts using `QuadraticVotesCountMap`, which maps Vote IDs to vote counts. [1](#0-0) 

However, the Vote ID generation creates a unique ID for each vote by incorporating the current `votingResult.VotesAmount` value, which represents the cumulative total of all votes. [2](#0-1) 

This `VotesAmount` value is incremented after each vote is processed. [3](#0-2) 

The quadratic voting logic reads the counter for the current Vote ID, increments it, and uses it to calculate the cost. [4](#0-3) 

**The Critical Flaw:**
Since `votingResult.VotesAmount` changes after every vote from ANY voter, each call to `Vote()` generates a different Vote ID. When this unique Vote ID is used as a key in `QuadraticVotesCountMap[input.VoteId]`, it always returns 0 (new key), so the counter never accumulates beyond 1.

**Example:**
- **First vote:** VotesAmount = 0 → VoteId₁ = Hash(0) → Counter = 1 → Cost = TicketCost × 1
- **Second vote:** VotesAmount = TicketCost → VoteId₂ = Hash(TicketCost) (different!) → Counter = 1 → Cost = TicketCost × 1
- **Nth vote:** VotesAmount = cumulative → VoteIdₙ (different!) → Counter = 1 → Cost = TicketCost × 1

The map should be keyed by `(Voter, VotingItemId, SnapshotNumber)` to accumulate vote counts per voter, not by a transaction-unique value.

## Impact Explanation

**Severity: High** - This completely negates the fundamental security mechanism of quadratic voting.

Quadratic voting is designed to prevent plutocracy by making it progressively more expensive to dominate voting outcomes. The intended cost formula is: total cost = TicketCost × (1 + 2 + 3 + ... + N) = TicketCost × N(N+1)/2.

**Concrete Impact:**
- A voter wanting 100 votes should pay: TicketCost × 5,050 tokens
- Instead, they pay only: TicketCost × 100 tokens (50× cheaper)
- For 1,000 votes: Should cost TicketCost × 500,500, actually costs TicketCost × 1,000 (500× cheaper)

**Protocol Damage:**
- Wealthy voters can buy disproportionate influence at a fraction of intended cost
- Voting outcomes become plutocratic instead of quadratic
- Any governance decisions using quadratic voting are fundamentally compromised
- The economic security model of the voting system is invalidated

## Likelihood Explanation

**Likelihood: Certain** - This bug activates automatically for every quadratic voting item.

The `Vote()` method is publicly callable by any user. [5](#0-4) 

The vulnerability requires only that a voting item be registered with `IsQuadratic = true`. [6](#0-5)  When `IsLockToken = true`, the Vote ID generation path with the bug is triggered. [7](#0-6) 

**Attack Complexity:** Trivial - simply call `Vote()` multiple times on the same voting item. No special timing, permissions, or complex exploits needed.

**Economic Rationality:** Exploiting this is economically beneficial with no downside. Voters get maximum voting power for minimum cost, with no risk or penalties.

## Recommendation

Replace the Vote ID generation mechanism for quadratic voting. Instead of using the cumulative `VotesAmount` which changes with every vote, generate a stable identifier per voter:

```csharp
// In AssertValidVoteInput for IsLockToken = true case:
var voterId = HashHelper.ComputeFrom(
    Context.Sender, 
    votingItem.VotingItemId, 
    votingItem.CurrentSnapshotNumber
);
input.VoteId = Context.GenerateId(Context.Self, voterId.Value);
```

This ensures the same voter voting on the same item in the same snapshot gets a consistent Vote ID, allowing `QuadraticVotesCountMap` to properly accumulate their vote count.

## Proof of Concept

```csharp
// Test demonstrates same voter making multiple votes pays flat cost
[Fact]
public async Task QuadraticVoting_BrokenCostEscalation_Test()
{
    // Setup: Register quadratic voting item with TicketCost = 100
    var votingItemId = await RegisterQuadraticVotingItem(ticketCost: 100);
    
    // Voter1 casts 3 votes on same option
    await VoteStub.Vote.SendAsync(new VoteInput { 
        VotingItemId = votingItemId, 
        Option = "OptionA" 
    });
    await VoteStub.Vote.SendAsync(new VoteInput { 
        VotingItemId = votingItemId, 
        Option = "OptionA" 
    });
    await VoteStub.Vote.SendAsync(new VoteInput { 
        VotingItemId = votingItemId, 
        Option = "OptionA" 
    });
    
    // Get locked token amount
    var lockedAmount = await GetLockedTokenAmount(Voter1);
    
    // BUG: Actual cost = 100 + 100 + 100 = 300
    // Expected cost = 100×1 + 100×2 + 100×3 = 600
    Assert.Equal(300, lockedAmount); // This passes, proving the bug
    // Assert.Equal(600, lockedAmount); // This would be correct behavior
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L50-50)
```csharp
            IsQuadratic = input.IsQuadratic,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-90)
```csharp
    public override Empty Vote(VoteInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-103)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L179-179)
```csharp
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```
