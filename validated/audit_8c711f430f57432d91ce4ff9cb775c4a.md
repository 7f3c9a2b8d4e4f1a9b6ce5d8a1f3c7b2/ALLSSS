# Audit Report

## Title
Null Reference Exception in DistributeProfitsForSubSchemes Due to Missing Null Check on Sub-Scheme Profit Details

## Summary
The `DistributeProfitsForSubSchemes` function in the Profit contract lacks null validation when accessing profit details for sub-schemes. A scheme manager can inadvertently call `RemoveBeneficiary` on a sub-scheme's virtual address, which removes the profit details from state but leaves the sub-scheme entry in the `SubSchemes` list. This state inconsistency causes a NullReferenceException during subsequent profit distributions, resulting in complete DoS of the scheme's distribution mechanism.

## Finding Description
The vulnerability stems from a state management inconsistency between two operations in the Profit contract:

When a sub-scheme is added via `AddSubScheme`, two state changes occur: (1) the sub-scheme's virtual address is added as a beneficiary with profit details [1](#0-0) , and (2) the sub-scheme is added to the parent scheme's `SubSchemes` list [2](#0-1) .

However, `RemoveBeneficiary` can be called directly by the manager on any beneficiary address, including sub-scheme virtual addresses, with only manager permission validation [3](#0-2) . This calls `RemoveProfitDetails`, which completely removes the beneficiary entry from the state map when all profit details are removed [4](#0-3) .

Critically, `RemoveBeneficiary` does NOT remove the entry from `scheme.SubSchemes` - only `RemoveSubScheme` performs that operation [5](#0-4) .

This creates an inconsistent state where a sub-scheme exists in the `SubSchemes` list but has no corresponding profit details. When `DistributeProfits` is subsequently called, it invokes `DistributeProfitsForSubSchemes` [6](#0-5) , which iterates through all sub-schemes and accesses their profit details without null validation [7](#0-6) . This causes a NullReferenceException when `subItemDetail` is null.

## Impact Explanation
When the inconsistent state exists and `DistributeProfits` is called:
- The transaction fails with a NullReferenceException at the point where it attempts to iterate over `subItemDetail.Details`
- Complete DoS of profit distribution for the entire scheme occurs
- All beneficiaries of the scheme (not just the problematic sub-scheme) cannot receive their entitled profits
- The scheme's economic functionality is halted until manual intervention
- The manager must either re-add the sub-scheme's profit details via `AddBeneficiary` or completely remove the sub-scheme via `RemoveSubScheme` to restore functionality

This represents a high-confidence DoS of a critical economic function that affects all participants in the scheme.

## Likelihood Explanation
This vulnerability can be triggered through legitimate scheme manager actions:

**Preconditions**:
- A scheme must have at least one sub-scheme added via `AddSubScheme`
- The manager (or TokenHolder contract) must call `RemoveBeneficiary` with the sub-scheme's virtual address

**Triggering Scenario**:
- Only the scheme manager or TokenHolder contract can call `RemoveBeneficiary` (not external attackers) [3](#0-2) 
- The manager may not realize a particular address is a sub-scheme's virtual address when performing beneficiary cleanup
- No validation prevents this action - the code treats sub-scheme virtual addresses identically to regular beneficiaries
- For schemes with `CanRemoveBeneficiaryDirectly=true`, managers may be more liberal in removing beneficiaries

While this requires manager action rather than external attack, it represents a defensive programming failure that allows an easily-triggered inconsistent state with no safeguards.

## Recommendation
Add a null check in `DistributeProfitsForSubSchemes` before accessing profit details: [8](#0-7) 

Replace the code with:
```csharp
var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
if (subItemDetail == null) continue; // Skip sub-schemes with no profit details
foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;
```

Additionally, consider adding validation in `RemoveBeneficiary` to prevent removing beneficiaries that are sub-scheme virtual addresses, or automatically remove the sub-scheme from `scheme.SubSchemes` when its profit details are cleared.

## Proof of Concept
```csharp
[Fact]
public async Task ProfitContract_SubScheme_NullReference_DoS_Test()
{
    const int shares = 100;
    var creator = Creators[0];
    
    // Create parent scheme with CanRemoveBeneficiaryDirectly=true
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        CanRemoveBeneficiaryDirectly = true
    });
    var schemeId = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Address.FromPublicKey(CreatorKeyPair[0].PublicKey) }
    )).SchemeIds.First();
    
    // Create and add sub-scheme
    var subSchemeId = await CreateSchemeAsync(1);
    await creator.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = schemeId,
        SubSchemeId = subSchemeId,
        SubSchemeShares = shares
    });
    
    // Get sub-scheme virtual address
    var subScheme = await creator.GetScheme.CallAsync(subSchemeId);
    var subSchemeVirtualAddress = subScheme.VirtualAddress;
    
    // Manager accidentally removes the sub-scheme's virtual address as a beneficiary
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        SchemeId = schemeId,
        Beneficiary = subSchemeVirtualAddress
    });
    
    // Contribute and try to distribute profits
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = 1000,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    });
    
    // This should fail with NullReferenceException
    var result = await creator.DistributeProfits.SendWithExceptionAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 1000 } }
    });
    
    // Verify DoS - transaction should fail
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("NullReferenceException");
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-118)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L121-125)
```csharp
        scheme.SubSchemes.Add(new SchemeBeneficiaryShare
        {
            SchemeId = input.SubSchemeId,
            Shares = input.SubSchemeShares
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L376-383)
```csharp
        if (profitDetails.Details.Count != 0)
        {
            State.ProfitDetailsMap[scheme.SchemeId][beneficiary] = profitDetails;
        }
        else
        {
            State.ProfitDetailsMap[scheme.SchemeId].Remove(beneficiary);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L592-592)
```csharp
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L634-637)
```csharp
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;

            State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;
```
