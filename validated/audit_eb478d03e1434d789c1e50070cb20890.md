# Audit Report

## Title
Validation Gap in NextRound Allows Negative LIB Injection Causing Temporary Consensus Throughput Reduction

## Summary
The AEDPoS consensus contract fails to apply `LibInformationValidationProvider` during `NextRound` behavior validation, allowing a malicious miner to inject negative `ConfirmedIrreversibleBlockRoundNumber` values. This triggers the `Severe` mining status, temporarily reducing blockchain throughput to 1 block per time slot until the next `UpdateValue` block recalculates the LIB.

## Finding Description

The vulnerability stems from differential validation logic applied to consensus behaviors. The `ValidateBeforeExecution` method in the consensus validation framework applies `LibInformationValidationProvider` only to `UpdateValue` behavior, not to `NextRound` or `NextTerm` behaviors. [1](#0-0) 

The `NextRoundInput.Create()` method copies LIB values directly from the current round without validation, including both `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber`. [2](#0-1) 

These fields are defined as `int64` (signed integers) in the protobuf schema, permitting negative values. [3](#0-2) 

The validation logic shows that `UpdateValue` behavior receives `LibInformationValidationProvider` (line 82), but `NextRound` behavior only receives `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` (lines 86-87). [4](#0-3) 

The `LibInformationValidationProvider` checks if provided LIB values are lower than base round values, which would catch negative injections (since any positive base value > negative provided value). [5](#0-4) 

The `RoundTerminateValidationProvider` only validates round number increments and InValue nullity, not LIB values. [6](#0-5) 

When a malicious `NextRound` block is processed, the `ProcessNextRound` method converts the input to a Round object (line 110) and stores it via `AddRoundInformation` (line 156) without additional validation. [7](#0-6) 

The `GetMaximumBlocksCount` method reads `ConfirmedIrreversibleBlockRoundNumber` (line 25) and uses it in the `BlockchainMiningStatusEvaluator`. With a negative `libRoundNumber` (e.g., -1) and a current round number of 10, the condition at lines 127-128 triggers `Severe` status (10 >= -1 + 8), causing the method to return 1 (line 66). [8](#0-7) 

The `GenerateNextRoundInformation` method propagates these values to subsequent rounds created via `NextRound` behavior.

However, recovery occurs automatically: [9](#0-8) 

When the next `UpdateValue` block is produced, the `LastIrreversibleBlockHeightCalculator` recalculates LIB from miner behavior (line 268-269), and if this value exceeds the current (negative) LIB, it updates the state (lines 272-280), automatically fixing the negative value. [10](#0-9) 

The LIB calculator computes based on implied irreversible heights from miners, producing valid positive values independent of the corrupted stored LIB.

## Impact Explanation

This vulnerability enables a **temporary denial-of-service attack** on consensus throughput:

1. **Immediate Effect**: All miners are limited to producing 1 block per time slot instead of the typical maximum (8+ blocks), reducing blockchain throughput by approximately 87.5%
2. **Duration**: From the malicious `NextRound` block until the next `UpdateValue` block (typically 1-2 blocks in normal operation, as most blocks use `UpdateValue` behavior)
3. **Repeatability**: A malicious miner can repeat this attack each time they serve as extra block producer, causing recurring disruptions

The impact is **NOT permanent** as claimed in some analyses - the consensus contract self-heals through normal `UpdateValue` operations. However, repeated exploitation could cause sustained throughput degradation if a malicious miner frequently serves as extra block producer.

## Likelihood Explanation

**Prerequisites**: [11](#0-10) 

The attacker must be an elected miner verified by the `PreCheck` method.

**Attack Execution**:
1. Malicious miner waits for their turn as extra block producer (when `NextRound` behavior is used)
2. They call the contract's view method to generate proper consensus extra data
3. They modify the `ConfirmedIrreversibleBlockRoundNumber` field to a negative value (e.g., -1) before creating their block
4. The block passes validation because `LibInformationValidationProvider` is not applied to `NextRound`
5. The corrupted state is stored and immediately affects all subsequent block production attempts

**Likelihood Assessment**: MEDIUM - Requires attacker to be an elected miner and wait for their turn as extra block producer, but once positioned, the attack is straightforward with no economic costs beyond normal block production.

## Recommendation

Add `LibInformationValidationProvider` to the `NextRound` and `NextTerm` validation chains:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this line
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this line
    break;
```

This ensures that LIB values in `NextRound` and `NextTerm` inputs are validated against the base round, preventing injection of negative or regressing LIB values.

## Proof of Concept

```csharp
[Fact]
public async Task NegativeLIBInjection_CausesMaxBlockCountReduction()
{
    // Setup: Initialize consensus with normal round
    var initialRound = GenerateFirstRound(MinerCount);
    await InitializeConsensus(initialRound);
    
    // Attacker produces NextRound block with negative LIB
    var maliciousRound = initialRound.Clone();
    maliciousRound.RoundNumber = 2;
    maliciousRound.ConfirmedIrreversibleBlockRoundNumber = -1; // Inject negative
    maliciousRound.ConfirmedIrreversibleBlockHeight = -1;
    
    var maliciousInput = NextRoundInput.Create(maliciousRound, GenerateRandomNumber());
    
    // Execute attack
    await ConsensusContract.NextRound.SendAsync(maliciousInput);
    
    // Verify: GetMaximumBlocksCount should return 1 instead of normal 8
    var maxBlocks = await ConsensusContract.GetMaximumBlocksCount.CallAsync(new Empty());
    Assert.Equal(1, maxBlocks.Value); // Confirms DoS impact
    
    // Verify: UpdateValue should fix it automatically
    await ProduceNormalBlock(); // Produces UpdateValue block
    var recoveredMaxBlocks = await ConsensusContract.GetMaximumBlocksCount.CallAsync(new Empty());
    Assert.True(recoveredMaxBlocks.Value > 1); // Confirms automatic recovery
}
```

## Notes

**Key Correction**: The original claim stated the negative LIB "persists across all future rounds until manual intervention or chain recovery." This is inaccurate. The consensus contract has a self-healing mechanism - the next `UpdateValue` block automatically recalculates LIB using `LastIrreversibleBlockHeightCalculator`, which computes based on actual miner behavior rather than stored state, thus overwriting the negative value. The attack causes temporary throughput reduction (1-2 blocks typically) but is not a persistent state corruption requiring manual intervention.

The vulnerability remains valid because: (1) the validation gap exists and is exploitable, (2) real consensus disruption occurs even if temporary, and (3) repeated exploitation by malicious miners can cause sustained degradation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** protobuf/aedpos_contract.proto (L257-259)
```text
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-67)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```
