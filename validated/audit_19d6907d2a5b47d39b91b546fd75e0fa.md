# Audit Report

## Title
Missing Resource Amount Validation for Non-Exclusive Side Chains Allows Rental Fee Evasion

## Summary
The CrossChain contract's validation logic for side chain creation contains a critical bypass that allows non-exclusive side chains to evade resource rental fees. When `IsPrivilegePreserved` is set to `false`, the validation returns early without checking that all required resource symbols are present in `InitialResourceAmount`, enabling side chains to be initialized with incomplete resource allocations that result in zero rental charges.

## Finding Description

The vulnerability exists in the side chain creation validation flow. When a side chain is created with `IsPrivilegePreserved = false` (non-exclusive side chain), the `AssertValidSideChainCreationRequest` method returns early with the comment "there is no restriction for non-exclusive side chain creation", bypassing the call to `AssertValidResourceTokenAmount`. [1](#0-0) 

The bypassed `AssertValidResourceTokenAmount` method is responsible for ensuring all symbols from `PayRentalSymbolListName` are present in `InitialResourceAmount` with values greater than zero. [2](#0-1) 

The unvalidated `InitialResourceAmount` is directly included in the `ChainInitializationData` that is passed to the side chain during initialization. [3](#0-2) 

On the side chain, the `InitializeFromParentChain` method in the token contract directly sets `State.ResourceAmount` for each provided symbol without any validation of completeness. [4](#0-3) 

This creates a critical mismatch in the rental fee calculation system. The `GetResourceUsage` method iterates over symbols from `PayRentalSymbolListName` and reads from `State.ResourceAmount`, returning zero (the default value) for any missing symbols. [5](#0-4) 

Most critically, the `PayRental` method calculates rental fees using the formula: `rental = duration × State.ResourceAmount[symbol] × State.Rental[symbol]`. For missing symbols where `State.ResourceAmount[symbol]` is zero, this results in zero rental charges regardless of duration or unit price. [6](#0-5) 

## Impact Explanation

This vulnerability allows malicious actors to create non-exclusive side chains with incomplete resource allocations (e.g., providing only `{"CPU": 1}` instead of the required `{"CPU": 1, "RAM": 1, "DISK": 1, "NET": 1}`). The missing resource symbols will:

1. **Report zero usage** through `GetResourceUsage()`, hiding actual resource allocations from accounting systems
2. **Never incur rental charges** through `PayRental()`, as the calculation multiplies by zero
3. **Provide unlimited free resources** to the side chain for the lifetime of the chain

This directly violates the protocol's economic model where all side chains must pay rental fees for allocated resources. The parent chain loses rental fee revenue, and resource allocation accounting becomes inconsistent across the system. Exclusive side chains with `IsPrivilegePreserved = true` have proper validation enforced, creating an unfair economic advantage for non-exclusive chains that exploit this bypass.

While `UpdateRentedResources` can fix the resource amounts post-deployment, this requires explicit governance action through the `SideChainRentalController`. During the interim period (which could be indefinite), the side chain enjoys completely free resource consumption. [7](#0-6) 

## Likelihood Explanation

The vulnerability is highly likely to be exploited because:

- **Public access**: `RequestSideChainCreation` is a publicly callable method with no special authorization requirements beyond token allowance
- **Low barriers**: The attacker only needs sufficient locked tokens (a standard requirement for side chain creation) and to set `IsPrivilegePreserved = false`
- **Simple execution**: Single transaction to create the proposal, followed by standard governance approval flow that doesn't re-validate resource amounts
- **Automatic bypass**: The vulnerability is in validation logic that automatically triggers based on the `IsPrivilegePreserved` flag
- **Detection difficulty**: The missing validation is not visible at runtime and requires code-level review to identify
- **Supported feature**: Non-exclusive side chains are explicitly supported, with test code defaulting to `isPrivilegePreserved = false` [8](#0-7) 

The economic cost of side chain creation (locked tokens) is a necessary business expense for legitimate side chains, making the exploitation cost reasonable relative to the potential savings from avoided rental fees over the chain's lifetime.

## Recommendation

Apply resource token amount validation for ALL side chains, regardless of the `IsPrivilegePreserved` flag. Modify `AssertValidSideChainCreationRequest` to remove the early return and enforce resource validation universally:

```csharp
private void AssertValidSideChainCreationRequest(SideChainCreationRequest sideChainCreationRequest,
    Address proposer)
{
    // ... existing allowance and basic validation ...
    
    // Always validate resource amounts for all side chains
    AssertValidResourceTokenAmount(sideChainCreationRequest);
    
    // Only validate token creation for exclusive chains
    if (!sideChainCreationRequest.IsPrivilegePreserved)
        return;
    
    if (!IsPrimaryTokenNeeded(sideChainCreationRequest))
        return;
        
    // ... existing token validation ...
}
```

This ensures that all side chains, regardless of type, must provide complete resource allocations and pay appropriate rental fees.

## Proof of Concept

```csharp
[Fact]
public async Task ExploitMissingResourceValidation_NonExclusiveSideChain()
{
    await InitializeCrossChainContractAsync();
    var lockedTokenAmount = 10_000_00000000;
    await ApproveBalanceAsync(lockedTokenAmount);
    
    // Create non-exclusive side chain with INCOMPLETE resource amounts
    // Only providing CPU, missing RAM, DISK, NET
    var incompleteResourceAmount = new Dictionary<string, int> { { "CPU", 1 } };
    
    var proposalId = await CreateSideChainProposalAsync(1, lockedTokenAmount, 
        incompleteResourceAmount, 
        ByteString.CopyFromUtf8("Test"), 
        isPrivilegePreserved: false); // Non-exclusive chain
        
    await ApproveWithMinersAsync(proposalId);
    await ReleaseProposalAsync(proposalId);
    
    // Side chain created successfully despite incomplete resources
    var chainId = ChainHelper.GetChainId(1);
    var chainStatus = await CrossChainContractStub.GetChainStatus.CallAsync(new Int32Value { Value = chainId });
    chainStatus.Value.ShouldBe((int)SideChainStatus.Active);
    
    // Verify initialization data contains incomplete resource amounts
    var initData = await CrossChainContractStub.GetSideChainInitializationInformation.CallAsync(
        new Int32Value { Value = chainId });
    initData.ResourceTokenInfo.InitialResourceAmount.Count.ShouldBe(1); // Only CPU, missing others
    initData.ResourceTokenInfo.InitialResourceAmount["CPU"].ShouldBe(1);
    
    // When side chain initializes, missing resources will have 0 amount
    // PayRental will calculate: rental = duration × 0 × rental_price = 0 for RAM/DISK/NET
    // Result: FREE resources for the side chain lifetime
}
```

**Notes**

The validation tests in the codebase only verify resource validation for exclusive side chains (`isPrivilegePreserved = true`), as shown in the test that removes resources and expects failure. [9](#0-8) 

This confirms that the validation gap exists specifically for non-exclusive side chains, where the early return prevents the resource validation from executing. The default value in the test helper method also demonstrates that non-exclusive chains are a commonly used configuration.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L124-127)
```csharp
        if (!sideChainCreationRequest.IsPrivilegePreserved)
            return; // there is no restriction for non-exclusive side chain creation

        AssertValidResourceTokenAmount(sideChainCreationRequest);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L139-145)
```csharp
    private void AssertValidResourceTokenAmount(SideChainCreationRequest sideChainCreationRequest)
    {
        var resourceTokenMap = sideChainCreationRequest.InitialResourceAmount;
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayRentalSymbolListName))
            Assert(resourceTokenMap.ContainsKey(resourceTokenSymbol) && resourceTokenMap[resourceTokenSymbol] > 0,
                "Invalid side chain resource token request.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L538-542)
```csharp
        res.ResourceTokenInfo = new ResourceTokenInfo
        {
            ResourceTokenListData = resourceTokenInformation,
            InitialResourceAmount = { sideChainCreationRequest.InitialResourceAmount }
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L179-186)
```csharp
    public override ResourceUsage GetResourceUsage(Empty input)
    {
        var usage = new ResourceUsage();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
            usage.Value.Add(symbol, State.ResourceAmount[symbol]);

        return usage;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1061-1061)
```csharp
            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1114-1127)
```csharp
    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** test/AElf.Contracts.CrossChain.Tests/CrossChainContractTestBase.cs (L313-333)
```csharp
    internal SideChainCreationRequest CreateSideChainCreationRequest(long indexingPrice, long lockedTokenAmount,
        Dictionary<string, int> resourceAmount, SideChainTokenInitialIssue[] sideChainTokenInitialIssueList,
        bool isPrivilegePreserved = false)
    {
        var res = new SideChainCreationRequest
        {
            IndexingPrice = indexingPrice,
            LockedTokenAmount = lockedTokenAmount,
            SideChainTokenCreationRequest = new SideChainTokenCreationRequest
            {
                SideChainTokenDecimals = 2,
                SideChainTokenTotalSupply = 1_000_000_000,
                SideChainTokenSymbol = "TE",
                SideChainTokenName = "TEST"
            },
            SideChainTokenInitialIssueList = { sideChainTokenInitialIssueList },
            InitialResourceAmount = { resourceAmount },
            IsPrivilegePreserved = isPrivilegePreserved
        };
        return res;
    }
```

**File:** test/AElf.Contracts.CrossChain.Tests/SideChainLifeTimeManagementTest.cs (L1145-1167)
```csharp
        {
            foreach (var t in ResourceTokenSymbolList)
            {
                // invalid resource token
                var resourceAmount = GetValidResourceAmount();
                resourceAmount.Remove(t);
                var createProposalInput = CreateSideChainCreationRequest(1, lockedTokenAmount,
                    resourceAmount, new[]
                    {
                        new SideChainTokenInitialIssue
                        {
                            Address = DefaultSender,
                            Amount = 100
                        }
                    }, true);
                var requestSideChainCreation =
                    await CrossChainContractStub.RequestSideChainCreation.SendWithExceptionAsync(
                        createProposalInput);

                requestSideChainCreation.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
                requestSideChainCreation.TransactionResult.Error.ShouldContain(
                    "Invalid side chain resource token request.");
            }
```
