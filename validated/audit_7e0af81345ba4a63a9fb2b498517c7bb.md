# Audit Report

## Title
Scheme Manager Can Retroactively Increase MinimumLockMinutes to Prevent User Withdrawals

## Summary
The TokenHolder contract allows scheme managers to call `CreateScheme` multiple times, unconditionally overwriting scheme parameters including `MinimumLockMinutes`. Since user lock timestamps persist independently while withdrawal validation uses the current scheme's parameters, managers can retroactively trap user funds indefinitely by increasing the lock period after users have registered.

## Finding Description

The vulnerability stems from an architectural flaw where lock timestamps and scheme parameters are stored in separate state mappings, allowing desynchronization through repeated scheme creation.

The `CreateScheme` function lacks validation to prevent multiple invocations and unconditionally overwrites the stored scheme parameters. [1](#0-0) 

When users register for profits, their lock timestamp is recorded in separate state storage. [2](#0-1) 

The state structure confirms these are independent mappings that can become desynchronized. [3](#0-2) 

During withdrawal, the function retrieves the current scheme and validates the original lock timestamp against the current `MinimumLockMinutes` value. [4](#0-3) 

The Profit contract enables this by using count-based scheme ID generation, creating a new scheme with a different ID for each invocation. [5](#0-4) 

The Profit contract's validation only prevents duplicate scheme IDs, not multiple schemes by the same manager. [6](#0-5) 

**Attack Scenario:**
1. Manager calls `CreateScheme(MinimumLockMinutes = 1)` - creates scheme with 1-minute lock
2. Users call `RegisterForProfits` - lock tokens with timestamp T0, expecting 1-minute lock period
3. Manager calls `CreateScheme(MinimumLockMinutes = 100000000)` again - overwrites scheme parameters to 190-year lock period
4. User attempts `Withdraw` after 1 minute - validation checks `T0 + 100000000 minutes < CurrentTime`, which fails
5. Users' funds are permanently trapped with no recovery mechanism

## Impact Explanation

**Direct Fund Impact**: All user funds locked in the affected scheme become permanently inaccessible. The withdrawal validation will perpetually fail as the original lock timestamp plus the new inflated `MinimumLockMinutes` exceeds any realistic future time.

**No Recovery Path**: The `Withdraw` function is the sole mechanism to unlock tokens, and it enforces the time validation that will always fail. There is no emergency unlock, no administrative override, and no alternative withdrawal path in the TokenHolder or underlying MultiToken contracts.

**Affected Scope**: 
- All users who registered before the parameter change
- Any TokenHolder profit scheme across the AElf ecosystem
- Smart contracts integrating TokenHolder for staking mechanisms

**Severity Justification**: HIGH - This enables complete and permanent fund theft. Unlike governance-based attacks requiring consensus, any scheme manager can execute this unilaterally with a single transaction. The attack is silent (no events emitted for parameter changes) and users discover the trap only when attempting withdrawal.

## Likelihood Explanation

**Attacker Capabilities**: Anyone can become a scheme manager by calling `CreateScheme` - there are no special permissions, stake requirements, or authorization checks preventing scheme creation.

**Attack Complexity**: Trivial - requires only two `CreateScheme` transactions with different `MinimumLockMinutes` values. No complex sequencing, timing windows, or multi-step coordination needed.

**Feasibility Conditions**:
- Attacker creates initial scheme with attractive short lock period
- Users register (normal protocol operation)
- Attacker calls `CreateScheme` again with inflated lock period
- No preconditions beyond normal protocol usage

**Detection Constraints**: The attack is completely silent. No events are emitted when scheme parameters change. On-chain state only reflects the current scheme. Users cannot detect the parameter change until attempting withdrawal and receiving an opaque "Cannot withdraw" error.

**Economic Rationality**: Extremely favorable for malicious actors. A single transaction can trap unlimited user funds. This enables rug pulls where attackers advertise attractive terms to maximize deposits, then trap all funds permanently.

**Probability Assessment**: HIGH - The vulnerability is trivial to exploit, economically incentivized, has no detection mechanism, and can affect any TokenHolder deployment.

## Recommendation

Implement one or more of the following mitigations:

1. **Prevent Multiple CreateScheme Calls**: Add validation to reject subsequent calls after scheme creation:
```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, "Scheme already exists.");
    // ... existing code
}
```

2. **Immutable Lock Parameters**: Store the original `MinimumLockMinutes` with each user's lock registration and validate against that value rather than the current scheme's parameters.

3. **Version-Based Validation**: Add a scheme version counter that increments on parameter changes, and validate that withdrawals use the same version as registration.

4. **Event Emissions**: Emit events when scheme parameters change to enable off-chain monitoring and user notification.

## Proof of Concept

```csharp
[Fact]
public async Task RetroactiveParameterChange_TrapsUserFunds()
{
    // Manager creates scheme with 1-minute lock
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    var managerAddress = DefaultSender;
    
    // User registers and locks 10000 tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = managerAddress,
        Amount = 10000
    });
    
    // Manager recreates scheme with 100000000-minute (190-year) lock
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100000000
    });
    
    // Advance time by 1 minute (should allow withdrawal under original terms)
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(1));
    
    // User attempts withdrawal - should succeed but will fail
    var result = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(managerAddress);
    
    // Assert withdrawal fails with "Cannot withdraw" despite 1-minute lock period elapsed
    result.TransactionResult.Error.ShouldContain("Cannot withdraw");
    
    // User funds are permanently trapped
}
```

## Notes

This vulnerability represents a critical trust violation in the TokenHolder profit-sharing system. The architectural separation of lock timestamps from scheme parameters, combined with the ability to overwrite scheme configuration without versioning or user consent, creates a severe rug pull vector. The issue affects the entire AElf TokenHolder ecosystem and requires immediate remediation to prevent fund loss.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L167-167)
```csharp
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L213-228)
```csharp
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-17)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }

    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }

    public MappedState<Hash, Timestamp> LockTimestamp { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-60)
```csharp
        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```
