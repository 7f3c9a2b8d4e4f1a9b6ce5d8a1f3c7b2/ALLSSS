# Audit Report

## Title
Post-Execution Consensus Validation Completely Bypassed Due to Object Reference Bug

## Summary
The `ValidateConsensusAfterExecution` method contains a critical object aliasing bug where recovery methods modify the current consensus state object in-place and return it, causing both sides of the validation comparison to reference the same object. This renders post-execution validation completely ineffective.

## Finding Description

The vulnerability exists in the `ValidateConsensusAfterExecution` method where recovery operations inadvertently create an object aliasing bug. [1](#0-0) 

The method retrieves `currentRound` from state, then calls recovery methods on this object: [2](#0-1) 

The recovery methods `RecoverFromUpdateValue` and `RecoverFromTinyBlock` modify the `this` reference in-place and return it: [3](#0-2) [4](#0-3) 

Since `Round` is a protobuf message (reference type), the assignment at lines 90-92 or 95-97 causes `headerInformation.Round` to point to the exact same object as `currentRound`. The subsequent hash comparison compares the object with itself, which always produces equal hashes.

The block header contains critical consensus fields that should be validated: [5](#0-4) 

These fields (`ProducedBlocks`, `ProducedTinyBlocks`, `ImpliedIrreversibleBlockHeight`, `ActualMiningTimes`) are supposed to match post-execution state after `ProcessUpdateValue` runs: [6](#0-5) 

However, the validation never checks the original header values because they're overwritten before comparison.

## Impact Explanation

This bug breaks a fundamental consensus safety invariant: **the ability to verify that block execution results match consensus claims in the block header**.

The post-execution validation serves as a final safety barrier that should catch:

1. **Malicious block data**: A dishonest miner could include fabricated values for critical consensus fields in their block header, and these would pass validation
2. **Implementation bugs**: Any bugs in the state update logic would go undetected since there's no verification that updates were applied correctly
3. **State corruption propagation**: Incorrect consensus state could spread across the network without detection
4. **Consensus integrity violation**: The system loses its ability to enforce that miners honestly report their block production

This is a **consensus-critical defense-in-depth failure** that undermines integrity guarantees of the AEDPoS consensus mechanism.

## Likelihood Explanation

This bug triggers **automatically and continuously** on every node for every block containing `UpdateValue` or `TinyBlock` consensus behaviors:

- **Reachable Entry Point**: `ValidateConsensusAfterExecution` is part of the ACS4 consensus interface, invoked automatically during the block validation pipeline
- **No Preconditions**: Happens during normal block processing for any miner
- **100% Trigger Rate**: The bug activates every time these consensus behaviors are processed
- **Silent Failure**: The validation appears to succeed even when it should fail

While pre-execution validation (`ValidateBeforeExecution`) provides some protection, the post-execution check is meant to catch discrepancies between claimed and actual execution results. Without it, bugs in consensus processing or malicious header data would go undetected.

## Recommendation

The recovery methods should operate on a copy of the header round data, not on the state object. The fix should:

1. **Option A**: Clone `currentRound` before calling recovery methods:
```csharp
var recoveredCurrentRound = currentRound.Clone();
if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
    recoveredCurrentRound.RecoverFromUpdateValue(headerInformation.Round, headerInformation.SenderPubkey.ToHex());
```

2. **Option B**: Change recovery methods to operate on the header object instead:
```csharp
if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
    headerInformation.Round.RecoverFromCurrentRound(currentRound, headerInformation.SenderPubkey.ToHex());
```

Either approach ensures the validation compares two distinct objects.

## Proof of Concept

The bug can be demonstrated by observing that the hash comparison always succeeds:

```csharp
// In ValidateConsensusAfterExecution:
// currentRound is retrieved from state
TryToGetCurrentRoundInformation(out var currentRound);

// Recovery methods modify currentRound and return it
headerInformation.Round = currentRound.RecoverFromUpdateValue(headerInformation.Round, pubkey);

// Now headerInformation.Round == currentRound (same object reference)
// This comparison will always be true:
headerInformation.Round.GetHash() == currentRound.GetHash() // Always true!
```

To prove this is a vulnerability, insert different values into the header's `ProducedBlocks` field before recovery - the validation will still pass because both sides of the comparison point to the same modified object.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-101)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```
