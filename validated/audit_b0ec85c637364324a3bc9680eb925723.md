# Audit Report

## Title
Unbounded ProfitDetails Growth Causes Denial of Service in Profit Claiming

## Summary
The Profit contract allows unlimited accumulation of ProfitDetail entries per beneficiary, leading to gas exhaustion when claiming profits. The vulnerability arises from unbounded list growth without size limits, inadequate cleanup logic, and missing ProfitDetailId in Election contract withdrawals. Both natural voting behavior and malicious scheme managers can trigger this DoS condition.

## Finding Description

The `AddBeneficiary` method creates a new ProfitDetail and appends it to the beneficiary's details list without any size validation or deduplication. [1](#0-0) 

The cleanup logic only removes details meeting all three strict conditions: EndPeriod is not MaxValue, already claimed past EndPeriod, and beyond the receiving due period. [2](#0-1) 

When claiming profits, the contract must iterate through ALL accumulated details using LINQ `.Where()` operations to filter available and profitable entries, regardless of the processing limit. [3](#0-2) 

The `ProfitReceivingLimitForEachTime` constant is set to 10, which only limits how many details are processed per transaction, not the total list size that must be iterated. [4](#0-3) 

**Attack Vector 1 - Malicious Scheme Manager:**
Any user can create their own profit scheme via the public `CreateScheme` method. [5](#0-4) 

The scheme manager can then repeatedly call `AddBeneficiary` with any beneficiary address, as the authorization only checks if the caller is the scheme manager or TokenHolder contract. [6](#0-5) 

**Attack Vector 2 - Election Contract Natural Accumulation:**
The Election contract's Vote method adds a new ProfitDetail for each vote using the unique voteId as the ProfitDetailId. [7](#0-6) 

However, when withdrawing votes, the Election contract calls `RemoveBeneficiary` WITHOUT specifying the ProfitDetailId. [8](#0-7) 

The Welfare scheme is created with `CanRemoveBeneficiaryDirectly = false` (scheme index 3), which means only expired details are removed when `EndPeriod < CurrentPeriod`. [9](#0-8) 

This causes the `RemoveProfitDetails` method to only remove details where the EndPeriod has already passed, leaving active vote details in the list indefinitely. [10](#0-9) 

## Impact Explanation

**Severity: HIGH**

When a beneficiary accumulates thousands of ProfitDetail entries (e.g., 10,000+), attempting to claim profits requires iterating through the entire list during the LINQ filtering operations. This gas-intensive operation can exceed block gas limits, making profit claims impossible.

**Affected Users:**
- Frequent voters in the Election contract who vote 100+ times will accumulate hundreds of uncleaned details
- Any address targeted by a malicious scheme manager will be unable to claim from that scheme
- System-wide citizen welfare distribution is disrupted

**No Recovery Path:**
- Victims cannot reduce their detail count (no self-service removal method)
- Cannot claim profits to trigger cleanup (catch-22: need to claim to cleanup expired details, but claiming is blocked by gas limits)
- Details persist indefinitely until manually cleaned by scheme manager
- Legitimate profit rewards become permanently inaccessible

## Likelihood Explanation

**Likelihood: HIGH**

**Natural Occurrence:**
Active Election contract participants naturally accumulate one ProfitDetail per vote. With 100+ votes over time, users reach hundreds of details. Since withdrawal doesn't properly remove these details, they persist and accumulate.

**Malicious Attack:**
- Any user can execute the attack (CreateScheme is public)
- Attack cost is minimal (only transaction fees for repeated AddBeneficiary calls)
- Attack complexity is LOW (simple loop of 10,000 AddBeneficiary transactions with different ProfitDetailIds)
- Can target any address preemptively before they even interact with the scheme
- Difficult to detect until victim attempts to claim profits

**Preconditions:**
- No special permissions required beyond scheme creation
- No on-chain constraints prevent accumulation
- Natural voting behavior triggers the condition over time

## Recommendation

**Fix 1 - Add Size Limit in AddBeneficiary:**
Implement a maximum limit on the number of ProfitDetail entries per beneficiary (e.g., 100). Reject AddBeneficiary calls that would exceed this limit.

**Fix 2 - Fix Election Contract Withdrawal:**
Modify `RemoveBeneficiaryOfVoter` to pass the voteId as ProfitDetailId when calling RemoveBeneficiary. This ensures specific vote details are removed upon withdrawal.

**Fix 3 - Enhanced Cleanup Logic:**
Modify the cleanup logic in `AddBeneficiary` to remove more aggressively, such as removing details where `LastProfitPeriod >= EndPeriod` (claimed through end) even if not beyond the due period.

**Fix 4 - Batch Cleanup Method:**
Add a public method that allows beneficiaries to trigger cleanup of their own expired details without claiming, providing a recovery path for affected users.

## Proof of Concept

```csharp
// Test demonstrating DoS through ProfitDetail accumulation
[Fact]
public async Task ProfitDetailAccumulationCausesDoS()
{
    // Setup: Create a scheme where attacker is manager
    var attackerKeyPair = SampleECKeyPairs.KeyPairs[10];
    var victimAddress = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[11].PublicKey);
    
    var createResult = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true
    });
    var schemeId = createResult.Output;
    
    // Attack: Add 1000 ProfitDetails with different IDs for victim
    for (int i = 0; i < 1000; i++)
    {
        await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
        {
            SchemeId = schemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = victimAddress,
                Shares = 100
            },
            EndPeriod = 1000,
            ProfitDetailId = HashHelper.ComputeFrom($"detail_{i}")
        });
    }
    
    // Verify: Victim cannot claim due to gas exhaustion
    // When victim tries to claim, ClaimProfits must iterate through all 1000 details
    var victimStub = GetProfitContractStub(SampleECKeyPairs.KeyPairs[11]);
    
    // This will fail or consume excessive gas due to iteration through 1000 details
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await victimStub.ClaimProfits.SendAsync(new ClaimProfitsInput
        {
            SchemeId = schemeId
        });
    });
    
    // The claim fails because LINQ .Where() must iterate all 1000 entries
    // even though only 10 are processed per call
}
```

## Notes

The vulnerability is confirmed through code analysis of the Profit, Election, and Treasury contracts. The issue stems from three converging factors:

1. **Unbounded accumulation** - No size limits in AddBeneficiary
2. **Inadequate cleanup** - Only removes very old expired details
3. **Missing removal identifiers** - Election withdrawal doesn't pass ProfitDetailId

The combination of these factors creates a permanent DoS condition that affects both malicious attack scenarios and natural usage patterns. The impact is HIGH because it breaks core profit distribution functionality with no recovery mechanism for affected users.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-84)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
    {
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;

        Context.LogDebug(() => $"Created scheme {State.SchemeInfos[schemeId]}");

        Context.Fire(new SchemeCreated
        {
            SchemeId = scheme.SchemeId,
            Manager = scheme.Manager,
            IsReleaseAllBalanceEveryTimeByDefault = scheme.IsReleaseAllBalanceEveryTimeByDefault,
            ProfitReceivingDuePeriodCount = scheme.ProfitReceivingDuePeriodCount,
            VirtualAddress = scheme.VirtualAddress
        });
        return schemeId;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-201)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-767)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L304-310)
```csharp
    private void RemoveBeneficiaryOfVoter(Address voterAddress = null)
    {
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            Beneficiary = voterAddress ?? Context.Sender
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-382)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```
