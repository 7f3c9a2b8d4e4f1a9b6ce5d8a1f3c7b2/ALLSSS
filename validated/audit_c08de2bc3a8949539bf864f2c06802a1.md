# Audit Report

## Title
Unauthorized Consensus Order Manipulation via TuneOrderInformation in ProcessUpdateValue

## Summary
The `ProcessUpdateValue()` function unconditionally applies arbitrary `TuneOrderInformation` entries from any miner to modify other miners' `FinalOrderOfNextRound` values without authorization or legitimacy checks. This allows any current miner to manipulate the mining order and block production schedule of the next round, compromising consensus integrity and enabling unfair reward allocation.

## Finding Description

The vulnerability exists in the consensus update mechanism where miners can arbitrarily modify other miners' next-round mining orders without proper validation.

**Root Cause:**

`ProcessUpdateValue()` blindly applies all `TuneOrderInformation` entries to update any miner's `FinalOrderOfNextRound` field without verifying the sender's authority or the legitimacy of the values: [1](#0-0) 

The only authorization check occurs in `PreCheck()`, which merely verifies the sender is in the current or previous miner list: [2](#0-1) 

This check does NOT validate whether the sender has authority to modify OTHER miners' `FinalOrderOfNextRound`, whether the keys correspond to legitimate miners, or whether the values match the intended cryptographic derivation.

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` correctness, completely ignoring `TuneOrderInformation`: [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` only checks the COUNT of miners with valid `FinalOrderOfNextRound`, not the authorization or actual values, and is only applied for NextRound behavior, not UpdateValue: [4](#0-3) [5](#0-4) 

The validation flow's `RecoverFromUpdateValue` blindly copies `FinalOrderOfNextRound` values from the provided round into the base round BEFORE hash comparison, rendering the validation ineffective: [6](#0-5) [7](#0-6) 

**Intended Design:**

According to legitimate extraction logic, `TuneOrderInformation` should only contain miners whose `FinalOrderOfNextRound` differs from `SupposedOrderOfNextRound` due to automatic conflict resolution: [8](#0-7) 

The `SupposedOrderOfNextRound` is cryptographically derived from each miner's signature: [9](#0-8) 

And conflict resolution should follow deterministic logic to find the next available order: [10](#0-9) 

However, the contract never validates that provided `TuneOrderInformation` matches this intended cryptographic derivation and conflict-resolution logic.

## Impact Explanation

**Direct Consensus Integrity Compromise:**

The manipulated `FinalOrderOfNextRound` values directly determine the mining order and timing in the next round. When generating the next round, miners are sorted by their `FinalOrderOfNextRound`, and their `Order` and `ExpectedMiningTime` are set accordingly: [11](#0-10) 

**Specific Harms:**

1. **Unfair Block Production**: An attacker can assign themselves earlier time slots (orders 1, 2, etc.) to produce more blocks and earn disproportionate rewards.

2. **Competitor Suppression**: The attacker can push competing miners to later slots or assign invalid orders, reducing their block production opportunities.

3. **Reward Misallocation**: Mining rewards are distributed based on block production counts. Manipulated mining order leads to unfair reward distribution among miners.

4. **Consensus Disruption**: Assigning conflicting or out-of-range orders can disrupt round transitions and cause consensus failures.

This violates the core consensus invariant of "miner schedule integrity" by enabling direct manipulation of block production order without cryptographic validation, fundamentally breaking the fairness assumption of the AEDPoS consensus mechanism.

## Likelihood Explanation

**Attacker Capabilities:**

The attacker only needs to be a current or previous miner, which is a standard participant role in the consensus system. No additional privileges or special access is required.

**Attack Complexity:**

LOW - The attacker simply needs to:
1. Craft an `UpdateValueInput` with legitimate `OutValue` and `Signature` (normal mining data that passes validation)
2. Add arbitrary `TuneOrderInformation` entries with target miners' public keys and desired order values
3. Submit via the public `UpdateValue()` method during their mining slot: [12](#0-11) 

Any miner in any round can exploit this vulnerability. Given the direct economic incentive (more blocks equals more rewards), rational miners would be motivated to attempt this manipulation.

## Recommendation

Implement validation of `TuneOrderInformation` in `ProcessUpdateValue()` to ensure:

1. **Authorization Check**: Verify the sender has authority to modify the specific miners' orders (or remove the ability to modify others' orders entirely).

2. **Cryptographic Validation**: Verify that each entry in `TuneOrderInformation` matches the expected cryptographic derivation from the miner's signature and follows the deterministic conflict-resolution logic.

3. **Legitimacy Check**: Verify that all keys in `TuneOrderInformation` correspond to legitimate miners in the current round.

Add a new validation provider `TuneOrderInformationValidationProvider` that validates these constraints before applying the values, and include it in the validation chain for UpdateValue behavior.

## Proof of Concept

A malicious miner can craft an `UpdateValueInput` with:
- Valid `OutValue` = Hash of their in-value
- Valid `Signature` = Computed from their consensus data
- Valid `PreviousInValue` = Their previous round's in-value
- Malicious `TuneOrderInformation` = `{ "MinerA": 10, "MinerB": 15, "Attacker": 1 }`

When they call `UpdateValue()`:
1. `PreCheck()` passes (they are a miner)
2. `UpdateValueValidationProvider` passes (OutValue, Signature, PreviousInValue are valid)
3. `ProcessUpdateValue()` applies the malicious `TuneOrderInformation` without validation
4. The attacker gets order 1 (earliest time slot) in the next round
5. Other miners get pushed to later slots

This breaks consensus fairness and enables reward manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
