# Audit Report

## Title
Miner Subset Exclusion Attack via Unvalidated ProvidedRound Miner List in NextRound Transitions

## Summary
The NextRound validation logic fails to verify that the proposed round contains all miners from the current round. A malicious miner can craft a NextRoundInput excluding legitimate miners, pass all validation checks, and commit an incomplete miner set to state, effectively removing elected miners from consensus and denying their rewards.

## Finding Description

The AEDPoS consensus contract allows any active miner to submit a NextRound transaction to transition to the next consensus round. [1](#0-0)  The validation logic validates internal consistency within the provided round but never compares the miner list against the current round to ensure completeness.

During NextRound behavior validation, only three validators are active: [2](#0-1) 

The MiningPermissionValidationProvider only verifies the transaction sender is in the BaseRound: [3](#0-2) 

The NextRoundMiningOrderValidationProvider only checks that miners with FinalOrderOfNextRound > 0 equals miners with OutValue != null, both computed from the same ProvidedRound: [4](#0-3)  This ensures internal consistency but does not validate completeness against BaseRound.

The RoundTerminateValidationProvider only checks round number increment and InValue fields: [5](#0-4) 

The ProvidedRound comes directly from attacker-controlled NextRoundInput via the ConsensusValidationContext: [6](#0-5) 

After validation passes, ProcessNextRound converts the input to a Round and commits it to state: [7](#0-6) 

The ToRound() method preserves whatever miners are in the input without validation: [8](#0-7) 

The incomplete miner set is committed directly to state: [9](#0-8) 

By contrast, the legitimate GenerateNextRoundInformation method ensures ALL miners from the current round are included by processing both miners who mined and miners who didn't mine: [10](#0-9) 

## Impact Explanation

**Consensus Integrity Compromise**: The fundamental invariant that all legitimately elected miners participate in consensus is violated. An attacker can arbitrarily reduce the active consensus set from N to M miners (M < N), directly breaking the miner schedule integrity critical invariant.

**Reward Misallocation**: Excluded miners lose 100% of their mining rewards for all subsequent rounds until corrected. In a 7-miner network where 2 miners are excluded, the remaining 5 miners receive disproportionate rewards (40% increase per miner). This constitutes direct economic theft from excluded miners.

**Security Degradation**: Reducing the active miner set from 7 to 5 decreases Byzantine fault tolerance from supporting 2 malicious nodes (2/7 < 1/3) to supporting only 1 malicious node (2/5 > 1/3). The network becomes vulnerable to attacks with fewer compromised nodes.

**Operational Denial-of-Service**: Excluded miners cannot participate in consensus despite being validly elected through the proper election mechanism. This can be repeated across multiple rounds to permanently suppress specific miners.

## Likelihood Explanation

**Reachable Entry Point**: The attack uses the public NextRound method which any authorized miner can call.

**Minimal Attacker Capabilities**: The attacker only needs to be an active miner with normal block production rights (obtainable through legitimate election), wait for their turn to produce the NextRound transition block, modify the NextRoundInput.RealTimeMinersInformation to exclude target miners while ensuring internal consistency, and submit the transaction.

**No Special Privileges Required**: The attack doesn't require compromising governance contracts, election mechanisms, or system keys. It only requires normal miner participation privileges that are obtained through the standard election process.

**Low Attack Complexity**: The attacker can legitimately call GetConsensusExtraData to generate proper NextRound data, then manually modify the miner list before submission. The validation logic has no defense against this manipulation since it never compares the provided miner list against the current round's miner list.

**High Economic Rationality**: Colluding miners can increase their rewards by 20-40% by excluding competitors, with minimal cost (one block production slot). The economic incentive is particularly strong when mining rewards are substantial.

## Recommendation

Add a validation provider that explicitly checks miner list completeness during NextRound transitions. The validator should:

1. Compare the count of miners in ProvidedRound against BaseRound
2. Verify that all miner public keys in BaseRound.RealTimeMinersInformation exist in ProvidedRound.RealTimeMinersInformation
3. Only allow miner list changes during NextTerm transitions, not NextRound transitions

Suggested implementation:

```csharp
public class MinerListCompletenessValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        
        // Check miner count matches
        if (baseRound.RealTimeMinersInformation.Count != providedRound.RealTimeMinersInformation.Count)
        {
            validationResult.Message = "Miner count mismatch between current and next round.";
            return validationResult;
        }
        
        // Check all current miners are present in next round
        foreach (var minerKey in baseRound.RealTimeMinersInformation.Keys)
        {
            if (!providedRound.RealTimeMinersInformation.ContainsKey(minerKey))
            {
                validationResult.Message = $"Miner {minerKey} missing from next round.";
                return validationResult;
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Then add this validator to the NextRound validation chain in AEDPoSContract_Validation.cs.

## Proof of Concept

A proof of concept would require:
1. Setting up a test environment with multiple miners
2. Having one miner craft a NextRoundInput with a subset of the current miners
3. Ensuring the crafted input maintains internal consistency (FinalOrderOfNextRound count matches OutValue count)
4. Calling NextRound with the crafted input
5. Verifying that the transaction succeeds and the incomplete miner set is committed to state
6. Confirming that excluded miners cannot participate in subsequent rounds

The test would demonstrate that the NextRound method accepts and commits an incomplete miner list without any validation failure, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```
