# Audit Report

## Title
Evil Miners Can Produce Blocks Despite Exceeding Missed Time Slots Threshold

## Summary
The `MiningPermissionValidationProvider` performs only dictionary key existence validation without checking the `MissedTimeSlots` counter. This allows miners who have exceeded the `TolerableMissedTimeSlotsCount` threshold (4320 slots = 3 days) to continue producing blocks and earning rewards until they are detected post-execution in `ProcessNextRound`. This creates an exploitation window where unreliable miners can earn rewards despite violating the protocol's availability requirements.

## Finding Description

The AEDPoS consensus protocol defines a tolerance threshold for miner inactivity: miners who miss 4320 time slots (3 days of continuous absence) should be marked as "evil" and excluded from block production. However, the pre-execution validation does not enforce this constraint.

**Root Cause:**

The `MiningPermissionValidationProvider.ValidateHeaderInformation` method only verifies that a miner's public key exists in the `RealTimeMinersInformation` dictionary, with a comment explicitly stating "Simply check keys of RealTimeMinersInformation should be enough." [1](#0-0) 

The method does not validate the `MissedTimeSlots` field against the threshold defined as 4320 (60 * 24 * 3). [2](#0-1) 

**Execution Flow Creating the Vulnerability Window:**

1. During `ValidateBeforeExecution`, the `MiningPermissionValidationProvider` is added to the validation chain: [3](#0-2) 

2. This validation occurs BEFORE block execution at the contract level.

3. Evil miner detection only happens AFTER block execution in `ProcessNextRound`: [4](#0-3) 

4. The detection method properly checks the `MissedTimeSlots` threshold: [5](#0-4) 

5. The `MissedTimeSlots` counter is incremented for miners who miss their slots: [6](#0-5) [7](#0-6) 

6. Evil miners remain in `RealTimeMinersInformation` for the current round. When generating the next round, miners are copied from the current round with their `MissedTimeSlots` preserved: [8](#0-7) 

**The Critical Gap:**

A miner with `MissedTimeSlots >= 4320` remains in the `RealTimeMinersInformation` dictionary. When their assigned time slot arrives, they can produce blocks that pass validation (since only key existence is checked), execute successfully, and increment their `ProducedBlocks` counter: [9](#0-8) [10](#0-9) 

## Impact Explanation

**High Severity - Consensus Economic Integrity Violation**

Miners who have demonstrated sustained unreliability (3 days of missed time slots) can continue to:

1. **Earn Mining Rewards:** When blocks are produced, the total reward is calculated based on blocks mined and the mining reward per block (initially 12,500,000 tokens): [11](#0-10) [12](#0-11) 

2. **Impact Honest Miners:** The mining reward distribution is based on `ProducedBlocks` counts, with individual miner shares calculated accordingly: [13](#0-12) [14](#0-13) 

Evil miners dilute the reward pool that should go exclusively to reliable miners.

3. **Violate Protocol Invariants:** The AEDPoS protocol's economic design assumes that miners crossing the 4320 missed slots threshold are immediately prevented from earning further rewards. This delay in enforcement breaks that fundamental assumption.

**Affected Parties:**
- Honest miners lose potential rewards to miners who should be excluded
- Token holders experience inflationary pressure from rewards paid to undeserving participants
- Network consensus quality is degraded by allowing unreliable miners to participate

## Likelihood Explanation

**High Likelihood**

**Preconditions:**
1. Attacker must be an active miner in the current consensus round
2. Attacker accumulates `MissedTimeSlots >= 4320` (achievable through 3 days of downtime or deliberate absence)
3. Attacker's time slot must arrive before the `NextRound` or `NextTerm` transition that would trigger detection

**Attack Execution:**
1. Miner intentionally or accidentally misses time slots across multiple rounds
2. `MissedTimeSlots` counter increments each round the miner fails to produce blocks
3. After crossing the 4320 threshold, miner remains in `RealTimeMinersInformation`
4. When miner's assigned time slot arrives, miner comes back online
5. Miner produces blocks that pass validation (only key existence is checked)
6. Miner's `ProducedBlocks` counter increases, earning them reward eligibility
7. Only during the subsequent `ProcessNextRound` call is the miner detected and marked as evil

**Feasibility Assessment:**
- **Current System Behavior:** This is not an edge case but the actual implementation. The validation explicitly states it only checks keys.
- **No Special Privileges Required:** Any miner can experience this scenario through network issues or deliberate manipulation.
- **Economically Rational:** The cost is being offline for 3 days, but miners can still earn rewards for any blocks produced before detection.
- **Observable in Code:** The comment in `MiningPermissionValidationProvider` confirms the insufficient validation is intentional but flawed.

## Recommendation

Add a `MissedTimeSlots` threshold check to the `MiningPermissionValidationProvider.ValidateHeaderInformation` method:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
    {
        validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
        return validationResult;
    }

    // Add threshold check
    var minerInfo = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    if (minerInfo.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
    {
        validationResult.Message = $"Sender {validationContext.SenderPubkey} exceeded missed time slots threshold.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

This ensures that miners who have exceeded the tolerance threshold are prevented from producing blocks during pre-execution validation, closing the exploitation window.

## Proof of Concept

The vulnerability is demonstrated by the execution flow:

1. Miner accumulates `MissedTimeSlots >= 4320` over multiple rounds
2. Pre-execution validation only checks key existence
3. Block executes successfully and increments `ProducedBlocks`
4. Post-execution detection marks miner as evil, but rewards are already earned

The code references provided demonstrate each step of this flow, showing that the validation gap allows evil miners to earn rewards before detection occurs.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L8-24)
```csharp
    /// <summary>
    ///     This validation will based on current round information stored in StateDb.
    ///     Simply check keys of RealTimeMinersInformation should be enough.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L7-7)
```csharp
    public const long InitialMiningRewardPerBlock = 12500000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L242-252)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L303-306)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L43-48)
```csharp
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L87-96)
```csharp
    private void CountMissedTimeSlots()
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return;

        foreach (var minerInRound in currentRound.RealTimeMinersInformation)
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);

        TryToUpdateRoundInformation(currentRound);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-121)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-55)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L789-812)
```csharp
        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }
```
