# Audit Report

## Title
Empty Miner Lists Cause Zero Maximum Blocks Count Leading to Cascading Block Production Throttling

## Summary
During Abnormal blockchain status, when no miners successfully produce UpdateValue blocks in previous rounds, the consensus mechanism incorrectly calculates a maximum blocks count of 0, which cascades into negative BlocksCount values that force all miners into NextRound-only behavior, severely throttling block production during critical network recovery periods.

## Finding Description

The vulnerability exists in the AElf consensus contract's block production throttling mechanism during Abnormal blockchain status (when LIB is not advancing).

**Root Cause:**

When the blockchain enters Abnormal state, `GetMaximumBlocksCount()` retrieves mined miner lists from the previous two rounds and calculates their intersection to determine how many blocks miners can produce [1](#0-0) 

Miners are only considered "mined" if they have `SupposedOrderOfNextRound != 0`, which is set during UpdateValue block processing [2](#0-1) [3](#0-2) 

During severe network issues, if few or no miners successfully produce UpdateValue blocks in rounds N-1 and N-2, both mined miner lists become empty. When both lists are empty, their intersection count is 0, resulting in `factor = 0` and `GetMaximumBlocksCount()` returning 0 [4](#0-3) 

**Cascading Failure:**

After processing any consensus information, `ResetLatestProviderToTinyBlocksCount()` is called with the calculated maximum blocks count [5](#0-4) 

When a different miner produces the next block, the function sets `BlocksCount = minersCountInTheory.Sub(1)` [6](#0-5) 

With `minersCountInTheory = 0`, this results in `BlocksCount = -1`.

**Forced NextRound Behavior:**

When a miner with negative BlocksCount requests a consensus command, the contract immediately forces NextRound behavior, bypassing normal behavior provider logic [7](#0-6) 

The normal behavior provider cannot return TinyBlock behavior because the check `ActualMiningTimes.Count < _maximumBlocksCount` is never satisfied when `_maximumBlocksCount = 0` (Count is always >= 0) [8](#0-7) 

Each active miner progressively gets `BlocksCount = -1` after producing a single block, forcing the entire network into NextRound-only mode.

NextRound blocks are scheduled for future rounds with significant time delays [9](#0-8) 

## Impact Explanation

**Operational Impact:**

This vulnerability causes severe blockchain throughput degradation during network recovery:

1. **Tiny Block Elimination**: The normal maximum of 8 tiny blocks per miner is reduced to 0, completely disabling high-throughput tiny block production [10](#0-9) 

2. **Forced Throttling**: All miners are progressively forced into NextRound behavior after producing just one block, even though they could produce valid UpdateValue blocks to help recovery

3. **Recovery Hindrance**: The mechanism designed to stabilize the network during Abnormal state actually makes recovery harder by creating a negative feedback loop - the worse the network situation, the more restrictive it becomes

4. **Throughput Collapse**: Block production rate drops to minimum possible - only scheduled NextRound blocks with future-time delays

**Affected Parties:**
- All network validators unable to produce blocks normally
- Users experiencing prolonged transaction processing delays  
- Entire blockchain suffering from extended degraded state

**Severity:** While not causing direct fund loss, this creates a DoS condition on consensus operations during critical network stress periods when recovery throughput is most needed. The cascading nature means the issue worsens as more miners attempt to participate.

## Likelihood Explanation

**Trigger Conditions:**

1. Network experiences instability for 2+ consecutive rounds
2. Few or no miners successfully produce UpdateValue blocks (due to network partitions, latency issues, or coordination failures)
3. Blockchain enters Abnormal status (LIB not advancing by 2+ rounds)
4. Empty mined miner lists exist for previous rounds

**Feasibility:**

- **No Attacker Required**: This is a natural failure mode during network issues - no malicious actor needed
- **Reachable State**: Occurs through normal consensus flows during network stress
- **Execution Practicality**: Automatically triggered when conditions are met
- **Probability**: Medium - requires sustained network issues but represents a realistic failure scenario in distributed systems

**Complexity:** Low - the condition naturally arises during network instability without requiring sophisticated coordination.

## Recommendation

Add a minimum lower bound to `GetMaximumBlocksCount()` to prevent it from returning 0:

```csharp
private int GetMaximumBlocksCount()
{
    // ... existing logic ...
    
    if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
    {
        var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
        var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
        var minersOfLastTwoRounds = previousRoundMinedMinerList
            .Intersect(previousPreviousRoundMinedMinerList).Count();
        var factor = minersOfLastTwoRounds.Mul(
            blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                (int)currentRoundNumber.Sub(libRoundNumber)));
        var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
            Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
        
        // Ensure minimum of 1 to prevent cascading negative BlocksCount
        count = Math.Max(1, count);
        
        Context.LogDebug(() => $"Maximum blocks count tune to {count}");
        return count;
    }
    
    // ... rest of the method ...
}
```

This ensures that even during severe network issues with empty mined miner lists, the system maintains a minimum blocks count of 1, preventing the cascading failure while still providing meaningful throttling during Abnormal state.

## Proof of Concept

A proof of concept would require:
1. Setting up a test network with multiple miners
2. Simulating network issues where no miners successfully produce UpdateValue blocks for 2+ consecutive rounds  
3. Observing the blockchain enter Abnormal status
4. Verifying that `GetMaximumBlocksCount()` returns 0 due to empty mined miner lists
5. Confirming that `BlocksCount` becomes -1 for miners
6. Demonstrating that all miners are forced into NextRound-only behavior

The vulnerability can be triggered by creating a scenario where `State.MinedMinerListMap[roundNumber]` contains MinerList objects with empty Pubkeys collections for the previous two rounds, which would occur naturally when `GetMinedMiners()` returns empty lists during sustained network failures.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-55)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L68-69)
```csharp
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-246)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L358-363)
```csharp
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-37)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
