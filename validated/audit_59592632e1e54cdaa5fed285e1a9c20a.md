# Audit Report

## Title
Extra Block Producer ArrangedMiningTime Violates Time Slot Boundaries in Future Rounds

## Summary

The `ArrangeAbnormalMiningTime` method incorrectly calculates the extra block producer's mining time for future rounds by using the producer's normal Order position instead of the extra block slot position (after all regular miners). This causes the extra block to be scheduled within another miner's time slot, violating the fundamental consensus time slot allocation invariant.

## Finding Description

The vulnerability exists in the time slot calculation logic when arranging extra block mining for future rounds after the designated time has passed.

**Entry Point:**
When a miner's behavior is `NextRound` or `NextTerm`, the `TerminateRoundCommandStrategy` is instantiated [1](#0-0) , which calls `ArrangeExtraBlockMiningTime` [2](#0-1) .

**Root Cause:**
The `ArrangeExtraBlockMiningTime` method delegates to `Round.ArrangeAbnormalMiningTime` [3](#0-2) . When the extra block producer's designated time has passed (the condition at line 30 fails), the code falls through to line 36 which calculates: `futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval))` [4](#0-3) . This uses the miner's normal `Order` position, not the extra block slot position.

**Expected Behavior:**
According to the consensus design, the extra block should be produced after all normal miners. The `GetExtraBlockMiningTime` method correctly implements this by taking the last miner's `ExpectedMiningTime` and adding one `MiningInterval` [5](#0-4) . This equals `RoundStartTime + minersCount * MiningInterval`.

**Why Order ≠ minersCount:**
The `BreakContinuousMining` logic swaps the last miner (Order = minersCount) with the second-to-last miner when the last miner is the extra block producer [6](#0-5) . This ensures the extra block producer typically has `Order < minersCount`.

**Missing Validation:**
The `TimeSlotValidationProvider` only validates against `ExpectedMiningTime` (normal slot) [7](#0-6) , and the `RoundTerminateValidationProvider` only validates round number and InValue fields [8](#0-7) . Neither checks that extra blocks are scheduled at the correct extra block time slot.

## Impact Explanation

This vulnerability violates the fundamental consensus invariant that each miner has a designated time slot and the extra block producer mines after all regular miners. 

**Concrete Example:**
- 5 miners, mining interval = 4000ms
- Extra block producer has Order = 2 (typical after BreakContinuousMining)
- If arranging for a future round starting at time T:
  - **Calculated (incorrect)**: T + (2 × 4000) = T + 8000ms (Order 2 slot)
  - **Expected (correct)**: T + (5 × 4000) = T + 20000ms (extra block slot)
  - **Violation**: 12000ms (3 time slots) off target

**Consensus Integrity Impact:**
1. **Time slot collision**: The extra block producer is scheduled during another miner's normal time slot, causing potential simultaneous mining attempts
2. **Round termination failures**: The extra block is not produced at the correct time, potentially delaying round transitions
3. **Consensus disruption**: Blocks produced out-of-sequence can affect consensus finality and chain progression

This constitutes a high-severity consensus integrity violation affecting the core time slot scheduling mechanism that ensures orderly block production in AEDPoS.

## Likelihood Explanation

**High likelihood** - this occurs during normal consensus operations without requiring any malicious actor.

**Preconditions (naturally occurring):**
1. Extra block producer's Order < minersCount (common due to BreakContinuousMining)
2. Extra block mining time has passed when consensus command is requested
3. Behavior is NextRound or NextTerm [9](#0-8) 

**Triggering Conditions:**
This occurs whenever a miner queries for their consensus command after their extra block time slot has passed. Given network latency, node synchronization delays, or brief outages, this is a regular occurrence in distributed consensus systems. The behavior provider automatically returns NextRound/NextTerm when appropriate [10](#0-9) .

## Recommendation

Modify `ArrangeAbnormalMiningTime` to use the correct extra block slot position when calculating future round mining time for extra block producers:

```csharp
public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
    bool mustExceededCurrentRound = false)
{
    var miningInterval = GetMiningInterval();
    var minerInRound = RealTimeMinersInformation[pubkey];

    if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
    {
        var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
            .Milliseconds();
        if (distance > 0) return GetExtraBlockMiningTime();
    }

    var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
    var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
    var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
    
    // FIX: Use extra block slot position for extra block producers
    if (GetExtraBlockProducerInformation().Pubkey == pubkey)
    {
        return futureRoundStartTime.AddMilliseconds(RealTimeMinersInformation.Count.Mul(miningInterval));
    }
    
    return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
}
```

## Proof of Concept

This vulnerability can be demonstrated by:

1. Setting up a 5-miner network with 4000ms mining interval
2. Assigning an extra block producer with Order = 2 (via BreakContinuousMining logic)
3. Allowing the extra block time to pass
4. Calling GetAEDPoSConsensusCommand with NextRound behavior
5. Observing the returned ArrangedMiningTime uses position 2 instead of position 5

The test would verify that for future rounds, the arranged time equals `futureRoundStartTime + (Order * miningInterval)` rather than `futureRoundStartTime + (minersCount * miningInterval)`, demonstrating the 12000ms (3 time slots) discrepancy in the example scenario.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L25-26)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-36)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L92-107)
```csharp
        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```
