# Audit Report

## Title
Cross-Scheme State Confusion Due to One-to-One Mapping Limitation in TokenHolder Contract

## Summary
The TokenHolder contract enforces a one-to-one relationship between manager addresses and schemes through `TokenHolderProfitSchemes` mapping, while the underlying Profit contract supports multiple schemes per manager. When `CreateScheme` is called multiple times, subsequent calls overwrite previous scheme metadata but create new schemes in the Profit contract, causing operations to use metadata from one scheme with the SchemeId from another, resulting in users locking wrong token types and being unable to receive profits.

## Finding Description

The vulnerability stems from an architectural mismatch between TokenHolder and Profit contracts regarding scheme management.

The TokenHolder contract uses a one-to-one mapping for scheme storage [1](#0-0) , allowing only one scheme per address. 

However, `CreateScheme` creates a new scheme in the Profit contract on every invocation [2](#0-1)  and then overwrites the TokenHolder storage [3](#0-2)  without any duplicate check.

The Profit contract explicitly supports multiple schemes per manager through a repeated list structure [4](#0-3)  defined in the protobuf as `repeated aelf.Hash scheme_ids` [5](#0-4) .

When `UpdateTokenHolderProfitScheme` retrieves the SchemeId, it uses `FirstOrDefault()` to get only the first scheme from the manager's list [6](#0-5) .

**Exploitation Scenario:**

1. User calls `CreateScheme` with symbol "ELF", minimum_lock_minutes = 100
   - Profit creates SchemeId_A
   - TokenHolder stores {symbol: "ELF", minimum_lock_minutes: 100}

2. User calls `CreateScheme` again with symbol "USDT", minimum_lock_minutes = 200
   - Profit creates SchemeId_B (added to list at index 1)
   - TokenHolder **overwrites** to {symbol: "USDT", minimum_lock_minutes: 200}

3. User calls `RegisterForProfits`:
   - Gets mixed scheme: metadata from second scheme (USDT, 200) but SchemeId_A
   - Locks USDT tokens [7](#0-6) 
   - Adds beneficiary to SchemeId_A (ELF scheme) [8](#0-7) 

4. Result: User has locked USDT tokens but is registered for ELF profits, making the locked funds effectively stuck with no profit distribution.

## Impact Explanation

**Critical Fund Impact:**
- Users lock incorrect token types that don't match the scheme's distribution token, making profits unclaimable
- Wrong lock duration enforcement causes users to lock funds for incorrect periods [9](#0-8) 
- First scheme becomes permanently orphaned and inaccessible through TokenHolder methods
- Operations like `Withdraw`, `ContributeProfits`, and `DistributeProfits` all use the corrupted mixed scheme state

This breaks the fundamental security guarantee that locked tokens correspond to the profit scheme they're registered to.

## Likelihood Explanation

**High Likelihood:**
- `CreateScheme` is a public method with no access restrictions [10](#0-9) 
- No assertion exists to prevent duplicate calls (verified through code search showing no duplicate check)
- The Profit contract is explicitly designed to support multiple schemes per manager, suggesting legitimate use cases
- No warning or error is thrown on subsequent calls, making accidental triggering likely
- Users may legitimately want multiple schemes for different tokens or configurations

## Recommendation

Add a duplicate check in `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this address. Use a different manager address.");
    
    // ... rest of existing code
}
```

Alternatively, if multiple schemes per address should be supported, redesign the storage to use a nested mapping structure similar to the Profit contract.

## Proof of Concept

```csharp
[Fact]
public async Task CrossSchemeStateConfusion_MultipleCreateScheme()
{
    // First CreateScheme call - ELF scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // Second CreateScheme call - USDT scheme (overwrites first)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 200
    });
    
    // ContributeProfits to initialize SchemeId
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 1000
    });
    
    // Get scheme - shows mixed state
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    
    // Verify vulnerability: metadata from USDT scheme but SchemeId from ELF scheme
    scheme.Symbol.ShouldBe("USDT"); // Metadata from second CreateScheme
    scheme.MinimumLockMinutes.ShouldBe(200); // Metadata from second CreateScheme
    
    var profitScheme = await ProfitContractStub.GetScheme.CallAsync(scheme.SchemeId);
    var managingSchemes = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    
    // Verify SchemeId points to FIRST scheme (ELF), not second (USDT)
    scheme.SchemeId.ShouldBe(managingSchemes.SchemeIds.First()); // First scheme
    managingSchemes.SchemeIds.Count.ShouldBe(2); // Two schemes exist in Profit
    
    // RegisterForProfits will attempt to lock USDT (from metadata) 
    // but register to ELF scheme (from SchemeId), causing mismatch
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-293)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** protobuf/profit_contract.proto (L288-290)
```text
message CreatedSchemeIds {
    // The scheme ids.
    repeated aelf.Hash scheme_ids = 1;
```
