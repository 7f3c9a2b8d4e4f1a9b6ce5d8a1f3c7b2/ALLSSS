# Audit Report

## Title
Replacement Miner Can Manipulate Mining Order Through Unvalidated PreviousInValue

## Summary
Replacement miners (those not present in the previous consensus round) can provide arbitrary `PreviousInValue` that bypasses validation, allowing them to manipulate their mining order in the next round. This creates unfair advantages over honest miners who are bound by deterministic values.

## Finding Description

The AEDPoS consensus contract fails to validate the `PreviousInValue` provided by replacement miners, enabling systematic mining order manipulation.

**Root Cause:**

When a replacement miner (not in the previous round) produces a block, the contract's validation logic creates an exploitable bypass: [1](#0-0) 

For replacement miners, the check at line 80 fails because `ContainsKey(pubkey)` returns false. Due to short-circuit AND evaluation, the validation is skipped, and execution falls through to the else block where the attacker-provided value is accepted without any validation.

The validation provider explicitly bypasses validation for non-existent miners: [2](#0-1) 

**Impact Chain:**

The manipulated `PreviousInValue` is used to calculate the miner's signature through XOR operations with all previous round signatures: [3](#0-2) 

This signature directly determines the miner's position in the next round through modular arithmetic: [4](#0-3) 

The `FinalOrderOfNextRound` value becomes the actual mining `Order` when the next round is generated: [5](#0-4) 

## Impact Explanation

This vulnerability violates consensus fairness guarantees:

1. **MEV Opportunities**: Position 1 miners produce the first block and see the mempool first, enabling front-running, sandwich attacks, and transaction ordering manipulation for profit extraction.

2. **Unfair Competition**: Honest miners are bound by their deterministic InValue from previous commitments and cannot choose their order. Replacement miners can systematically select optimal positions, creating a two-tier system.

3. **Consensus Predictability Violation**: Mining order should be deterministically derived from unpredictable signatures. Allowing individual choice undermines this security property.

While this doesn't directly steal funds or break chain liveness, it fundamentally compromises the fairness invariant that honest participants depend upon. In blockchain systems, mining order directly translates to economic opportunities, and systematic manipulation creates compounding advantages.

## Likelihood Explanation

**Preconditions (Highly Realistic)**:
- Replacement miners occur regularly through automatic evil miner detection or manual `ReplaceCandidatePubkey` operations
- No special permissions required beyond being a valid replacement miner

**Attack Complexity (LOW)**:
1. Offline computation: For each candidate `PreviousInValue`, calculate `signature = XOR(PreviousInValue, AllPreviousSignatures)` and derive `order = (signature % minersCount) + 1`
2. Find value yielding desired order (average ~minersCount/2 attempts, trivial for 17 miners)
3. Modify node software to inject chosen value into trigger information
4. Produce block - contract accepts without validation

**Detection Difficulty**: Very high. The manipulated value appears as legitimate consensus data with no baseline for comparison since the miner wasn't in the previous round.

**Economic Rationality**: Attack cost is negligible (microseconds of hash computation), while benefits are significant (optimal mining position, MEV extraction, transaction ordering control).

## Recommendation

Implement validation for replacement miners by generating deterministic `PreviousInValue` from verifiable sources:

1. **Use public randomness**: Derive `PreviousInValue` from the previous round's random hash combined with the miner's public key
2. **Validate against protocol-generated value**: Instead of accepting arbitrary input, calculate the expected value on-chain and compare
3. **Alternative**: Use the miner's public key hash as the InValue for their first appearance

Example fix in `GetConsensusExtraDataToPublishOutValue`:

```csharp
// For replacement miners, use deterministic value
if (!previousRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)];
    var deterministicPreviousInValue = HashHelper.ConcatAndCompute(
        previousRandomHash, 
        HashHelper.ComputeFrom(pubkey)
    );
    
    // Validate provided value matches expected
    if (triggerInformation.PreviousInValue != deterministicPreviousInValue)
    {
        previousInValue = Hash.Empty; // Reject invalid value
    }
    else
    {
        previousInValue = deterministicPreviousInValue;
    }
    signature = previousRound.CalculateSignature(deterministicPreviousInValue);
}
```

## Proof of Concept

A proof-of-concept would demonstrate:

1. Setup: Initialize consensus with multiple miners, trigger miner replacement
2. Attack: Replacement miner computes optimal `PreviousInValue` offline:
   - Retrieve all previous round signatures
   - For target order=1: Calculate `targetSig = 0 + k*minersCount` for some k
   - Solve `PreviousInValue = targetSig XOR AllPreviousSignatures`
3. Execution: Replacement miner provides computed value during block production
4. Verification: Next round shows attacker at position 1 instead of random/deterministic position
5. Compare: Honest miners cannot achieve this, demonstrating unfair advantage

**Notes**

The vulnerability is limited to the round immediately after a miner joins as a replacement. After producing one block with the manipulated order, they have a committed `OutValue` and cannot manipulate subsequent rounds. However, this still creates systematic advantages during high-value periods and enables targeted MEV extraction when replacing a miner at opportune moments.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L74-92)
```csharp
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L40-40)
```csharp
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-44)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
