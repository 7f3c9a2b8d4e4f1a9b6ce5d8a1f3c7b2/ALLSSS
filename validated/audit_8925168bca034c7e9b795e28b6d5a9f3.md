# Audit Report

## Title
Quadratic Voting Cost Progression Broken for Locked Token Voting

## Summary
The Vote contract's quadratic voting implementation fails to enforce progressive cost increases when `IsLockToken` is true. Each vote generates a unique `VoteId` based on the accumulating `VotesAmount`, causing the `QuadraticVotesCountMap` tracking to always start at zero for each vote. This results in constant cost (`TicketCost * 1`) instead of the intended quadratic progression (`TicketCost * 1, 2, 3...`), completely defeating quadratic voting's vote-buying resistance.

## Finding Description

The vulnerability exists in the interaction between VoteId generation and quadratic cost tracking in the Vote contract.

**Root Cause:**

For locked token voting (`IsLockToken=true`), the `VoteId` is generated using the current `VotesAmount` from the voting result: [1](#0-0) 

Since `VotesAmount` increases with each vote, every vote generates a unique `VoteId`. The quadratic cost calculation uses this `VoteId` as the key to lookup the vote count: [2](#0-1) 

The map structure is defined as: [3](#0-2) 

**Execution Flow:**

1. **First vote by voter A:**
   - `votingResult.VotesAmount = 0` (initial state)
   - `VoteId = GenerateId(Self, 0.ToBytes())` → UniqueID_1
   - `QuadraticVotesCountMap[UniqueID_1]` defaults to 0
   - `currentVotesCount = 0 + 1 = 1`
   - `amount = TicketCost * 1`
   - `votingResult.VotesAmount` updated to `TicketCost` [4](#0-3) 

2. **Second vote by voter A:**
   - `votingResult.VotesAmount = TicketCost` (from first vote)
   - `VoteId = GenerateId(Self, TicketCost.ToBytes())` → UniqueID_2 (DIFFERENT!)
   - `QuadraticVotesCountMap[UniqueID_2]` defaults to 0 (NEW KEY!)
   - `currentVotesCount = 0 + 1 = 1` (SAME AS FIRST!)
   - `amount = TicketCost * 1` (NO INCREASE!)

3. **Subsequent votes:** Pattern continues - each vote costs `TicketCost * 1`

**Why Protections Fail:**

The `Register` method accepts both `IsQuadratic` and `IsLockToken` flags without validation: [5](#0-4) 

The validation function `AssertValidNewVotingItem` does not check for incompatible flag combinations: [6](#0-5) 

**Contrast with Delegated Voting:**

For delegated voting (`IsLockToken=false`), the sponsor provides the `VoteId` in the input: [7](#0-6) 

However, this still requires sponsor cooperation and lacks proper per-voter tracking.

## Impact Explanation

**Token Economics Manipulation:**
- Voters acquire unlimited votes at constant cost (`TicketCost` per vote) instead of quadratic cost
- Expected total cost for N votes: `TicketCost * (1+2+...+N) = TicketCost * N(N+1)/2` ≈ O(N²)
- Actual cost: `TicketCost * N` = O(N)

**Quantified Damage:**
For a voter acquiring 100 votes with `TicketCost=1000` tokens:
- **Intended cost:** 1000 × 5050 = 5,050,000 tokens
- **Actual cost:** 1000 × 100 = 100,000 tokens  
- **Savings:** 4,950,000 tokens (98% discount!)

**Governance Integrity Compromise:**
- Wealthy actors can cheaply dominate any voting item created with both flags enabled
- Nullifies quadratic voting's vote-buying resistance
- Honest voters who vote few times pay proportional cost while attackers exploit constant cost

**Protocol Design Violation:**
The feature is labeled "quadratic" but provides no quadratic cost progression, breaking the fundamental security guarantee.

**Severity:** HIGH - Breaks core security property, enables voting manipulation, no special permissions required.

## Likelihood Explanation

**Attacker Capabilities:**
- Any address can call `Register` to create a voting item (public method)
- Any address can call `Vote` to participate (public method)
- No special permissions required

**Attack Complexity:**
- **Trivial:** Two simple transactions:
  1. `Register(IsQuadratic=true, IsLockToken=true, TicketCost=X, ...)`
  2. `Vote(...)` multiple times with same voter
- No sophisticated contract interactions needed
- Attacker controls `TicketCost` parameter

**Feasibility Conditions:**
- ✅ Public methods accessible to all
- ✅ No validation prevents the flag combination  
- ✅ No economic barriers
- ✅ Works in current contract state without preconditions

**Detection:**
- Not easily detectable without analyzing `QuadraticVotesCountMap` state
- Appears as legitimate voting activity
- No on-chain alerts for constant-cost voting in "quadratic" items

**Probability:** VERY HIGH - The vulnerability is exploitable in every voting item where both flags are true. Even unaware sponsors can inadvertently create exploitable voting items.

## Recommendation

Implement per-voter tracking for quadratic voting instead of using a global `VoteId`:

1. **Add voter-specific tracking map**:
```csharp
// In VoteContractState.cs
public MappedState<Hash, Address, long> VoterQuadraticCountMap { get; set; } // VotingItemId -> Voter -> Count
```

2. **Modify quadratic cost calculation**:
```csharp
// In Vote method
if (votingItem.IsQuadratic)
{
    var voterCountKey = HashHelper.ConcatAndCompute(input.VotingItemId, input.Voter.Value);
    var currentVotesCount = State.VoterQuadraticCountMap[input.VotingItemId][input.Voter].Add(1);
    State.VoterQuadraticCountMap[input.VotingItemId][input.Voter] = currentVotesCount;
    amount = votingItem.TicketCost.Mul(currentVotesCount);
}
```

3. **Add validation in Register**:
```csharp
// Optionally, if quadratic + locked tokens is not intended
Assert(!(input.IsQuadratic && input.IsLockToken), 
    "Quadratic voting with locked tokens is not supported.");
```

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_LockedToken_FailsToIncreaseVoteCost()
{
    // Register a quadratic voting item with locked tokens
    var startTime = TimestampHelper.GetUtcNow();
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(10),
        StartTimestamp = startTime,
        Options = { "Option1", "Option2" },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = true,
        IsQuadratic = true,
        TicketCost = 1000
    };
    
    await VoteContractStub.Register.SendAsync(input);
    input.Options.Clear();
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender));
    
    var voter = Accounts[0].KeyPair;
    var voterStub = GetVoteContractTester(voter);
    
    // First vote - should cost 1000 * 1 = 1000
    await voterStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "Option1",
        Amount = 0 // ignored for quadratic
    });
    
    // Second vote - SHOULD cost 1000 * 2 = 2000, but will cost 1000 * 1 = 1000
    await voterStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "Option1",
        Amount = 0
    });
    
    // Third vote - SHOULD cost 1000 * 3 = 3000, but will cost 1000 * 1 = 1000
    await voterStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "Option1",
        Amount = 0
    });
    
    // Verify: Total votes should be 3, total amount should be 6000 (1+2+3)*1000
    // But actual will be 3000 (3*1000)
    var result = await VoteContractStub.GetLatestVotingResult.CallAsync(votingItemId);
    result.VotesAmount.ShouldBe(3000); // Proves vulnerability: should be 6000
    result.Results["Option1"].ShouldBe(3); // Vote count is correct
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L42-51)
```csharp
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-102)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L179-179)
```csharp
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L392-397)
```csharp
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```
