# Audit Report

## Title
Delegated Voting VoteId Overwrite Enables Vote Double-Counting and Record Corruption

## Summary
The Vote contract's `Vote` function unconditionally overwrites voting records at `State.VotingRecords[input.VoteId]` without checking if a record already exists at that key. In delegated voting mode (`IsLockToken = false`), the sponsor supplies the `VoteId` and can reuse the same identifier for multiple voters, causing vote double-counting, loss of original voting data, and corrupted withdrawal tracking.

## Finding Description
When a voting item is registered with `IsLockToken = false` (delegated voting), only the sponsor may call the `Vote` function and must provide the `VoteId` parameter. [1](#0-0) 

The validation logic checks that `input.VoteId` is not null, but does not verify that the `VoteId` has never been used before. [1](#0-0) 

The `Vote` function then unconditionally writes the new voting record to state, overwriting any existing record at that key. [2](#0-1) 

Subsequently, `UpdateVotingResult` is called, which adds the vote amount to the total without any duplicate detection. [3](#0-2) 

The vote tallies are incremented each time, regardless of whether the `VoteId` was previously used. [4](#0-3) 

Additionally, `UpdateVotedItems` adds the `VoteId` to the new voter's `ActiveVotes` list, meaning multiple voters can have the same `VoteId` in their tracking lists even though only the last record persists in storage. [5](#0-4) 

**Attack Path:**
1. A malicious or buggy sponsor registers a voting item with `IsLockToken = false` (no access control on registration). [6](#0-5) 
2. Sponsor calls `Vote(VoteId=X, Voter=Alice, Amount=100)`
   - Record stored: `State.VotingRecords[X] = {Voter: Alice, Amount: 100}`
   - Alice's `ActiveVotes` contains X
   - Vote total incremented by 100
3. Sponsor calls `Vote(VoteId=X, Voter=Bob, Amount=200)` with the **same VoteId**
   - Record **overwritten**: `State.VotingRecords[X] = {Voter: Bob, Amount: 200}`
   - Bob's `ActiveVotes` contains X
   - Vote total incremented by 200 (now 300 total, but should be 200)
4. Result:
   - Only Bob's record exists in `State.VotingRecords[X]`
   - Alice's `ActiveVotes` still contains X, but the record shows Bob
   - Vote tally is inflated by 100 (double-counted)
   - When Alice tries to withdraw, the withdrawal logic will fail or incorrectly affect Bob's vote

## Impact Explanation
**Critical Severity:**

1. **Governance Manipulation**: Vote totals are artificially inflated through double-counting, enabling manipulation of voting outcomes. In governance systems, this could lead to unauthorized proposals passing or legitimate proposals failing.

2. **Data Corruption**: Previous voters' records are permanently lost when overwritten. This creates irreversible state corruption where the on-chain voting history becomes inaccurate and cannot be audited correctly.

3. **Withdrawal Failures**: The withdrawal function retrieves records by `VoteId`, so multiple voters may believe they have active votes (because the `VoteId` is in their `ActiveVotes` list), but only the last voter's record actually exists. [7](#0-6) 

4. **Protocol Integrity Violation**: Core invariants are broken:
   - Each `VoteId` should map to exactly one voting record
   - Vote totals should equal the sum of all non-withdrawn records
   - Each voter's `ActiveVotes` should correspond to valid, non-overwritten records they created

## Likelihood Explanation
**High Likelihood:**

1. **No Access Control on Registration**: Any address can call the `Register` function to create a voting item with `IsLockToken = false` and become a sponsor. [6](#0-5) 

2. **Simple to Trigger**: A malicious or buggy sponsor contract can easily call `Vote` multiple times with the same `VoteId` for different voters. The attack requires no special privileges beyond being a sponsor.

3. **Realistic Scenarios**: 
   - A buggy third-party voting contract accidentally reuses `VoteId` values
   - A compromised or malicious sponsor intentionally manipulates votes
   - A poorly audited integration contract fails to generate unique identifiers

4. **Difficult to Detect**: The corruption is subtleâ€”vote tallies appear normal, but individual record lookups reveal inconsistencies. Post-hoc auditing may not detect the issue until disputes arise over withdrawal eligibility.

5. **No Defense in Depth**: The Vote contract relies entirely on sponsors being well-behaved. While the trusted Election contract generates unique `VoteId` values correctly [8](#0-7) , this does not prevent untrusted sponsors from misusing the system.

## Recommendation
Add a uniqueness check before storing the voting record:

```csharp
// At line 117 in VoteContract.cs
Assert(State.VotingRecords[input.VoteId] == null, "VoteId already exists.");
State.VotingRecords[input.VoteId] = votingRecord;
```

Alternatively, if vote updates/changes are intended for delegated voting, implement proper update logic that:
1. Retrieves the existing record
2. Subtracts the old vote amount from totals
3. Removes the old `VoteId` from the previous voter's `ActiveVotes`
4. Updates the record and totals accordingly

The current design creates an unsafe contract interface that assumes perfect sponsor behavior, violating defense-in-depth security principles.

## Proof of Concept
The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task VoteId_Reuse_Causes_Double_Counting()
{
    // Setup: Register delegated voting item (IsLockToken = false)
    var votingItemId = await RegisterDelegatedVotingItem();
    
    // Sponsor votes with VoteId X for Alice
    var voteIdX = HashHelper.ComputeFrom("X");
    await VoteContract.Vote(new VoteInput
    {
        VotingItemId = votingItemId,
        VoteId = voteIdX,
        Voter = AliceAddress,
        Amount = 100,
        Option = "OptionA"
    });
    
    // Verify first vote recorded
    var record1 = await VoteContract.GetVotingRecord(voteIdX);
    record1.Voter.ShouldBe(AliceAddress);
    record1.Amount.ShouldBe(100);
    
    // Sponsor reuses same VoteId X for Bob
    await VoteContract.Vote(new VoteInput
    {
        VotingItemId = votingItemId,
        VoteId = voteIdX,  // Same VoteId!
        Voter = BobAddress,
        Amount = 200,
        Option = "OptionA"
    });
    
    // Alice's record is overwritten - only Bob's exists
    var record2 = await VoteContract.GetVotingRecord(voteIdX);
    record2.Voter.ShouldBe(BobAddress);  // Alice's record lost
    record2.Amount.ShouldBe(200);
    
    // But vote total is double-counted: 100 + 200 = 300
    var result = await VoteContract.GetVotingResult(votingItemId, 1);
    result.Results["OptionA"].ShouldBe(300);  // Should be 200!
    result.VotersCount.ShouldBe(2);  // But only 1 record exists
    
    // Alice's ActiveVotes contains X, but record shows Bob
    var aliceVotes = await VoteContract.GetVotedItems(AliceAddress);
    aliceVotes.VotedItemVoteIds[votingItemId.ToHex()].ActiveVotes.ShouldContain(voteIdX);
}
```

This test proves:
1. The same `VoteId` can be reused for different voters
2. Previous records are overwritten and lost
3. Vote totals are double-counted (300 instead of 200)
4. Multiple voters have the same `VoteId` in their `ActiveVotes` lists
5. Only the last record persists in storage

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-39)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-120)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
        UpdateVotedItems(input.VoteId, votingRecord.Voter, votingItem);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-205)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L402-412)
```csharp
    private Hash GenerateVoteId(VoteMinerInput voteMinerInput)
    {
        if (voteMinerInput.Token != null)
            return Context.GenerateId(Context.Self, voteMinerInput.Token);

        var candidateVotesCount =
            State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0;
        return Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(voteMinerInput.CandidatePubkey.GetBytes(),
                candidateVotesCount.ToBytes(false)));
    }
```
