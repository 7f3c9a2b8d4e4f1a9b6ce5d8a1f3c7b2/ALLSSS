# Audit Report

## Title
Race Condition in EnableConnector: Token Supply Manipulation via Transfer Callback Leads to Under-Collateralization

## Summary
The `EnableConnector()` function in TokenConverter has a time-of-check to time-of-use (TOCTOU) vulnerability where it calculates the required deposit based on the current token supply, but the supply can be manipulated through a transfer callback before the deposit balance is set. This violates the checks-effects-interactions pattern and can result in critical under-collateralization of the Bancor connector pair.

## Finding Description

The vulnerability exists in `EnableConnector()` where the deposit calculation occurs before external interactions, but the state update happens after: [1](#0-0) 

The execution sequence creates a race window:

1. **Line 276**: `GetNeededDeposit(input)` queries the token's current total supply and calculates the required deposit [2](#0-1) 

2. **Lines 287-295**: Resource token is transferred to the contract via `TransferFrom`, which triggers the MultiToken transfer callback mechanism [3](#0-2) 

3. During the callback execution via `Context.SendInline`, if the callback contract is configured as the token's Issuer, it can call `Issue()` to mint additional tokens [4](#0-3) 

4. **Line 297**: The deposit balance is set to the originally calculated amount, which no longer reflects the actual circulating supply

The MultiToken contract's `DoTransferFrom` invokes the callback after the transfer completes [5](#0-4) 

**Critical Finding**: Unlike other TokenConverter management functions (`UpdateConnector`, `AddPairConnector`, `SetFeeRate`), `EnableConnector` has **no authorization checks**, making it publicly callable by anyone once the connector pair exists.

## Impact Explanation

**Under-Collateralization Scenario:**

The Bancor formula maintains pricing based on the relationship between deposit balance and token supply. The deposit calculation ensures sufficient base tokens exist to buy back all circulating tokens [6](#0-5) 

When users sell tokens back to the converter, the pricing calculation uses the deposit balance [7](#0-6) 

The `GetSelfBalance` function returns the stored `DepositBalance` for deposit connectors [8](#0-7) 

**Concrete Attack:**
- Initial supply: 1,000 tokens
- `AmountToTokenConvert`: 100 tokens
- Calculated deposit: For 900 circulating tokens = X ELF
- **During transfer callback**: Attacker mints 100,000 additional tokens
- Actual circulating supply: 100,900 tokens
- Deposit remains: X ELF (only sufficient for 900 tokens)

**Direct Consequences:**
1. Bancor formula calculates incorrect pricing due to artificially low deposit balance
2. Attacker sells the newly minted tokens, draining the under-collateralized deposit
3. Later sellers face DoS when deposit is exhausted
4. Protocol-level invariant broken: deposit cannot cover all circulating tokens

## Likelihood Explanation

**Prerequisites:**
1. Parliament approves a connector pair via `AddPairConnector` (requires governance vote)
2. Token has transfer callback configured in `ExternalInfo` metadata
3. Callback contract address is set as the token's Issuer (allowing `Issue()` calls)
4. Anyone can then call `EnableConnector` (no authorization required)

**Feasibility Assessment: MEDIUM**

While Parliament approval is required, several factors increase likelihood:

1. **Subtle Attack Vector**: Transfer callbacks are configured in `ExternalInfo` metadata, which may be overlooked during governance review of token proposals

2. **No Authorization on EnableConnector**: Unlike other management functions, `EnableConnector` is public, allowing the attacker to trigger the exploit after Parliament approval

3. **Legitimate Use Case Confusion**: Transfer callbacks have legitimate purposes (notification systems, cross-contract interactions), making malicious configurations less obvious

4. **Defense-in-Depth Violation**: Smart contracts should not rely solely on external governance to prevent exploitable code paths. This represents a fundamental design flaw violating the checks-effects-interactions pattern.

## Recommendation

**Primary Fix**: Move state update before external interactions:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    var needDeposit = GetNeededDeposit(input);
    
    // SET STATE BEFORE EXTERNAL CALLS
    State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
    toConnector.IsPurchaseEnabled = true;
    fromConnector.IsPurchaseEnabled = true;
    
    // Now perform transfers
    if (needDeposit.NeedAmount > 0)
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = needDeposit.NeedAmount
            });

    if (input.AmountToTokenConvert > 0)
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.TokenSymbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.AmountToTokenConvert
            });

    return new Empty();
}
```

**Alternative Fixes**:
1. Add authorization check requiring Parliament approval for `EnableConnector`
2. Re-calculate deposit after transfers and verify it matches the original calculation
3. Validate tokens don't have transfer callbacks before allowing connector creation

## Proof of Concept

**Setup:**
1. Create malicious token `EVIL` with:
   - Issuer = AttackerCallbackContract address
   - ExternalInfo contains `TransferCallbackExternalInfoKey` pointing to AttackerCallbackContract
2. Submit proposal to Parliament to add connector pair for `EVIL`
3. Parliament approves (assuming callback configuration overlooked)

**Attack Execution:**
```csharp
// AttackerCallbackContract callback method
public override Empty OnTransferCallback(TransferFromInput input) 
{
    // Called during EnableConnector's TransferFrom
    // Mint 100,000 additional tokens
    State.TokenContract.Issue.Send(new IssueInput 
    {
        Symbol = input.Symbol,
        Amount = 100000,
        To = Context.Self  // Or attacker's address
    });
    return new Empty();
}

// Attacker calls EnableConnector
EnableConnector(new ToBeConnectedTokenInfo 
{
    TokenSymbol = "EVIL",
    AmountToTokenConvert = 100
});

// Result: Deposit calculated for ~100 circulating tokens
// But actual circulating supply is ~100,100 tokens
// Under-collateralization achieved
```

**Verification**: Query deposit balance vs actual circulating supply to confirm mismatch.

## Notes

The vulnerability fundamentally violates the checks-effects-interactions pattern by performing state updates after external calls that can manipulate the state assumptions. The lack of authorization on `EnableConnector` significantly increases the attack surface compared to other management functions. While Parliament governance provides a control layer, defense-in-depth principles require the contract logic itself to be resilient to malicious inputs even after governance approval.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```
