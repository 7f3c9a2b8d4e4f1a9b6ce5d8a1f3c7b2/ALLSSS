# Audit Report

## Title
ProposerWhiteList Desynchronization in ChangeMember() Breaking Proposal Authorization

## Summary
The `ChangeMember()` function in the Association contract updates the `OrganizationMemberList` but fails to synchronize the `ProposerWhiteList`, creating an authorization desynchronization vulnerability. When a member is replaced, the removed member retains proposal creation rights without voting rights, while the new member gains voting rights without proposal creation rights.

## Finding Description

The Association contract maintains two separate authorization lists that control governance permissions:
- `OrganizationMemberList`: Controls who can vote (approve/reject/abstain) on proposals
- `ProposerWhiteList`: Controls who can create proposals

The vulnerability exists in the `ChangeMember()` function which only modifies `OrganizationMemberList` without updating `ProposerWhiteList`. [1](#0-0) 

When `ChangeMember(input)` executes, it removes `input.OldMember` from the member list and adds `input.NewMember`, but the `ProposerWhiteList` remains unchanged. This creates an authorization inconsistency where:
- The old member can still create proposals but cannot vote
- The new member can vote but cannot create proposals

Proposal creation authorization is enforced by `AssertIsAuthorizedProposer()` which only checks `ProposerWhiteList` membership. [2](#0-1) 

Voting authorization is enforced by `AssertIsAuthorizedOrganizationMember()` which only checks `OrganizationMemberList` membership. [3](#0-2) 

The `Validate()` function does not enforce consistency between these authorization lists - it only verifies that neither list is empty or contains duplicates, and that threshold constraints are satisfied. [4](#0-3) 

Both `CreateProposal()` and `CreateProposalBySystemContract()` only verify `ProposerWhiteList` membership through `AssertIsAuthorizedProposer()`, not `OrganizationMemberList` membership. [5](#0-4) 

**Attack Scenario:**
1. Organization has member Bob in both `OrganizationMemberList` and `ProposerWhiteList`
2. Organization passes proposal to call `ChangeMember({OldMember: Bob, NewMember: Dave})`
3. Post-execution state: Bob removed from `OrganizationMemberList`, Dave added to `OrganizationMemberList`, but `ProposerWhiteList` unchanged (still contains Bob)
4. Bob can call `CreateProposal()` (passes `ProposerWhiteList` check) but cannot vote via `Approve()/Reject()/Abstain()` (fails `OrganizationMemberList` check)
5. Dave can vote but cannot call `CreateProposal()` (fails `ProposerWhiteList` check)

## Impact Explanation

This vulnerability breaks a critical authorization invariant of the Association governance system:

1. **Authorization Bypass**: A removed/replaced member retains proposal creation rights, allowing them to continue influencing governance by creating proposals they should no longer be authorized to create. If the member was removed due to becoming untrusted or having their key compromised, this is a significant security risk.

2. **Incomplete Privilege Transfer**: The new member gains voting rights but lacks proposal creation rights, preventing them from exercising the full governance authority that the replacement intended to grant.

3. **Operational Complexity**: Organizations must perform two separate governance actions (`ChangeMember` + `ChangeOrganizationProposerWhiteList`) to properly replace a proposer. [6](#0-5) 

4. **Silent Failure**: The contract provides no warnings, events, or validation failures when this desynchronization occurs, allowing the vulnerable state to persist undetected.

The severity is **Medium** because:
- It breaks authorization invariants and enables unauthorized proposal creation
- It does NOT directly steal funds or manipulate token balances
- Proposals still require approval thresholds from current members to execute
- Can be mitigated by separately calling `ChangeOrganizationProposerWhiteList()`
- Requires governance action to trigger (not exploitable by external attackers directly)

## Likelihood Explanation

This vulnerability has **High** likelihood of occurrence:

1. **Common Scenario**: Organizations frequently need to replace members who leave, become inactive, are compromised, or lose trust. Member replacement is a routine governance operation.

2. **Entry Point Accessibility**: `ChangeMember()` is callable by the organization itself through approved governance proposals, which is the standard mechanism for membership modifications.

3. **Non-Obvious Requirement**: The need to separately update `ProposerWhiteList` is not enforced by the contract, not checked by validation logic, and not documented. Organizations naturally assume that "changing a member" includes transferring all their privileges.

4. **Operational Friction**: Properly replacing a proposer requires two separate governance proposals and voting rounds, significantly increasing the likelihood that only the first step is completed.

5. **No Automated Detection**: The contract emits a `MemberChanged` event but provides no indication that the `ProposerWhiteList` is now inconsistent with `OrganizationMemberList`.

## Recommendation

Modify the `ChangeMember()` function to automatically synchronize the `ProposerWhiteList` when a member is replaced. The function should:

1. Check if the old member is in the `ProposerWhiteList`
2. If yes, remove the old member from `ProposerWhiteList` and add the new member to `ProposerWhiteList`
3. Maintain the same validation and event emission logic

Alternatively, add validation in the `Validate()` function to ensure that all members in `ProposerWhiteList` are also in `OrganizationMemberList`, which would cause the transaction to fail and alert organizations to the inconsistency.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating an Association organization with member Bob in both `OrganizationMemberList` and `ProposerWhiteList`
2. Creating and approving a proposal to execute `ChangeMember({OldMember: Bob, NewMember: Dave})`
3. Releasing the proposal to execute the member change
4. Attempting to create a proposal as Bob (succeeds - passes `AssertIsAuthorizedProposer`)
5. Attempting to vote as Bob (fails - fails `AssertIsAuthorizedOrganizationMember`)
6. Attempting to create a proposal as Dave (fails - fails `AssertIsAuthorizedProposer`)
7. Attempting to vote as Dave (succeeds - passes `AssertIsAuthorizedOrganizationMember`)

This demonstrates the authorization desynchronization where Bob retains proposal creation rights despite being removed from the organization, while Dave lacks proposal creation rights despite being added as a member.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-121)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }

    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Not authorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
