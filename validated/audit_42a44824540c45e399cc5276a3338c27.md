# Audit Report

## Title
Transaction Fee Free Allowance Overflow Causes DoS Due to Missing Sum Validation

## Summary
The `ConfigTransactionFeeFreeAllowances` method allows parliament to configure multiple threshold symbols that each grant free transaction fee allowances for the same token. When users qualify for multiple thresholds, the `GetFreeFeeAllowanceAmount` method sums all allowances using checked arithmetic. If the cumulative sum exceeds `long.MaxValue`, an `OverflowException` is thrown during fee charging, causing transaction failure and creating a denial-of-service for affected users.

## Finding Description

Parliament can configure multiple threshold symbols (e.g., "ELF", "USDT") via `ConfigTransactionFeeFreeAllowances`, where each threshold symbol can grant allowances for the same fee token. [1](#0-0) 

When a user holds sufficient balances in multiple threshold tokens, `CalculateTransactionFeeFreeAllowances` includes all qualifying thresholds in the returned map by iterating through all configured symbols and checking balance against threshold. [2](#0-1) 

During fee charging, `GetFreeFeeAllowanceAmount` calculates total allowances by iterating through all threshold symbols and summing their allowances using the `Add` extension method. [3](#0-2) 

The `Add` method uses checked arithmetic which throws `OverflowException` when the result exceeds `long.MaxValue`. [4](#0-3) 

The configuration method validates individual inputs (threshold >= 0, symbol exists) but does NOT validate that cumulative allowances across all threshold symbols remain within `long.MaxValue`. [5](#0-4) 

When affected users attempt transactions, the overflow occurs during fee charging at call sites in `ChargeBaseFee` and `ChargeSizeFee` where `GetFreeFeeAllowanceAmount` is invoked. [6](#0-5) 

No exception handling exists around these calls, so the `OverflowException` propagates up and causes transaction failure.

## Impact Explanation

Users holding sufficient balances in multiple threshold tokens to qualify for cumulative allowances exceeding `long.MaxValue` (9,223,372,036,854,775,807) become unable to submit any transactions. Every transaction attempt fails during fee charging with an `OverflowException`, creating complete denial-of-service for these users.

While no funds are lost, affected users are locked out entirely - they cannot transfer tokens, interact with contracts, or perform any on-chain actions. This represents severe operational disruption with:

- **Severity**: Medium-High - Complete DoS for affected users, but requires governance misconfiguration
- **Scope**: Limited to users qualifying for multiple high-value allowance thresholds  
- **Duration**: Permanent until parliament reconfigures to fix the overflow condition
- **Reversibility**: Can be resolved by parliament removing or adjusting threshold configurations

## Likelihood Explanation

**Preconditions**:
1. Parliament must configure multiple threshold symbols where allowances for the same token sum to > `long.MaxValue`
2. Users must hold sufficient balances to qualify for multiple such thresholds simultaneously

**Feasibility**: While parliament is a trusted governance role, configuration mistakes are realistic operational risks. With tokens using 8 decimals, values like 10^17 (representing 1 billion tokens) are plausible allowance amounts. Configuring multiple thresholds granting such allowances could easily exceed the limit unintentionally. The system provides NO warnings, validation, or safeguards against this misconfiguration. Multiple threshold symbols are an explicitly supported use case as demonstrated in existing tests. [7](#0-6) 

**Probability**: Low-Medium - Requires governance error rather than malicious action, but the absence of validation makes this a realistic failure mode.

## Recommendation

Add validation in `ConfigTransactionFeeFreeAllowances` to ensure cumulative allowances across all threshold symbols do not exceed `long.MaxValue` for any given fee token. Before storing new configurations, iterate through all existing threshold symbols and calculate the maximum possible cumulative allowance for each fee token. Assert that adding the new allowances will not cause overflow.

Example validation logic:
```csharp
// After line 1242, add cumulative validation
var cumulativeAllowances = new Dictionary<string, long>();
foreach (var symbol in State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols)
{
    var existingConfig = State.TransactionFeeFreeAllowancesConfigMap[symbol];
    foreach (var feeAllowance in existingConfig.FreeAllowances.Map)
    {
        cumulativeAllowances.TryGetValue(feeAllowance.Key, out var current);
        cumulativeAllowances[feeAllowance.Key] = current.Add(feeAllowance.Value.Amount);
    }
}
// Check new allowances won't cause overflow
foreach (var newAllowance in allowances.TransactionFeeFreeAllowances.Value)
{
    cumulativeAllowances.TryGetValue(newAllowance.Symbol, out var current);
    Assert(long.MaxValue - current >= newAllowance.Amount, 
        $"Cumulative allowance for {newAllowance.Symbol} would exceed long.MaxValue");
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ConfigTransactionFeeFreeAllowances_CumulativeOverflow_Test()
{
    await SetPrimaryTokenSymbolAsync();
    await CreateTokenAndIssueAsync();
    
    // Configure first threshold symbol with large allowance
    await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendAsync(
        new ConfigTransactionFeeFreeAllowancesInput
        {
            Value =
            {
                new ConfigTransactionFeeFreeAllowance
                {
                    Symbol = NativeTokenSymbol,
                    TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                    {
                        Value =
                        {
                            new TransactionFeeFreeAllowance
                            {
                                Symbol = NativeTokenSymbol,
                                Amount = long.MaxValue / 2 + 1
                            }
                        }
                    },
                    RefreshSeconds = 600,
                    Threshold = 1_00000000
                }
            }
        });
    
    // Configure second threshold symbol with large allowance that causes overflow
    await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendAsync(
        new ConfigTransactionFeeFreeAllowancesInput
        {
            Value =
            {
                new ConfigTransactionFeeFreeAllowance
                {
                    Symbol = USDT,
                    TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                    {
                        Value =
                        {
                            new TransactionFeeFreeAllowance
                            {
                                Symbol = NativeTokenSymbol,
                                Amount = long.MaxValue / 2 + 1
                            }
                        }
                    },
                    RefreshSeconds = 600,
                    Threshold = 1_000000
                }
            }
        });
    
    // User holds both threshold tokens
    // Attempt transaction - should fail with OverflowException
    var result = await TokenContractImplStub.Transfer.SendAsync(new TransferInput
    {
        To = UserBAddress,
        Symbol = NativeTokenSymbol,
        Amount = 1
    });
    
    // Transaction should fail due to overflow in GetFreeFeeAllowanceAmount
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L336-373)
```csharp
    private bool ChargeBaseFee(Dictionary<string, long> methodFeeMap, Address fromAddress, ref TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        ref TransactionFreeFeeAllowanceBill allowanceBill,
        TransactionFeeDelegations delegations = null)
    {
        Context.LogDebug(() => "ChargeBaseFee Start");
        // Fail to charge
        if (!ChargeFirstSufficientToken(methodFeeMap, fromAddress, out var symbolToChargeBaseFee,
                out var amountToChargeBaseFee, out var existingBalance, out var existingAllowance,
                transactionFeeFreeAllowancesMap,
                delegations))
        {
            Context.LogDebug(() => "Failed to charge first sufficient token.");
            if (symbolToChargeBaseFee != null)
            {
                bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            } // If symbol == 

            return false;
        }

        // Succeed to charge, freeAllowance first.
        if (existingAllowance > amountToChargeBaseFee)
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee);
            // free fee allowance has covered fee, add 0 for size fee
            bill.FeesMap.Add(symbolToChargeBaseFee, 0);
        }
        else
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            bill.FeesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee.Sub(existingAllowance));
        }

        Context.LogDebug(() => "ChargeBaseFee End");
        return true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1224-1266)
```csharp
    public override Empty ConfigTransactionFeeFreeAllowances(ConfigTransactionFeeFreeAllowancesInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input.Value != null && input.Value.Count > 0, "Invalid input");

        State.TransactionFeeFreeAllowancesSymbolList.Value ??= new TransactionFeeFreeAllowancesSymbolList
        {
            Symbols = { new RepeatedField<string>() }
        };

        foreach (var allowances in input.Value!)
        {
            ValidateToken(allowances.Symbol);
            Assert(
                allowances.TransactionFeeFreeAllowances?.Value != null &&
                allowances.TransactionFeeFreeAllowances.Value.Count > 0,
                "Invalid input allowances");
            Assert(allowances.Threshold >= 0, "Invalid input threshold");
            Assert(allowances.RefreshSeconds >= 0, "Invalid input refresh seconds");

            var config = new TransactionFeeFreeAllowanceConfig
            {
                Symbol = allowances.Symbol,
                Threshold = allowances.Threshold,
                RefreshSeconds = allowances.RefreshSeconds,
                FreeAllowances = new TransactionFeeFreeAllowanceMap()
            };

            foreach (var allowance in allowances.TransactionFeeFreeAllowances!.Value!)
            {
                config.FreeAllowances.Map.TryAdd(allowance.Symbol, allowance);
            }

            State.TransactionFeeFreeAllowancesConfigMap[allowances.Symbol] = config;

            if (!State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Contains(allowances.Symbol))
            {
                State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Add(allowances.Symbol);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1313-1356)
```csharp
    private TransactionFeeFreeAllowancesMap CalculateTransactionFeeFreeAllowances(Address input)
    {
        var freeAllowanceMap = State.TransactionFeeFreeAllowances[input];

        var freeAllowancesConfig = State.TransactionFeeFreeAllowancesSymbolList.Value;
        if (freeAllowancesConfig == null)
        {
            return new TransactionFeeFreeAllowancesMap();
        }

        var transactionFeeFreeAllowancesMap = new TransactionFeeFreeAllowancesMap();

        foreach (var symbol in freeAllowancesConfig.Symbols)
        {
            var balance = State.Balances[input][symbol];
            if (balance < State.TransactionFeeFreeAllowancesConfigMap[symbol].Threshold) continue;

            var lastRefreshTime = State.TransactionFeeFreeAllowancesLastRefreshTimes[input][symbol];

            var freeAllowances = freeAllowanceMap[symbol];

            if (freeAllowances == null)
            {
                transactionFeeFreeAllowancesMap.Map.Add(symbol,
                    State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone());
                continue;
            }

            if (lastRefreshTime == null)
            {
                transactionFeeFreeAllowancesMap.Map.Add(symbol, freeAllowances);
            }
            else
            {
                transactionFeeFreeAllowancesMap.Map[symbol] =
                    (Context.CurrentBlockTime - lastRefreshTime).Seconds >
                    State.TransactionFeeFreeAllowancesConfigMap[symbol].RefreshSeconds
                        ? State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone()
                        : freeAllowances;
            }
        }

        return transactionFeeFreeAllowancesMap;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L179-194)
```csharp
    private long GetFreeFeeAllowanceAmount(TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, string symbol)
    {
        var allowance = 0L;
        var map = transactionFeeFreeAllowancesMap.Map;

        if (map == null) return allowance;

        foreach (var freeAllowances in map.Values)
        {
            freeAllowances.Map.TryGetValue(symbol, out var freeAllowance);

            allowance = allowance.Add(freeAllowance?.Amount ?? 0L);
        }

        return allowance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest_FreeAllowance.cs (L117-226)
```csharp
    public async Task ConfigTransactionFeeFreeAllowances_MultipleTokens_OneByOne_Test()
    {
        await SetPrimaryTokenSymbolAsync();
        await CreateTokenAndIssueAsync();

        await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendAsync(
            new ConfigTransactionFeeFreeAllowancesInput
            {
                Value =
                {
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = NativeTokenSymbol,
                        TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                        {
                            Value =
                            {
                                new TransactionFeeFreeAllowance
                                {
                                    Symbol = NativeTokenSymbol,
                                    Amount = 1_00000000
                                }
                            }
                        },
                        RefreshSeconds = 600,
                        Threshold = 1_00000000
                    }
                }
            });

        {
            var config = await TokenContractImplStub.GetTransactionFeeFreeAllowancesConfig.CallAsync(new Empty());
            config.Value.Count.ShouldBe(1);
            config.Value.First().Symbol.ShouldBe(NativeTokenSymbol);
            config.Value.First().Threshold.ShouldBe(1_00000000);
            config.Value.First().RefreshSeconds.ShouldBe(600);
            config.Value.First().FreeAllowances.Map.Keys.First().ShouldBe(NativeTokenSymbol);
            config.Value.First().FreeAllowances.Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            config.Value.First().FreeAllowances.Map.Values.First().Amount.ShouldBe(1_00000000);

            var userAFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserAAddress);
            userAFreeAllowances.Result.Map.Keys.First().ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Keys.First().ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Values.First().Amount.ShouldBe(1_00000000);
            var userBFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserBAddress);
            userBFreeAllowances.Result.Map.Count.ShouldBe(0);
            var userCFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserCAddress);
            userCFreeAllowances.Result.Map.ShouldBe(userAFreeAllowances.Result.Map);
        }

        await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendAsync(
            new ConfigTransactionFeeFreeAllowancesInput
            {
                Value =
                {
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = USDT,
                        TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                        {
                            Value =
                            {
                                new TransactionFeeFreeAllowance
                                {
                                    Symbol = NativeTokenSymbol,
                                    Amount = 1_00000000
                                }
                            }
                        },
                        RefreshSeconds = 300,
                        Threshold = 1_000000
                    }
                }
            });

        {
            var config = await TokenContractImplStub.GetTransactionFeeFreeAllowancesConfig.CallAsync(new Empty());
            config.Value.Count.ShouldBe(2);
            config.Value.First().Symbol.ShouldBe(NativeTokenSymbol);
            config.Value.First().Threshold.ShouldBe(1_00000000);
            config.Value.First().RefreshSeconds.ShouldBe(600);
            config.Value.First().FreeAllowances.Map.Keys.First().ShouldBe(NativeTokenSymbol);
            config.Value.First().FreeAllowances.Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            config.Value.First().FreeAllowances.Map.Values.First().Amount.ShouldBe(1_00000000);

            config.Value.Last().Symbol.ShouldBe(USDT);
            config.Value.Last().Threshold.ShouldBe(1_000000);
            config.Value.Last().RefreshSeconds.ShouldBe(300);
            config.Value.Last().FreeAllowances.Map.Keys.First().ShouldBe(NativeTokenSymbol);
            config.Value.Last().FreeAllowances.Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            config.Value.Last().FreeAllowances.Map.Values.First().Amount.ShouldBe(1_00000000);

            var userAFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserAAddress);
            userAFreeAllowances.Result.Map.Count.ShouldBe(1);
            userAFreeAllowances.Result.Map.Keys.First().ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Keys.First().ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Values.First().Amount.ShouldBe(1_00000000);
            var userBFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserBAddress);
            userBFreeAllowances.Result.Map.Count.ShouldBe(1);
            userBFreeAllowances.Result.Map.Keys.First().ShouldBe(USDT);
            userBFreeAllowances.Result.Map.Values.First().Map.Keys.First().ShouldBe(NativeTokenSymbol);
            userBFreeAllowances.Result.Map.Values.First().Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            userBFreeAllowances.Result.Map.Values.First().Map.Values.First().Amount.ShouldBe(1_00000000);
            var userCFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserCAddress);
            userAFreeAllowances.Result.Map.Add(USDT, userBFreeAllowances.Result.Map.Values.First());
            userCFreeAllowances.Result.Map.ShouldBe(userAFreeAllowances.Result.Map);
        }
    }
```
