# Audit Report

## Title
Authorization Bypass in CreateScheme Allows Attacker to Pollute Victim's Manager Scheme List Causing Bounded DoS

## Summary
The `CreateScheme` function in the Profit contract lacks authorization checks when accepting the `input.Manager` parameter, allowing any caller to designate an arbitrary address as the scheme manager without that address's consent. This enables an attacker to pollute a victim's managing scheme list up to the state size limit (~4000 schemes, 128KB), causing bounded DoS when querying `GetManagingSchemeIds` and violating the authorization invariant that users control their own manager role assignments.

## Finding Description

The root cause lies in the `CreateScheme` function's handling of the manager parameter. [1](#0-0)  The function directly assigns `input.Manager ?? Context.Sender` as the scheme manager without verifying that the caller (`Context.Sender`) is authorized to assign that specific manager address.

The vulnerable execution path proceeds as follows:
1. Attacker calls `CreateScheme` with `input.Manager` set to victim's address
2. The scheme is created with the victim as the manager [2](#0-1) 
3. The scheme ID is added to `State.ManagingSchemeIds[victim]` without any authorization check [3](#0-2) 

The function only validates the `ProfitReceivingDuePeriodCount` parameter and scheme uniqueness, performing no authorization check on the manager field assignment [4](#0-3) 

This design is inconsistent with all other manager-gated operations in the contract. Operations like `AddSubScheme` [5](#0-4) , `RemoveSubScheme` [6](#0-5) , `AddBeneficiary` [7](#0-6) , and `ResetManager` [8](#0-7)  all properly verify that `Context.Sender == scheme.Manager` before allowing management operations.

The attack is bounded by the state size limit of 128KB [9](#0-8) . Since each Hash is 32 bytes, this allows approximately 4096 schemes maximum per manager address before state writes fail (with protobuf overhead, closer to ~4000 in practice).

The `GetManagingSchemeIds` view method returns the entire list without pagination [10](#0-9) , meaning a victim's query can return up to ~4000 unwanted scheme IDs in a single 128KB response.

## Impact Explanation

**Authorization Violation**: The primary impact is a clear authorization bypass. The victim becomes the actual manager of schemes they never created or authorized. All manager-restricted operations will succeed if the victim calls them on these attacker-created schemes, meaning the victim has been forced into an unwanted management role with associated responsibilities.

**Bounded DoS Impact**: 
- The victim's `GetManagingSchemeIds` query returns up to ~4000 unwanted scheme IDs (128KB of data)
- Clients and applications processing this data experience degraded performance with memory and CPU overhead
- The victim's legitimate scheme management interface becomes polluted with attacker-created schemes
- Applications displaying scheme lists must process and render thousands of entries

**No Mitigation Available**: The victim cannot remove these unwanted schemes from their manager list. While they can use `ResetManager` to transfer management to another address, the pollution already occurred and the schemes existed in their list during the attack period.

**Severity Justification**: This qualifies as Medium severity due to:
1. Clear authorization bypass - fundamental security invariant violated
2. Bounded but significant DoS (128KB response, ~4000 schemes)
3. Practical exploitability with reasonable cost
4. Operational degradation rather than direct fund loss
5. No impact on consensus, cross-chain integrity, or protocol-level guarantees

## Likelihood Explanation

**Attacker Capabilities**: Any address with sufficient ELF tokens for transaction fees can execute this attack. No special permissions or trusted roles are required.

**Attack Complexity**: The attack is simple - repeatedly call `CreateScheme` with the victim's address as manager. Each call costs 10 ELF in transaction fees [11](#0-10) .

**Economic Feasibility**: 
- Maximum impact attack costs ~40,000 ELF (4000 schemes Ã— 10 ELF)
- Smaller-scale attacks (100-500 schemes) cost 1,000-5,000 ELF and still cause noticeable degradation
- No rate limiting or scheme creation caps per manager exist

**Detection**: The attack is publicly visible on-chain, but the victim cannot prevent or reverse it once executed.

## Recommendation

Add an authorization check in the `CreateScheme` function to ensure that when a custom manager is specified, the caller has authorization to assign that manager role. The recommended fix:

```csharp
public override Hash CreateScheme(CreateSchemeInput input)
{
    ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);
    
    // Add authorization check
    if (input.Manager != null)
    {
        Assert(input.Manager == Context.Sender, 
            "Cannot assign manager role to another address without authorization.");
    }

    if (input.ProfitReceivingDuePeriodCount == 0)
        input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
    // ... rest of function
}
```

Alternatively, if there's a legitimate use case for delegated scheme creation (e.g., by system contracts), implement a whitelist of authorized creators or require explicit authorization from the target manager address.

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_ArbitraryManager_AuthorizationBypass_Test()
{
    // Attacker is Creators[0]
    var attacker = Creators[0];
    
    // Victim is Creators[1]
    var victimAddress = Address.FromPublicKey(CreatorKeyPair[1].PublicKey);
    
    // Attacker creates scheme with victim as manager (no authorization check)
    var result = await attacker.CreateScheme.SendAsync(new CreateSchemeInput
    {
        Manager = victimAddress,  // Victim's address without their consent
        ProfitReceivingDuePeriodCount = 100
    });
    
    var schemeId = result.Output;
    
    // Verify scheme was created with victim as manager
    var scheme = await attacker.GetScheme.CallAsync(schemeId);
    scheme.Manager.ShouldBe(victimAddress);
    
    // Verify victim's managing scheme list is polluted
    var victimSchemes = await attacker.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = victimAddress });
    
    victimSchemes.SchemeIds.Count.ShouldBe(1);
    victimSchemes.SchemeIds.ShouldContain(schemeId);
    
    // Victim becomes actual manager - they can perform manager operations
    var victim = Creators[1];
    var addBeneficiaryResult = await victim.AddBeneficiary.SendAsync(
        new AddBeneficiaryInput
        {
            SchemeId = schemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Address.FromPublicKey(CreatorKeyPair[2].PublicKey),
                Shares = 100
            }
        });
    
    // This succeeds, proving victim is the actual manager without consent
    addBeneficiaryResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

## Notes

The absence of authorization checks in `CreateScheme` contrasts sharply with the design of system contracts that use this functionality. For example, the TokenHolder contract explicitly sets `Manager = Context.Sender` [12](#0-11) , and all existing tests omit the Manager field entirely, letting it default to `Context.Sender`. This suggests the ability to specify an arbitrary manager was likely not intended as a feature, but rather represents a missing validation that should have been present from the design phase.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L48-60)
```csharp
        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L99-99)
```csharp
        Assert(Context.Sender == scheme.Manager, "Only manager can add sub-scheme.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L139-139)
```csharp
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L729-729)
```csharp
        Assert(Context.Sender == scheme.Manager, "Only scheme manager can reset manager.");
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```
