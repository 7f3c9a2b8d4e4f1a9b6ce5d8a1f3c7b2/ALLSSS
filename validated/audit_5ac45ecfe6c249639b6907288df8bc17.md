# Audit Report

## Title
Case-Insensitive Token Uniqueness Bypass via CrossChainCreateToken

## Summary
The `CrossChainCreateToken` method bypasses case-insensitive token uniqueness validation by performing only a case-sensitive existence check before registering tokens. This allows an attacker controlling a registered side-chain to create tokens differing only in case (e.g., "token" after "TOKEN"), violating the protocol's fundamental design invariant.

## Finding Description

The AElf MultiToken contract enforces case-insensitive token uniqueness through `State.InsensitiveTokenExisting`, which stores uppercased symbols to prevent tokens differing only by case. [1](#0-0) 

**Secure Path (Normal Token Creation):**

The standard `CreateToken` flow properly enforces this invariant by calling `CheckTokenExists` before registration: [2](#0-1) 

The `CheckTokenExists` method validates case-insensitive uniqueness by checking the uppercased symbol: [3](#0-2) 

**Vulnerable Path (Cross-Chain Token Creation):**

The `CrossChainCreateToken` method bypasses this validation. After verifying cross-chain proofs, it calls `AssertNftCollectionExist`: [4](#0-3) 

This method returns null for non-NFT tokens, providing no validation: [5](#0-4) 

For tokens without the NFT separator, `GetNftCollectionSymbol` returns null: [6](#0-5) 

**Root Cause:**

The vulnerable case-sensitive check occurs here: [7](#0-6) 

Since `State.TokenInfos` uses case-sensitive string keys, if "TOKEN" exists, checking `State.TokenInfos["token"]` returns null, allowing duplicate registration.

The `RegisterTokenInfo` method then sets both states without validation: [8](#0-7) 

**Attack Scenario:**
1. Legitimate token "TOKEN" exists on the destination chain
2. Attacker controls a registered side-chain and creates "token" (lowercase) on their chain
3. Attacker calls `CrossChainCreateToken` with valid merkle proofs
4. The case-sensitive check passes (`State.TokenInfos["token"]` is null)
5. `RegisterTokenInfo` creates a separate entry for "token"
6. Both "TOKEN" and "token" now coexist as independent tokens with separate balances, supplies, and issuers

## Impact Explanation

**Protocol Integrity Violation:**
The protocol explicitly designed case-insensitive uniqueness enforcement through `State.InsensitiveTokenExisting`. This vulnerability completely undermines that design.

**Concrete Harms:**
1. **Token Impersonation:** Attackers can create "elf" to impersonate "ELF", or "usdt" to impersonate "USDT"
2. **User Financial Loss:** Users and applications relying on symbol-based identification will interact with the wrong token
3. **Independent Token State:** Both tokens exist with completely separate `State.TokenInfos` entries (separate balances, supplies, issuers)
4. **Symbol Resolution Confusion:** `GetTokenInfo("TOKEN")` and `GetTokenInfo("token")` return different tokens, breaking DApp assumptions

**Severity:** HIGH - Violates a fundamental protocol invariant, enables targeted impersonation attacks against high-value tokens, and causes direct financial harm to users.

## Likelihood Explanation

**Reachable Entry Point:**
`CrossChainCreateToken` is a public method: [9](#0-8) 

**Attacker Requirements:**
1. Control a side-chain and register its token contract address (requires Parliament approval but achievable through governance)
2. Create a token with different case on their side-chain
3. Generate valid cross-chain merkle proofs (standard functionality)

**Execution Practicality:**
- Cross-chain token creation is actively used functionality
- Attack follows normal cross-chain creation flow
- No exceptional permissions required beyond registered token contract
- Technical barriers are low once side-chain registration is achieved

**Economic Rationality:**
For high-value token impersonation targets, the cost of side-chain deployment and governance approval is economically rational compared to the potential profit from user confusion.

**Probability:** MEDIUM-HIGH likelihood, especially in environments with permissionless or semi-permissionless side-chain creation.

## Recommendation

Add case-insensitive uniqueness validation in `CrossChainCreateToken` before calling `RegisterTokenInfo`:

```csharp
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    // Add this check before RegisterTokenInfo
    CheckTokenExists(tokenInfo.Symbol);
    
    RegisterTokenInfo(tokenInfo);
    // ... rest of the code
}
```

This ensures both the normal and cross-chain token creation paths enforce the same case-insensitive uniqueness invariant.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_CaseInsensitive_Bypass_Test()
{
    // Setup: Create token "TOKEN" on destination chain
    await CreateTokenAsync("TOKEN", "Original Token", 1000000);
    
    // Setup: Register side-chain
    var sideChainId = await GenerateSideChainAsync();
    await RegisterSideChainTokenContractAsync();
    
    // Attack: Create "token" (lowercase) on side-chain
    var validateTx = CreateValidateTokenTransaction("token", "Fake Token", 1000000);
    var sideBlock = await SideChainTestKit.MineAsync(new List<Transaction> { validateTx });
    
    var merklePath = GetTransactionMerklePathAndRoot(validateTx, out var blockRoot);
    await MainAndSideIndexAsync(sideChainId, sideBlock.Height, blockRoot);
    
    // Execute CrossChainCreateToken for "token"
    var result = await TokenContractStub.CrossChainCreateToken.SendAsync(
        new CrossChainCreateTokenInput
        {
            FromChainId = sideChainId,
            ParentChainHeight = sideBlock.Height,
            TransactionBytes = validateTx.ToByteString(),
            MerklePath = merklePath
        });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Both "TOKEN" and "token" now exist as separate tokens
    var tokenUpper = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "TOKEN" });
    var tokenLower = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "token" });
    
    tokenUpper.ShouldNotBeNull();
    tokenLower.ShouldNotBeNull();
    tokenUpper.Symbol.ShouldBe("TOKEN");
    tokenLower.Symbol.ShouldBe("token");
    tokenUpper.TokenName.ShouldNotBe(tokenLower.TokenName); // Separate tokens!
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L17-17)
```csharp
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-87)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-478)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L491-491)
```csharp
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L153-161)
```csharp
    private string GetNftCollectionSymbol(string inputSymbol, bool isAllowCollection = false)
    {
        var symbol = inputSymbol;
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        const int tokenSymbolLength = 1;
        if (words.Length == tokenSymbolLength) return null;
        Assert(words.Length == 2 && IsValidItemId(words[1]), "Invalid NFT Symbol Input");
        return symbol == $"{words[0]}-0" ? (isAllowCollection ? $"{words[0]}-0" : null) : $"{words[0]}-0";
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L163-170)
```csharp
    private TokenInfo AssertNftCollectionExist(string symbol)
    {
        var collectionSymbol = GetNftCollectionSymbol(symbol);
        if (collectionSymbol == null) return null;
        var collectionInfo = GetTokenInfo(collectionSymbol);
        Assert(collectionInfo != null, "NFT collection not exist");
        return collectionInfo;
    }
```
