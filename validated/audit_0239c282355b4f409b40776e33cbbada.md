# Audit Report

## Title
VRF Manipulation via Invalid PreviousInValue Leading to Mining Order Control

## Summary
A critical logic error in the AEDPoS consensus mechanism allows miners to manipulate their mining position in subsequent rounds. When a miner provides an invalid `PreviousInValue` that fails validation, the code correctly sets `previousInValue = Hash.Empty` but erroneously calculates the signature using the invalid value. This breaks the Verifiable Random Function (VRF) fairness guarantee by allowing miners to select arbitrary signature values that determine their mining order.

## Finding Description

The vulnerability exists in the `GetConsensusExtraDataToPublishOutValue` method where signature calculation occurs independently of the self-check validation result.

**Root Cause:**

When a miner produces a block, they must reveal their `PreviousInValue` which should hash to their committed `OutValue` from the previous round. The self-check validation occurs here: [1](#0-0) 

When this check fails, `previousInValue` is correctly set to `Hash.Empty`. However, the signature calculation happens **outside** the validation block and always uses the potentially invalid value: [2](#0-1) 

These mismatched values (previousInValue=Hash.Empty, signature calculated from invalid value) are then passed to `ApplyNormalConsensusData`: [3](#0-2) 

In `ApplyNormalConsensusData`, the signature directly determines the miner's position in the next round: [4](#0-3) [5](#0-4) 

**Why Protections Fail:**

The validation system explicitly allows `PreviousInValue = Hash.Empty`: [6](#0-5) 

This was designed to handle legitimate edge cases (first round, new miners), but it also permits the exploited scenario. There is no verification that the stored signature matches `CalculateSignature(PreviousInValue)` after the round completes.

**Execution Path:**

When generating the next round, miners are ordered by their `FinalOrderOfNextRound` value: [7](#0-6) 

The `order` directly determines each miner's `ExpectedMiningTime`, giving earlier positions to miners with lower order numbers.

The signature calculation combines the input value with previous signatures: [8](#0-7) 

Evil miner detection only checks for missed time slots, not invalid PreviousInValue submissions: [9](#0-8) 

## Impact Explanation

**Critical Consensus Invariant Broken:**
The AEDPoS consensus relies on VRF (Verifiable Random Function) to ensure fair, unpredictable mining order. By allowing miners to choose arbitrary values instead of revealing their committed secrets, the system loses its verifiable randomness property - a fundamental security guarantee.

**Concrete Harm:**
- **Mining Order Manipulation**: Malicious miners can position themselves at order 1 (first position) in every round by selecting invalid `PreviousInValue` values that produce favorable signatures off-chain
- **Unfair Advantage**: Earlier mining positions provide higher certainty of successful block production, transaction ordering control, and MEV opportunities
- **Systemic Impact**: Honest miners lose fair chances at early positions, undermining the entire consensus fairness model

**Severity Assessment:** Medium-High
While this doesn't directly steal funds, it breaks a critical consensus invariant that ensures fair participation. The impact is systemic and affects the integrity of the entire blockchain's consensus mechanism.

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker must be an authorized miner in the current round (legitimate requirement for consensus participation)
- No special cryptographic capabilities required beyond standard hash operations

**Attack Complexity: LOW**
1. Miner computes `CalculateSignature(candidateValue)` for various `candidateValue` options off-chain
2. Selects the value producing desired `FinalOrderOfNextRound` (e.g., order=1)  
3. Submits block with chosen invalid `PreviousInValue` during normal block production

**Feasibility: HIGH**
- Entry point is the standard block production flow (UpdateValue behavior)
- No additional permissions needed beyond being an active miner
- Computationally trivial (just hash operations)
- Can be repeated every round
- Difficult to detect: `PreviousInValue = Hash.Empty` is allowed by design for legitimate cases
- No penalty mechanism exists for this behavior

**Probability:** HIGH for any motivated miner seeking consistent early mining positions.

## Recommendation

Fix the signature calculation to use the validated `previousInValue` variable instead of the raw `triggerInformation.PreviousInValue`:

```csharp
// After the validation block (lines 74-91), replace line 92 with:
signature = previousRound.CalculateSignature(previousInValue);
```

This ensures that if the self-check fails and `previousInValue` is set to `Hash.Empty`, the signature will be calculated from `Hash.Empty` (which is the legitimate value for edge cases) rather than from an invalid attacker-chosen value.

Additionally, consider adding explicit validation that compares the stored signature against what it should be based on the stored `previousInValue` during the next round's validation phase.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a miner in an active round
2. Computing multiple candidate `PreviousInValue` values off-chain
3. For each candidate, calculating `signature = previousRound.CalculateSignature(candidate)`
4. Computing `order = GetAbsModulus(signature.ToInt64(), minersCount) + 1`
5. Selecting a candidate that yields order=1
6. Submitting a block with this invalid `PreviousInValue`
7. Observing that:
   - The self-check fails (hash doesn't match OutValue)
   - `previousInValue` is set to `Hash.Empty` (line 85)
   - But `signature` is calculated from the invalid candidate (line 92)
   - The miner receives `FinalOrderOfNextRound = 1` in `ApplyNormalConsensusData`
   - In the next round, the miner is assigned `Order = 1` and earliest `ExpectedMiningTime`

The attack succeeds because the validation at line 46 of `UpdateValueValidationProvider` explicitly allows `Hash.Empty`, and there is no check verifying that the signature matches the previousInValue.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L80-86)
```csharp
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
