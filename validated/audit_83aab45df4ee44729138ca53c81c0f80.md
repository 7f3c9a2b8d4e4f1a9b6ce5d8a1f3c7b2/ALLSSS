# Audit Report

## Title
Retroactive Miner Count Calculation Causes Sudden Jumps When MinerIncreaseInterval is Modified

## Summary
The `SetMinerIncreaseInterval()` function allows governance to decrease the miner increase interval, but the miner count calculation retroactively applies the new interval to the entire blockchain history. This causes a sudden, unintended jump in the allowed miner count at the next term transition, disrupting consensus dynamics and diluting mining rewards.

## Finding Description

The vulnerability stems from how the AEDPoS consensus contract calculates the auto-increased miner count. The `GetAutoIncreasedMinersCount()` function uses a formula that divides the entire elapsed blockchain time by the current `MinerIncreaseInterval`: [1](#0-0) 

When governance calls `SetMinerIncreaseInterval()` to decrease the interval value, the function only validates that the new interval is not greater than the current value, with no historical tracking: [2](#0-1) 

At the next term transition, `ProcessNextTerm()` calls `UpdateMinersCountToElectionContract()`: [3](#0-2) 

This invokes `GetMinersCount()` which uses the same retroactive calculation: [4](#0-3) 

The suddenly increased count is sent to the Election contract: [5](#0-4) 

The Election contract stores this count: [6](#0-5) 

And uses it in `GetVictories()` to determine how many candidates become miners: [7](#0-6) 

Additionally, the data center count is calculated as 5x the miner count: [8](#0-7) 

## Impact Explanation

Using the constant `SupposedMinersCount = 17`: [9](#0-8) 

**Concrete Example:**
- Blockchain age: 3 years (94,608,000 seconds)
- Original interval: 31,536,000 seconds (1 year)
- Original miner count: 17 + (94,608,000 / 31,536,000) × 2 = 23 miners
- New interval: 3,153,600 seconds (36.5 days)
- New miner count: 17 + (94,608,000 / 3,153,600) × 2 = 77 miners
- **Sudden jump: 54 miners in one term transition**

**Impact on Stakeholders:**

1. **Existing Miners**: Mining reward per miner drops from 1/23 to 1/77 of the reward pool (approximately 70% reduction), as rewards are donated to the Treasury contract based on blocks mined: [10](#0-9) 

2. **Consensus Network**: A sudden 3x increase in miner count disrupts consensus algorithm performance, increases coordination overhead, and violates the gradual growth model designed to maintain network stability.

3. **Data Center Operators**: ValidDataCenterCount jumps from 115 to 385, allowing 270 additional data centers into the subsidy scheme, diluting subsidy distribution across many more beneficiaries.

4. **Candidates**: 54 candidates suddenly become miners without following the intended gradual admission process, undermining the fairness of the election system.

## Likelihood Explanation

**Attacker Profile**: Requires governance control via `MaximumMinersCountController` (typically Parliament contract), which is realistic as parameter adjustments are normal governance operations.

**Attack Complexity**: Low - single transaction calling `SetMinerIncreaseInterval()` with a decreased value. The effect triggers automatically at the next scheduled term transition.

**Realistic Scenario**: Governance might legitimately want to accelerate future miner growth by decreasing the interval, expecting the change to apply going forward. However, due to the retroactive calculation, it unexpectedly causes a massive immediate jump instead.

**Detection Challenge**: The effect becomes visible only after the term transition completes and the new miner set is selected, making it difficult to prevent once the parameter is changed.

## Recommendation

Implement a non-retroactive miner count calculation that tracks historical interval changes. Two potential approaches:

**Option 1: Track interval change timestamp and apply incrementally**
- Store the timestamp when `MinerIncreaseInterval` changes
- Calculate miners added during old interval period separately from new interval period
- Formula: `SupposedMinersCount + (oldPeriodSeconds / oldInterval) * 2 + (newPeriodSeconds / newInterval) * 2`

**Option 2: Store cumulative auto-increased miners**
- When `SetMinerIncreaseInterval()` is called, calculate and store current `AutoIncreasedMinersCount`
- Future calculations add incremental increases from that point forward
- This prevents retroactive application to blockchain history

Add validation to prevent drastic interval changes (e.g., require new interval >= 50% of current interval, or implement gradual step-down over multiple terms).

## Proof of Concept

```csharp
// Test demonstrating retroactive miner count jump
public async Task RetroactiveMinerCountJump_Test()
{
    // Setup: Chain has been running for 3 years (94,608,000 seconds)
    // Initial interval: 31,536,000 seconds (1 year)
    // Current miner count should be: 17 + (3 years / 1 year) * 2 = 23 miners
    
    // Governance decreases interval to 36.5 days (3,153,600 seconds)
    await MaximumMinersCountControllerStub.SetMinerIncreaseInterval.SendAsync(
        new Int64Value { Value = 3_153_600 }
    );
    
    // Advance to next term transition
    await BlockMiningService.MineBlockAsync(/* trigger NextTerm */);
    
    // Verify sudden jump
    var minersCount = await ElectionContractStub.GetMinersCount.CallAsync(new Empty());
    
    // Expected retroactive calculation: 17 + (94,608,000 / 3,153,600) * 2 = 77 miners
    minersCount.Value.ShouldBe(77); // Sudden jump of 54 miners
    
    // Verify data center count jumped proportionally
    var dataCenterCount = minersCount.Value * 5;
    dataCenterCount.ShouldBe(385); // Was 115, now 385
}
```

## Notes

This vulnerability is particularly dangerous because it affects a trusted governance action. The Parliament organization making this change would have legitimate authority and good intentions (accelerating network growth), but the retroactive calculation mechanism turns this into a sudden consensus disruption. The lack of any warning, validation, or gradual transition mechanism makes this a critical design flaw in the miner count auto-increase logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-176)
```csharp
        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
