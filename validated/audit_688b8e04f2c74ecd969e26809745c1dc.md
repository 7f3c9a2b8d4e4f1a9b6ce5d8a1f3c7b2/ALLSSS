# Audit Report

## Title
Circular Swap Logic in BreakContinuousMining Fails to Prevent Consecutive Block Production with Two Miners

## Summary
The `BreakContinuousMining` function in the AEDPoS consensus contract contains a logic flaw where two sequential swap operations cancel each other out when exactly two miners participate in consensus. This allows the same miner to produce both the extra block terminating round N and the first regular block of round N+1, violating the consensus fairness invariant.

## Finding Description

The vulnerability exists in the `BreakContinuousMining` method, which is designed to prevent consecutive block production across round boundaries by rearranging the mining order. [1](#0-0) 

The method performs two independent swap operations:

1. **First swap**: If the first miner of the next round (order 1) matches the extra block producer of the current round, it swaps miners at positions 1 and 2. [2](#0-1) 

2. **Second swap**: If the last miner of the next round matches the extra block producer of the next round, it swaps the last miner with the second-to-last miner. [3](#0-2) 

**Root Cause**: When `minersCount = 2`, both swaps operate on the same pair of miners (order 1 ↔ order 2). Critically, the `IsExtraBlockProducer` flag is NOT modified during swaps—only the `Order` field changes. This means:

- After the first swap, Miner A (extra block producer) moves from order 1 to order 2, but retains `IsExtraBlockProducer = true`
- The second swap checks if the last miner (order 2, now Miner A) equals the extra block producer of next round
- Since `GetExtraBlockProducerInformation()` returns the miner with `IsExtraBlockProducer = true` (still Miner A), the condition triggers [4](#0-3) 
- The second swap reverses the first swap, returning Miner A to order 1

This violates the stated invariant at line 78: "First miner of next round != Extra block producer of current round".

The extra block producer selection uses pseudo-random calculation based on the first miner's signature: [5](#0-4) 

With 2 miners, the modulo operation has approximately 50% probability of selecting the same miner as extra block producer for consecutive rounds.

## Impact Explanation

**Consensus Fairness Violation**: The AEDPoS consensus mechanism explicitly implements `BreakContinuousMining` to prevent any single miner from dominating block production. When this protection fails, the same miner can produce consecutive blocks, defeating the fairness guarantee.

**Pseudo-Random Manipulation Risk**: The next round's extra block producer selection depends on the first miner's signature. Consecutive block production by the same miner means they control the signature used for selection, potentially influencing the pseudo-random process. [6](#0-5) 

**Validation Conflicts**: The continuous blocks validator may incorrectly reject legitimate blocks when the same miner produces consecutively across round boundaries, potentially causing consensus disruption. [7](#0-6) 

## Likelihood Explanation

**Automatic Trigger**: The vulnerability triggers automatically during normal consensus operation when generating next round information. [8](#0-7) 

**Valid Configuration**: While the default `SupposedMinersCount` is 17, chains can legitimately operate with 2 miners during: [9](#0-8) 

- Initial network deployment with minimal validators
- Test networks
- Chains with minimal validator requirements
- Edge cases during validator set transitions

**High Probability**: With 2 miners and modulo-2 selection, there's approximately 50% probability per round that the same miner will be selected as extra block producer for both the current and next rounds.

**No Attacker Control**: This occurs through the natural consensus mechanism without requiring any malicious actor.

## Recommendation

Modify `BreakContinuousMining` to handle the 2-miner edge case explicitly, or ensure the second swap check accounts for miners that have already been swapped in the first operation. 

**Recommended fix**:
```csharp
private void BreakContinuousMining(ref Round nextRound)
{
    var minersCount = RealTimeMinersInformation.Count;
    if (minersCount <= 1) return;

    // For 2 miners, only perform one swap to avoid cancellation
    if (minersCount == 2)
    {
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
        return; // Skip second swap for 2 miners
    }

    // Original logic for 3+ miners
    // ... rest of the method
}
```

## Proof of Concept

```csharp
[Fact]
public void BreakContinuousMining_TwoMiners_SwapsCancelOut()
{
    // Setup: Create a round with 2 miners
    var currentRound = new Round
    {
        RoundNumber = 1,
        RealTimeMinersInformation =
        {
            ["MinerA"] = new MinerInRound
            {
                Pubkey = "MinerA",
                Order = 1,
                IsExtraBlockProducer = true,
                Signature = Hash.FromString("sig1")
            },
            ["MinerB"] = new MinerInRound
            {
                Pubkey = "MinerB",
                Order = 2
            }
        }
    };

    // Generate next round where MinerA is also selected as extra block producer
    currentRound.GenerateNextRoundInformation(
        Timestamp.FromDateTime(DateTime.UtcNow),
        Timestamp.FromDateTime(DateTime.UtcNow.AddDays(-1)),
        out Round nextRound
    );

    // Manually set MinerA as extra block producer for next round
    // (simulating the ~50% probability scenario)
    nextRound.RealTimeMinersInformation["MinerA"].IsExtraBlockProducer = true;
    nextRound.RealTimeMinersInformation["MinerA"].Order = 1;

    // Verify: MinerA is at order 1 in next round despite being extra block producer of current round
    var firstMiner = nextRound.RealTimeMinersInformation.Values.First(m => m.Order == 1);
    var currentExtraBlockProducer = currentRound.GetExtraBlockProducerInformation();
    
    Assert.Equal(currentExtraBlockProducer.Pubkey, firstMiner.Pubkey);
    // This assertion passes, proving the invariant is violated
}
```

## Notes

The test framework version in `test/AElf.Contracts.Consensus.AEDPoS.Tests/Types/Round_Generation.cs` notably does NOT include the `BreakContinuousMining` call, suggesting this fairness mechanism was added later and never properly tested for edge cases: [10](#0-9) 

This vulnerability specifically affects chains operating with exactly 2 miners. While uncommon in production, such configurations are valid and may occur during initial deployment phases or in specialized network setups.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/Types/Round_Generation.cs (L10-73)
```csharp
internal partial class Round
{
    public bool GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp, ByteString randomNumber,
        out NextRoundInput nextRound)
    {
        nextRound = new NextRoundInput();

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        if (RoundNumber == 1)
            nextRound.BlockchainAge = 1;
        else
            nextRound.BlockchainAge = (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp +
                                     new Duration { Seconds = miningInterval.Div(1000).Mul(order) },
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp +
                                     new Duration { Seconds = miningInterval.Div(1000).Mul(order) },
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots + 1
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
        nextRound.RandomNumber = randomNumber;
        
        return true;
    }
```
