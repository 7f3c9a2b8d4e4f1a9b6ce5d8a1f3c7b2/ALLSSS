# Audit Report

## Title
Time Slot Validation Allows Malicious Round Crafting with Biased Mining Intervals

## Summary
The AEDPoS consensus contract's `CheckRoundTimeSlots()` validation uses an overly permissive 100% tolerance that allows mining intervals ranging from 0 to 2× the base interval. A malicious extra block producer can craft Round data with manipulated `ExpectedMiningTime` values that pass validation but disrupt consensus through DoS attacks (impossibly short intervals) or severe performance degradation (excessively long intervals). The contract fails to regenerate and verify the expected Round during NextRound processing, instead storing the attacker-provided Round directly to state.

## Finding Description

The AEDPoS consensus system breaks the security guarantee that all miners receive equal time slots for block production during NextRound transitions.

**Root Cause - Permissive Tolerance Check:**

The time slot validation allows any interval within 0 to 2× the base interval through a 100% tolerance check. [1](#0-0) 

This mathematical constraint `Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval` permits intervals from 0ms to 2×baseMiningInterval. The validation is invoked during consensus header validation for new rounds. [2](#0-1) 

**Missing Protection - No Round Regeneration Check:**

When processing NextRound transactions, the contract directly converts and stores the input Round without verifying it matches what would be legitimately generated by `GenerateNextRoundInformation`. [3](#0-2) 

The converted Round is stored directly to state without semantic validation. [4](#0-3) 

**Mining Interval Calculation Dependency:**

The mining interval used throughout consensus operations is calculated from the first two miners' `ExpectedMiningTime` values, making it vulnerable to manipulation. [5](#0-4) 

**Ineffective After-Execution Validation:**

The after-execution validation compares the header Round hash with the state Round hash, but since ProcessNextRound already stored the malicious Round to state during execution, they are identical and validation passes. [6](#0-5) 

The current round is retrieved from state, which contains the malicious Round that was just stored. [7](#0-6) 

**No Minimum/Maximum Bounds:**

The contract constants define various parameters but lack bounds on mining intervals beyond requiring them to be greater than zero. [8](#0-7) 

**Attack Execution Path:**

1. Extra block producer legitimately generates consensus data through `GetConsensusExtraDataForNextRound` [9](#0-8) 

2. Attacker modifies `Round.RealTimeMinersInformation[*].ExpectedMiningTime` values before including in block header

3. Modified Round passes `CheckRoundTimeSlots` validation (within 0-2× tolerance)

4. `ProcessNextRound` stores malicious Round to state via `AddRoundInformation`

5. `ValidateConsensusAfterExecution` passes because it compares identical data

**Additional Validation Providers Do Not Prevent This:**

The `NextRoundMiningOrderValidationProvider` only validates order fields, not time slots. [10](#0-9) 

The `RoundTerminateValidationProvider` only validates round number increments and InValue nullness, not time slot correctness. [11](#0-10) 

## Impact Explanation

The manipulated mining interval directly impacts consensus operations. The mining interval is used to calculate critical block production parameters. [12](#0-11) 

**Attack Scenarios:**

1. **DoS Attack (Impossibly Short Intervals):** Setting the first two miners 1ms apart creates baseMiningInterval=1ms. This results in TinyBlockSlotInterval = 1ms/8 ≈ 0ms and DefaultBlockMiningLimit = 0ms * 3/5 = 0ms, which is physically impossible for miners to meet, halting consensus.

2. **Consensus Slowdown (Excessively Long Intervals):** Setting the first two miners 8000ms apart allows intervals up to 16000ms (within the 2× tolerance). This creates TinyBlockSlotInterval = 1000ms and DefaultBlockMiningLimit = 600ms, compared to normal values of 500ms and 300ms respectively, drastically reducing network throughput by 50% or more.

**Affected Parties:**
- All network participants experience consensus disruption
- Honest miners unable to produce blocks within impossible time limits lose rewards
- Users face transaction delays or complete service outage

**Severity:** HIGH - A single malicious miner can compromise consensus integrity for an entire round, causing network-wide DoS or severe performance degradation affecting all participants.

## Likelihood Explanation

**Attacker Requirements:**
- Must be in the current miner list (validated by PreCheck)
- Must become the extra block producer for a round

The extra block producer rotates pseudo-randomly based on VRF signatures. [13](#0-12) 

**Attack Complexity:**
LOW - The attacker simply modifies `ExpectedMiningTime` values in the Round data structure before including it in the block header. Legitimate round generation creates equal spacing based on the mining interval. [14](#0-13) 

The attacker deviates from this equal spacing pattern while staying within the loose 100% tolerance validation.

**Trigger Conditions:**
NextRound behavior is triggered naturally when terminating the current round, requiring no special preconditions beyond being the extra block producer.

**Detection/Operational Constraints:**
- No cryptographic binding between legitimate Round generation and block production
- Validation only checks mathematical constraints (0 < interval ≤ 2×base), not semantic correctness
- Difficult to detect without regenerating the expected Round and comparing

**Probability:** MEDIUM-HIGH - Given the rotating nature of extra block producers (pseudo-random selection each round), any compromised miner will eventually have the opportunity to exploit this vulnerability. The attack is repeatable every time they become the extra block producer, which occurs regularly over time.

## Recommendation

Implement strict Round regeneration validation during NextRound processing:

1. **Regenerate Expected Round:** In `ProcessNextRound`, regenerate the expected Round using `GenerateNextRoundInformation` with the current round and block time.

2. **Compare Critical Fields:** Validate that the provided Round's `ExpectedMiningTime` values match the regenerated Round's values (allowing only minimal clock drift tolerance, e.g., ±100ms).

3. **Tighten Tolerance:** Reduce `CheckRoundTimeSlots()` tolerance from 100% to a reasonable value like 10-20% to account for minor timing variations while preventing extreme manipulation.

4. **Add Interval Bounds:** Define minimum and maximum mining interval constants (e.g., MIN_MINING_INTERVAL = 2000ms, MAX_MINING_INTERVAL = 8000ms) and validate against these bounds.

5. **Validate Before Storage:** Perform the regeneration check in `ProcessNextRound` before calling `AddRoundInformation` to prevent malicious Rounds from ever reaching state.

Example validation code to add in `ProcessNextRound`:
```csharp
// Regenerate expected Round
GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var expectedRound);

// Validate time slots match (with small tolerance for clock drift)
const int clockDriftTolerance = 100; // milliseconds
foreach (var expectedMiner in expectedRound.RealTimeMinersInformation)
{
    var providedMiner = nextRound.RealTimeMinersInformation[expectedMiner.Key];
    var timeDiff = Math.Abs((providedMiner.ExpectedMiningTime - expectedMiner.Value.ExpectedMiningTime).Milliseconds());
    Assert(timeDiff <= clockDriftTolerance, $"Invalid ExpectedMiningTime for miner {expectedMiner.Key}");
}
```

## Proof of Concept

A malicious miner can craft a Round with 1ms intervals and include it in their NextRound transaction. The validation flow would be:

1. Miner becomes extra block producer (rotates naturally)
2. Calls `GetConsensusCommand` which returns legitimate Round with 4000ms intervals
3. Before block production, modifies Round: sets `miners[0].ExpectedMiningTime = T`, `miners[1].ExpectedMiningTime = T+1ms`, maintaining relative order but with 1ms spacing
4. Includes modified Round in block header
5. `ValidateConsensusBeforeExecution` is called:
   - `CheckRoundTimeSlots()` checks: `Math.Abs(1ms - 1ms) > 1ms` → False (validation passes)
   - All intervals between consecutive miners are 1ms, within the 0-2ms allowed range
6. Transaction executes, `ProcessNextRound` stores the malicious Round
7. `ValidateConsensusAfterExecution` compares hashes of identical Rounds (both malicious)
8. Next round begins with 1ms mining interval
9. `TinyBlockSlotInterval = 1ms / 8 = 0ms`, `DefaultBlockMiningLimit = 0ms`
10. All miners fail to produce blocks within 0ms limit → consensus halts

The vulnerability is confirmed through code analysis showing the lack of Round regeneration checks and the permissive tolerance allowing extreme interval manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L49-55)
```csharp
        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-112)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-106)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-102)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L1-16)
```csharp
namespace AElf.Contracts.Consensus.AEDPoS;

// ReSharper disable once InconsistentNaming
public static class AEDPoSContractConstants
{
    public const int MaximumTinyBlocksCount = 8;
    public const long InitialMiningRewardPerBlock = 12500000;
    public const long TimeToReduceMiningRewardByHalf = 126144000; // 60 * 60 * 24 * 365 * 4
    public const int SupposedMinersCount = 17;
    public const int KeepRounds = 40960;
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
    public const string SideChainShareProfitsTokenSymbol = "SHARE";
    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";
    public const string SecretSharingEnabledConfigurationKey = "SecretSharingEnabled";
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-178)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L35-49)
```csharp
        protected MinerInRound MinerInRound => CurrentRound.RealTimeMinersInformation[Pubkey];
        protected int Order => CurrentRound.GetMiningOrder(Pubkey);
        protected int MiningInterval => CurrentRound.GetMiningInterval();

        /// <summary>
        ///     Producing time of every (tiny) block at most.
        /// </summary>
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);

        protected int MinersCount => CurrentRound.RealTimeMinersInformation.Count;

        /// <summary>
        ///     Give 3/5 of producing time for mining by default.
        /// </summary>
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```
