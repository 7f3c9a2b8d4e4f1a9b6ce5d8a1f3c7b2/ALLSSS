# Audit Report

## Title
Assembled NFTs Can Be Minted Multiple Times Allowing Disassembly Without Returning Locked Assets

## Summary
When an NFT protocol has `IsTokenIdReuse = true`, minters can call `Mint()` to increase the quantity of an already-assembled NFT, creating additional copies not backed by locked assets in `AssembledNftsMap`. Subsequent disassemblies of these unbacked copies burn the NFT but return nothing, causing permanent loss of the originally locked assets.

## Finding Description

The vulnerability exists in the interaction between `Assemble()`, `Mint()`, and `Disassemble()` methods in the NFT contract.

When `Assemble()` is called, it locks NFTs/FTs by transferring them to the contract and storing a single reference in `AssembledNftsMap`, then calls `PerformMint()` with `isTokenIdMustBeUnique = true` to create the assembled NFT. [1](#0-0) 

However, a minter can subsequently call the public `Mint()` method with the same `tokenId`. The `Mint()` method calls `PerformMint()` with the default parameter `isTokenIdMustBeUnique = false`. [2](#0-1) 

In `PerformMint()`, the token ID reuse check only triggers when either `IsTokenIdReuse` is false OR `isTokenIdMustBeUnique` is true. [3](#0-2) 

For protocols with `IsTokenIdReuse = true`, when `isTokenIdMustBeUnique = false` (regular Mint), the check evaluates to `if (!true || false)` = `if (false)`, allowing the mint to bypass the uniqueness assertion. The code then increments the existing NFT's quantity without creating a new `AssembledNftsMap` entry. [4](#0-3) 

The `AssembledNftsMap` state variable stores only ONE entry per token hash, regardless of quantity. [5](#0-4) 

When `Disassemble()` is called the first time, it burns one copy (Amount = 1), retrieves the locked assets from `AssembledNftsMap`, transfers them back, and crucially removes the map entry. [6](#0-5) 

A second `Disassemble()` call successfully burns another copy (because the quantity is still >= 1 and the caller is a minter), but when it tries to retrieve from `AssembledNftsMap`, the entry is null, so the condition at line 204 evaluates to false and no assets are returned. The NFT is burned without returning its backing.

## Impact Explanation

**Direct Fund Impact**: Permanent loss of locked NFT/FT value. When unbacked assembled NFTs (those minted after initial assembly) are disassembled, they are burned but the locked assets are not returned because the `AssembledNftsMap` entry was already removed by the first disassembly. The locked assets remain trapped in the contract with no mechanism to retrieve them.

**Affected Parties**:
- Holders of unbacked assembled NFTs who expect to receive locked assets upon disassembly
- Protocol integrity is compromised as unbacked assembled NFTs exist that appear identical to properly backed ones
- Market participants who may trade these unbacked assembled NFTs at full value, unaware they cannot be disassembled for their components

**Severity**: Critical - This breaks the fundamental invariant that assembled NFTs should always be backed by their locked components. The locked NFTs/FTs (which could have significant value) are permanently lost when unbacked copies are disassembled.

## Likelihood Explanation

**Attacker Capabilities Required**:
1. Must be a minter of an NFT protocol (added by protocol creator via `AddMinters()`) [7](#0-6) 
2. Protocol must have `IsTokenIdReuse = true` (set during protocol creation) [8](#0-7) 
3. Protocol must have `IsBurnable = true` (required for Disassemble to work) [9](#0-8) 

**Attack Complexity**: Low - straightforward sequence of public method calls (Assemble → Mint with same tokenId → Disassemble → Disassemble)

**Feasibility**: High - While requiring minter role is a constraint, this is a legitimate and commonly granted capability. Protocols may enable `IsTokenIdReuse` for legitimate use cases (re-minting after burn). The burn function's requirement that only minters can burn means this particularly affects the minter community. [10](#0-9) 

**Detection**: Difficult - the unbacked assembled NFTs appear identical to properly backed ones in terms of token hash, symbol, and token ID. Only by checking the actual `AssembledNftsMap` state or attempting disassembly would the issue be discovered.

## Recommendation

The fix should ensure that either:
1. Prevent minting additional copies of assembled NFTs by checking if the token hash exists in `AssembledNftsMap` before allowing quantity increments, OR
2. Store backing information per quantity unit rather than per token hash, OR
3. Override `isTokenIdMustBeUnique` to always be `true` for assembled NFTs by checking `AssembledNftsMap` in `PerformMint`

Recommended fix in `PerformMint()`:

```csharp
// Add check for assembled NFTs before line 395
if (State.AssembledNftsMap[tokenHash] != null)
{
    throw new AssertionException("Cannot mint additional copies of assembled NFTs.");
}

if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
    Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

## Proof of Concept

```csharp
[Fact]
public async Task AssembledNFT_CanBeMinted_MultipleTimes_CausingAssetLoss()
{
    // Setup: Create protocol with IsTokenIdReuse = true and IsBurnable = true
    var symbol = await CreateProtocolWithTokenIdReuse();
    await AddMinterAsync(symbol);
    
    // Step 1: Mint first NFT to use in assembly
    var componentHash = await MintComponentNFT(symbol);
    
    // Step 2: Assemble - locks the component NFT
    var assembledHash = await AssembleNFT(symbol, componentHash);
    
    // Verify: 1 assembled NFT exists with backing
    var balanceBefore = await GetBalance(assembledHash, DefaultAddress);
    balanceBefore.ShouldBe(1);
    
    // Step 3: EXPLOIT - Mint additional copy of same assembled token ID
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        TokenId = 2, // Same token ID as assembled NFT
        Quantity = 1
    });
    
    // Now we have 2 copies but only 1 backing in AssembledNftsMap
    var balanceAfterMint = await GetBalance(assembledHash, DefaultAddress);
    balanceAfterMint.ShouldBe(2);
    
    // Step 4: First disassemble - returns assets and removes map entry
    await Disassemble(symbol, 2);
    var componentBalance1 = await GetBalance(componentHash, DefaultAddress);
    componentBalance1.ShouldBe(1); // Assets returned
    
    // Step 5: Second disassemble - burns but returns NOTHING
    await Disassemble(symbol, 2);
    var componentBalance2 = await GetBalance(componentHash, DefaultAddress);
    componentBalance2.ShouldBe(1); // Still 1 - no additional assets returned!
    
    // The component NFT that was locked is now PERMANENTLY LOST in the contract
    var contractBalance = await GetBalance(componentHash, NFTContractAddress);
    contractBalance.ShouldBe(0); // Assets already released in first disassemble
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L12-19)
```csharp
    public override Hash Mint(MintInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var nftMinted = PerformMint(input);
        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L87-88)
```csharp
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L90-93)
```csharp
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L113-189)
```csharp
    public override Hash Assemble(AssembleInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var metadata = input.Metadata ?? new Metadata();

        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
        }

        if (input.AssembledFts.Value.Any())
        {
            metadata.Value[AssembledFtsKey] = input.AssembledFts.ToString();
            // Check balance and allowance.
            foreach (var pair in input.AssembledFts.Value)
            {
                var symbol = pair.Key;
                var amount = pair.Value;
                var balance = State.TokenContract.GetBalance.Call(new MultiToken.GetBalanceInput
                {
                    Owner = Context.Sender,
                    Symbol = symbol
                }).Balance;
                Assert(balance >= amount, $"Insufficient balance of {symbol}");
                var allowance = State.TokenContract.GetAllowance.Call(new MultiToken.GetAllowanceInput
                {
                    Owner = Context.Sender,
                    Spender = Context.Self,
                    Symbol = symbol
                }).Allowance;
                Assert(allowance >= amount, $"Insufficient allowance of {symbol}");
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
        }

        var mingInput = new MintInput
        {
            Symbol = input.Symbol,
            Alias = input.Alias,
            Owner = input.Owner,
            Uri = input.Uri,
            Metadata = metadata,
            TokenId = input.TokenId
        };

        var nftMinted = PerformMint(mingInput, true);
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;

        Context.Fire(new Assembled
        {
            Symbol = input.Symbol,
            TokenId = nftMinted.TokenId,
            AssembledNfts = input.AssembledNfts,
            AssembledFts = input.AssembledFts
        });

        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-210)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-32)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L48-48)
```csharp
            IsTokenIdReuse = input.IsTokenIdReuse,
```
