# Audit Report

## Title
Organization State Manipulation During Active Proposal Voting Enables Governance Attack

## Summary
The Association contract allows organization parameters (thresholds and member lists) to be modified through proposals while other proposals are still being voted on. Threshold calculation functions read the current organization state at evaluation time rather than capturing it at proposal creation, enabling attackers to manipulate voting outcomes by changing thresholds or removing voters mid-vote.

## Finding Description

**Root Cause:** The Association contract's threshold evaluation functions always read the current organization state from storage, but organization modification methods have no checks preventing changes while active proposals exist.

The three threshold calculation functions all read organization data dynamically. [1](#0-0) [2](#0-1) [3](#0-2) 

These functions filter votes using `organization.OrganizationMemberList.Contains()` and compare counts against `organization.ProposalReleaseThreshold` values. The organization object is passed as a parameter, which is fetched fresh from state each time during proposal evaluation. [4](#0-3) [5](#0-4) 

**Vulnerability Path:** The contract provides multiple methods that modify organization state without checking for active proposals:
- `ChangeOrganizationThreshold` [6](#0-5) 
- `AddMember` [7](#0-6) 
- `RemoveMember` [8](#0-7) 
- `ChangeMember` [9](#0-8) 

These methods can be invoked via proposals through the organization's virtual address. [10](#0-9) 

The `Validate()` function only checks structural correctness of the organization, not whether modifications would affect pending proposals. [11](#0-10) 

**Proof from Test Suite:** The codebase's own test case demonstrates this behavior. [12](#0-11) 

This test shows a proposal that is `ToBeReleased = true` (line 751) becoming `ToBeReleased = false` (line 785) after threshold modification (lines 777-782), proving that organization changes retroactively affect existing proposals.

The member list filtering logic confirms votes are counted only if the voter is in the current member list. [13](#0-12) 

## Impact Explanation

**Governance Manipulation Attacks:**

1. **Censorship Attack:** An attacker creates a proposal to increase `MinimalApprovalThreshold`. While a competing legitimate proposal has sufficient approvals under current rules, the attacker passes their threshold-change proposal first. The legitimate proposal can no longer be released despite having received sufficient votes under the original threshold.

2. **Vote Invalidation Attack:** An attacker creates a proposal to remove specific members from `OrganizationMemberList`. Since vote counting uses `organization.OrganizationMemberList.Contains()`, removed members' votes are retroactively discounted, potentially changing proposals from passing to failing state.

3. **Threshold Lowering Attack:** An attacker with control over threshold-modification proposals can lower `MinimalApprovalThreshold` to push through malicious proposals that would otherwise fail.

4. **Member Addition for Vote Dilution:** Adding members changes the denominator for percentage-based threshold calculations, potentially invalidating proposals that were close to threshold.

**Affected Parties:**
- All organizations using the Association contract
- Legitimate proposers whose proposals can be censored
- Organization members whose voting rights can be retroactively invalidated
- The entire governance system's integrity

**Severity Justification:** This is CRITICAL because it:
- Undermines the fundamental governance security model
- Enables unauthorized control over proposal outcomes
- Allows selective censorship of legitimate proposals
- Can be exploited deterministically by any proposer with threshold-passing capability
- Affects core system governance operations

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be in the organization's `ProposerWhiteList` (legitimate access)
- Must control enough votes to pass a threshold-modification or member-change proposal
- These are normal operational capabilities, not elevated privileges

**Attack Complexity:**
- Create proposal targeting `ChangeOrganizationThreshold` or member modification methods
- Vote to pass this proposal while target proposals are pending
- Release the modification proposal before target proposals are evaluated
- The attack is deterministic - no race conditions or timing windows needed

**Feasibility Conditions:**
- Multiple proposals must exist concurrently (common in active organizations)
- The attacker's modification proposal must reach threshold before target proposals are released
- This is easily achievable through coordination or in organizations with longer proposal periods

**Detection/Operational Constraints:**
- The attack appears as legitimate governance activity
- No abnormal transaction patterns
- Cannot be distinguished from normal threshold adjustments
- Once executed, changes are permanent until reversed through another proposal

**Economic Rationality:**
- Cost is only the standard proposal creation/voting cost
- Benefit is complete control over competing proposals
- Extremely high ROI for governance capture
- No financial loss risk for attacker

## Recommendation

Implement one of the following solutions:

**Solution 1: Snapshot Organization State at Proposal Creation**
Store a snapshot of the organization's thresholds and member list in the proposal at creation time, and use this snapshot for all threshold evaluations:

```csharp
// In ProposalInfo, add:
public ProposalReleaseThreshold SnapshotThreshold { get; set; }
public OrganizationMemberList SnapshotMemberList { get; set; }

// In CreateNewProposal:
var organization = State.Organizations[input.OrganizationAddress];
proposal.SnapshotThreshold = organization.ProposalReleaseThreshold.Clone();
proposal.SnapshotMemberList = organization.OrganizationMemberList.Clone();

// In threshold checking functions, use snapshot instead of current state
```

**Solution 2: Block Organization Modifications During Active Voting**
Add a check in organization modification methods to prevent changes when active proposals exist:

```csharp
private void AssertNoActiveProposals(Address organizationAddress)
{
    // Iterate through proposals or maintain a counter of active proposals per organization
    Assert(!HasActiveProposals(organizationAddress), 
           "Cannot modify organization while proposals are pending.");
}
```

**Solution 3: Require Proposal Expiration Grace Period**
Implement a mandatory waiting period after any organization modification before new proposals can be released, allowing existing proposals to complete under original rules.

## Proof of Concept

```csharp
[Fact]
public async Task Governance_Attack_Via_Retroactive_Threshold_Change()
{
    // Setup: Create organization with minimal threshold = 2
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 2, 
        minimalVoteThreshold: 2,
        maximalAbstentionThreshold: 1, 
        maximalRejectionThreshold: 1, 
        Reviewer1, Reviewer2, Reviewer3);
    
    // Step 1: Create legitimate proposal
    var legitimateProposalId = await CreateProposalAsync(
        Reviewer1KeyPair, 
        organizationAddress);
    
    // Step 2: Get 2 approvals (meets current threshold)
    await ApproveAsync(Reviewer1KeyPair, legitimateProposalId);
    await ApproveAsync(Reviewer2KeyPair, legitimateProposalId);
    
    // Verify proposal is ready to release
    var proposal = await AssociationContractStub.GetProposal.CallAsync(legitimateProposalId);
    proposal.ToBeReleased.ShouldBeTrue();
    
    // Step 3: Attacker creates malicious threshold-change proposal
    var maliciousThreshold = new ProposalReleaseThreshold
    {
        MinimalVoteThreshold = 3,  // Increase threshold
        MinimalApprovalThreshold = 3
    };
    
    var attackProposalId = await CreateAssociationProposalAsync(
        Reviewer1KeyPair,
        maliciousThreshold,
        nameof(AssociationContractStub.ChangeOrganizationThreshold),
        organizationAddress);
    
    // Step 4: Pass and release attack proposal
    await ApproveAsync(Reviewer1KeyPair, attackProposalId);
    await ApproveAsync(Reviewer2KeyPair, attackProposalId);
    await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendAsync(attackProposalId);
    
    // Step 5: Verify legitimate proposal is now blocked
    proposal = await AssociationContractStub.GetProposal.CallAsync(legitimateProposalId);
    proposal.ToBeReleased.ShouldBeFalse();  // Censored despite having valid votes!
    
    // Attempt to release fails
    var result = await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendWithExceptionAsync(legitimateProposalId);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Not approved");
}
```

## Notes

This vulnerability affects all three governance contracts (Association, Parliament, Referendum) to varying degrees:

- **Association**: Most severe impact due to `AddMember`/`RemoveMember` methods that can invalidate votes
- **Parliament**: Affected by threshold changes, but member list is determined by consensus miners
- **Referendum**: Affected by threshold changes for token-weighted voting

The test case from the codebase explicitly demonstrates this is intentional behavior, not a bug in the test suite. This represents a fundamental design flaw in the governance model where voting rules are not immutable during proposal lifecycles.

The vulnerability is particularly dangerous because it requires no special privileges beyond normal governance participation, and attacks appear as legitimate governance activity, making them difficult to detect or prevent through operational measures.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L18-42)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];
        var readyToRelease = IsReleaseThresholdReached(proposal, organization);

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = readyToRelease,
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L740-787)
```csharp
    public async Task Change_OrganizationThreshold_Test()
    {
        var minimalApproveThreshold = 1;
        var minimalVoteThreshold = 1;
        var maximalAbstentionThreshold = 1;
        var maximalRejectionThreshold = 1;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
        var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
        await ApproveAsync(Reviewer1KeyPair, proposalId);
        var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
        proposal.ToBeReleased.ShouldBeTrue();


        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 2
            };

            var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
            var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair,
                proposalReleaseThresholdInput,
                nameof(associationContractStub.ChangeOrganizationThreshold), organizationAddress);
            await ApproveAsync(Reviewer1KeyPair, changeProposalId);
            var result = await associationContractStub.Release.SendWithExceptionAsync(changeProposalId);
            result.TransactionResult.Error.ShouldContain("Invalid organization.");
        }

        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 2,
                MinimalApprovalThreshold = minimalApproveThreshold
            };

            var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
            var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair,
                proposalReleaseThresholdInput,
                nameof(associationContractStub.ChangeOrganizationThreshold), organizationAddress);
            await ApproveAsync(Reviewer1KeyPair, changeProposalId);
            var result = await associationContractStub.Release.SendAsync(changeProposalId);
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            proposal = await associationContractStub.GetProposal.CallAsync(proposalId);
            proposal.ToBeReleased.ShouldBeFalse();
        }
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
