# Audit Report

## Title
Cross-Chain Token Metadata Confusion via Unchecked IssueChainId Parameter

## Summary
The `CreateToken()` function allows creating tokens with arbitrary `IssueChainId` values without validating that it matches the current chain ID. This enables attackers to front-run legitimate cross-chain token synchronization by creating tokens with matching symbols and IssueChainIds but malicious metadata (Issuer, Owner, TotalSupply), causing permanent metadata confusion since `CrossChainCreateToken()` does not overwrite existing tokens.

## Finding Description

The vulnerability stems from insufficient validation during token creation and inadequate metadata synchronization in cross-chain operations.

**Root Cause:**
The `CreateToken()` function accepts any non-zero `IssueChainId` value without asserting it equals the current chain ID. [1](#0-0) 

The validation function `AssertValidCreateInput()` checks token name length, symbol format, and existence, but does not validate that `IssueChainId` matches `Context.ChainId`. [2](#0-1) 

**Why Existing Protections Fail:**

1. **Issue() protection is insufficient**: While the `Issue()` function prevents issuing tokens with mismatched IssueChainId [3](#0-2) , this only prevents local issuance but doesn't prevent the token from being created and receiving cross-chain transfers.

2. **CrossChainCreateToken doesn't overwrite**: When legitimate cross-chain sync occurs, if the token already exists, the function only updates alias information in the ExternalInfo field and does NOT overwrite the token's Issuer, Owner, or TotalSupply. [4](#0-3) 

3. **CrossChainReceiveToken accepts squatted tokens**: When cross-chain transfers arrive, the function retrieves the local token info and only validates that the IssueChainId matches, without checking that Issuer, Owner, or TotalSupply match the source chain's values. [5](#0-4) 

**Exploitation Path:**
1. Attacker on Main Chain obtains Seed NFT for target symbol (required by the Seed NFT check) [6](#0-5) 
2. Attacker calls `Create()` with Symbol="LEGIT", IssueChainId=SideChainAId (not MainChainId), and attacker's addresses for Issuer/Owner
3. Token is created on Main Chain with IssueChainId=SideChainAId but cannot be issued locally due to the check at line 159
4. Legitimate issuer creates "LEGIT" on Side Chain A with IssueChainId=SideChainAId and correct metadata
5. When legitimate `CrossChainCreateToken` is called on Main Chain, it finds the token exists and only updates alias information
6. Cross-chain transfers via `CrossChainReceiveToken` succeed because IssueChainId matches, but use the squatted token's metadata showing attacker as Issuer/Owner

## Impact Explanation

**High Severity** due to:

1. **Permanent Metadata Corruption**: Once a token is squatted, there is no mechanism to overwrite or correct its metadata. The CrossChainCreateToken function explicitly preserves existing tokens and only updates alias information.

2. **Trust and Identification Break**: Users querying token information on the destination chain see incorrect Issuer and Owner addresses, fundamentally breaking token identification and trust mechanisms.

3. **Supply Tracking Inconsistencies**: The squatted token can have arbitrary TotalSupply values (e.g., 1,000 vs legitimate 100,000,000), causing severe supply tracking discrepancies across chains.

4. **Cross-Chain Integrity Violation**: The fundamental guarantee that tokens with the same symbol and IssueChainId represent the same asset across all chains is violated, breaking cross-chain token semantics.

5. **Governance Impact**: For governance tokens, incorrect Owner information misdirects control and authority, potentially affecting voting and proposal mechanisms.

**Affected Parties**:
- Users receiving cross-chain transfers see incorrect token metadata
- DApps and explorers querying token info receive fraudulent Issuer/Owner/TotalSupply data
- Legitimate token issuers cannot properly register their tokens cross-chain after squatting occurs

## Likelihood Explanation

**Medium-to-High Likelihood** due to:

1. **Low Attack Complexity**: The attack requires only a straightforward call to `Create()` with specific parameters. No specialized technical knowledge beyond understanding the IssueChainId parameter is needed.

2. **Realistic Preconditions**: 
   - Attacker must obtain a Seed NFT for the target symbol, which is achievable through marketplace purchase or the Seed creation mechanism
   - Cross-chain operations have inherent latency, providing a timing window for front-running
   - The attack is more feasible for newly created tokens or tokens with publicly available Seed NFTs

3. **Economic Feasibility**: The primary cost is Seed NFT acquisition, which is market-dependent but often economically viable for valuable token symbols or governance tokens.

4. **No Automated Prevention**: The system has no validation mechanism to prevent creating tokens with IssueChainId values different from Context.ChainId, and no detection system to identify squatted tokens.

5. **Permanent Impact**: Once executed, the attack leaves permanent state that is observable via GetTokenInfo queries but cannot be automatically remediated.

## Recommendation

Add validation in the `CreateToken()` function to ensure that if `IssueChainId` is explicitly set (non-zero), it must match `Context.ChainId`:

```csharp
// In CreateToken() function, after line 76:
IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,

// Add validation:
Assert(input.IssueChainId == 0 || input.IssueChainId == Context.ChainId, 
    "IssueChainId must match current chain ID or be zero.");
```

Additionally, consider enhancing `CrossChainCreateToken()` to validate and potentially update token metadata when synchronizing from the authoritative source chain (the chain matching IssueChainId), or implement a governance-controlled mechanism to correct squatted token metadata.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainTokenMetadataSquatting_Test()
{
    // Setup: Create Main Chain and Side Chain
    var mainChainId = ChainHelper.ConvertBase58ToChainId("AELF");
    var sideChainId = ChainHelper.ConvertBase58ToChainId("tDVV");
    var attackerAddress = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[1].PublicKey);
    var legitimateIssuer = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey);
    
    // Step 1: Attacker obtains Seed NFT for "LEGIT" symbol on Main Chain
    await PrepareSeedNFT("LEGIT", attackerAddress);
    
    // Step 2: Attacker creates token on Main Chain with IssueChainId=SideChainId
    var attackerCreateResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "LEGIT",
        TokenName = "Legit Token",
        TotalSupply = 1000, // Malicious low supply
        Decimals = 8,
        Issuer = attackerAddress, // Attacker as issuer
        Owner = attackerAddress, // Attacker as owner
        IsBurnable = true,
        IssueChainId = sideChainId // Points to side chain!
    });
    Assert.True(attackerCreateResult.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Step 3: Legitimate issuer creates token on Side Chain with correct metadata
    var legitCreateResult = await SideChainTokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "LEGIT",
        TokenName = "Legit Token",
        TotalSupply = 100000000, // Correct high supply
        Decimals = 8,
        Issuer = legitimateIssuer, // Legitimate issuer
        Owner = legitimateIssuer,
        IsBurnable = true,
        IssueChainId = sideChainId
    });
    Assert.True(legitCreateResult.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Step 4: CrossChainCreateToken is called on Main Chain
    // (This would normally sync the legitimate token, but token already exists)
    var crossChainResult = await CrossChainCreateTokenOnMainChain("LEGIT", sideChainId);
    
    // Step 5: Verify the squatted metadata persists on Main Chain
    var mainChainTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "LEGIT"
    });
    
    // Vulnerability confirmed: Main Chain shows attacker's metadata
    Assert.Equal(attackerAddress, mainChainTokenInfo.Issuer); // Should be legitimateIssuer!
    Assert.Equal(attackerAddress, mainChainTokenInfo.Owner); // Should be legitimateIssuer!
    Assert.Equal(1000, mainChainTokenInfo.TotalSupply); // Should be 100000000!
    Assert.Equal(sideChainId, mainChainTokenInfo.IssueChainId); // This matches correctly
    
    // Step 6: Cross-chain transfer succeeds with wrong metadata
    var transferResult = await CrossChainReceiveToken("LEGIT", 100, sideChainId);
    Assert.True(transferResult.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Users receiving tokens see attacker as Issuer/Owner - vulnerability confirmed
}
```

**Notes**: 
- The vulnerability exploits the fact that `IssueChainId` can be set to any value during token creation without validation
- The core issue is the combination of: (1) unchecked IssueChainId in Create(), (2) CrossChainCreateToken not overwriting existing tokens, and (3) CrossChainReceiveToken only validating IssueChainId match
- This breaks the fundamental cross-chain token invariant that tokens with matching symbols and IssueChainIds should have consistent metadata across all chains
- The attack is permanent and cannot be remediated without governance intervention or contract upgrade

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L59-64)
```csharp
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L76-76)
```csharp
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L159-159)
```csharp
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L522-531)
```csharp
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L607-609)
```csharp
        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```
