# Audit Report

## Title
Missing Miner List Validation in NextTerm Allows Consensus Takeover Through Arbitrary Miner Selection

## Summary
The `NextTerm` method in the AEDPoS consensus contract critically lacks validation of the miner list against election results. Any current miner can craft a `NextTermInput` with an arbitrary miner set that bypasses the democratic election mechanism, as validation only checks term and round number increments while accepting any miner list without verification against `GetVictories` election results.

## Finding Description

The vulnerability exists in the validation and processing flow of term transitions in the AEDPoS consensus contract.

**Insufficient Validation:**

The `ValidationForNextTerm` method only validates numeric increments without checking the miner list: [1](#0-0) 

This validation is invoked during consensus validation but only added for `NextTerm` behavior: [2](#0-1) 

**Unverified Miner List Acceptance:**

When `ProcessNextTerm` executes, it directly extracts the miner list from the input without any verification: [3](#0-2) 

The `SetMinerList` function only checks if the term's miner list hasn't been set previously, performing no validation against election results: [4](#0-3) 

**Legitimate Flow Uses Election Results:**

The legitimate term generation process calls `GenerateFirstRoundOfNextTerm` which queries election results via `TryToGetVictories`: [5](#0-4) 

Election winners are retrieved from the Election Contract: [6](#0-5) 

However, this is only used when creating consensus extra data, not during validation: [7](#0-6) 

**Insufficient Permission Check:**

The `PreCheck` method only verifies the sender is in the current or previous miner list, which an attacker already satisfies: [8](#0-7) 

**Public Method Accessibility:**

The `NextTerm` method is publicly callable with any crafted input: [9](#0-8) 

## Impact Explanation

**Severity: Critical - Complete Consensus Takeover**

This vulnerability enables a malicious current miner to:

1. **Consensus Control**: Arbitrarily select the miner set for the next term, excluding legitimately elected miners and including only themselves or colluding parties. This establishes permanent control over block production.

2. **Election Bypass**: Completely circumvent the democratic election mechanism where token holders vote for block producers. All voting becomes meaningless as the attacker controls miner selection.

3. **Governance Manipulation**: Monopolize block production and control transaction inclusion, enabling manipulation of on-chain governance proposals and decisions.

4. **Economic Exploitation**: Redirect mining rewards intended for legitimately elected miners to the attacker's controlled addresses.

5. **Censorship Power**: Selectively exclude transactions or manipulate block contents without competing miners to challenge the behavior.

**Affected Parties:**
- Token holders who participated in voting (votes rendered meaningless)
- Legitimately elected candidates (denied rightful miner positions)
- Entire network (consensus integrity compromised)
- DApps and users (subject to censorship and manipulation)

This breaks the fundamental security guarantee: "Miner schedule must reflect election results from token holder votes."

## Likelihood Explanation

**High Likelihood - Simple Exploitation**

**Attacker Prerequisites:**
- Must be a current miner (achievable through legitimate means initially)
- Ability to construct and submit a transaction with `NextTermInput`
- No special privileges beyond current miner status

**Attack Execution:**
1. Wait for the term period to elapse (when `NeedToChangeTerm` would return true): [10](#0-9) 

2. Craft a `NextTermInput` with:
   - Correct term number (current + 1)
   - Correct round number (properly incremented)
   - Arbitrary miner list (attacker-controlled addresses)

3. Submit transaction to `NextTerm` method - passes all validations

4. Miner list is accepted as the first update for the new term

**Feasibility Analysis:**
- Attack requires only one transaction
- No race conditions or complex timing requirements
- Validation checks are deterministic and easily satisfied
- No cryptographic challenges or computational barriers

**Detection Difficulty:**
- Transaction appears structurally valid with correct format and numbers
- Only detectable by comparing miner list against `GetVictories` results (which is not performed)
- May go unnoticed until excluded miners realize they cannot produce blocks

**Economic Rationality:**
- Cost: Single transaction fee
- Benefit: Permanent consensus control, monopoly on mining rewards, governance influence
- Risk/Reward heavily favors execution from a rational attacker perspective

## Recommendation

Add validation in `ValidationForNextTerm` to verify the miner list matches election results:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // NEW: Validate miner list against election results
    if (State.IsMainChain.Value)
    {
        var electionVictories = State.ElectionContract.GetVictories.Call(new Empty());
        var providedMiners = extraData.Round.RealTimeMinersInformation.Keys
            .Select(k => ByteStringHelper.FromHexString(k))
            .OrderBy(p => p.ToHex())
            .ToList();
        var electedMiners = electionVictories.Value
            .OrderBy(p => p.ToHex())
            .ToList();
        
        if (providedMiners.Count != electedMiners.Count ||
            !providedMiners.SequenceEqual(electedMiners))
        {
            return new ValidationResult 
            { 
                Message = "Miner list does not match election results." 
            };
        }
    }

    return new ValidationResult { Success = true };
}
```

This ensures that any `NextTermInput` must contain the exact miner list determined by the election contract, preventing arbitrary miner selection.

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_WithArbitraryMinerList_ShouldFail()
{
    // Setup: Initialize consensus with legitimate miners
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(initialMiners);
    
    // Simulate election where miner4 and miner5 win
    await SetupElectionWinners(new[] { "miner4", "miner5", "miner6" });
    
    // Attacker (current miner1) crafts NextTermInput with arbitrary miners
    var maliciousNextTerm = new NextTermInput
    {
        // Correct term and round numbers to pass validation
        TermNumber = 2,
        RoundNumber = await GetNextRoundNumber(),
        // Arbitrary miner list excluding election winners
        MinerList = new[] { "miner1", "attacker1", "attacker2" },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Attack: Submit malicious NextTerm
    var result = await ConsensusContract.NextTerm(maliciousNextTerm);
    
    // Vulnerability: Should fail but currently succeeds
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    
    // Verify miner list was not updated with arbitrary miners
    var actualMiners = await ConsensusContract.GetCurrentMinerList();
    actualMiners.Pubkeys.ShouldNotContain("attacker1");
    actualMiners.Pubkeys.ShouldNotContain("attacker2");
}
```

This test demonstrates that a current miner can successfully submit a `NextTermInput` with an arbitrary miner list that bypasses election results, proving the vulnerability exists.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```
