# Audit Report

## Title
RemoveNFTType Breaks Cross-Chain Synchronization for Active NFT Protocols

## Summary
The `RemoveNFTType()` function in the NFT contract fails to validate whether active NFT protocols depend on the NFT type being removed. When Parliament removes an NFT type that has associated protocols, subsequent `CrossChainCreate()` calls permanently fail, breaking cross-chain synchronization for all affected protocols.

## Finding Description

The vulnerability exists in the `RemoveNFTType()` function which performs insufficient validation before removing NFT type mappings. [1](#0-0) 

The function validates Parliament authorization, checks the short name length (2 characters), and verifies the type exists in the mapping. However, it proceeds to remove entries from `NFTTypeFullNameMap`, `NFTTypeShortNameMap`, and `NFTTypes` without checking if any protocols in `State.NftProtocolMap` reference this NFT type through their symbol prefix.

NFT protocol symbols are generated by concatenating the 2-character short name with a random number. [2](#0-1) 

When protocols are created, they are stored with their full symbol as the key in `State.NftProtocolMap`. [3](#0-2) 

The critical breakage occurs in `CrossChainCreate()`, which extracts the 2-character short name from the protocol symbol and looks it up in `NFTTypeFullNameMap`. [4](#0-3) 

If the NFT type has been removed, the lookup returns null, causing an assertion failure that prevents cross-chain protocol synchronization. The protocol remains valid on the mainchain but cannot be synchronized to any sidechain.

**Root Cause:** No validation exists to check if protocols with symbols starting with the short name being removed exist in `State.NftProtocolMap`. The state mapping structure doesn't support efficient prefix-based queries, but this validation is necessary for data integrity.

**Why Existing Protections Fail:**
- Parliament authorization only validates governance authority, not operational safety
- Existence check only validates the type is in the mapping, not whether it's actively referenced by protocols
- No cross-reference validation between NFT type mappings and protocol storage

## Impact Explanation

**Cross-Chain Integrity Violation:**
- All NFT protocols with the removed type's short name prefix become permanently unable to synchronize to sidechains
- `CrossChainCreate()` will fail with assertion: "Full name of {shortName} not found. Use AddNFTType to add this new pair."
- Breaks AElf's fundamental multi-chain architecture guarantee for NFT protocols

**Affected Parties:**
- Protocol creators who issued NFTs with the removed type on the mainchain cannot expand to sidechains
- Users attempting cross-chain NFT operations face permanent failures
- Sidechains cannot receive legitimate NFT protocol synchronization from mainchain

**Severity Justification: CRITICAL**
- Permanent operational DoS of cross-chain functionality with no automatic recovery mechanism
- Even re-adding the NFT type requires Parliament to manually identify and re-sync all affected protocols
- Violates the protocol invariant that successfully created protocols should be cross-chain syncable
- No built-in mechanism to detect protocol dependencies before governance action is taken

## Likelihood Explanation

**Governance Scenario:** This requires Parliament default organization authority, representing legitimate governance operations rather than malicious exploitation.

**Trigger Complexity: LOW**
- Single transaction: `RemoveNFTType(shortName)`
- No complex preconditions or multi-step exploitation required

**Realistic Feasibility:**
- Parliament may legitimately deprecate old NFT type categories as the protocol evolves
- May consolidate naming schemes or remove types that appear unused
- Without tooling to query protocol dependencies on NFT types, removal appears safe
- Common operational governance pattern in mature blockchain protocols

**Probability Assessment: HIGH**
- No visibility provided to Parliament about protocol dependencies on specific NFT types
- Legitimate "cleanup" governance actions can be performed without awareness of downstream breakage
- Cross-chain synchronization failures may not be immediately detected since they occur during protocol expansion to new chains, not during normal mainchain operations
- No test coverage exists for `RemoveNFTType` to validate edge cases

## Recommendation

Add validation in `RemoveNFTType()` to prevent removal of NFT types that are currently in use by active protocols. Since state mappings don't support efficient iteration, maintain an additional index:

**Option 1: Add Reference Counter**
```csharp
// In NFTContractState.cs
public MappedState<string, int> NFTTypeProtocolCount { get; set; }

// In Create() after line 53
State.NFTTypeProtocolCount[State.NFTTypeShortNameMap[input.NftType]] = 
    State.NFTTypeProtocolCount[State.NFTTypeShortNameMap[input.NftType]] + 1;

// In RemoveNFTType() after line 157
var protocolCount = State.NFTTypeProtocolCount[input.Value];
Assert(protocolCount == null || protocolCount == 0, 
    $"Cannot remove NFT type {input.Value}: {protocolCount} protocols still use this type.");
```

**Option 2: Add Deprecation Status**
Instead of removing, mark types as deprecated and prevent new protocol creation with deprecated types, while allowing existing protocols to continue cross-chain synchronization.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveNFTType_Breaks_CrossChainCreate_Test()
{
    // Step 1: Create NFT protocol with "Art" type (short name "AR")
    var createResult = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = "ipfs://test/",
        Creator = DefaultAddress,
        IsBurnable = true,
        NftType = NFTType.Art.ToString(), // "Art" -> short name "AR"
        ProtocolName = "TestProtocol",
        TotalSupply = 1000000
    });
    var protocolSymbol = createResult.Output.Value; // e.g., "AR123456"
    
    // Step 2: Parliament removes NFT type "AR"
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    var proposalId = await CreateProposalAsync(
        NFTContractAddress,
        defaultParliament,
        nameof(NFTContractStub.RemoveNFTType),
        new StringValue { Value = "AR" }
    );
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // Step 3: Attempt CrossChainCreate on sidechain - should fail
    var exception = await Assert.ThrowsAsync<AssertionException>(async () =>
    {
        await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = protocolSymbol
        });
    });
    
    // Verify the exact error message
    exception.Message.ShouldContain("Full name of AR not found");
}
```

---

## Notes

This vulnerability demonstrates a governance operational safety issue where a trusted role (Parliament) can unintentionally break protocol invariants by performing legitimate administrative actions without sufficient validation. The issue is architectural - the contract does not maintain bidirectional relationships between NFT types and protocols, making it impossible to safely remove NFT types that are in use.

The vulnerability is particularly concerning because:
1. Parliament has no way to query which protocols depend on a specific NFT type before removal
2. The failure occurs on sidechains during cross-chain synchronization, not on the mainchain where the removal happens
3. Recovery requires Parliament to not only re-add the NFT type but also potentially re-synchronize all affected protocols
4. The issue compounds over time as more protocols are created with various NFT types

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L53-53)
```csharp
        State.NftProtocolMap[symbol] = protocolInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```
