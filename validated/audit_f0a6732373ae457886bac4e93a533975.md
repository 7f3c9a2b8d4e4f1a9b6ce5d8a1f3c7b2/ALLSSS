# Audit Report

## Title
Incomplete Token Distribution Due to Outdated SymbolList in TakeSnapshot Causing Permanent Reward Loss

## Summary
The Election contract's `TakeSnapshot()` method retrieves Treasury's manually-configured `SymbolList` and uses it to distribute profits to SubsidyHash and WelfareHash schemes. A critical design flaw in `DistributeProfits()` causes it to process ONLY symbols in the provided `AmountsMap` when non-empty, completely bypassing the scheme's `ReceivedTokenSymbols` list that tracks ALL contributed tokens. This results in permanent loss of rewards for tokens omitted from `SymbolList`, as the distribution period irreversibly increments regardless of distribution completeness.

## Finding Description

The vulnerability stems from a logic flaw in the conditional branching of `DistributeProfits()` that breaks the protocol invariant that all contributed tokens should be distributed each period.

**Entry Point**: The Election contract's `TakeSnapshot()` method (called automatically by consensus at term end) retrieves Treasury's `SymbolList` and creates an `amountsMap` for distribution [1](#0-0) . It then distributes to both SubsidyHash and WelfareHash schemes using this map [2](#0-1) .

**Root Cause**: The `DistributeProfits()` method contains mutually exclusive code paths. When `AmountsMap` has ANY entries, lines 433-446 execute and process ONLY those symbols [3](#0-2) . The alternative path at lines 447-460 that checks `IsReleaseAllBalanceEveryTimeByDefault` and processes ALL tokens in `ReceivedTokenSymbols` is in an `else` block [4](#0-3) . Since `TakeSnapshot()` always provides a non-empty `AmountsMap`, the `else` block NEVER executes, rendering the `IsReleaseAllBalanceEveryTimeByDefault = true` flag completely ineffective.

**Treasury SymbolList Management**: Treasury's `SymbolList` is initialized with only the native token [5](#0-4)  and must be manually updated via governance-controlled `SetSymbolList()` [6](#0-5) . There is no validation that `SymbolList` includes all tokens tracked in `ReceivedTokenSymbols`.

**Token Tracking**: When tokens are contributed to schemes via `ContributeProfits()`, they are automatically tracked in the scheme's `ReceivedTokenSymbols` [7](#0-6) . When Treasury distributes to sub-schemes (SubsidyHash, WelfareHash), distributed tokens are also added to the sub-scheme's `ReceivedTokenSymbols` [8](#0-7) .

**Irreversible Period Advancement**: After any distribution completes, `CurrentPeriod` is unconditionally incremented [9](#0-8) , regardless of whether all tokens were distributed.

**Prevention of Retry**: Period validation strictly enforces that only the current period can be processed [10](#0-9) , making it impossible to redistribute missed tokens from past periods.

**Scheme Initialization**: All Treasury profit schemes are initialized with `IsReleaseAllBalanceEveryTimeByDefault = true` [11](#0-10) , indicating the design intent was to distribute all tokens, but this is bypassed by the conditional logic flaw.

## Impact Explanation

**Direct Financial Harm**: When Treasury holds multiple token types (e.g., ELF, USDT) that have been contributed and propagated to SubsidyHash/WelfareHash schemes, but Treasury's `SymbolList` remains outdated with only `["ELF"]`:

1. Only ELF rewards are distributed to backup node operators and voters
2. USDT and other tokens remain permanently locked in the schemes' virtual addresses for that specific period
3. The period advances, making redistribution for that term impossible
4. Beneficiaries lose entitled rewards proportional to their shares
5. This loss compounds with each term where `SymbolList` remains incomplete

**Affected Parties**:
- Backup node operators expecting subsidy rewards from SubsidyHash
- Token holders/voters expecting welfare dividends from WelfareHash
- All beneficiaries whose reward calculations depend on complete multi-token distribution

**Severity Justification**:
- **Permanent Fund Loss**: Tokens become effectively locked for an entire distribution period with no recovery mechanism
- **Protocol Invariant Violation**: Breaks the guarantee that all contributed tokens are distributed according to beneficiary shares
- **Cumulative Damage**: Each term with incomplete `SymbolList` causes additional, compounding losses
- **Trust Erosion**: Users lose confidence when entitled rewards fail to materialize

## Likelihood Explanation

**Realistic Scenario**:
1. Treasury initializes with `SymbolList = ["ELF"]`
2. Ecosystem expands: governance adds USDT as method fee token
3. USDT flows through `Treasury.Donate()` to SubsidyHash/WelfareHash schemes, tracked in `ReceivedTokenSymbols`
4. Governance oversight: `SymbolList` update is forgotten during rapid expansion
5. Consensus contract automatically calls `TakeSnapshot()` at term end (~weekly)
6. Only ELF distributes; USDT locked for that period

**Feasibility**:
- **No Attacker Required**: Operational failure triggered by normal system operations
- **Automatic Trigger**: `TakeSnapshot()` called automatically by trusted consensus contract [12](#0-11) 
- **No Safeguards**: Contract lacks validation comparing `SymbolList` against `ReceivedTokenSymbols`
- **Multi-Step Coordination Required**: Token addition → method fee enablement → `SymbolList` update must be perfectly synchronized

**Probability**: Medium-High - As the ecosystem grows and token variety increases, coordination overhead grows significantly. A single oversight in the multi-step governance process causes immediate, irreversible loss for that term.

## Recommendation

Implement one of these solutions:

**Solution 1 - Remove AmountsMap Dependency**: Modify `TakeSnapshot()` to pass an empty `AmountsMap`, forcing `DistributeProfits()` to use the `else` block that processes `ReceivedTokenSymbols`:

```csharp
State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
{
    SchemeId = State.SubsidyHash.Value,
    Period = input.TermNumber,
    AmountsMap = { } // Empty map
});
```

**Solution 2 - Fix DistributeProfits Logic**: Modify `DistributeProfits()` to check `IsReleaseAllBalanceEveryTimeByDefault` even when `AmountsMap` is provided, merging symbols from both `AmountsMap` and `ReceivedTokenSymbols`.

**Solution 3 - Add Validation**: Add validation in `TakeSnapshot()` to assert that `SymbolList` contains all tokens in the sub-schemes' `ReceivedTokenSymbols`, preventing incomplete distributions.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Initialize Treasury with `SymbolList = ["ELF"]`
2. Create and initialize SubsidyHash and WelfareHash schemes with `IsReleaseAllBalanceEveryTimeByDefault = true`
3. Contribute both ELF and USDT tokens to Treasury (both added to `ReceivedTokenSymbols`)
4. Treasury distributes to sub-schemes (both tokens transferred, both added to sub-schemes' `ReceivedTokenSymbols`)
5. Call `TakeSnapshot()` with term number N
6. Verify: Only ELF distributed from SubsidyHash/WelfareHash; USDT remains locked
7. Verify: `CurrentPeriod` incremented to N+1
8. Attempt to call `DistributeProfits()` again for period N: Transaction reverts with "Invalid period"
9. Result: USDT permanently locked for period N

**Expected Behavior**: Both ELF and USDT should distribute based on `ReceivedTokenSymbols` since schemes have `IsReleaseAllBalanceEveryTimeByDefault = true`.

**Actual Behavior**: Only ELF distributes because `AmountsMap` contains only ELF, bypassing `ReceivedTokenSymbols` entirely.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L408-408)
```csharp
        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L440-441)
```csharp
        var symbolList = State.DividendPoolContract.GetSymbolList.Call(new Empty());
        var amountsMap = symbolList.Value.ToDictionary(s => s, s => 0L);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L442-454)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.WelfareHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-446)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L447-460)
```csharp
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L479-480)
```csharp
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-645)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L72-75)
```csharp
        State.SymbolList.Value = new SymbolList
        {
            Value = { Context.Variables.NativeSymbol }
        };
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L282-310)
```csharp
    public override Empty SetSymbolList(SymbolList input)
    {
        AssertPerformedByTreasuryController();
        Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        foreach (var symbol in input.Value.Where(s => s != Context.Variables.NativeSymbol))
        {
            var isTreasuryInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
            {
                Symbol = symbol,
                Address = Context.Self
            }).Value;
            Assert(
                State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value ||
                isTreasuryInWhiteList, "Symbol need to be profitable.");
            Assert(!State.TokenConverterContract.IsSymbolAbleToSell.Call(new StringValue { Value = symbol }).Value,
                $"Token {symbol} doesn't need to set to symbol list because it would become native token after donation.");
        }

        State.SymbolList.Value = input;
        return new Empty();
    }
```
