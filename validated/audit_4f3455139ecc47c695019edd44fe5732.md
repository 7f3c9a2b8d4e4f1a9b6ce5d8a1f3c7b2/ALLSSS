# Audit Report

## Title
CachedDelayTotalShares Corruption via RemoveSubScheme in Delayed Distribution Schemes

## Summary
The `RemoveSubScheme` method fails to update `CachedDelayTotalShares` when removing a sub-scheme from a parent scheme with delayed distribution enabled, causing remaining beneficiaries to receive less than their entitled share of profits in future distribution periods.

## Finding Description

The Profit contract maintains a `CachedDelayTotalShares` map to track total shares for future distribution periods when delayed distribution is enabled. [1](#0-0) 

When distributing profits with delay enabled, the system caches current `TotalShares` for a future period and retrieves the cached value for the current period to use as the denominator in profit calculations. [2](#0-1) 

**Root Cause:** The `RemoveSubScheme` method updates `TotalShares` but completely omits updating `CachedDelayTotalShares`. [3](#0-2) 

This creates a critical inconsistency because other methods correctly maintain cached shares:

1. `RemoveBeneficiary` correctly iterates through all cached periods and subtracts removed shares. [4](#0-3) 

2. `ClaimProfits` also correctly updates all cached periods when removing expired profit details. [5](#0-4) 

The Treasury contract actively uses `RemoveSubScheme` via its `ResetWeight` helper method. [6](#0-5) 

Furthermore, the CitizenWelfare scheme is created with `DelayDistributePeriodCount = 1`. [7](#0-6) 

## Impact Explanation

When a sub-scheme with X shares is removed from a parent scheme with `DelayDistributePeriodCount = N`, the cached shares for the next N periods remain inflated by X shares. During profit distribution for those periods, the calculation uses the stale cached total as the denominator instead of the actual reduced value.

**Concrete Example:**
- Period 2: Parent has Sub-A (50 shares) + Sub-B (50 shares) = 100 total. Distribute 1000 tokens → caches TotalShares=100 for Period 5 (delay=3)
- Period 3: Manager calls `RemoveSubScheme` to remove Sub-A → `TotalShares` becomes 50 but `CachedDelayTotalShares[5]` stays at 100
- Period 5: Distribute 1000 tokens → uses cached 100 instead of actual 50 → Sub-B receives (50/100) × 1000 = 500 tokens instead of (50/50) × 1000 = 1000 tokens

The profit calculation logic uses these cached values as the denominator. [8](#0-7) 

The missing 500 tokens remain in the period's virtual address, effectively lost to the intended beneficiary. This violates the critical invariant of profit share calculation accuracy and causes measurable fund loss to legitimate beneficiaries.

## Likelihood Explanation

`RemoveSubScheme` is a public method callable by the scheme manager with authorization only requiring manager status. [9](#0-8) 

The Treasury contract's `ResetWeight` method demonstrates this is used in production for legitimate weight adjustments when changing dividend pool or miner reward settings. [10](#0-9) 

**Feasible Preconditions:**
1. Scheme created with `DelayDistributePeriodCount > 0` (CitizenWelfare uses delay=1)
2. Sub-schemes added and profits distributed (normal operation)
3. Manager calls `RemoveSubScheme` for weight adjustments (legitimate operation)

This is triggered during normal operations when Treasury administrators adjust dividend pool or miner reward weight settings via `SetDividendPoolWeightSetting`. [11](#0-10)  or `SetMinerRewardWeightSetting`. [12](#0-11) 

No sophisticated attack is required - the bug manifests from legitimate administrative actions controlled by the treasury controller (parliament default organization).

## Recommendation

The `RemoveSubScheme` method should update `CachedDelayTotalShares` in the same way as `RemoveBeneficiary` does. Add the following logic after updating `TotalShares`:

```csharp
// After line 152 in RemoveSubScheme
if (scheme.DelayDistributePeriodCount > 0)
{
    var currentPeriod = scheme.CurrentPeriod;
    for (var period = currentPeriod; 
         period < currentPeriod.Add(scheme.DelayDistributePeriodCount); 
         period++)
    {
        if (scheme.CachedDelayTotalShares.ContainsKey(period))
        {
            scheme.CachedDelayTotalShares[period] = 
                scheme.CachedDelayTotalShares[period].Sub(shares.Shares);
        }
    }
}
```

This ensures consistency with other beneficiary removal operations and maintains the cached delay total shares invariant.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveSubScheme_Should_Update_CachedDelayTotalShares()
{
    // Setup: Create parent scheme with delay=1
    var parentScheme = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        DelayDistributePeriodCount = 1
    });
    var parentSchemeId = parentScheme.Output;
    
    // Create two sub-schemes
    var subScheme1 = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput());
    var subScheme2 = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput());
    
    // Add both as beneficiaries with 50 shares each
    await ProfitContractStub.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = parentSchemeId,
        SubSchemeId = subScheme1.Output,
        SubSchemeShares = 50
    });
    await ProfitContractStub.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = parentSchemeId,
        SubSchemeId = subScheme2.Output,
        SubSchemeShares = 50
    });
    
    // Distribute in period 1 - this caches TotalShares=100 for period 2
    await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Period = 1,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // Remove subScheme1 - BUG: doesn't update CachedDelayTotalShares[2]
    await ProfitContractStub.RemoveSubScheme.SendAsync(new RemoveSubSchemeInput
    {
        SchemeId = parentSchemeId,
        SubSchemeId = subScheme1.Output
    });
    
    var scheme = await ProfitContractStub.GetScheme.CallAsync(parentSchemeId);
    scheme.TotalShares.ShouldBe(50); // Updated correctly
    
    // Distribute in period 2 - uses stale cache of 100 instead of actual 50
    await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Period = 2,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // SubScheme2 should get 100% of 1000 = 1000 tokens
    // But actually gets 50% of 1000 = 500 tokens due to stale cached denominator
    var profitAmount = await ProfitContractStub.GetProfitAmount.CallAsync(new GetProfitAmountInput
    {
        SchemeId = parentSchemeId,
        Symbol = "ELF",
        Beneficiary = Context.ConvertVirtualAddressToContractAddress(subScheme2.Output)
    });
    
    // This assertion will FAIL, proving the vulnerability
    profitAmount.Value.ShouldBe(1000); // Expected: 1000, Actual: 500
}
```

**Notes:**

The vulnerability is a state corruption issue where the cached delay mechanism - designed to ensure fair profit distribution over multiple periods - is not properly maintained when sub-schemes are removed. This creates a financial loss for remaining beneficiaries as the denominator in the profit calculation formula remains artificially inflated, causing their share percentage to be calculated incorrectly. The issue affects the Treasury contract's normal operations, specifically the CitizenWelfare distribution scheme used for voter rewards.

### Citations

**File:** protobuf/profit_contract.proto (L156-157)
```text
    // Record the scheme's current total share for deferred distribution of benefits, period -> total shares.
    map<int64, int64> cached_delay_total_shares = 11;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L245-258)
```csharp
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L793-797)
```csharp
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L56-68)
```csharp
        for (var i = 0; i < 7; i++)
        {
            var index = i;
            Context.LogDebug(() => profitItemNameList[index]);
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L312-322)
```csharp
    public override Empty SetDividendPoolWeightSetting(DividendPoolWeightSetting input)
    {
        AssertPerformedByTreasuryController();
        Assert(
            input.CitizenWelfareWeight > 0 && input.BackupSubsidyWeight > 0 &&
            input.MinerRewardWeight > 0,
            "invalid input");
        ResetSubSchemeToTreasury(input);
        State.DividendPoolWeightSetting.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L324-334)
```csharp
    public override Empty SetMinerRewardWeightSetting(MinerRewardWeightSetting input)
    {
        AssertPerformedByTreasuryController();
        Assert(
            input.BasicMinerRewardWeight > 0 && input.WelcomeRewardWeight > 0 &&
            input.FlexibleRewardWeight > 0,
            "invalid input");
        ResetSubSchemeToMinerReward(input);
        State.MinerRewardWeightSetting.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L520-540)
```csharp
    private void ResetWeight(Hash parentSchemeId, Hash subSchemeId, int oldWeight,
        int newWeight)
    {
        if (oldWeight == newWeight)
            return;

        // old weight equals 0 indicates the subScheme has not been registered
        if (oldWeight > 0)
            State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
            {
                SchemeId = parentSchemeId,
                SubSchemeId = subSchemeId
            });

        State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
        {
            SchemeId = parentSchemeId,
            SubSchemeId = subSchemeId,
            SubSchemeShares = newWeight
        });
    }
```
