# Audit Report

## Title
Missing Miner List Validation in NextTerm Allows Consensus Takeover Through Arbitrary Miner Selection

## Summary
The `NextTerm` method in the AEDPoS consensus contract lacks validation of the miner list against election results. A current miner can submit a `NextTermInput` with an arbitrary miner set that bypasses the democratic election mechanism, as the validation only checks term and round number increments without verifying the miner list against `GetVictories` election results.

## Finding Description

The vulnerability exists in the validation and processing flow of term transitions in the AEDPoS consensus contract, breaking the fundamental security guarantee that "miner schedule must reflect election results from token holder votes."

**Insufficient Validation:**

The `ValidationForNextTerm` method only validates numeric increments without checking the miner list. [1](#0-0)  This validation is invoked during consensus validation for `NextTerm` behavior. [2](#0-1) 

**Unverified Miner List Acceptance:**

When `ProcessNextTerm` executes, it directly extracts the miner list from the input without any verification. [3](#0-2)  The `ToRound` conversion simply copies fields including the miner list without validation. [4](#0-3)  The `SetMinerList` function only checks if the term's miner list hasn't been set previously, performing no validation against election results. [5](#0-4) 

**Legitimate Flow Uses Election Results:**

The legitimate term generation process calls `GenerateFirstRoundOfNextTerm` which queries election results via `TryToGetVictories`. [6](#0-5)  Election winners are retrieved from the Election Contract. [7](#0-6)  However, this is only used when creating consensus extra data via `GetConsensusExtraDataForNextTerm`, not during validation of incoming `NextTerm` transactions. [8](#0-7) 

**Insufficient Permission Check:**

The `PreCheck` method only verifies the sender is in the current or previous miner list, which an attacker already satisfies. [9](#0-8) 

**Public Method Accessibility:**

The `NextTerm` method is publicly callable as a standard RPC method. [10](#0-9) [11](#0-10) 

## Impact Explanation

**Severity: Critical - Complete Consensus Takeover**

This vulnerability enables a malicious current miner to:

1. **Consensus Control**: Arbitrarily select the miner set for the next term, excluding legitimately elected miners and including only themselves or colluding parties, establishing permanent control over block production.

2. **Election Bypass**: Completely circumvent the democratic election mechanism where token holders vote for block producers. All voting becomes meaningless as the attacker controls miner selection.

3. **Governance Manipulation**: Monopolize block production and control transaction inclusion, enabling manipulation of on-chain governance proposals and decisions.

4. **Economic Exploitation**: Redirect mining rewards intended for legitimately elected miners to the attacker's controlled addresses.

5. **Censorship Power**: Selectively exclude transactions or manipulate block contents without competing miners to challenge the behavior.

**Affected Parties:**
- Token holders who participated in voting (votes rendered meaningless)
- Legitimately elected candidates (denied rightful miner positions)
- Entire network (consensus integrity compromised)
- DApps and users (subject to censorship and manipulation)

This breaks the fundamental security guarantee that miner schedule must reflect election results from token holder votes.

## Likelihood Explanation

**High Likelihood - Simple Exploitation**

**Attacker Prerequisites:**
- Must be a current miner (achievable through legitimate means initially)
- Ability to construct and submit a transaction with `NextTermInput`
- No special privileges beyond current miner status

**Attack Execution:**
1. Wait for the term period to elapse when a term change is due
2. Craft a `NextTermInput` with:
   - Correct term number (current + 1)
   - Correct round number (properly incremented)
   - Arbitrary miner list (attacker-controlled addresses)
3. Submit transaction to `NextTerm` method - passes all validations
4. Miner list is accepted as the first update for the new term

**Feasibility Analysis:**
- Attack requires only one transaction
- No race conditions or complex timing requirements
- Validation checks are deterministic and easily satisfied
- No cryptographic challenges or computational barriers

**Detection Difficulty:**
- Transaction appears structurally valid with correct format and numbers
- Only detectable by comparing miner list against `GetVictories` results (which is not performed)
- May go unnoticed until excluded miners realize they cannot produce blocks

## Recommendation

Add validation in `ValidationForNextTerm` to verify the proposed miner list matches the election results:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate miner list against election results
    if (State.IsMainChain.Value)
    {
        var expectedVictories = State.ElectionContract.GetVictories.Call(new Empty());
        var proposedMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var expectedMiners = expectedVictories.Value.Select(v => v.ToHex()).OrderBy(k => k).ToList();
        
        if (proposedMiners.Count != expectedMiners.Count ||
            !proposedMiners.SequenceEqual(expectedMiners))
        {
            return new ValidationResult { Message = "Proposed miner list does not match election results." };
        }
    }
    
    return new ValidationResult { Success = true };
}
```

Additionally, add a similar check in `ProcessNextTerm` as a defense-in-depth measure before calling `SetMinerList`.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Set up an initial term with legitimate miners elected through the election contract
2. Have one of the current miners craft a `NextTermInput` with arbitrary miners not matching election results
3. Call `NextTerm` with this crafted input
4. Verify that the transaction succeeds and the arbitrary miner list is set for the new term
5. Confirm that the new miners match the attacker's list, not the election results

The test would show that `ValidationForNextTerm` does not reject the malicious input, and `ProcessNextTerm` accepts and installs the arbitrary miner list, completely bypassing the election mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** protobuf/aedpos_contract.proto (L37-39)
```text
    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }
```
