# Audit Report

## Title
Duplicate Initial Miner Entries Cause Consensus DoS During Evil Miner Replacement

## Summary
The Election Contract's `State.InitialMiners` list can contain duplicate pubkey entries due to missing deduplication during initialization and incomplete removal during pubkey replacement. When the Consensus Contract needs to replace evil miners and falls back to selecting initial miners as alternatives, these duplicates can be returned, causing an `ArgumentException` when attempting to add the same pubkey twice to the round's protobuf map, resulting in consensus failure and chain halt.

## Finding Description

**Root Cause Analysis:**

The Election Contract initializes `State.InitialMiners` directly from input without any deduplication logic. [1](#0-0) 

During pubkey replacement operations, the code uses C#'s `List<T>.Remove()` method which only removes the **first occurrence** of a duplicate element. [2](#0-1)  Additionally, there is no validation preventing the same `newPubkey` from being added multiple times to `InitialMiners` when different old pubkeys are replaced with identical new ones.

**Exploitation Path:**

When `GetMinerReplacementInformation()` is called to replace evil miners, if insufficient non-initial-miner candidates exist in the election snapshot, the method falls back to selecting from `State.InitialMiners`. [3](#0-2) 

The selection logic uses `Select().Where().Where().Take()` LINQ operations which do not perform deduplication. If `State.InitialMiners.Value.Value` contains duplicate entries like `[pubkeyA, pubkeyA, pubkeyB]`, and both `pubkeyA` entries pass the filters (not banned, not in current miner list), the method can return `[pubkeyA, pubkeyA]` in `selectedInitialMiners`, which is then added to `AlternativeCandidatePubkeys`. [4](#0-3) 

The Consensus Contract iterates through the alternative candidates and calls `Add()` on the `RealTimeMinersInformation` protobuf map for each replacement. [5](#0-4) 

The `real_time_miners_information` field is defined as a protobuf map type. [6](#0-5)  Protobuf maps in C# use `Dictionary<TKey, TValue>` semantics where calling `Add()` with an already-existing key throws `ArgumentException`, causing the Consensus Contract to crash and preventing round generation.

**Trigger Scenarios:**

1. **Configuration Error:** Initial chain setup with duplicate pubkeys in `InitialMinerList` configuration
2. **Replacement Bug:** Multiple old pubkeys replaced with the same new pubkey (no validation prevents duplicate new pubkeys in `InitialMiners`)
3. **Stale Entry:** If initial list has `[A, A, B]` and first `A` is replaced with `A'`, only first occurrence removed, leaving `[A, B, A']` where old `A` becomes stale

## Impact Explanation

**Severity: Critical - Consensus DoS**

This vulnerability causes a complete denial of service of the consensus mechanism:

- **Consensus Failure:** The Consensus Contract crashes with `ArgumentException` when attempting to generate the next round with duplicate miner pubkeys
- **Chain Halt:** Block production stops entirely as no new rounds can be generated
- **Network-Wide Impact:** All nodes experience the same failure deterministically based on shared state
- **Manual Recovery Required:** Requires emergency governance intervention or contract upgrade to resolve
- **Operational Criticality:** Affects the most critical blockchain infrastructure component

The impact is categorized as critical because it breaks a fundamental protocol invariant (consensus must always be able to generate new rounds) and causes complete service unavailability for all network participants.

## Likelihood Explanation

**Likelihood: Medium**

**Preconditions:**
1. `State.InitialMiners` contains duplicate pubkey entries through either:
   - Operational configuration error during chain initialization (realistic in complex multi-node deployments)
   - Multiple pubkey replacements using identical new pubkeys (no validation prevents this)
2. Evil miner detection triggers (automatic system feature that will periodically activate)
3. Insufficient non-initial-miner candidates in election snapshot (depends on chain state but realistic)

**Feasibility Assessment:**
- Configuration errors with duplicate entries are realistic operational risks in production blockchain deployments
- The replacement logic has a deterministic bug where `List.Remove()` behavior combined with lack of duplicate new pubkey validation can create duplicates
- Evil miner detection is a designed feature that triggers automatically when miners misbehave
- Once duplicates exist in `InitialMiners`, the vulnerability triggers automatically when the specific conditions align

**Detection Difficulty:**
- Not detectable until the DoS actually occurs
- No proactive validation during initialization or replacement
- No monitoring or alerts for duplicate initial miner entries

The likelihood is medium rather than high because it requires either an operational error or a specific edge case in replacement operations, but once these preconditions are met, the consequences trigger deterministically.

## Recommendation

**Fix 1: Add deduplication during initialization**
```csharp
State.InitialMiners.Value = new PubkeyList
{
    Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)).Distinct() }
};
```

**Fix 2: Remove all occurrences during replacement**
```csharp
var initialMiners = State.InitialMiners.Value;
if (initialMiners.Value.Contains(oldPubkeyBytes))
{
    // Remove ALL occurrences
    initialMiners.Value = new RepeatedField<ByteString> 
    { 
        initialMiners.Value.Where(p => !p.Equals(oldPubkeyBytes)) 
    };
    
    // Check for duplicate new pubkey
    Assert(!initialMiners.Value.Contains(newPubkeyBytes), 
        "New pubkey already exists in initial miners.");
    
    initialMiners.Value.Add(newPubkeyBytes);
    State.InitialMiners.Value = initialMiners;
}
```

**Fix 3: Add deduplication in GetMinerReplacementInformation**
```csharp
var selectedInitialMiners = State.InitialMiners.Value.Value
    .Select(k => k.ToHex())
    .Distinct()  // Add deduplication
    .Where(k => !State.BannedPubkeyMap[k])
    .Where(k => !input.CurrentMinerList.Contains(k))
    .Take(takeAmount);
```

**Fix 4: Add defensive check in Consensus Contract**
```csharp
if (!currentRound.RealTimeMinersInformation.ContainsKey(alternativeCandidatePubkey))
{
    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
}
```

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateInitialMiners_CausesConsensusDoS()
{
    // Setup: Initialize Election Contract with duplicate initial miners
    var duplicateInitialMiners = new List<string> 
    { 
        "pubkeyA", 
        "pubkeyA",  // Duplicate
        "pubkeyB" 
    };
    
    await ElectionContractStub.InitialElectionContract.SendAsync(
        new InitialElectionContractInput
        {
            MinerList = { duplicateInitialMiners },
            MinersCount = 3,
            TimeEachTerm = 604800,
            MinimumLockTime = 7776000,
            MaximumLockTime = 31536000
        });
    
    // Mark one miner as evil to trigger replacement
    await ElectionContractStub.UpdateCandidateInformation.SendAsync(
        new UpdateCandidateInformationInput
        {
            Pubkey = "evilMinerPubkey",
            IsEvilNode = true
        });
    
    // Call GetMinerReplacementInformation with insufficient candidates
    // This will fall back to initial miners and return duplicates
    var replacementInfo = await ElectionContractStub.GetMinerReplacementInformation.CallAsync(
        new GetMinerReplacementInformationInput
        {
            CurrentMinerList = { "evilMinerPubkey", "validMinerPubkey" }
        });
    
    // Verify duplicates are returned
    Assert.Contains(replacementInfo.AlternativeCandidatePubkeys, p => 
        replacementInfo.AlternativeCandidatePubkeys.Count(x => x == p) > 1);
    
    // Attempt to generate next round in Consensus Contract
    // This should throw ArgumentException due to duplicate Add() call
    await Assert.ThrowsAsync<ArgumentException>(async () =>
    {
        await AEDPoSContractStub.NextRound.SendAsync(new NextRoundInput
        {
            RoundNumber = 2
        });
    });
}
```

**Notes:**
- This vulnerability demonstrates a critical failure in defensive programming where input validation and deduplication are missing at multiple layers
- The issue can manifest through either operational configuration errors or through the replacement logic's incomplete duplicate handling
- The consensus contract assumes valid input from the election contract but lacks defensive checks against malformed data
- Recovery requires emergency governance action or contract upgrade, making this a high-severity availability issue

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L34-38)
```csharp
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L382-392)
```csharp
        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L394-398)
```csharp
        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** protobuf/aedpos_contract.proto (L243-247)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
```
