# Audit Report

## Title
Binary Choice in Mining Order Calculation Allows Consensus Manipulation

## Summary
Miners can strategically choose whether to provide their `PreviousInValue` during block production, resulting in two different signature calculations that determine their next-round mining position. This binary choice allows malicious miners to select more favorable positions in the mining schedule, undermining the fairness guarantees of the AEDPoS consensus mechanism.

## Finding Description

The vulnerability exists in the signature calculation logic within `GetConsensusExtraDataToPublishOutValue`, which determines a miner's position in the next round.

**Two Code Paths for Signature Calculation:**

When a miner produces a block, the system follows one of two paths:

**Path 1 - Provide PreviousInValue:** If the miner supplies their `PreviousInValue` in the trigger information (non-null and non-empty), the signature is calculated using that value. [1](#0-0) 

**Path 2 - Omit PreviousInValue:** If the miner provides `null` or `Hash.Empty`, the system computes a `fakePreviousInValue` based on the miner's pubkey and current block height, or attempts to retrieve an `appointedPreviousInValue` from the previous round's stored `InValue`. [2](#0-1) 

**Root Cause - InValue Never Stored for Successful Miners:**

The critical flaw is that `InValue` is only stored on-chain for miners who **miss** their time slots, not for miners who successfully produce blocks. In `SupplyCurrentRoundInformation`, the `InValue` field is assigned only for miners with `OutValue == null`: [3](#0-2) 

During normal block production via `ProcessUpdateValue`, the `InValue` field is never assigned: [4](#0-3) 

This means for miners who successfully mined in round N, the check at line 99 to retrieve `appointedPreviousInValue` from `previousRound.RealTimeMinersInformation[pubkey].InValue` will always return `null`, causing the system to fall back to the predictable `fakePreviousInValue = Hash(pubkey + Context.CurrentHeight.ToString())`.

**Signature Determines Mining Order:**

The calculated signature directly determines the mining order in the next round through modulo arithmetic: [5](#0-4) 

The signature is computed by XORing the provided `inValue` with all previous miners' signatures: [6](#0-5) 

**Validation Explicitly Allows Omission:**

The validation system permits miners to omit their `PreviousInValue` by accepting `Hash.Empty` as valid: [7](#0-6) 

The code includes an explicit comment stating this is intentional: [8](#0-7) 

**Attack Execution:**

1. Miner caches their `PreviousInValue` locally from the previous round via the node's `InValueCache` [9](#0-8) 

2. Before block production, the miner computes both possible signatures:
   - `signatureA = CalculateSignature(cachedPreviousInValue)`
   - `signatureB = CalculateSignature(Hash(pubkey + currentHeight))`

3. The miner calculates resulting orders: `orderX = GetAbsModulus(signatureX.ToInt64(), minersCount) + 1`

4. The miner modifies their node software to return `Hash.Empty` from the cache if `orderB` is preferable, otherwise provides the actual `cachedPreviousInValue`

5. The miner produces their block with whichever choice gives them a better position

## Impact Explanation

This vulnerability directly compromises **consensus integrity** by allowing miners to manipulate their scheduling position, breaking core fairness assumptions:

**1. MEV Extraction:** Earlier mining positions enable miners to be first to process transactions, allowing front-running, transaction ordering manipulation, and MEV extraction opportunities that should be prevented by unpredictable random ordering.

**2. Fairness Violation:** The AEDPoS design assumes mining order is random and unpredictable based on cryptographic secrets. This binary choice mechanism breaks that fundamental assumption, allowing strategic position selection.

**3. Systematic Bias:** Unlike a one-time exploit, this attack can be repeated every round by any active miner, creating systematic bias in the consensus schedule over time. Miners who exploit this gain cumulative advantages.

**4. Extra Block Producer Selection:** Mining order influences selection for the extra block producer role (the miner who produces the round-terminating block), which has additional privileges in the consensus mechanism.

**5. Competitive Disadvantage:** Honest miners who consistently provide their `PreviousInValue` are systematically disadvantaged compared to attackers who strategically choose, creating a race-to-the-bottom where all miners must adopt the exploit to remain competitive.

**Severity: HIGH** - Violates core consensus fairness guarantees and enables systematic manipulation affecting network-wide block production scheduling.

## Likelihood Explanation

**Attacker Profile:**
- Must be an active consensus miner (legitimate participant with staked tokens)
- Requires technical capability to modify node software
- Can predict their mining time slot based on current round schedule

**Attack Feasibility:**

**Technical Barrier:** Moderate - Requires modifying the `AEDPoSTriggerInformationProvider` or manipulating the `InValueCache` to control what value is returned. This is straightforward for technically capable miners with access to their node's source code.

**Economic Cost:** Zero - There is no on-chain penalty, slashing, or economic disincentive for omitting `PreviousInValue`. The validation explicitly permits it, so malicious omission is indistinguishable from legitimate behavior.

**Detection Risk:** None - Since validation allows `Hash.Empty` and the code comments indicate this is "permissible," there is no mechanism to detect or flag this behavior. The evil miner detection system only triggers on missed time slots, not on `PreviousInValue` omission. [10](#0-9) 

**Repeatability:** High - The attack can be executed every round with zero accumulated cost or risk, providing pure upside for attackers.

**Probability: HIGH** - While requiring custom node software creates a barrier, the lack of any detection or penalty mechanism means any technically capable miner has strong incentives to implement this. The zero-risk, pure-benefit nature makes adoption likely among sophisticated miners.

## Recommendation

**Immediate Fixes:**

1. **Mandatory PreviousInValue Provision:** Remove the permissive validation that allows `Hash.Empty`. Require all miners to provide their `PreviousInValue` when they had successfully mined in the previous round:

```csharp
// In UpdateValueValidationProvider.cs
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;

    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    
    // If miner produced a block in previous round, PreviousInValue is MANDATORY
    if (previousOutValue != null && previousOutValue != Hash.Empty)
    {
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == null || previousInValue == Hash.Empty)
            return false; // REJECT - must provide PreviousInValue
        
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }

    return true;
}
```

2. **Store InValue On-Chain:** Modify `ProcessUpdateValue` to store the current round's `InValue` on-chain for successful miners, ensuring `appointedPreviousInValue` is always available:

```csharp
// In ProcessUpdateValue
minerInRound.InValue = updateValueInput.InValue; // Store current InValue
if (updateValueInput.PreviousInValue != Hash.Empty)
    minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

3. **Penalty for Omission:** Implement slashing or reputation penalties for miners who fail to provide `PreviousInValue` when they should have it, making the attack economically costly.

**Long-term Solution:**

Consider redesigning the signature calculation to use verifiable random functions (VRFs) that cannot be selectively withheld, ensuring mining order is truly unpredictable and non-manipulable.

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateMiningOrderByOmittingPreviousInValue()
{
    // Setup: Initialize consensus with 3 miners
    var miners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusAsync(miners);
    
    // Round 1: All miners produce blocks normally with PreviousInValue
    await ProduceRoundAsync(miners, providePreviousInValue: true);
    
    var round1 = await GetCurrentRoundAsync();
    var miner1Round1 = round1.RealTimeMinersInformation["miner1"];
    
    // Verify: InValue is NOT stored for successful miners
    Assert.Null(miner1Round1.InValue);
    
    // Round 2: Miner1 computes both possible signatures
    var cachedPreviousInValue = GetFromCache("miner1", round1.RoundId);
    var fakePreviousInValue = HashHelper.ComputeFrom("miner1" + Context.CurrentHeight.ToString());
    
    var signatureA = CalculateSignature(round1, cachedPreviousInValue);
    var signatureB = CalculateSignature(round1, fakePreviousInValue);
    
    var orderA = GetAbsModulus(signatureA.ToInt64(), 3) + 1;
    var orderB = GetAbsModulus(signatureB.ToInt64(), 3) + 1;
    
    // Attacker chooses whichever gives better position
    bool shouldOmit = orderB < orderA; // Prefer earlier position
    
    // Execute: Miner1 produces block with strategic choice
    if (shouldOmit)
        await ProduceBlockAsync("miner1", previousInValue: Hash.Empty);
    else
        await ProduceBlockAsync("miner1", previousInValue: cachedPreviousInValue);
    
    var round2 = await GetCurrentRoundAsync();
    var actualOrder = round2.RealTimeMinersInformation["miner1"].SupposedOrderOfNextRound;
    
    // Verify: Miner1 achieved the more favorable position
    Assert.Equal(shouldOmit ? orderB : orderA, actualOrder);
    Assert.True(actualOrder == Math.Min(orderA, orderB), 
        "Attacker successfully manipulated mining order to favorable position");
}
```

## Notes

This vulnerability represents a fundamental flaw in the fairness assumptions of the AEDPoS consensus mechanism. The explicit comment stating "It is permissible for miners not publish their in values" suggests this may have been a known design trade-off, but the security implications of allowing this binary choice were not fully considered. The combination of (1) optional `PreviousInValue` provision, (2) predictable fallback values, (3) no detection or penalty, and (4) direct impact on mining order creates a manipulable consensus schedule that violates the protocol's fairness guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L74-92)
```csharp
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L94-107)
```csharp
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-221)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L53-67)
```csharp
        if (hint.Behaviour == AElfConsensusBehaviour.UpdateValue)
        {
            var newInValue = _inValueCache.GetInValue(hint.RoundId);
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
            Logger.LogDebug($"New in value {newInValue} for round of id {hint.RoundId}");
            Logger.LogDebug($"Previous in value {previousInValue} for round of id {hint.PreviousRoundId}");
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = newInValue,
                PreviousInValue = previousInValue,
                Behaviour = hint.Behaviour
            };

            return trigger.ToBytesValue();
```
