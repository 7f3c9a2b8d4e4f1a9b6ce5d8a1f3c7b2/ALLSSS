# Audit Report

## Title
Unauthorized Candidate Registration via AnnounceElectionFor() Enables Authorization Violation, Subsidy Theft, and DataCentersRankingList DoS

## Summary
The `AnnounceElectionFor()` function lacks permission validation, allowing any caller to register arbitrary public keys as election candidates without authorization from the key owners. This violates the fundamental security principle that users control their own identity and participation in the election system, while enabling attackers to steal subsidy benefits and temporarily DoS the DataCentersRankingList.

## Finding Description

The `AnnounceElectionFor()` function accepts any public key from user input and registers it as a candidate without verifying that the caller owns or has permission from the key owner. [1](#0-0) 

The function calls the private `AnnounceElection(byte[] pubkeyBytes)` method which only validates that the public key is not an initial miner and not already a candidate, but performs **no ownership or authorization check**: [2](#0-1) 

This contrasts sharply with the regular `AnnounceElection()` function which uses `Context.RecoverPublicKey()` to ensure the transaction sender owns the private key being registered: [3](#0-2) 

**Attack Execution:**

1. Attacker calls `AnnounceElectionFor()` with victim's public key
2. Attacker sets themselves as admin (defaults to `Context.Sender` if not specified)
3. Attacker locks their own 100,000 ELF tokens per candidate
4. Victim's public key is now registered as a candidate [4](#0-3) 

5. If DataCentersRankingList has available space (capacity = `minersCount * 5`), the victim is automatically added with 0 votes and enrolled in the subsidy profit scheme: [5](#0-4) 

**Victim Lockout Mechanism:**

The victim cannot quit the election because only the admin (set to the attacker) has permission to call `QuitElection()`: [6](#0-5) 

The victim cannot change the admin via `SetCandidateAdmin()` because an admin is already set, and only the current admin can modify it (unless Parliament intervenes): [7](#0-6) 

**DataCentersRankingList Impact:**

When candidates are registered and the list has available space, they are automatically added and enrolled in the subsidy profit scheme: [8](#0-7) 

While legitimate candidates with votes can eventually replace fake candidates with 0 votes through the replacement mechanism, the attacker receives subsidy benefits during the interim period: [9](#0-8) 

## Impact Explanation

**Primary Impact - Authorization Violation (HIGH):**
- Any attacker can register arbitrary public keys as candidates without permission, fundamentally violating user autonomy over their own identity
- Victims' public keys are permanently associated with election candidacy in contract state without consent
- Victims have no practical recourse except slow Parliament governance intervention
- Privacy and reputation damage as keys are publicly listed as candidates against the owner's will

**Secondary Impact - Subsidy Theft (MEDIUM-HIGH):**
- Attackers receive subsidy profit scheme benefits for fake candidates they control as admin
- For a system with default 17 miners, the DataCentersRankingList capacity is 85 slots (17 Ã— 5)
- Attacker can fill all slots with fake candidates (each having 0 votes) at a cost of 8,500,000 ELF
- Legitimate candidates registering after the list is full miss automatic subsidy benefits until they accumulate enough votes to trigger replacement
- This creates an initial economic disadvantage for legitimate participants

**Tertiary Impact - Griefing (MEDIUM):**
- Attacker maintains control as admin and can reclaim all locked tokens by calling `QuitElection()` on behalf of victims
- Since tokens are fully recoverable, the attack can be repeated at minimal cost
- Continuous registration and quitting of fake candidates disrupts the election system

## Likelihood Explanation

**High Likelihood:**
- `AnnounceElectionFor()` is a public function with no permission requirements
- Only requires holding 100,000 ELF per fake candidate
- Attack execution is straightforward with no complex preconditions
- Economic cost is feasible for motivated attackers, especially since tokens are fully recoverable
- No detection or prevention mechanism exists
- Test suite confirms the basic functionality works as designed: [10](#0-9) 

## Recommendation

Add permission validation to `AnnounceElectionFor()` to ensure the caller has authorization from the public key owner. The recommended fix is to require a signature from the target public key proving consent:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    // Verify the caller has permission from the public key owner
    // Option 1: Require explicit signature/authorization from the target public key
    // Option 2: Only allow the key owner to call this function
    // Option 3: Implement a whitelist/approval mechanism
    
    Assert(input.Authorization != null, "Authorization from key owner required.");
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
    
    // Verify signature proves ownership
    Assert(Context.Sender == Address.FromPublicKey(pubkeyBytes) || 
           VerifyAuthorization(input.Authorization, pubkeyBytes), 
           "No permission to register this public key.");
    
    // ... rest of implementation
}
```

Alternatively, consider restricting `AnnounceElectionFor()` to only work when the admin is set to the address derived from the candidate's public key, ensuring the key owner maintains control.

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_Unauthorized_Registration_Attack()
{
    // Attacker and victim keypairs
    var attackerKeyPair = ValidationDataCenterKeyPairs[0];
    var victimKeyPair = ValidationDataCenterKeyPairs[1];
    
    // Attacker announces election for victim without permission
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Admin = Address.FromPublicKey(attackerKeyPair.PublicKey), // Attacker sets themselves as admin
        Pubkey = victimKeyPair.PublicKey.ToHex() // Victim's public key
    });
    
    // Verify victim is now registered as candidate
    var candidateInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    candidateInfo.IsCurrentCandidate.ShouldBeTrue();
    
    // Verify attacker is the admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    admin.ShouldBe(Address.FromPublicKey(attackerKeyPair.PublicKey));
    
    // Verify victim cannot quit (only admin can quit)
    var victimStub = GetElectionContractTester(victimKeyPair);
    var quitResult = await victimStub.QuitElection.SendWithExceptionAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    quitResult.TransactionResult.Error.ShouldContain("Only admin can quit election");
    
    // Verify victim is in DataCentersRankingList receiving subsidy benefits
    var dataCenterList = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
    dataCenterList.DataCenters.ContainsKey(victimKeyPair.PublicKey.ToHex()).ShouldBeTrue();
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-40)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-236)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L469-490)
```csharp
    private void TryToBecomeAValidationDataCenter(VoteMinerInput input, long candidateVotesAmount,
        DataCenterRankingList rankingList)
    {
        var minimumVotes = candidateVotesAmount;
        var minimumVotesCandidate = input.CandidatePubkey;
        var replaceWillHappen = false;
        foreach (var pubkeyToVotesAmount in rankingList.DataCenters.OrderBy(x => x.Value))
            if (pubkeyToVotesAmount.Value < minimumVotes)
            {
                replaceWillHappen = true;
                minimumVotesCandidate = pubkeyToVotesAmount.Key;
                break;
            }

        if (replaceWillHappen)
        {
            State.DataCentersRankingList.Value.DataCenters.Remove(minimumVotesCandidate);
            State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                candidateVotesAmount);
            NotifyProfitReplaceCandidateInDataCenter(minimumVotesCandidate, input.CandidatePubkey);
        }
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/SponsorTests.cs (L16-49)
```csharp
    public async Task ElectionContract_AnnounceElectionFor_State_Test()
    {
        var candidatesKeyPair = ValidationDataCenterKeyPairs.First();
        var sponsorKeyPair = ValidationDataCenterKeyPairs.Last();
        var balanceBeforeAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);

        // Execute AnnounceElectionFor.
        var electionStub = GetElectionContractTester(sponsorKeyPair);
        var candidateAdmin = Address.FromPublicKey(candidatesKeyPair.PublicKey);
        await electionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
        {
            Admin = candidateAdmin,
            Pubkey = candidatesKeyPair.PublicKey.ToHex()
        });

        var balanceAfterAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);
        balanceAfterAnnouncing.ShouldBe(balanceBeforeAnnouncing - ElectionContractConstants.LockTokenForElection);

        var votingItem = await VoteContractStub.GetVotingItem.CallAsync(new GetVotingItemInput
        {
            VotingItemId = MinerElectionVotingItemId
        });
        votingItem.Options.Count.ShouldBe(1);
        votingItem.Options.ShouldContain(candidatesKeyPair.PublicKey.ToHex());
        var dataCenterList = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
        dataCenterList.DataCenters.ContainsKey(candidatesKeyPair.PublicKey.ToHex()).ShouldBeTrue();
        var subsidy = ProfitItemsIds[ProfitType.BackupSubsidy];
        var profitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            SchemeId = subsidy,
            Beneficiary = Address.FromPublicKey(candidatesKeyPair.PublicKey)
        });
        profitDetail.Details.Count.ShouldBe(1);
    }
```
