# Audit Report

## Title
Alias-to-Alias Mapping Enables Circular References and Incomplete Symbol Resolution

## Summary
The token alias system allows creating aliases that point to other aliases instead of actual token symbols. The `GetActualTokenSymbol` function only resolves one level of indirection, causing balance queries, transfers, and other token operations to fail or return incorrect results when chained aliases are used.

## Finding Description

The vulnerability exists in the alias resolution mechanism within the MultiToken contract. 

**Single-Level Alias Resolution:**

The `GetActualTokenSymbol` function performs only one level of alias lookup. [1](#0-0) 

When an alias points to another alias, resolution stops at the intermediate alias instead of resolving to the actual token symbol. This affects all token operations:

- Balance queries use `GetActualTokenSymbol` to resolve symbols [2](#0-1) 
- Approval operations resolve aliases before setting allowances [3](#0-2) 
- Batch approve operations similarly resolve symbols [4](#0-3) 
- UnApprove operations also use the resolution function [5](#0-4) 
- Internal balance retrieval uses alias resolution [6](#0-5) 

**Missing Validation in Alias Creation:**

The `SetTokenAlias` function extracts symbol-alias pairs from TokenInfo's ExternalInfo and creates the mapping without validating that the target symbol is not itself an alias. [7](#0-6) 

The `CheckTokenAlias` function only validates that the alias matches the collection's seed name but never checks if the target symbol is an actual token or another alias. [8](#0-7) 

The `ExtractAliasSetting` function parses the ExternalInfo to extract the symbol-alias mapping without any validation on the target symbol. [9](#0-8) 

**Attack Vectors:**

This is exploitable through NFT Collection creation where ExternalInfo can contain arbitrary alias settings. [10](#0-9) 

It's also exploitable during cross-chain token synchronization. [11](#0-10) 

**Attack Scenario:**
1. Alice creates NFT collection "SEED1-0" with item "SEED1-123" and sets alias: `SymbolAliasMap["SEED1"] = "SEED1-123"`
2. Bob creates NFT collection "SEED2-0" with ExternalInfo `{"SEED1":"SEED2"}`, creating: `SymbolAliasMap["SEED2"] = "SEED1"`
3. When users query balance using "SEED2":
   - `GetActualTokenSymbol("SEED2")` returns "SEED1"
   - Balance lookup uses "SEED1" instead of the actual symbol "SEED1-123"
   - Returns 0 or wrong balance since balances are stored under "SEED1-123"

## Impact Explanation

**Operational Disruption:**
- Balance queries using chained aliases return incorrect results (0 balance when tokens exist)
- Transfer operations would fail or affect unintended token balances
- Approval and allowance operations malfunction, creating incorrect allowance entries
- Any contract integration relying on alias resolution receives incorrect data

**Economic Impact:**
- Users lose practical access to their token balances through alias-based queries
- NFT marketplace integrations break when aliases resolve incorrectly
- Cross-chain operations can propagate broken alias chains to other chains
- Smart contracts relying on balance checks make incorrect decisions

The severity is HIGH because while this doesn't directly steal funds, it creates a denial-of-service condition for affected tokens and corrupts the alias mapping state system-wide, including cross-chain deployments.

## Likelihood Explanation

**Attacker Capabilities:**
- Requires only standard NFT collection creation rights (available to any user)
- No special permissions, governance approval, or trusted role needed

**Attack Complexity:**
- Very low: Single transaction to create NFT collection with crafted ExternalInfo
- No timing requirements or race conditions
- Reliable exploitation every time

**Feasibility:**
- Any user can create NFT collections
- Cost is minimal: standard token creation gas fees
- Only requires one existing alias to target

**Detection:**
- Cannot be prevented by monitoring since ExternalInfo is a legitimate parameter
- No runtime checks exist to detect or prevent alias-to-alias mappings
- Silent failure makes detection difficult until users report incorrect balances

The probability is HIGH - the attack is trivial to execute through normal contract interfaces with no special access required.

## Recommendation

Add validation in `SetTokenAlias` to ensure the target symbol is an actual registered token, not another alias:

```csharp
private void SetTokenAlias(TokenInfo tokenInfo)
{
    var (symbol, alias) = ExtractAliasSetting(tokenInfo);
    
    // Validate that symbol is an actual token, not an alias
    Assert(State.TokenInfos[symbol] != null, $"Target symbol {symbol} must be an actual token, not an alias.");
    
    State.SymbolAliasMap[alias] = symbol;
    CheckTokenAlias(alias, tokenInfo.Symbol);
    
    Context.Fire(new SymbolAliasAdded
    {
        Symbol = symbol,
        Alias = alias
    });
}
```

Additionally, consider implementing recursive resolution in `GetActualTokenSymbol` as a defense-in-depth measure:

```csharp
private string GetActualTokenSymbol(string aliasOrSymbol)
{
    var resolvedSymbol = aliasOrSymbol;
    var visited = new HashSet<string>();
    
    while (State.TokenInfos[resolvedSymbol] == null)
    {
        if (visited.Contains(resolvedSymbol))
        {
            throw new AssertionException("Circular alias reference detected");
        }
        visited.Add(resolvedSymbol);
        
        var nextSymbol = State.SymbolAliasMap[resolvedSymbol];
        if (nextSymbol == null) break;
        resolvedSymbol = nextSymbol;
    }
    
    return resolvedSymbol;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task AliasToAliasMapping_CausesIncorrectBalanceResolution()
{
    // Step 1: Create first NFT collection and item with alias
    var collection1Symbol = "SEED1-0";
    var item1Symbol = "SEED1-123";
    var alias1 = "SEED1";
    
    await CreateNftCollectionAsync(new TokenInfo
    {
        Symbol = collection1Symbol,
        TokenName = "Collection 1",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        IssueChainId = _chainId
    });
    
    await CreateNftAsync(collection1Symbol, new TokenInfo
    {
        Symbol = item1Symbol,
        TokenName = "Item 1",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress
    });
    
    await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
    {
        Symbol = item1Symbol,
        Alias = alias1
    });
    
    // Issue token to user
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = item1Symbol,
        Amount = 1,
        To = DefaultAddress
    });
    
    // Verify balance with alias works
    var balance1 = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = alias1
    });
    balance1.Balance.ShouldBe(1);
    
    // Step 2: Create second NFT collection with alias pointing to first alias
    var collection2Symbol = "SEED2-0";
    var alias2 = "SEED2";
    
    await CreateNftCollectionAsync(new TokenInfo
    {
        Symbol = collection2Symbol,
        TokenName = "Collection 2",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        IssueChainId = _chainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { TokenAliasExternalInfoKey, $"{{\"{alias1}\":\"{alias2}\"}}" }
            }
        }
    });
    
    // Step 3: Query balance using the chained alias
    var balance2 = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = alias2  // This should resolve to item1Symbol but only resolves to alias1
    });
    
    // VULNERABILITY: Returns 0 instead of 1 because GetActualTokenSymbol
    // only resolves one level (SEED2 -> SEED1) but doesn't continue to SEED1-123
    balance2.Balance.ShouldBe(0);  // Expected: 1, Actual: 0
    
    // The actual balance is stored under item1Symbol (SEED1-123)
    var actualBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = item1Symbol
    });
    actualBalance.Balance.ShouldBe(1);
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L38-48)
```csharp
    [View]
    public override GetBalanceOutput GetBalance(GetBalanceInput input)
    {
        var symbol = GetActualTokenSymbol(input.Symbol);
        return new GetBalanceOutput
        {
            Symbol = input.Symbol,
            Owner = input.Owner,
            Balance = GetBalance(input.Owner, symbol)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L81-85)
```csharp
        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L261-268)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        AssertValidInputAddress(input.Spender);
        var actualSymbol = GetActualTokenSymbol(input.Symbol);
        AssertValidApproveTokenAndAmount(actualSymbol, input.Amount);
        Approve(input.Spender, actualSymbol, input.Amount);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L285-298)
```csharp
        Assert(input != null && input.Value != null && input.Value.Count > 0, "Invalid input .");
        Assert(input.Value.Count <= GetMaxBatchApproveCount(), "Exceeds the max batch approve count.");
        foreach (var approve in input.Value)
        {
            AssertValidInputAddress(approve.Spender);
            var actualSymbol = GetActualTokenSymbol(approve.Symbol);
            AssertValidApproveTokenAndAmount(actualSymbol, approve.Amount);
        }
        var approveInputList = input.Value.GroupBy(approve => approve.Symbol + approve.Spender, approve => approve)
            .Select(approve => approve.Last()).ToList();
        foreach (var approve in approveInputList)
            Approve(approve.Spender, approve.Symbol, approve.Amount);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L300-310)
```csharp
    public override Empty UnApprove(UnApproveInput input)
    {
        AssertValidInputAddress(input.Spender);
        var symbol = GetActualTokenSymbol(input.Symbol);
        AssertValidApproveTokenAndAmount(symbol, input.Amount);
        var oldAllowance = State.Allowances[Context.Sender][input.Spender][symbol];
        var amountOrAll = Math.Min(input.Amount, oldAllowance);
        State.Allowances[Context.Sender][input.Spender][symbol] = oldAllowance.Sub(amountOrAll);
        Context.Fire(new UnApproved
        {
            Owner = Context.Sender,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L790-793)
```csharp
        if (IsAliasSettingExists(newTokenInfo))
        {
            SetTokenAlias(newTokenInfo);
            return true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L811-824)
```csharp
    private KeyValuePair<string, string> ExtractAliasSetting(TokenInfo tokenInfo)
    {
        if (!tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TokenAliasExternalInfoKey))
        {
            return new KeyValuePair<string, string>(string.Empty, string.Empty);
        }

        var tokenAliasSetting = tokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey];
        tokenAliasSetting = tokenAliasSetting.Trim('{', '}');
        var parts = tokenAliasSetting.Split(':');
        var key = parts[0].Trim().Trim('\"');
        var value = parts[1].Trim().Trim('\"');
        return new KeyValuePair<string, string>(key, value);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L826-838)
```csharp
    private void SetTokenAlias(TokenInfo tokenInfo)
    {
        var (symbol, alias) = ExtractAliasSetting(tokenInfo);
        State.SymbolAliasMap[alias] = symbol;

        CheckTokenAlias(alias, tokenInfo.Symbol);

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = symbol,
            Alias = alias
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```
