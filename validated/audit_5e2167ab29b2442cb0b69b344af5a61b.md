# Audit Report

## Title
Parliament Proposal Vote Count Miscalculation Due to Dynamic Miner List Retrieval

## Summary
The Parliament contract's `IsReleaseThresholdReached()` function retrieves the current miner list dynamically at proposal release time rather than using a snapshot from when votes were cast. When parliament membership changes during term transitions (every 7 days), votes from former members are silently discarded, causing governance manipulation and unpredictable proposal outcomes.

## Finding Description

The Parliament contract validates proposal votes by filtering them against the **current** miner list retrieved at validation time, not the miner list from when votes were cast.

The `IsReleaseThresholdReached()` function calls `GetCurrentMinerList()` which makes a cross-contract call to the consensus contract to fetch the active miner list: [1](#0-0) [2](#0-1) 

This current member list is then used to filter stored votes. Only votes from addresses in the **current** parliament member list are counted:

**Rejection counting:** [3](#0-2) 

**Abstention counting:** [4](#0-3) 

**Approval counting:** [5](#0-4) 

The miner list changes during term transitions in the consensus contract, which occur regularly: [6](#0-5) [7](#0-6) 

When `Release()` is called after a term transition, votes from former parliament members fail the `parliamentMembers.Contains()` check and are excluded from threshold calculations: [8](#0-7) 

**Architectural Inconsistency:** The Association contract uses a different pattern - it stores a static member list in the organization structure and validates votes against that fixed list, not a dynamic one: [9](#0-8) 

This demonstrates that the intended design pattern for governance vote validation is to use a fixed membership snapshot, not dynamic retrieval.

## Impact Explanation

**Governance Integrity Violation:**
- Votes legitimately cast by authorized parliament members become retroactively invalid
- Proposal outcomes depend on release timing rather than actual vote counts
- No notification or re-voting mechanism exists when votes are invalidated

**Attack Scenarios:**

1. **Blocking Legitimate Proposals:** A proposal that received sufficient approvals (e.g., 8/10 miners = 80% approval) can fail validation if released after a term transition that replaces 4 of the 8 approvers. The vote count drops to 4/10 (40%), failing a 60% threshold despite legitimate approval.

2. **Timing-Based Manipulation:** Proposers can strategically delay or accelerate release timing to align with term transitions that favor or block their proposals based on which specific members are replaced.

3. **Governance Paralysis:** Critical system upgrades, parameter changes, and treasury releases can be blocked if they span term boundaries, creating operational deadlock.

**Affected Systems:**
- Contract upgrades and deployments
- Economic parameter adjustments  
- Treasury fund releases
- Consensus parameter changes
- All critical governance decisions

## Likelihood Explanation

**Attack Feasibility:**
- Term transitions occur every 7 days (604800 seconds) and are fully predictable
- Proposals have a 72-hour (259200 seconds) default expiration window
- Simple arithmetic: 72 hours easily spans the weekly term boundary
- No special privileges required beyond normal proposer authority
- Exploitation requires only timing coordination, not technical sophistication

**Detection Difficulty:**
- Vote discarding is silent with no events emitted
- Appears as legitimate "Not approved" failure
- Difficult to distinguish from genuine vote insufficiency
- No audit trail shows that votes were previously sufficient

**Practical Probability:** Medium-High
- Every 7 days, proposals in progress may be affected
- High-value governance decisions are economically rational targets
- Natural occurrence for any proposal spanning term boundaries

## Recommendation

**Solution:** Implement a membership snapshot mechanism:

1. **Store parliament member list at proposal creation:**
   ```csharp
   private Hash CreateNewProposal(CreateProposalInput input)
   {
       // ... existing code ...
       var currentParliament = GetCurrentMinerList();
       proposal.ParliamentMembersSnapshot = currentParliament; // Add new field
       State.Proposals[proposalId] = proposal;
   }
   ```

2. **Use snapshot for vote validation:**
   ```csharp
   private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
   {
       // Use stored snapshot instead of dynamic retrieval
       var parliamentMembers = proposal.ParliamentMembersSnapshot ?? GetCurrentMinerList();
       // ... rest of validation logic ...
   }
   ```

3. **Alternative:** Allow re-voting after term transitions with explicit notification mechanism.

4. **Immediate mitigation:** Document this behavior clearly and recommend proposers release proposals before term transitions.

## Proof of Concept

A complete PoC requires test infrastructure to simulate term transitions:

```csharp
[Fact]
public async Task Parliament_VoteInvalidation_After_TermTransition_Test()
{
    // 1. Create proposal with initial miner set (Miners A, B, C)
    var proposalId = await CreateProposalAsync(organizationAddress);
    
    // 2. Get approval from 2/3 miners (sufficient for 60% threshold)
    await ParliamentContractStubA.Approve.SendAsync(proposalId);
    await ParliamentContractStubB.Approve.SendAsync(proposalId);
    
    // 3. Verify proposal is approved with current members
    var proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue();
    
    // 4. Simulate term transition - replace Miners A & B with Miners D & E
    await SimulateTermTransition(newMiners: new[] { MinerC, MinerD, MinerE });
    
    // 5. Attempt to release proposal
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(proposalId);
    
    // 6. Assert: Release fails despite having sufficient votes when cast
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    // Only MinerC's vote counts now (1/3 = 33% < 60% threshold)
    // MinerA and MinerB votes are silently discarded
}
```

The vulnerability is confirmed by code analysis showing dynamic member list retrieval with no snapshot mechanism, creating exploitable timing windows during predictable term transitions.

## Notes

This vulnerability represents a fundamental architectural flaw in Parliament governance vote validation. Unlike the Association contract which uses static member lists, Parliament's dynamic approach creates retroactive vote invalidation without notification or re-voting mechanisms. The 72-hour proposal window combined with 7-day term cycles guarantees regular exposure to this issue, affecting all governance operations during term boundaries.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-59)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```
