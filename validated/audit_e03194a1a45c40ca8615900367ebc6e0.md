# Audit Report

## Title
Missed Time Slots Reset Without Evil Miner Detection at Term Boundaries

## Summary
The AEDPoS consensus contract resets `MissedTimeSlots` counters to zero during term transitions without performing evil miner detection, allowing validators to bypass the punishment mechanism that only executes during round transitions. This enables persistent poor performance without accountability.

## Finding Description

The AEDPoS consensus system implements two distinct state transition paths with asymmetric security checks:

**Round Transitions (Protected Path):**
During normal round transitions via `ProcessNextRound()`, the system correctly performs evil miner detection before advancing state. [1](#0-0) 

This detection queries miners whose `MissedTimeSlots` exceeds the tolerable threshold using `TryToDetectEvilMiners()`. [2](#0-1) 

The threshold is defined as 4320 time slots (approximately 3 days at 1-minute intervals). [3](#0-2) 

**Term Transitions (Vulnerable Path):**
However, `ProcessNextTerm()` follows a different execution path that omits this critical check. [4](#0-3) 

The function increments missed slots one final time via `CountMissedTimeSlots()`. [5](#0-4) 

But then immediately resets all counters to zero without invoking `TryToDetectEvilMiners()`. [6](#0-5) 

**Why Existing Protections Fail:**

Historical statistics are sent to the Election contract via `UpdateCurrentMinerInformationToElectionContract()`. [7](#0-6) 

However, the Election contract only accumulates this data for tracking purposes - it does not trigger automatic banning. [8](#0-7) 

Banning only occurs when the consensus contract explicitly sends `IsEvilNode = true`. [9](#0-8) 

Furthermore, miner replacement logic in `GenerateNextRoundInformation()` only executes during same-term transitions, not across term boundaries. [10](#0-9) 

**Attack Execution:**
1. Malicious miner accumulates missed time slots up to ~4,319 during a term
2. Term transition occurs naturally based on elapsed time (time-based, not attacker-controlled but predictable)
3. `CountMissedTimeSlots()` potentially pushes counter to 4,320+
4. Counter immediately resets to 0 without evil detection
5. Miner continues with clean record if re-elected
6. Process repeats across unlimited terms

## Impact Explanation

**Severity: HIGH**

This vulnerability completely bypasses a critical consensus integrity mechanism. The evil miner detection system exists specifically to ensure validator accountability - miners who persistently fail to produce blocks must be removed from the active set.

**Direct Protocol Impact:**
- Validators can miss ~4,300 slots per term (approximately 72 hours of downtime) indefinitely without facing punishment
- The consensus mechanism's reliability guarantee is broken as unreliable nodes remain in the validator set
- Performance-based election and reward distribution becomes meaningless

**Affected Parties:**
- Honest validators are disadvantaged as they bear operational costs while malicious actors reduce infrastructure investment
- Network users experience degraded service with inconsistent block production
- The economic model based on validator performance metrics is fundamentally compromised

This represents a **consensus integrity break** - the system can no longer guarantee validator accountability, which is a core security invariant.

## Likelihood Explanation

**Likelihood: HIGH**

**Prerequisites:**
- Attacker must be an elected validator (standard requirement for consensus-level exploits)
- No additional privileges, governance control, or token holdings required

**Feasibility:**
- **Execution Complexity: LOW** - Simply miss time slots strategically while monitoring the public `MissedTimeSlots` counter
- **No Precise Timing Required** - Term transitions happen naturally based on elapsed time; vulnerability exists passively at every term boundary
- **No Coordination Needed** - Single validator can exploit independently
- **Strong Economic Incentive** - Reduce operational/infrastructure costs without consequence
- **Detection Difficulty** - Requires manual cross-term historical analysis

The combination of low execution complexity, passive exploitation opportunity, and strong economic incentive makes this highly likely to be exploited in production environments.

## Recommendation

Add evil miner detection to `ProcessNextTerm()` before resetting counters:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    // ... existing code ...
    
    // Count missed time slot of current round.
    CountMissedTimeSlots();
    
    // Get current round for evil detection
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // ADD: Perform evil miner detection BEFORE resetting counters
    if (State.IsMainChain.Value && 
        currentRound.TryToDetectEvilMiners(out var evilMiners))
    {
        foreach (var evilMiner in evilMiners)
        {
            State.ElectionContract.UpdateCandidateInformation.Send(
                new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
        }
    }
    
    // ... rest of existing code including counter reset ...
}
```

This ensures evil miners are detected and banned regardless of whether the transition is a round change or term change.

## Proof of Concept

A proof of concept would require:

1. Set up test chain with validators
2. Have validator miss time slots approaching 4,320
3. Trigger term transition via time-based condition
4. Verify counter resets to 0 without `IsEvilNode` flag being set
5. Confirm validator continues in next term despite poor performance

The vulnerability is demonstrated by code inspection showing `ProcessNextTerm()` lacks the `TryToDetectEvilMiners()` call that exists in `ProcessNextRound()`, combined with immediate counter reset, creating an exploitable bypass window at every term boundary.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-183)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L87-96)
```csharp
    private void CountMissedTimeSlots()
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return;

        foreach (var minerInRound in currentRound.RealTimeMinersInformation)
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);

        TryToUpdateRoundInformation(currentRound);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L115-119)
```csharp
        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
        candidateInformation.MissedTimeSlots =
            candidateInformation.MissedTimeSlots.Add(input.RecentlyMissedTimeSlots);
        State.CandidateInformationMap[input.Pubkey] = candidateInformation;
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-305)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```
