# Audit Report

## Title
Insufficient Recharge Validation Allows Side Chain to Immediately Fall Back Into Debt

## Summary
The `Recharge` function in the CrossChain contract contains a critical mathematical error in its validation logic that double-counts the recharge amount. This allows side chains to be recharged with insufficient funds (as little as `arrears + indexingPrice/2` instead of the required `arrears + indexingPrice`), causing the chain to immediately fall back into `IndexingFeeDebt` status upon the next block indexing operation, resulting in direct fund loss for rechargers and preventing proper chain reactivation.

## Finding Description

The vulnerability exists in the recharge validation assertion. The function first transfers the recharge amount to the chain's virtual address [1](#0-0) , then if the chain is in debt, pays all arrears from the chain's virtual address to creditors [2](#0-1) .

The critical flaw occurs when fetching the remaining balance AFTER arrears have been paid [3](#0-2) , followed by the flawed validation assertion [4](#0-3) .

**Mathematical Analysis:**

Let R = recharge amount, A = total arrears, P = IndexingPrice, B = initial balance.

- After step 1 (transfer): balance = B + R
- After step 2 (pay arrears): balance = B + R - A
- At step 3: originBalance = B + R - A
- At step 4: Assert R + (B + R - A) >= A + P

Simplifying: 2R + B - A >= A + P → 2R + B >= 2A + P → R >= A + (P - B)/2

For a fully drained chain (B = 0): **R >= A + P/2** (INCORRECT)

**Correct Requirement:**

After paying arrears, the remaining balance must cover at least one indexing operation:
- (B + R - A) >= P
- R >= A + P - B
- For B = 0: **R >= A + P** (CORRECT)

The flawed assertion allows recharges with only approximately half the required indexing fee.

**Exploitation via IndexSideChainBlockData:**

The `IndexSideChainBlockData` function determines locked token amount based on chain status [5](#0-4) . Since `Recharge` sets the status to `Active` [6](#0-5) , the next indexing operation fetches the actual balance.

When indexing a block, the indexing price is deducted from locked tokens [7](#0-6) . If the result is negative, new arrears are created and the chain status reverts to `IndexingFeeDebt` [8](#0-7) .

## Impact Explanation

This vulnerability has **HIGH** severity impact:

**Direct Financial Loss:**
- Rechargers lose funds without achieving chain reactivation
- With IndexingPrice = 10 and arrears = 100, a user recharging with 105 tokens (the minimum allowed by the flawed assertion) will pay 100 to clear arrears, leaving only 5 tokens. The next indexing requiring 10 tokens will create 5 new tokens of arrears, making the 105-token recharge effectively worthless.

**Operational Disruption:**
- Side chains cannot be properly reactivated from debt status
- Cross-chain indexing functionality remains broken
- Miners/proposers don't receive payment for indexing work, accumulating more debt

**System Integrity:**
- Breaks the invariant that a successful recharge should enable at least one indexing operation
- Undermines trust in the side chain fee system

## Likelihood Explanation

This vulnerability has **HIGH** likelihood:

**Accessibility:**
- The `Recharge` function is publicly accessible to any user
- No special permissions required beyond token allowance

**Preconditions:**
- Side chain in `IndexingFeeDebt` status (common operational state when chains run low on funds)
- `IndexingPrice >= 2` (typical in production environments)

**Note:** The test suite uses `indexingPrice = 1` which masks the bug [9](#0-8) . With P=1, the formula R >= A + 0.5 effectively rounds to R >= A + 1 in integer arithmetic, making the bug less visible.

**Triggering:**
- Occurs naturally when operators attempt minimal recharges to minimize costs
- No malicious intent required - legitimate users will encounter this
- Deterministic mathematical error that always triggers under the specified conditions

## Recommendation

Fix the validation logic to check the remaining balance after arrears payment, not the sum of recharge and remaining balance:

```csharp
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(originBalance >= sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

This ensures that after paying arrears, the remaining balance can cover at least one indexing operation.

## Proof of Concept

```csharp
[Fact]
public async Task RechargeWithInsufficientFunds_DoubleCountingBug()
{
    // Setup: Create side chain with indexingPrice = 10 (not 1 to reveal the bug)
    var parentChainId = 123;
    long lockedToken = 200;
    long indexingPrice = 10;
    long parentChainHeightOfCreation = 10;

    var sideChainId = await InitAndCreateSideChainAsync(
        parentChainHeightOfCreation, parentChainId, lockedToken, indexingPrice);

    // Drain the chain by indexing 20 blocks (20 * 10 = 200 tokens)
    for (int i = 1; i <= 20; i++)
    {
        var sideChainBlockData = CreateSideChainBlockData(
            HashHelper.ComputeFrom($"block{i}"), i, sideChainId, 
            HashHelper.ComputeFrom("merkle"));
        await DoIndexAsync(new CrossChainBlockData { 
            SideChainBlockDataList = { sideChainBlockData } 
        }, new[] { sideChainId });
    }

    // Verify chain is in debt with 100 tokens arrears (after 10 more blocks attempted)
    var chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    var balance = await GetSideChainBalanceAsync(sideChainId);
    balance.ShouldBe(0); // Fully drained

    // Recharge with 105 tokens (minimum passing flawed assertion: 105 >= 100 + 10/2)
    await ApproveBalanceAsync(105);
    await CrossChainContractStub.Recharge.SendAsync(new RechargeInput
    {
        ChainId = sideChainId,
        Amount = 105
    });

    // Verify status is Active and balance is only 5 (should have been 15)
    chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.Active);
    
    balance = await GetSideChainBalanceAsync(sideChainId);
    balance.ShouldBe(5); // Only 5 tokens remain after paying 100 arrears

    // Index one more block - this should work but will fail
    var nextBlock = CreateSideChainBlockData(
        HashHelper.ComputeFrom("block21"), 21, sideChainId, 
        HashHelper.ComputeFrom("merkle"));
    await DoIndexAsync(new CrossChainBlockData { 
        SideChainBlockDataList = { nextBlock } 
    }, new[] { sideChainId });

    // BUG CONFIRMED: Chain immediately falls back into debt
    chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt); // Back in debt!
    
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt
        .CallAsync(new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(5); // New arrears of 5 tokens created
    
    // User lost 105 tokens but chain is still in debt
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L181-188)
```csharp
        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L194-204)
```csharp
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L206-206)
```csharp
            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L207-208)
```csharp
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L212-212)
```csharp
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L828-830)
```csharp
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L844-844)
```csharp
                lockedToken -= indexingPrice;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L846-851)
```csharp
                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
```

**File:** test/AElf.Contracts.CrossChain.Tests/CrossChainIndexingActionTest.cs (L341-341)
```csharp
        long indexingPrice = 1;
```
