# Audit Report

## Title
Incorrect LIB Index Calculation Violates 2/3 Consensus Threshold in AEDPoS

## Summary
The Last Irreversible Block (LIB) height calculation in the AEDPoS consensus contract uses a mathematically flawed index formula that allows blocks to be finalized with insufficient miner agreement (as low as 50-57% instead of the required 67%), fundamentally breaking the Byzantine Fault Tolerance guarantee of the consensus protocol.

## Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method which calculates the LIB height by selecting a value at index `(Count - 1) / 3` from a sorted list of implied irreversible heights. [1](#0-0) 

The `MinersCountOfConsent` threshold is correctly defined as `(TotalMiners * 2) / 3 + 1`. [2](#0-1) 

**Root Cause:**

The algorithm retrieves implied irreversible heights from miners who mined in the current round [3](#0-2) , verifies at least `MinersCountOfConsent` miners provided heights [4](#0-3) , then selects the height using the flawed index formula.

In a sorted ascending list of n heights, selecting index i means (n - i) miners reported heights â‰¥ selected height. With `index = (n - 1) / 3`:
- Agreeing miners = n - (n - 1) / 3 = (2n + 1) / 3

When n = MinersCountOfConsent (minimum valid case):
- **7 total miners**: MinersCountOfConsent = 5, index = 1, agreeing = 4/7 = **57%**
- **10 total miners**: MinersCountOfConsent = 7, index = 2, agreeing = 5/10 = **50%**

Both fall critically below the required 67% (2/3 + 1) threshold.

**Why Existing Protections Fail:**

The guard only verifies sufficient miners have mined, not that the selected height achieves 2/3 consensus. [4](#0-3) 

The `LibInformationValidationProvider` only validates that LIB values don't decrease, not that they were correctly calculated. [5](#0-4) 

## Impact Explanation

**Severity: HIGH - Consensus Integrity Violation**

1. **Byzantine Fault Tolerance Breakdown**: BFT consensus requires 2/3+ agreement to tolerate up to 1/3 faulty/malicious nodes. With only 50-57% agreement, less than 2/3 of miners agree on finality, allowing 43-50% of miners to potentially compromise finalization guarantees.

2. **Irreversible Block Compromise**: The incorrectly calculated LIB fires the `IrreversibleBlockFound` event which updates the chain's canonical irreversible block height. [6](#0-5)  The event processor sets this as the chain's LIB without validating the consensus calculation. [7](#0-6) 

3. **System-Wide Impact**: LIB height affects state finalization, transaction pool pruning, cross-chain verification, and governance cleanup throughout the system.

4. **Cross-Chain Security**: Side chains and bridges rely on main chain LIB for security anchoring, propagating this weakness to connected chains.

## Likelihood Explanation

**Likelihood: HIGH - Natural Occurrence During Normal Operation**

1. **Reachable Entry Point**: Triggered when miners call `UpdateValue` during normal block production. [8](#0-7) 

2. **Frequent Trigger Condition**: Occurs when exactly `MinersCountOfConsent` miners successfully mine in a round - a common scenario when some miners experience delays or temporary issues.

3. **No Attack Required**: This is a deterministic logic bug manifesting during legitimate protocol execution.

4. **Silent Failure**: Produces valid block heights passing all existing validation checks.

5. **Persistent Risk**: Repeats across every consensus round meeting the trigger condition.

## Recommendation

Change the index calculation to ensure proper 2/3+ consensus on the selected LIB height:

```csharp
// Correct formula: select index 0 when n = MinersCountOfConsent
// More generally: index = max(0, n - MinersCountOfConsent) for n miners
libHeight = impliedIrreversibleHeights[0];
```

This ensures when `MinersCountOfConsent` miners provide heights, all of them (representing 2/3+ of total miners) agree on the minimum height as the LIB.

Alternatively, use a more robust formula:
```csharp
// Ensure at least MinersCountOfConsent miners agree on the selected height
int index = Math.Max(0, impliedIrreversibleHeights.Count - _currentRound.MinersCountOfConsent);
libHeight = impliedIrreversibleHeights[index];
```

## Proof of Concept

A test demonstrating the vulnerability would:

1. Configure a chain with 7 total miners (MinersCountOfConsent = 5)
2. Have exactly 5 miners mine blocks in current round with implied heights [100, 200, 300, 400, 500]
3. Invoke `UpdateValue` to trigger LIB calculation
4. Observe LIB is set to height 200 (index 1) with only 4/7 miners agreeing (57% < 67%)
5. Verify `IrreversibleBlockFound` event fires with this incorrectly calculated height

The same test with 10 miners (MinersCountOfConsent = 7) and 7 miners mining would demonstrate 5/10 = 50% agreement.

---

## Notes

This vulnerability represents a fundamental flaw in the consensus finality mechanism. The mathematical error in the index calculation directly violates the 2/3 Byzantine Fault Tolerance threshold that the protocol depends upon. The issue is deterministic, occurs during normal operation without requiring any attack, and affects the core security guarantees of the blockchain. The existing validation layers fail to catch this because they only verify monotonicity of LIB values, not the correctness of the consensus calculation itself.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-25)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-30)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L32-32)
```csharp
            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L60-79)
```csharp
            if (chain.LastIrreversibleBlockHeight > irreversibleBlockFound.IrreversibleBlockHeight)
                return;

            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;

            if (chain.LastIrreversibleBlockHeight == irreversibleBlockFound.IrreversibleBlockHeight) return;

            var blockIndex = new BlockIndex(libBlockHash, irreversibleBlockFound.IrreversibleBlockHeight);
            Logger.LogDebug($"About to set new lib height: {blockIndex.BlockHeight} " +
                            $"Event: {irreversibleBlockFound} " +
                            $"BlockIndex: {blockIndex.BlockHash} - {blockIndex.BlockHeight}");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var currentChain = await _blockchainService.GetChainAsync();
                    if (currentChain.LastIrreversibleBlockHeight < blockIndex.BlockHeight)
                        await _blockchainService.SetIrreversibleBlockAsync(currentChain, blockIndex.BlockHeight,
                            blockIndex.BlockHash);
```
