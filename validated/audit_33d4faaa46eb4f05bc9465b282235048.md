# Audit Report

## Title
Token Dust Accumulation from Integer Division in Resource Token Distribution

## Summary
The `DistributeResourceTokensToPreviousMiners` method uses integer division to distribute resource tokens to miners on side chains, causing remainder tokens to be permanently locked in the consensus contract with no recovery mechanism. This leads to gradual token loss over time.

## Finding Description

The vulnerability exists in the resource token distribution mechanism for side chains. When the consensus contract distributes accumulated resource tokens (READ, WRITE, STORAGE, TRAFFIC) to miners during cross-chain updates, it uses integer division which truncates any remainder.

**Root Cause:**

The distribution method calculates each miner's share using integer division. [1](#0-0)  The `Div` extension method performs standard C# integer division without handling remainders. [2](#0-1) 

**Execution Path:**

1. On side chains, resource tokens accumulate in the consensus contract balance through the `DonateResourceToken` mechanism, where tokens are sent to the consensus contract address. [3](#0-2) 

2. When `UpdateInformationFromCrossChain` is invoked by the CrossChain contract, [4](#0-3)  it calls `DistributeResourceTokensToPreviousMiners`. [5](#0-4) 

3. For each resource token symbol, the balance is retrieved and divided equally among miners. [6](#0-5) 

4. Each miner receives the calculated amount via transfer. [7](#0-6) 

5. The remainder (balance % minerCount) stays locked in the consensus contract with no method to recover it.

**No Recovery Mechanism:**

This is the only location in the entire consensus contract that transfers tokens out of the contract's balance. There are no administrative functions or governance mechanisms to withdraw locked tokens. The consensus contract has no public methods for token withdrawal beyond this distribution function.

## Impact Explanation

**Direct Fund Loss:**
Resource tokens that should be distributed to miners are permanently locked in the consensus contract. The impact compounds over time because:

- Each cross-chain update leaves a remainder of up to (minerCount - 1) token units per symbol
- Multiple resource token symbols are affected simultaneously (READ, WRITE, STORAGE, TRAFFIC)
- No administrative recovery function exists
- The accumulated dust can never be reclaimed

**Quantified Impact:**
For each update cycle where `balance % minerCount != 0`, up to (minerCount - 1) token units per symbol are locked. With typical side chain configurations having 5-21 miners and frequent cross-chain updates, this accumulates to measurable amounts over time.

**Affected Parties:**
- Side chain miners receive marginally less resource token compensation than intended
- Side chain resource token economics are distorted as tokens accumulate in an inaccessible address
- The consensus contract becomes an unintended permanent token sink

**Severity:** MEDIUM - Individual losses per update are small (measured in minimum token units), but the cumulative effect is irreversible and there is no recovery mechanism. This violates the intended token distribution economics of the system.

## Likelihood Explanation

**Entry Point:**
The vulnerability is triggered through `UpdateInformationFromCrossChain`, which is called by the CrossChain system contract during normal cross-chain consensus synchronization. [8](#0-7) 

**Preconditions:**
The issue occurs whenever the consensus contract's resource token balance is not evenly divisible by the miner count. This is extremely common because:

- Resource token balances vary based on contract execution and resource consumption patterns
- Miner counts (typically 5-21) are rarely exact divisors of accumulated token amounts
- No attacker involvement is required - this happens during normal operations

**Execution Probability:**
This occurs automatically on every cross-chain update cycle on side chains where a remainder exists. Given typical token accumulation patterns and miner counts, the majority of distribution events will have at least one token symbol with a non-zero remainder.

**Probability:** HIGH - This is not an attack scenario but a systematic flaw that occurs during routine cross-chain consensus updates on all AElf side chains.

## Recommendation

Modify the `DistributeResourceTokensToPreviousMiners` method to handle remainders. Two potential solutions:

**Option 1: Distribute remainder to first miner**
After the equal distribution loop, calculate the remainder and add it to the first miner's allocation:
```csharp
var remainder = balance.Sub(amount.Mul(minerList.Count));
if (remainder > 0) {
    // Give remainder to first miner
    var firstMinerAddress = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(minerList[0].ToHex()));
    State.TokenContract.Transfer.Send(new TransferInput {
        To = firstMinerAddress,
        Amount = remainder,
        Symbol = symbol
    });
}
```

**Option 2: Round-robin distribution**
Distribute the remainder one token at a time to miners in round-robin fashion until exhausted.

Both approaches ensure complete distribution with minimal impact on fairness given the small remainder amounts.

## Proof of Concept

The existing test in `test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainConsensusInformationTest.cs` at lines 35-88 can be modified to demonstrate the vulnerability by checking the consensus contract's balance after distribution:

```csharp
[Fact]
public async Task UpdateInformationFromCrossChainTest_DustAccumulation()
{
    SetToSideChain();
    InitialContracts();
    InitialAcs3Stubs();
    var mockedCrossChain = SampleAccount.Accounts.Last();
    var mockedCrossChainStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        mockedCrossChain.KeyPair);

    var headerInformation = new AElfConsensusHeaderInformation {
        Round = new Round {
            RoundNumber = 2,
            RealTimeMinersInformation = {
                { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                { Accounts[1].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                { Accounts[2].KeyPair.PublicKey.ToHex(), new MinerInRound() }
            }
        }
    };

    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput {
        ProposerAuthorityRequired = false,
        PrivilegedProposer = Address.FromPublicKey(MissionedECKeyPairs.InitialKeyPairs.First().PublicKey)
    });
    
    await CreateAndIssueToken("READ");
    
    // Transfer amount not evenly divisible by 3 miners
    var transferAmount = 1000000001L; // Will leave remainder of 1
    await TokenStub.Transfer.SendAsync(new TransferInput {
        Symbol = "READ",
        Amount = transferAmount,
        To = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name]
    });

    await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue {
        Value = headerInformation.ToByteString()
    });

    // Check consensus contract still has remainder
    var consensusBalance = await TokenStub.GetBalance.CallAsync(new GetBalanceInput {
        Owner = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        Symbol = "READ"
    });
    
    // Should have remainder of 1 (1000000001 % 3 = 1)
    consensusBalance.Balance.ShouldBe(1L);
}
```

This test demonstrates that after distribution, the consensus contract retains the remainder (1 token unit in this case), which accumulates permanently with no recovery mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-38)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L53-53)
```csharp
        DistributeResourceTokensToPreviousMiners();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L73-81)
```csharp
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L84-94)
```csharp
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1000-1006)
```csharp
                    {
                        Context.LogDebug(() => $"Adding {amount} of {symbol}s to consensus address account.");
                        // Side Chain
                        receiver =
                            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
                        ModifyBalance(receiver, symbol, amount);
                    }
```
