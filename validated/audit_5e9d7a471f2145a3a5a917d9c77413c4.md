# Audit Report

## Title
Cross-Chain Token Property Inconsistency Allows Denial of Service on Cross-Chain Transfers

## Summary
The `CrossChainCreateToken` function fails to update critical token properties when a token already exists on the destination chain, only modifying the ExternalInfo field. An attacker can front-run legitimate cross-chain token deployments by creating tokens with mismatched properties (particularly `IssueChainId`), permanently breaking cross-chain transfer functionality for that token symbol.

## Finding Description

The vulnerability exists in `CrossChainCreateToken`'s handling of existing tokens. When a token already exists, the function only updates the ExternalInfo field: [1](#0-0) 

All critical security properties remain unchanged: **IssueChainId**, **TotalSupply**, **Decimals**, **Issuer**, and **Owner**.

The `ValidateTokenInfoExists` function explicitly validates all these properties as security-critical, confirming they must match between chains: [2](#0-1) 

**Attack Vector:**

On the main chain, anyone can create tokens by burning seed NFTs: [3](#0-2) 

The attacker can specify any `IssueChainId`: [4](#0-3) 

When `CrossChainCreateToken` is subsequently called for the same token, it finds the token exists and skips property updates: [5](#0-4) 

The `CrossChainReceiveToken` function enforces strict `IssueChainId` validation, causing all subsequent transfers to fail: [6](#0-5) 

Unlike `CrossChainReceiveToken` which implements replay protection: [7](#0-6) 

`CrossChainCreateToken` has no such mechanism to prevent multiple calls or track synchronized tokens.

## Impact Explanation

**Critical Cross-Chain Transfer Failure:**
When properties diverge between chains (especially `IssueChainId`), the protocol's cross-chain transfer mechanism becomes permanently inoperable for that token. Users cannot transfer tokens cross-chain, the token loses all cross-chain utility, and there is no recovery mechanism.

**Economic Impact:**
Token holders lose cross-chain functionality and liquidity. DApps expecting cross-chain operations fail. The cost to the attacker is one seed NFT, making this economically viable for disrupting valuable tokens.

The `Issue` function also enforces supply constraints based on the local `TotalSupply` value, which may differ from the legitimate chain: [8](#0-7) 

## Likelihood Explanation

**Public Entry Point:**
`CrossChainCreateToken` is a public function with minimal guards: [9](#0-8) 

**Economically Feasible:**
The attacker needs to burn one seed NFT to create a token with malicious properties before legitimate cross-chain synchronization occurs.

**Test Evidence:**
A test explicitly shows this behavior was intentionally changed to allow calling `CrossChainCreateToken` when the token exists: [10](#0-9) 

The test demonstrates that the function can be called multiple times for the same token, with only ExternalInfo being updated.

## Recommendation

Add validation in `CrossChainCreateToken` to verify that when a token already exists, its critical properties match the incoming token information. If properties don't match, revert the transaction. Alternatively, implement replay protection similar to `CrossChainReceiveToken` to prevent the same token from being synchronized multiple times with different properties.

Additionally, add authorization checks to prevent token creation with arbitrary `IssueChainId` values that don't match the current chain, or require tokens created via `Create()` to always use `Context.ChainId` as the `IssueChainId`.

## Proof of Concept

```csharp
// 1. Attacker burns seed NFT and creates token "ABC" on main chain with wrong IssueChainId
var maliciousCreate = new CreateInput
{
    Symbol = "ABC",
    TokenName = "Test Token",
    TotalSupply = 1000000,
    Decimals = 8,
    Issuer = attackerAddress,
    IssueChainId = sideChainId,  // Wrong! Should be MainChainId
    IsBurnable = true
};
await TokenContractStub.Create.SendAsync(maliciousCreate);

// 2. Legitimate CrossChainCreateToken is called from side chain
// It finds token exists and only updates ExternalInfo, leaving IssueChainId wrong

// 3. CrossChainReceiveToken fails with "Incorrect issue chain id."
var result = await TokenContractStub.CrossChainReceiveToken.SendWithExceptionAsync(input);
Assert.Contains("Incorrect issue chain id.", result.TransactionResult.Error);
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L54-65)
```csharp
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L76-76)
```csharp
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L163-166)
```csharp
        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L444-447)
```csharp
        var validationResult = tokenInfo.TokenName == input.TokenName &&
                               tokenInfo.IsBurnable == input.IsBurnable && tokenInfo.Decimals == input.Decimals &&
                               tokenInfo.Issuer == input.Issuer && tokenInfo.TotalSupply == input.TotalSupply &&
                               tokenInfo.IssueChainId == input.IssueChainId && tokenInfo.Owner == input.Owner;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-482)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-520)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L522-530)
```csharp
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L596-597)
```csharp
        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L608-609)
```csharp
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractCrossChainTest.cs (L328-329)
```csharp
    [Fact(Skip = "Now we allow this.")]
    public async Task SideChain_CrossChainCreateToken_WithAlreadyCreated_Test()
```
