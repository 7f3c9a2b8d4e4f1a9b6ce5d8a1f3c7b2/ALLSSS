# Audit Report

## Title
Insufficient Validation of Next Round Miner Information Allows Consensus Manipulation

## Summary
The AEDPoS consensus contract's `NextRound()` validation only checks that `InValue` fields are null and round numbers increment correctly, but fails to validate that `OutValue`, `Signature`, `PreviousInValue`, `FinalOrderOfNextRound`, and other consensus-critical fields remain in their initial state. This allows a malicious miner to pre-fill these cryptographically-derived fields with arbitrary values, breaking consensus integrity and enabling manipulation of mining schedules and block producer selection.

## Finding Description

The vulnerability exists in the validation logic executed before storing next round information. The `ValidationForNextRound()` method performs only minimal checks on the proposed next round data: [1](#0-0) 

This validation only ensures `InValue` fields are null and the round number is correct. However, the `MinerInRound` protobuf structure contains many consensus-critical fields: [2](#0-1) 

When a legitimate next round is generated, only basic fields are initialized, leaving `OutValue`, `Signature`, `PreviousInValue`, `FinalOrderOfNextRound`, etc. at their default values: [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` only performs a count-based check that is satisfied when both counts are zero (legitimate) OR equal to any positive number N (malicious): [4](#0-3) 

The processing logic directly converts and stores the input without field sanitization: [5](#0-4) 

The `ToRound()` conversion copies ALL fields from `NextRoundInput`: [6](#0-5) 

Finally, `AddRoundInformation()` stores the round directly to state without sanitization: [7](#0-6) 

**Attack Flow:**
1. Malicious miner generates legitimate next round via `GetConsensusExtraDataForNextRound()`
2. Modifies the Round structure to pre-fill `OutValue`, `Signature`, `FinalOrderOfNextRound`, `Order` for miners
3. Ensures `InValue` remains null for all miners and counts match
4. Creates `NextRoundInput` from manipulated Round
5. Produces block with `NextRound()` transaction containing manipulated data
6. Validation passes all checks (InValue null, round number correct, counts equal)
7. Manipulated round is stored in state and becomes canonical

## Impact Explanation

**Consensus Integrity Violation:**

The `Signature` field is cryptographically derived and used to calculate new signatures. The `CalculateSignature()` method XORs input values with all miners' signatures: [8](#0-7) 

Pre-filled `Signature` values break the cryptographic chain when `CalculateSignature()` is called on the stored round in subsequent operations like `SupplyCurrentRoundInformation()`: [9](#0-8) 

**Extra Block Producer Manipulation:**

The extra block producer selection uses signatures from the stored round: [10](#0-9) 

Pre-filled `Signature` values in a manipulated round directly influence which miner becomes the extra block producer in subsequent rounds.

**Mining Schedule Manipulation:**

The `Order` field determines `ExpectedMiningTime`, which is validated by `TimeSlotValidationProvider`: [11](#0-10) 

By pre-filling arbitrary `Order` values, an attacker manipulates when miners are allowed to produce blocks, disrupting the intended mining schedule.

**Protocol-Wide Impact:**

The manipulated round becomes canonical state through the validation flow that calls `ValidateBeforeExecution`: [12](#0-11) 

All nodes accept blocks containing the corrupted consensus data, making it the canonical state used for all subsequent consensus decisions, LIB calculations, and reward distributions.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in current or previous round (verified by `PreCheck()`): [13](#0-12) 

- Must be able to produce a block (typically the extra block producer for NextRound transitions)
- No additional privileges beyond standard miner role

**Attack Feasibility:**

The validation checks are in `ValidateBeforeExecution`, which adds both providers for NextRound behavior: [14](#0-13) 

The attack is straightforward:
1. Generate legitimate next round data
2. Modify the Round structure to pre-fill consensus fields
3. Ensure `InValue=null` and `count(FinalOrderOfNextRound>0) == count(OutValue!=null)` to satisfy validation
4. Submit via `NextRound()` transaction in produced block

The validation logic is deterministic and can be analyzed from the open-source code. The bypass technique requires only ensuring counts match while pre-filling fields.

**Probability Assessment:** HIGH - Any miner producing a NextRound block can execute this attack with standard miner capabilities and no complex preconditions.

## Recommendation

Add comprehensive field validation in `ValidationForNextRound()` to ensure all consensus-critical fields are in their expected initial state:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // Check all InValue fields are null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information - InValue must be null." };
    
    // ADD: Validate all consensus-critical fields are in initial state
    foreach (var miner in extraData.Round.RealTimeMinersInformation.Values)
    {
        if (miner.OutValue != null)
            return new ValidationResult { Message = "OutValue must be null in next round." };
        if (miner.Signature != null)
            return new ValidationResult { Message = "Signature must be null in next round." };
        if (miner.PreviousInValue != null)
            return new ValidationResult { Message = "PreviousInValue must be null in next round." };
        if (miner.FinalOrderOfNextRound != 0)
            return new ValidationResult { Message = "FinalOrderOfNextRound must be 0 in next round." };
        if (miner.SupposedOrderOfNextRound != 0)
            return new ValidationResult { Message = "SupposedOrderOfNextRound must be 0 in next round." };
        if (miner.ActualMiningTimes.Any())
            return new ValidationResult { Message = "ActualMiningTimes must be empty in next round." };
        if (miner.ImpliedIrreversibleBlockHeight != 0)
            return new ValidationResult { Message = "ImpliedIrreversibleBlockHeight must be 0 in next round." };
    }
    
    return new ValidationResult { Success = true };
}
```

Additionally, update `NextRoundMiningOrderValidationProvider` to explicitly check that both counts are zero:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    
    var finalOrderCount = providedRound.RealTimeMinersInformation.Values.Count(m => m.FinalOrderOfNextRound > 0);
    var outValueCount = providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null);
    
    // For NextRound behavior, both should be zero
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextRound)
    {
        if (finalOrderCount != 0 || outValueCount != 0)
        {
            validationResult.Message = "Next round must have no FinalOrderOfNextRound or OutValue set.";
            return validationResult;
        }
    }
    else if (finalOrderCount != outValueCount)
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

The vulnerability can be demonstrated by creating a test that:
1. Sets up a consensus round with active miners
2. Has a miner generate legitimate next round data via `GetConsensusExtraDataForNextRound()`
3. Modifies the returned Round to pre-fill `OutValue`, `Signature`, and other fields with arbitrary values while keeping `InValue=null`
4. Creates a `NextRoundInput` from the manipulated Round with matching counts
5. Calls `NextRound()` with the manipulated input
6. Verifies that validation passes and the manipulated data is stored in state
7. Demonstrates that subsequent consensus operations (`CalculateSignature()`, `CalculateNextExtraBlockProducerOrder()`) use the corrupted values

The test would confirm that the validation logic only checks `InValue=null` and count equality, allowing arbitrary values in other consensus-critical fields to bypass validation and corrupt the stored consensus state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L99-124)
```csharp
    /// <summary>
    ///     Will force to generate a `Change` to tx executing result.
    /// </summary>
    /// <param name="round"></param>
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-221)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
