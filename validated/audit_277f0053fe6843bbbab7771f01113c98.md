# Audit Report

## Title
Miner Subset Exclusion Attack via Unvalidated ProvidedRound Miner List in NextRound Transitions

## Summary
The NextRound consensus transition validation fails to verify that the `ProvidedRound` contains all miners from the current `BaseRound`. A malicious miner can submit a `NextRoundInput` with an incomplete miner list, pass all validations, and commit corrupted consensus state that excludes legitimate miners from participation and rewards.

## Finding Description

The vulnerability exists in the validation logic for NextRound consensus transitions. The validation system uses five validators for NextRound behavior, but NONE of them verify that the provided round contains all miners from the base round. [1](#0-0) 

This validator only performs internal consistency checks within `ProvidedRound` - comparing miners with `FinalOrderOfNextRound > 0` against those with `OutValue != null`. Both counts come from the SAME `ProvidedRound.RealTimeMinersInformation` collection with no comparison against `BaseRound`.

The complete set of validators for NextRound behavior is instantiated here: [2](#0-1) 

The `MiningPermissionValidationProvider` only validates the sender exists in BaseRound: [3](#0-2) 

The `ProvidedRound` comes from the consensus header extra data submitted by the block producer: [4](#0-3) 

After validation passes, `ProcessNextRound` commits the input directly to state: [5](#0-4) 

The `ToRound()` conversion preserves whatever miners exist in the input: [6](#0-5) 

The legitimate `GenerateNextRoundInformation` method preserves all miners: [7](#0-6) 

However, a malicious miner can bypass this by manually crafting a reduced `NextRoundInput`. The entry point is publicly accessible: [8](#0-7) 

The legitimate generation is used when calling `GetConsensusExtraData`: [9](#0-8) 

But a miner can call this, then manually modify the returned data to remove miners before including it in their block and transaction.

## Impact Explanation

**Consensus Integrity Compromise**: An attacker can arbitrarily reduce the active consensus set from N to M miners (M < N), directly violating the miner schedule integrity invariant that all elected miners should participate in consensus.

**Reward Misallocation**: Excluded miners lose 100% of their mining rewards for all rounds until an honest miner produces the next NextRound block and restores the full miner list. In a 7-miner network where 2 miners are excluded, each remaining miner receives a 40% increase in rewards at the expense of the victims.

**Security Degradation**: Reducing the active miner set decreases Byzantine fault tolerance. A network that can normally tolerate 2 malicious miners (2/7 < 33%) becomes vulnerable when reduced to 5 miners, where 2 malicious miners represent 40% of the set.

**Operational Denial-of-Service**: Excluded miners cannot produce blocks despite being validly elected, creating a protocol-level DoS condition that persists across multiple rounds.

## Likelihood Explanation

**Reachable Entry Point**: The vulnerability is directly reachable via the public `NextRound` method that any active miner can call when producing their designated block.

**Minimal Attacker Capabilities**: The attacker only needs to:
1. Be an active miner with normal block production rights
2. Wait for their turn to produce a NextRound transition block
3. Call `GetConsensusExtraData` to generate legitimate round data
4. Manually remove target miners from `RealTimeMinersInformation`
5. Submit both block header and transaction with the modified data

**No Special Privileges Required**: The attack uses normal miner permissions without requiring governance control, election manipulation, or system contract compromise. The validation logic provides no defense.

**Attack Complexity**: LOW - The attacker can ensure internal consistency is maintained (removed miners have consistent `FinalOrderOfNextRound` and `OutValue` fields set to appropriate values) while excluding targets.

**Economic Rationality**: HIGH - Colluding miners gain 20-40% reward increases by excluding competitors, with minimal cost (one block production opportunity). The incentive is particularly strong during high-reward periods.

## Recommendation

Add a validation provider that explicitly checks miner list completeness against the base round:

```csharp
public class MinerListCompletenessValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        
        // Skip if this is a term change (miner list may legitimately change)
        if (providedRound.TermNumber != baseRound.TermNumber)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        // Verify all miners from base round are present in provided round
        foreach (var minerPubkey in baseRound.RealTimeMinersInformation.Keys)
        {
            if (!providedRound.RealTimeMinersInformation.ContainsKey(minerPubkey))
            {
                validationResult.Message = $"Miner {minerPubkey} from base round is missing in provided round.";
                return validationResult;
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Then add this validator to the NextRound validation chain in `AEDPoSContract_Validation.cs` at line 86, right after `MiningPermissionValidationProvider`.

## Proof of Concept

```csharp
[Fact]
public async Task MinerSubsetExclusionAttack_Test()
{
    // Setup: Initialize consensus with 7 miners
    var initialMiners = GenerateInitialMiners(7);
    await InitializeConsensus(initialMiners);
    
    // Progress to round 2 where NextRound can be called
    await ProduceBlocks(initialMiners, 1);
    
    // Attacker is miner[0], victims are miner[5] and miner[6]
    var attacker = initialMiners[0];
    var victim1 = initialMiners[5];
    var victim2 = initialMiners[6];
    
    // Attacker waits for their turn to produce NextRound block
    await AdvanceToNextRoundSlot(attacker);
    
    // Attacker generates legitimate next round data
    var legitimateExtraData = await GetConsensusExtraData(attacker);
    var legitimateNextRound = ParseNextRoundFromExtraData(legitimateExtraData);
    
    // Verify legitimate round has all 7 miners
    legitimateNextRound.RealTimeMinersInformation.Count.ShouldBe(7);
    
    // Attacker manually crafts malicious input by removing 2 miners
    var maliciousNextRound = legitimateNextRound.Clone();
    maliciousNextRound.RealTimeMinersInformation.Remove(victim1.PublicKey.ToHex());
    maliciousNextRound.RealTimeMinersInformation.Remove(victim2.PublicKey.ToHex());
    
    // Attacker submits malicious NextRound transaction
    var result = await ConsensusContract.NextRound.SendAsync(
        NextRoundInput.Create(maliciousNextRound, GenerateRandomNumber()));
    
    // Transaction succeeds (THIS IS THE VULNERABILITY)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify corrupted state: only 5 miners in new round
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation.Count.ShouldBe(5);
    currentRound.RealTimeMinersInformation.ContainsKey(victim1.PublicKey.ToHex()).ShouldBeFalse();
    currentRound.RealTimeMinersInformation.ContainsKey(victim2.PublicKey.ToHex()).ShouldBeFalse();
    
    // Victims cannot produce blocks
    await AdvanceToSlot(victim1);
    var victimResult = await ConsensusContract.UpdateValue.SendAsync(
        GenerateUpdateValueInput(victim1));
    victimResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    victimResult.TransactionResult.Error.ShouldContain("not a miner");
}
```

## Notes

This vulnerability breaks the fundamental consensus invariant that all elected miners must participate in the consensus process. The attack is economically incentivized because colluding miners directly profit from excluding competitors. The missing validation represents a critical gap in the consensus security model that should be addressed immediately.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L23-27)
```csharp

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
