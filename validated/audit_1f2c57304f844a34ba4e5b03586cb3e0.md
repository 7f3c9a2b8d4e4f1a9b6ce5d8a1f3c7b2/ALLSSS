# Audit Report

## Title
Retroactive Threshold Changes Enable Governance Denial-of-Service Attack

## Summary
The `ChangeOrganizationThreshold()` function in Association, Parliament, and Referendum contracts allows modification of voting thresholds that retroactively affect all existing active proposals. This enables governance denial-of-service attacks where malicious actors can create proposals to raise thresholds, rendering previously qualifying proposals permanently unreleasable.

## Finding Description

**Root Cause:**

Proposals do not store threshold values at creation time. The `ProposalInfo` structure only stores metadata without any threshold fields. [1](#0-0) 

When `Release()` is invoked, it dynamically fetches the current organization state and evaluates thresholds at release time rather than at proposal creation time. [2](#0-1) 

The `IsReleaseThresholdReached()` function reads threshold values from the organization's current state, making the check dependent on real-time configuration. [3](#0-2) [4](#0-3) 

**Why Protections Fail:**

The `ChangeOrganizationThreshold()` function modifies thresholds in-place without checking impact on existing proposals. [5](#0-4) 

Validation only verifies structural correctness (positive numbers, mathematical relationships) but does not assess impact on pending proposals. [6](#0-5) 

Parliament and Referendum contracts exhibit identical vulnerable patterns. [7](#0-6) [8](#0-7) 

**Attack Execution:**

1. An organization operates with defined thresholds (e.g., MinimalApprovalThreshold = 10,000)
2. Legitimate Proposal A is created and gathers sufficient approvals (e.g., 10,500), meeting release requirements
3. Attacker (with proposer whitelist membership) creates Proposal B calling `ChangeOrganizationThreshold` with drastically increased thresholds (e.g., MinimalApprovalThreshold = 1,000,000)
4. Proposal B is approved under current thresholds and released
5. Upon release, Proposal B executes via virtual inline call as the organization, raising thresholds [9](#0-8) 
6. Proposal A can no longer be released despite having gathered sufficient votes under original thresholds

**Proof from Test Suite:**

The existing test suite explicitly validates this retroactive behavior. After a proposal qualifies with `ToBeReleased = true`, a threshold change proposal is executed, and the test confirms the original proposal becomes `ToBeReleased = false`. [10](#0-9) 

The same pattern is confirmed in Referendum tests. [11](#0-10) 

## Impact Explanation

This vulnerability enables HIGH severity governance denial-of-service attacks:

**Direct Harms:**
- **Governance Paralysis**: Legitimate proposals that met approval requirements become permanently blocked from execution
- **Critical Operations Prevention**: Time-sensitive actions including security patches, emergency fund releases, or protocol parameter adjustments cannot be executed
- **Trust Erosion**: Violates the fundamental governance guarantee that proposals meeting threshold requirements at approval time should be releasable

**Affected Stakeholders:**
- Organization members whose approved proposals are rendered unexecutable
- Token holders who participated in voting on invalidated proposals  
- The entire protocol when critical governance decisions are prevented

**Severity Justification:**
HIGH severity is warranted because this directly compromises governance system availability—a critical protocol function. The attack demonstrates concrete, provable impact across all three governance contract implementations (Association, Parliament, Referendum).

## Likelihood Explanation

**Attacker Prerequisites:**
1. Membership in organization's proposer whitelist (standard requirement for organizational members)
2. Sufficient voting power to approve ONE threshold-changing proposal under existing requirements
3. Understanding of standard proposal creation and approval workflows

**Attack Complexity: LOW**
- Leverages only standard proposal submission mechanisms
- Requires no specialized technical expertise
- Single malicious proposal execution achieves the attack objective

**Practical Feasibility:**
- Voting power can be accumulated gradually or through member collusion
- Low voter participation periods make proposal approval easier
- Economic incentive exists when blocking competing proposals provides strategic advantage

**Detection Challenges:**
- Malicious threshold modifications are indistinguishable from legitimate governance parameter adjustments
- Impact is immediate and irreversible upon execution
- No built-in time-lock or warning mechanisms for threshold changes

**Overall Assessment: MEDIUM to HIGH Probability**
Given that proposer rights are naturally held by organization members and threshold changes represent legitimate governance functions, this attack vector is practically feasible.

## Recommendation

Implement proposal threshold snapshotting to preserve approval requirements from creation time:

**Solution 1: Store Thresholds in ProposalInfo**
- Capture `ProposalReleaseThreshold` values when proposals are created
- Evaluate release eligibility against creation-time thresholds, not current thresholds
- Ensures proposals are judged by the rules under which votes were gathered

**Solution 2: Threshold Change Time-Lock**
- Implement mandatory delay period (e.g., 7 days) between threshold modification approval and application
- Allows proposal creators to release qualifying proposals before threshold changes take effect
- Add events warning of pending threshold modifications

**Solution 3: Grandfather Existing Proposals**
- Mark all existing proposals as "legacy" when threshold changes occur
- Apply new thresholds only to proposals created after the modification
- Preserves releasability of proposals approved under original requirements

## Proof of Concept

The vulnerability is demonstrated by the existing test case `Change_OrganizationThreshold_Test`:

1. Create organization with MinimalVoteThreshold = 1
2. Create and approve Proposal A → verify `ToBeReleased = true`
3. Create Proposal B to change MinimalVoteThreshold to 2
4. Approve and release Proposal B
5. Check Proposal A → verify `ToBeReleased = false` (retroactive invalidation)

This test explicitly validates that threshold changes retroactively affect existing proposals, confirming the vulnerability mechanism.

## Notes

This vulnerability represents an **intentional design choice** that creates an exploitable security weakness. While all three governance contracts consistently implement this behavior and test cases validate it, the retroactive threshold application introduces a governance attack surface that enables denial-of-service against legitimate proposals. The security impact stems from the lack of safeguards (time-locks, proposal grandfathering, threshold snapshotting) that would prevent malicious exploitation while preserving governance flexibility.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L149-161)
```csharp
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
```

**File:** contract/AElf.Contracts.Association/Association.cs (L187-188)
```csharp
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L189-191)
```csharp
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L740-787)
```csharp
    public async Task Change_OrganizationThreshold_Test()
    {
        var minimalApproveThreshold = 1;
        var minimalVoteThreshold = 1;
        var maximalAbstentionThreshold = 1;
        var maximalRejectionThreshold = 1;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
        var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
        await ApproveAsync(Reviewer1KeyPair, proposalId);
        var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
        proposal.ToBeReleased.ShouldBeTrue();


        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 2
            };

            var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
            var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair,
                proposalReleaseThresholdInput,
                nameof(associationContractStub.ChangeOrganizationThreshold), organizationAddress);
            await ApproveAsync(Reviewer1KeyPair, changeProposalId);
            var result = await associationContractStub.Release.SendWithExceptionAsync(changeProposalId);
            result.TransactionResult.Error.ShouldContain("Invalid organization.");
        }

        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 2,
                MinimalApprovalThreshold = minimalApproveThreshold
            };

            var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
            var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair,
                proposalReleaseThresholdInput,
                nameof(associationContractStub.ChangeOrganizationThreshold), organizationAddress);
            await ApproveAsync(Reviewer1KeyPair, changeProposalId);
            var result = await associationContractStub.Release.SendAsync(changeProposalId);
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            proposal = await associationContractStub.GetProposal.CallAsync(proposalId);
            proposal.ToBeReleased.ShouldBeFalse();
        }
    }
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L710-760)
```csharp
        await ApproveAllowanceAsync(keyPair, minimalApproveThreshold, proposalId);
        await ApproveAsync(Accounts[3].KeyPair, proposalId);
        var proposal = await ReferendumContractStub.GetProposal.CallAsync(proposalId);
        proposal.ToBeReleased.ShouldBeTrue();

        // invalid sender
        {
            var ret =
                await ReferendumContractStub.ChangeOrganizationThreshold.SendWithExceptionAsync(
                    new ProposalReleaseThreshold());
            ret.TransactionResult.Error.ShouldContain("Organization not found");
        }

        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 20000
            };

            var changeProposalId = await CreateReferendumProposalAsync(DefaultSenderKeyPair,
                proposalReleaseThresholdInput,
                nameof(ReferendumContractStub.ChangeOrganizationThreshold), organizationAddress,
                ReferendumContractAddress);
            await ApproveAllowanceAsync(keyPair, minimalApproveThreshold, changeProposalId);
            await ApproveAsync(Accounts[3].KeyPair, changeProposalId);
            var referendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
            var result = await referendumContractStub.Release.SendWithExceptionAsync(changeProposalId);
            result.TransactionResult.Error.ShouldContain("Invalid organization.");
        }

        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 20000,
                MinimalApprovalThreshold = minimalApproveThreshold
            };

            ReferendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
            var changeProposalId = await CreateReferendumProposalAsync(DefaultSenderKeyPair,
                proposalReleaseThresholdInput,
                nameof(ReferendumContractStub.ChangeOrganizationThreshold), organizationAddress,
                ReferendumContractAddress);
            await ApproveAllowanceAsync(keyPair, minimalApproveThreshold, changeProposalId);
            await ApproveAsync(Accounts[3].KeyPair, changeProposalId);
            var referendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
            var result = await referendumContractStub.Release.SendAsync(changeProposalId);
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            proposal = await referendumContractStub.GetProposal.CallAsync(proposalId);
            proposal.ToBeReleased.ShouldBeFalse();
        }
```
