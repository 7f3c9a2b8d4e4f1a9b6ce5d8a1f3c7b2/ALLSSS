# Audit Report

## Title
Sponsor Can Manipulate Voting Timing Through Unrestricted Snapshot Control

## Summary
The `TakeSnapshot()` function in the Vote contract allows sponsors to take snapshots at arbitrary times without enforcing the declared `StartTimestamp` and `EndTimestamp` parameters, enabling governance manipulation through timing control and denial of expected voting periods.

## Finding Description

The Vote contract's `TakeSnapshot()` function lacks temporal validation despite storing voting period timestamps. The function only validates sponsor authorization, snapshot count limits, and sequence ordering, but completely omits time-based checks. [1](#0-0) 

During registration, the contract validates and stores `StartTimestamp` and `EndTimestamp`: [2](#0-1) [3](#0-2) 

However, these timestamps are never enforced during voting operations. The `AssertValidVoteInput` validation function checks only snapshot numbers, not time constraints: [4](#0-3) 

Test evidence confirms snapshots can be taken in rapid succession with no temporal delays: [5](#0-4) 

This creates false expectations: voters see declared voting periods but sponsors can close all snapshots immediately after registration.

## Impact Explanation

**Severity: MEDIUM** - Governance manipulation affecting voting fairness.

The vulnerability enables concrete attacks:

1. **Immediate Closure Attack**: Sponsor registers a 30-day voting period with 10 snapshots, then immediately calls `TakeSnapshot()` ten times in sequence, closing all snapshots before any voter participation.

2. **Strategic Timing Manipulation**: Sponsor monitors voting results in real-time and closes snapshots at opportune moments to achieve favorable outcomes or front-run unfavorable votes.

3. **Voter Expectation Violation**: Declared timestamps create legitimate expectations about voting duration that are systematically violated.

The Election contract usage is protected by consensus-controlled snapshot timing, but standalone Vote contract usage remains vulnerable to this manipulation. [6](#0-5) 

## Likelihood Explanation

**Likelihood: HIGH** - Trivially executable with strong incentives.

- **Attacker Profile**: Any legitimate sponsor (anyone can register voting items)
- **Attack Complexity**: Extremely low - simple loop calling `TakeSnapshot()` with sequential numbers
- **Cost**: Only gas fees
- **Benefit**: Complete control over voting timeline
- **Motivation**: Any sponsor with conflicts of interest in voting outcomes

## Recommendation

Add temporal validation to `TakeSnapshot()` to enforce the declared voting period:

```csharp
public override Empty TakeSnapshot(TakeSnapshotInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");
    
    // Add temporal validation
    Assert(Context.CurrentBlockTime >= votingItem.StartTimestamp, 
        "Voting period has not started yet.");
    Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, 
        "Voting period has already ended.");
    
    // Add minimum duration between snapshots
    var previousResult = State.VotingResults[GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber)];
    if (previousResult != null && previousResult.SnapshotStartTimestamp != null)
    {
        var minDuration = votingItem.EndTimestamp.Sub(votingItem.StartTimestamp)
            .Div(votingItem.TotalSnapshotNumber);
        Assert(Context.CurrentBlockTime >= previousResult.SnapshotStartTimestamp.Add(minDuration),
            "Minimum snapshot duration not elapsed.");
    }
    
    Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    
    // ... rest of implementation
}
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteContract_TakeSnapshot_ImmediateClosureAttack_Test()
{
    // Register voting item with 30-day period and 10 snapshots
    var startTime = TimestampHelper.GetUtcNow();
    var endTime = startTime.AddDays(30);
    var votingItem = await RegisterVotingItemAsync(
        totalSnapshotNumber: 10,
        startTimestamp: startTime,
        endTimestamp: endTime
    );

    // Attack: Immediately close all snapshots
    for (var i = 1; i <= 10; i++)
    {
        var result = await VoteContractStub.TakeSnapshot.SendAsync(
            new TakeSnapshotInput
            {
                VotingItemId = votingItem.VotingItemId,
                SnapshotNumber = i
            });
        
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }

    // Verify: All snapshots closed within seconds, denying voter participation
    var finalItem = await GetVoteItem(votingItem.VotingItemId);
    finalItem.CurrentSnapshotNumber.ShouldBe(11); // All snapshots completed
    
    // Time elapsed should be minimal (seconds), not 30 days as declared
    var timeElapsed = Context.CurrentBlockTime.Sub(startTime).Seconds;
    timeElapsed.ShouldBeLessThan(60); // Completed in under 1 minute
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L46-47)
```csharp
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L361-361)
```csharp
        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/SnapshotTests.cs (L78-101)
```csharp
    public async Task VoteContract_TakeSnapshot_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, 3);
        for (var i = 0; i < 3; i++)
        {
            var transactionResult = (await VoteContractStub.TakeSnapshot.SendAsync(
                new TakeSnapshotInput
                {
                    VotingItemId = registerItem.VotingItemId,
                    SnapshotNumber = i + 1
                })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingItem = await GetVoteItem(registerItem.VotingItemId);
            votingItem.CurrentSnapshotNumber.ShouldBe(i + 2);
            var voteResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
            {
                VotingItemId = registerItem.VotingItemId,
                SnapshotNumber = i + 2
            });
            voteResult.SnapshotNumber.ShouldBe(i + 2);
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L402-426)
```csharp
    public override Empty TakeSnapshot(TakeElectionSnapshotInput input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");

        SavePreviousTermInformation(input);

        if (State.ProfitContract.Value == null)
        {
            var profitContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            // Return if profit contract didn't deployed. (Often in test cases.)
            if (profitContractAddress == null) return new Empty();
            State.ProfitContract.Value = profitContractAddress;
        }

        // Update snapshot of corresponding voting record by the way.
        State.VoteContract.TakeSnapshot.Send(new TakeSnapshotInput
        {
            SnapshotNumber = input.TermNumber,
            VotingItemId = State.MinerElectionVotingItemId.Value
        });
```
