# Audit Report

## Title
Approval Count Race Condition: Membership Changes Can Invalidate Legitimately Approved Proposals

## Summary
The Association contract contains a critical governance vulnerability where approved proposals can become permanently un-releaseable if approving members are removed from the organization between the approval and release phases. The vulnerability stems from recounting approvals against current membership at release time rather than using membership snapshots from when votes were cast.

## Finding Description

The vulnerability exists in the approval validation logic that executes during proposal release. When members cast approval votes, their addresses are stored in the proposal's approval list [1](#0-0) . However, at release time, the system recounts these approvals by filtering them against the **current** organization membership rather than the membership at the time of voting [2](#0-1) .

The attack sequence works as follows:

1. A proposal (ProposalX) is created and gathers sufficient approvals to meet the `MinimalApprovalThreshold`
2. An attacker creates a competing proposal (ProposalY) to remove one or more of the approving members via the `RemoveMember` method [3](#0-2) 
3. ProposalY is approved and released, executing the member removal
4. When ProposalX attempts release, the threshold check at [4](#0-3)  fails because the approval recount excludes the removed member's vote

The validation logic at member removal time only verifies that thresholds remain theoretically achievable with the new member count, but does not protect existing approved proposals [5](#0-4) . This allows the organization validation to pass while existing proposals become invalid.

## Impact Explanation

This vulnerability enables **governance denial-of-service attacks** with the following impacts:

**Operational Impact:**
- Legitimately approved proposals that met all requirements can be retroactively invalidated
- Critical governance actions (security patches, emergency responses, configuration updates) can be blocked indefinitely
- Proposals cannot be "rescued" without re-adding removed members, which itself requires a new proposal

**Strategic Impact:**
- In contentious governance scenarios, competing factions can systematically block each other's proposals
- Governance deadlock becomes possible when multiple factions employ this tactic
- The attack has asymmetric effectiveness - it's easier to block proposals than to pass them

**Severity Assessment: HIGH**
While this doesn't directly result in fund loss, it breaks a critical governance invariant: that approved proposals remain approved until expiration. For organizations managing significant value or critical system parameters, the ability to block governance execution is nearly equivalent to a critical vulnerability. The severity approaches CRITICAL for organizations where timely governance execution is essential for security or operations.

## Likelihood Explanation

**Attacker Capabilities:**
The attack requires an adversary with sufficient voting power within the organization to:
1. Approve a member removal proposal
2. Execute it before the target proposal is released

This is achievable by organization insiders or coalitions, not external attackers.

**Attack Complexity: MODERATE**
- Requires coordinating two proposals (target proposal + member removal)
- Timing window exists between proposal approval and release
- The `Release` method can only be called by the original proposer [6](#0-5) , creating a predictable vulnerability window
- No special technical skills required beyond understanding the governance flow

**Feasibility:**
- **High feasibility** in organizations with active governance and competing interests
- Can occur accidentally through legitimate membership management that inadvertently invalidates pending proposals
- More probable when organizations have frequent membership changes or long proposal review periods
- **No on-chain mechanism exists to detect or prevent this scenario**

**Economic Rationality:**
- Low cost if attacker already has voting rights
- High benefit in contentious governance where blocking specific proposals has strategic value
- Particularly attractive when the cost of blocking (member removal) is lower than the cost of defeating a proposal through normal voting

## Recommendation

Implement membership snapshots at the time of proposal creation or voting:

**Option 1: Snapshot at Proposal Creation**
Store the organization's member list hash or full member list with each proposal at creation time. At release, validate approvals against this snapshot rather than current membership.

**Option 2: Snapshot at Vote Time**
Store membership context with each vote. This is more storage-intensive but provides the most accurate historical record.

**Option 3: Validation Enhancement**
Enhance the `Validate()` function in `RemoveMember`, `ChangeMember`, and `AddMember` to check if any pending proposals would become invalid due to the membership change, and reject such changes or require explicit proposal cancellation first.

**Recommended Implementation (Option 1):**
```csharp
// In ProposalInfo message, add:
OrganizationMemberList organization_member_list_snapshot = 14;

// In CreateNewProposal, capture snapshot:
proposal.OrganizationMemberListSnapshot = organization.OrganizationMemberList;

// In CheckEnoughVoteAndApprovals, use snapshot:
var approvedMemberCount = proposal.Approvals.Count(
    proposal.OrganizationMemberListSnapshot.Contains);
```

## Proof of Concept

```csharp
[Fact]
public async Task MemberRemoval_InvalidatesApprovedProposal()
{
    // Setup: Create organization with 10 members, threshold = 6
    var members = Enumerable.Range(0, 10).Select(_ => GenerateAddress()).ToList();
    var organizationAddress = await CreateOrganization(
        members, 
        minimalApprovalThreshold: 6);
    
    // Step 1: Create ProposalX with 6 approvals from members[0-5]
    var proposalX = await CreateProposal(organizationAddress);
    for (int i = 0; i < 6; i++)
    {
        await ApproveProposal(proposalX, members[i]);
    }
    
    // Verify ProposalX is releaseable
    var proposal = await GetProposal(proposalX);
    Assert.True(proposal.ToBeReleased);
    
    // Step 2: Create ProposalY to remove members[0]
    var removeMemberInput = members[0];
    var proposalY = await CreateRemoveMemberProposal(
        organizationAddress, 
        removeMemberInput);
    
    // Approve and release ProposalY (using different members)
    for (int i = 1; i < 7; i++)
    {
        await ApproveProposal(proposalY, members[i]);
    }
    await ReleaseProposal(proposalY, members[1]);
    
    // Step 3: Attempt to release ProposalX - should fail
    var result = await ReleaseProposal(proposalX, originalProposer);
    
    // Assert: ProposalX is now un-releaseable despite having had 6 approvals
    Assert.False(result.Success);
    Assert.Contains("Not approved", result.Error);
    
    // Verify approval count dropped from 6 to 5
    var updatedProposal = await GetProposal(proposalX);
    Assert.False(updatedProposal.ToBeReleased);
}
```

## Notes

**Additional Context:**

1. **Parliament Contract Comparison:** The Parliament contract exhibits similar behavior [7](#0-6) , but Parliament membership is derived from the current miner list through consensus, making strategic manipulation far more difficult.

2. **Validation Gap:** The organization validation function correctly prevents reducing membership below threshold requirements [8](#0-7) , but this only ensures *future* proposals can theoretically reach threshold, not that *existing* proposals remain valid.

3. **Design Trade-off:** The current design may have intentionally favored dynamic membership validation to ensure only current members' votes count. However, this creates the governance DoS vector described above.

4. **Workaround Limitations:** Organizations cannot easily work around this issue. Re-adding removed members requires a new proposal (creating another vulnerability window), and there's no mechanism to "freeze" membership during critical proposals.

### Citations

**File:** protobuf/association_contract.proto (L92-92)
```text
    repeated aelf.Address approvals = 8;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L72-80)
```csharp
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L186-186)
```csharp
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L188-188)
```csharp
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L83-83)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
```
