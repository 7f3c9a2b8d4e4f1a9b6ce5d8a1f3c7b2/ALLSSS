# Audit Report

## Title
Evil Miners Can Continue Operating When Valid Replacement Candidates Exist Due to Incomplete Alternative Candidate Search

## Summary
The `GetMinerReplacementInformation()` function in the Election contract only searches for alternative candidates in the previous term's election snapshot, completely ignoring currently valid candidates with active votes. During term 1 (blockchain bootstrap) or after terms with empty election results, evil miners continue operating even when legitimate voted candidates are available, violating consensus security guarantees.

## Finding Description

The vulnerability exists in the `GetMinerReplacementInformation()` method which is responsible for identifying replacement candidates when evil miners are detected during consensus operations.

**Root Cause:**

The function retrieves only the previous term's snapshot and conditionally populates alternative candidates from that snapshot. [1](#0-0) 

The critical flaw is that alternative candidates are ONLY populated if `latestSnapshot != null && latestSnapshot.ElectionResult.Any()`. [2](#0-1)  When this condition fails, the function falls back exclusively to initial miners. [3](#0-2) 

**Why Current Candidates Are Ignored:**

The contract maintains current candidate state through `State.Candidates` and `State.CandidateVotes`. [4](#0-3) 

A helper function `GetValidCandidates()` exists that correctly queries these state variables to retrieve candidates with active votes. [5](#0-4) 

However, `GetMinerReplacementInformation()` never calls `GetValidCandidates()` and never queries current candidate state, relying solely on the previous term's snapshot retrieved via `GetPreviousTermSnapshotWithNewestPubkey()`. [6](#0-5) 

**Execution Path:**

The consensus contract invokes this function during mid-term round generation when on the main chain within the same term. [7](#0-6) 

If alternative candidates are found, evil miners are replaced in the current round. [8](#0-7) 

If the returned `AlternativeCandidatePubkeys` list is empty, no replacement occurs and evil miners remain active.

**Critical Scenarios:**

1. **Term 1 (Blockchain Bootstrap):** The previous snapshot retrieval attempts to access term 0 by computing `State.CurrentTermNumber.Value.Sub(1)`. [9](#0-8) 

Since term 0 never exists (blockchain initializes at term 1 [10](#0-9) ), the snapshot is null and no election candidates are considered for replacement, even if candidates have announced and received votes during term 1.

2. **After Empty Terms:** If a term completes with no election results, the snapshot's `ElectionResult` will be empty, triggering the same failure path.

**Security Invariant Violated:**

Evil miners (those marked in `BannedPubkeyMap`) are detected automatically when consensus updates candidate information with `IsEvilNode = true`. [11](#0-10) 

The evil miners are identified by querying the `BannedPubkeyMap`. [12](#0-11) 

The protocol's security guarantee is that evil miners should be replaced when alternative candidates exist. This guarantee is broken when current valid candidates are ignored.

**Current Candidates Can Exist:**

The `AnnounceElection` function has no term restrictions and can be called at any time. [13](#0-12)  Announced candidates are immediately added to `State.Candidates` and can receive votes which update `State.CandidateVotes`, making them available in real-time but ignored by the replacement logic.

## Impact Explanation

**Consensus Integrity Compromise:**

Evil miners who should be replaced continue participating in block production with the following impacts:

- **Transaction Censorship:** Evil miners can refuse to include specific transactions, preventing legitimate operations
- **Block Withholding:** Can deliberately skip their mining slots, degrading network performance and reliability  
- **Undeserved Rewards:** Continue earning block production rewards despite malicious behavior
- **Centralization Risk:** Reduces effective validator set, increasing centralization and attack surface

**Voter Disenfranchisement:**

Token holders who voted for candidates during the current term have their votes effectively ignored. Candidates they supported who should be eligible for miner positions are never considered, undermining the election system's purpose.

**Network Security Degradation:**

The most critical impact occurs during term 1 (chain bootstrap), which is the most vulnerable period for a new blockchain. If initial miners become evil before term 2 begins, the network has no defense mechanism even when legitimate candidates are available.

## Likelihood Explanation

**High Probability for Term 1:**

- Term 1 scenario is **guaranteed** to occur during every blockchain bootstrap
- No term 0 snapshot exists by definition
- If any initial miner becomes evil in term 1, the vulnerability is triggered

**Attacker Requirements (Low Complexity):**

An attacker only needs to:
1. Become a miner (initially legitimate, or be an initial miner)
2. Exhibit malicious behavior that triggers evil node detection (miss mining time slots)
3. Time the attack when previous snapshot is null/empty

Evil detection is automatic and built into the consensus mechanism - miners missing time slots are automatically flagged without requiring governance action.

**Current Candidates Can Exist:**

Candidates can announce election at any time with no term restrictions, and voters can vote for them immediately. The contract state tracks these candidates in real-time through `State.Candidates` and `State.CandidateVotes`, making it entirely feasible for valid voted candidates to exist when the vulnerability is triggered.

**Natural Occurrence:**

This is not a complex attack requiring sophisticated manipulation - it occurs through natural consensus operations during the blockchain's most vulnerable early lifecycle phase.

## Recommendation

Modify `GetMinerReplacementInformation()` to query current candidates when the previous term snapshot is unavailable or empty. The function should:

1. First attempt to retrieve alternatives from the previous term snapshot (existing logic)
2. If alternatives are insufficient, call `GetValidCandidates()` to retrieve current candidates with active votes
3. Filter current candidates to exclude those already in the current miner list and banned pubkeys
4. Add eligible current candidates to the alternative list before falling back to initial miners

Example fix:

```csharp
// After checking latestSnapshot (around line 380)
var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
if (diff > 0)
{
    // First try current valid candidates
    var validCandidates = GetValidCandidates()
        .Where(k => !input.CurrentMinerList.Contains(k))
        .Where(k => !State.BannedPubkeyMap[k])
        .Where(k => !alternativeCandidates.Contains(k))
        .Take(diff);
    alternativeCandidates.AddRange(validCandidates);
    
    // Then fall back to initial miners if still needed
    diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
    if (diff > 0)
    {
        // Existing initial miner fallback logic
    }
}
```

## Proof of Concept

A proof of concept would demonstrate:

1. Initialize blockchain at term 1
2. Have a candidate announce election and receive votes during term 1
3. Trigger evil miner detection by having a miner miss time slots
4. Show that `GetMinerReplacementInformation()` returns empty `AlternativeCandidatePubkeys` despite the valid voted candidate existing
5. Verify evil miner continues operating in subsequent rounds

The test would call `GetMinerReplacementInformation` with the current miner list during term 1 after evil detection, confirming that valid candidates are ignored and only initial miners are considered as alternatives.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L130-134)
```csharp
    private TermSnapshot GetPreviousTermSnapshotWithNewestPubkey()
    {
        var termNumber = State.CurrentTermNumber.Value.Sub(1);
        var snapshot = State.Snapshots[termNumber];
        if (snapshot == null) return null;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L21-27)
```csharp
    public MappedState<string, CandidateVote> CandidateVotes { get; set; }

    public MappedState<string, CandidateInformation> CandidateInformationMap { get; set; }

    public Int64State CurrentTermNumber { get; set; }

    public SingletonState<PubkeyList> Candidates { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-305)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L45-45)
```csharp
        State.CurrentTermNumber.Value = 1;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```
