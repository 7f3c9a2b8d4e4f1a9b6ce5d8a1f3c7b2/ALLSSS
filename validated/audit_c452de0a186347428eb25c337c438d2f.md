# Audit Report

## Title
Continuous Blocks Validation Bypass via Manipulated Round Number in UpdateValue

## Summary
The `RecoverFromUpdateValue()` function fails to validate that `providedRound.RoundNumber` matches the current round number. A malicious block producer can exploit this by constructing a consensus header with `RoundNumber ≤ 2` while maintaining a correct `RoundIdForValidation`, thereby bypassing the `ContinuousBlocksValidationProvider` check and producing unlimited consecutive blocks.

## Finding Description

**Root Cause - Insufficient Round Validation:**

The `RecoverFromUpdateValue()` method only validates pubkey existence in both rounds without checking critical round identity fields like `RoundNumber` or `TermNumber`: [1](#0-0) 

The function merges data from the provided round into the base round without validating round consistency, allowing an attacker to supply arbitrary `RoundNumber` values.

**Validation Pipeline Vulnerability:**

During `ValidateBeforeExecution`, the consensus extra data's Round object is used to recover the base round before validation providers execute: [2](#0-1) 

The validation context uses `ProvidedRound` which references the original `ExtraData.Round` from the block header: [3](#0-2) 

The `ContinuousBlocksValidationProvider` checks `ProvidedRound.RoundNumber > 2` to skip validation during the bootstrap period: [4](#0-3) 

Since `ProvidedRound` comes directly from the attacker-controlled consensus header, a malicious miner can set `RoundNumber = 1` (or 2) to bypass this check entirely.

**Bypassing RoundId Validation:**

The `TimeSlotValidationProvider` validates that `ProvidedRound.RoundId` matches `BaseRound.RoundId`: [5](#0-4) 

However, `RoundId` is computed dynamically. When `ExpectedMiningTime` is not set for miners, it falls back to `RoundIdForValidation`: [6](#0-5) 

In simplified UpdateValue rounds created by `GetUpdateValueRound`, `ExpectedMiningTime` is not populated for miners: [7](#0-6) 

This allows an attacker to independently set both `RoundIdForValidation` (to match the current round's RoundId) and `RoundNumber` (to ≤ 2), passing the RoundId validation while bypassing the continuous blocks check.

**Lack of Structure Validation:**

The consensus extra data extraction only validates that `SenderPubkey` matches `SignerPubkey`, not the Round content: [8](#0-7) 

A miner can construct their own consensus header with their own pubkey, satisfying this check while providing manipulated Round data.

## Impact Explanation

**Consensus Integrity Violation:**

The continuous blocks mechanism exists to prevent any single miner from dominating block production. When a miner exceeds the limit, `GetConsensusCommand` forces NextRound behavior: [9](#0-8) 

By bypassing the `ContinuousBlocksValidationProvider` check, a malicious miner can:

1. **Monopolize Block Production**: Continue producing blocks indefinitely after exceeding the allowed consecutive block limit
2. **Deny Service to Honest Miners**: Prevent other miners from producing blocks and earning rewards
3. **Centralize Consensus**: Undermine the distributed nature of AEDPoS by allowing single-miner dominance
4. **Capture Mining Rewards**: Accumulate disproportionate rewards while honest miners are excluded

The system tracks consecutive blocks via `LatestPubkeyToTinyBlocksCount` and resets it after each consensus round: [10](#0-9) 

This core consensus invariant is completely bypassed by the attack.

**Severity Justification:**

High severity - directly violates fundamental consensus fairness guarantees, allowing manipulation of miner schedule integrity and centralization of block production.

## Likelihood Explanation

**Attacker Capabilities:**

The attacker must be an active miner with block production rights, which is realistic in the AEDPoS consensus system where miners are elected through the voting mechanism.

**Attack Complexity:**

The attack is straightforward to execute:

1. Miner produces blocks until `LatestPubkeyToTinyBlocksCount.BlocksCount` becomes negative
2. Instead of following the forced NextRound behavior, constructs a malicious consensus header
3. Sets `Behaviour = UpdateValue`, `RoundNumber = 1`, and `RoundIdForValidation` to the current round's RoundId
4. Sets `SenderPubkey` to their own pubkey and fills other miner data correctly
5. Signs the block with their private key
6. Submits the block - validation passes because:
   - `SenderPubkey == SignerPubkey` ✓
   - `MiningPermissionValidationProvider` passes (attacker is in miner list) ✓
   - `TimeSlotValidationProvider` passes (RoundId matches via RoundIdForValidation) ✓
   - `ContinuousBlocksValidationProvider` SKIPPED (RoundNumber ≤ 2) ✓

**Feasibility:**

While honest miners use `GetUpdateValueRound` which sets RoundNumber correctly: [11](#0-10) 

A malicious miner can construct their own `AElfConsensusHeaderInformation` with arbitrary field values before block submission, as the consensus header is part of block extra data controlled by the block producer: [12](#0-11) 

**Detection Constraints:**

The attack leaves minimal on-chain traces. `ValidateConsensusAfterExecution` doesn't detect it because `RecoverFromUpdateValue` modifies the base round object in-place and returns it, causing the hash comparison to compare the same object with itself: [13](#0-12) 

## Recommendation

Add validation in `RecoverFromUpdateValue` to ensure the provided round's `RoundNumber` and `TermNumber` match the base round:

```csharp
public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
        !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return this;
    
    // Add validation for round identity fields
    if (providedRound.RoundNumber != RoundNumber || 
        providedRound.TermNumber != TermNumber)
        return this; // Reject mismatched rounds
    
    // ... rest of the existing logic
}
```

Alternatively, modify `ContinuousBlocksValidationProvider` to use `BaseRound.RoundNumber` instead of `ProvidedRound.RoundNumber`, since the base round is fetched from trusted state.

## Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlocksBypass_WithManipulatedRoundNumber()
{
    // Setup: Miner has exceeded continuous blocks limit
    var miner = InitialCoreDataCenterKeyPairs[0];
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Force BlocksCount to negative by producing max blocks
    for (int i = 0; i < AEDPoSContractConstants.MaximumTinyBlocksCount + 1; i++)
    {
        await ProduceBlockAsync(miner);
    }
    
    // Verify limit exceeded - next block should force NextRound
    var latestCount = await AEDPoSContractStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    latestCount.BlocksCount.ShouldBeLessThan(0);
    
    // Attack: Construct malicious header with RoundNumber=1
    var maliciousRound = currentRound.Clone();
    maliciousRound.RoundNumber = 1; // Bypass check
    maliciousRound.RoundIdForValidation = currentRound.RoundId; // Pass RoundId validation
    
    var maliciousHeader = new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteString.CopyFrom(miner.PublicKey),
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        Round = maliciousRound.GetUpdateValueRound(miner.PublicKey.ToHex())
    };
    
    // Validate - should pass despite exceeding limit
    var result = await AEDPoSContractStub.ValidateConsensusBeforeExecution.CallAsync(
        new BytesValue { Value = maliciousHeader.ToByteString() });
    
    result.Success.ShouldBeTrue(); // Vulnerability: validation passes!
    
    // Miner can continue producing blocks indefinitely
}
```

## Notes

The vulnerability exploits the architectural assumption that consensus headers are generated by the honest `GetConsensusBlockExtraData` flow. However, block producers have full control over block header contents and can construct arbitrary consensus data, limited only by validation checks. Since `RecoverFromUpdateValue` doesn't validate round identity and `ContinuousBlocksValidationProvider` relies on the attacker-controlled `ProvidedRound.RoundNumber`, the continuous blocks mechanism can be completely bypassed.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-12)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-60)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-102)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L333-365)
```csharp
    /// <summary>
    ///     To prevent one miner produced too many continuous blocks.
    /// </summary>
    /// <param name="minersCountInTheory"></param>
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-33)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;
```
