# Audit Report

## Title
Division by Zero Vulnerability in Miner Increase Interval Configuration

## Summary
The `SetMinerIncreaseInterval()` function in the AEDPoS consensus contract contains insufficient input validation that allows setting `MinerIncreaseInterval` to zero. This causes division by zero exceptions in critical consensus operations, permanently breaking consensus functionality including term transitions, miner count calculations, and view methods.

## Finding Description

The vulnerability exists in the `SetMinerIncreaseInterval()` function which only validates that the new value does not exceed the current value, but fails to enforce a minimum bound greater than zero. [1](#0-0) 

The assertion at line 61 checks only `input.Value <= State.MinerIncreaseInterval.Value`, allowing `input.Value = 0` to pass when the current value is 31536000 (the default initialization value shown in the configuration).

Once set to zero, multiple critical functions perform division by `State.MinerIncreaseInterval.Value` without checking if it's zero:

**Division in GetAutoIncreasedMinersCount():** [2](#0-1) 

**Division in GetMinersCount():** [3](#0-2) 

The `.Div()` extension method provides no zero-check protection and will throw `DivideByZeroException`: [4](#0-3) 

**Failure occurs at multiple critical points:**

1. Public view method `GetMaximumMinersCount()` becomes unusable: [5](#0-4) 

2. Governance function `SetMaximumMinersCount()` fails: [6](#0-5) 

3. Term transitions fail in `UpdateMinersCountToElectionContract()`: [7](#0-6) 

4. First round initialization fails in `ProcessConsensusInformation()`: [8](#0-7) 

5. Term change processing also calls UpdateMinersCountToElectionContract(): [9](#0-8) 

**Irreversible State:** Once set to zero, the value cannot be restored because the assertion requires `input.Value <= 0`, making any positive value invalid.

## Impact Explanation

This vulnerability has **CRITICAL** operational impact:

1. **View Method DoS**: The public `GetMaximumMinersCount()` view method throws `DivideByZeroException` for any caller, preventing users and applications from querying the maximum miner count.

2. **Governance Operations Break**: The `SetMaximumMinersCount()` governance function fails when calculating miner counts, preventing legitimate governance updates to miner limits.

3. **Consensus Halts**: Term transitions in `UpdateMinersCountToElectionContract()` fail with division by zero, preventing the consensus mechanism from advancing to new terms. This effectively freezes the blockchain's consensus progression.

4. **Chain Initialization Fails**: First-round processing in `ProcessConsensusInformation()` becomes impossible, breaking new chain initialization or round transitions.

5. **Permanent State Corruption**: The vulnerability creates an irreversible state. Once `MinerIncreaseInterval` is set to zero, it cannot be increased back to any positive value due to the validation logic, requiring emergency intervention or contract upgrade.

This breaks the fundamental security guarantee that consensus operations must be able to progress normally and that governance can manage miner count configurations.

## Likelihood Explanation

The likelihood is **HIGH**:

**Entry Point**: `SetMinerIncreaseInterval()` is a public method callable by the MaximumMinersCountController, which defaults to the Parliament organization as shown in the permission check code.

**Preconditions**: 
- Requires Parliament governance approval
- This is a standard configuration change, not requiring extraordinary privileges
- Can be triggered through:
  - Accidental misconfiguration (governance members might assume 0 means "disable auto-increase")
  - Malicious governance proposal
  - Misunderstanding of parameter semantics

**Execution Complexity**: Simple - a single transaction with `input.Value = 0` passes validation and corrupts the state.

**Detection**: The issue is only detected after the transaction succeeds, when subsequent consensus operations fail with division by zero errors, making recovery difficult.

## Recommendation

Add a minimum value check in `SetMinerIncreaseInterval()` to prevent setting the interval to zero:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Alternatively, add zero-checks before all division operations involving `MinerIncreaseInterval`, though the validation fix is cleaner and prevents the invalid state entirely.

## Proof of Concept

```csharp
[Fact]
public async Task SetMinerIncreaseInterval_ToZero_CausesConsensusFailure()
{
    // Arrange: Initialize consensus with default MinerIncreaseInterval (31536000)
    var keyPair = SampleECKeyPairs.KeyPairs[0];
    var consensusStub = GetConsensusContractTester(keyPair);
    
    // Act: Parliament governance sets MinerIncreaseInterval to 0
    var result = await consensusStub.SetMinerIncreaseInterval.SendAsync(new Int64Value { Value = 0 });
    
    // Assert: Subsequent operations fail with division by zero
    // 1. GetMaximumMinersCount view method throws
    var exception1 = await Assert.ThrowsAsync<Exception>(async () =>
        await consensusStub.GetMaximumMinersCount.CallAsync(new Empty()));
    Assert.Contains("DivideByZeroException", exception1.Message);
    
    // 2. SetMaximumMinersCount governance function fails
    var exception2 = await Assert.ThrowsAsync<Exception>(async () =>
        await consensusStub.SetMaximumMinersCount.SendAsync(new Int32Value { Value = 20 }));
    Assert.Contains("DivideByZeroException", exception2.Message);
    
    // 3. Verify state is irreversible - cannot set back to positive value
    var exception3 = await Assert.ThrowsAsync<Exception>(async () =>
        await consensusStub.SetMinerIncreaseInterval.SendAsync(new Int64Value { Value = 31536000 }));
    Assert.Contains("Invalid interval", exception3.Message);
}
```

## Notes

The vulnerability is confirmed through code analysis showing:
- Missing minimum bound validation in the setter function
- Multiple division operations without zero-checks throughout consensus logic
- The SafeMath.Div() extension performs standard C# division with no protection
- Default value of 31536000 seconds (1 year) allows zero to pass validation
- Irreversibility due to the <= validation constraint once corrupted

This represents a critical flaw in consensus parameter validation that could permanently disable blockchain consensus progression through either accidental misconfiguration or malicious governance action.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L72-78)
```csharp
    public override Int32Value GetMaximumMinersCount(Empty input)
    {
        return new Int32Value
        {
            Value = Math.Min(GetAutoIncreasedMinersCount(), State.MaximumMinersCount.Value)
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-137)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-177)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

```
