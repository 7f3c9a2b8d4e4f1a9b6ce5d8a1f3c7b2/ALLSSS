# Audit Report

## Title
NFT Collection Creation Bypass Allows Non-Zero Decimals Through Direct TokenContract Call

## Summary
The NFT contract enforces `Decimals = 0` for NFT collections to guarantee indivisibility, but this invariant can be bypassed by calling `TokenContract.Create` directly with a valid SEED NFT. The TokenContract only validates that decimals are within [0, 18] for NFT collections, not that they equal zero, allowing creation of divisible NFT collections that violate the fundamental non-fungibility property.

## Finding Description

The NFT contract's `Create` method correctly hardcodes `Decimals = 0` when creating NFT collections, ensuring non-divisibility. [1](#0-0) 

However, `TokenContract.Create` is a public method that routes token creation based on symbol patterns. [2](#0-1) 

The symbol type classification is purely pattern-based - symbols ending with "-0" are classified as `SymbolType.NftCollection`. [3](#0-2)  The collection suffix is defined as "0". [4](#0-3) 

For NFT collections, `CreateNFTCollection` simply delegates to `CreateToken` without additional decimals validation. [5](#0-4) 

The `CreateToken` method validates decimals only through `AssertValidCreateInput`, which permits any value between 0 and 18 (`MaxDecimals`). [6](#0-5) [7](#0-6)  The token is then created with the user-provided decimals value without enforcement of zero for collections. [8](#0-7) 

Critically, SEED NFT validation allows `OwnedSymbol` values ending in "-0" (NFT collection format) because it only checks that the owned symbol is NOT of type `SymbolType.Nft` (individual NFT items), allowing `SymbolType.NftCollection` to pass. [9](#0-8) 

The SEED NFT validation in `CheckSeedNFT` only verifies existence, balance, symbol match, and expiration - but NOT decimals. [10](#0-9) 

**Attack Flow:**
1. Create SEED NFT (e.g., SEED-1) with `ExternalInfo["__seed_owned_symbol"] = "ABC-0"`
2. Call `TokenContract.Create` with `Symbol = "ABC-0"` and `Decimals = 8`
3. System classifies "ABC-0" as NFT collection, validates and burns SEED NFT
4. Token is created with `Decimals = 8`
5. Result: NFT collection exists with non-zero decimals, making it divisible

The design intent confirms NFT collections should have `Decimals = 0`. [11](#0-10) 

## Impact Explanation

**Protocol Invariant Violation**: NFTs are fundamentally non-fungible and indivisible tokens. The protocol enforces `Decimals = 0` to guarantee uniqueness and prevent fractional ownership. Creating NFT collections with `Decimals > 0` breaks this core invariant, allowing fractional NFT amounts (e.g., 0.5 of an NFT with `Decimals = 8` would be represented as 50,000,000 smallest units).

**Ecosystem Confusion**: dApps, wallets, and NFT marketplaces rely on the "-0" suffix pattern to identify and handle NFT collections. These divisible tokens will be incorrectly treated as proper NFTs, causing:
- Incorrect display/accounting in NFT galleries and marketplaces
- Failed assumptions in smart contracts expecting indivisible NFT units
- User deception when purchasing apparent NFTs that are actually divisible

**Operational Impact**: Once created, these malformed NFT collections can be issued and transferred in fractional amounts via standard token operations (`Issue`, `Transfer`, `TransferFrom`), violating the NFT uniqueness guarantee.

## Likelihood Explanation

**Reachable Entry Point**: `TokenContract.Create` is a public method callable by any user with a valid SEED NFT.

**Feasible Preconditions**:
- Attacker must acquire a SEED NFT for the target symbol via normal SEED NFT acquisition mechanisms
- No special privileges required beyond standard SEED NFT ownership
- SEED creation validation explicitly allows `OwnedSymbol` ending in "-0" because the check only rejects `SymbolType.Nft`, not `SymbolType.NftCollection`

**Execution Steps**:
1. Acquire/create SEED NFT with `OwnedSymbol = "ABC-0"` (passes validation)
2. Call `TokenContract.Create(Symbol="ABC-0", Decimals=8, ...)`
3. System validates SEED NFT ownership and burns it
4. Token is created with `Decimals = 8`
5. Attacker can now issue/transfer fractional amounts of the "NFT collection"

## Recommendation

Add explicit validation in `CreateToken` or `AssertValidCreateInput` to enforce `Decimals = 0` for `SymbolType.NftCollection`:

```csharp
private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
{
    Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
           && input.Symbol.Length > 0
           && input.Decimals >= 0
           && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
    
    // Add this validation
    if (symbolType == SymbolType.NftCollection)
    {
        Assert(input.Decimals == 0, "NFT collection must have Decimals = 0.");
    }
    
    CheckSymbolLength(input.Symbol, symbolType);
    if (symbolType == SymbolType.Nft) return;
    CheckTokenAndCollectionExists(input.Symbol);
    if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CreateNFTCollection_WithNonZeroDecimals_ShouldFail()
{
    // Step 1: Create SEED NFT with OwnedSymbol ending in "-0" (NFT collection format)
    var seedSymbol = "SEED-1";
    var ownedSymbol = "ATTACK-0";  // NFT collection symbol
    
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = seedSymbol,
        TokenName = "Seed NFT",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = _chainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                ["__seed_owned_symbol"] = ownedSymbol,
                ["__seed_exp_time"] = (Context.CurrentBlockTime.Seconds + 86400).ToString()
            }
        },
        Owner = DefaultAddress
    });
    
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = seedSymbol,
        Amount = 1,
        To = DefaultAddress
    });
    
    // Step 2: Call TokenContract.Create directly with non-zero decimals
    var result = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = ownedSymbol,
        TokenName = "Malicious NFT Collection",
        TotalSupply = 10000,
        Decimals = 8,  // Should be 0 for NFT collections, but validation is missing
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = _chainId,
        Owner = DefaultAddress
    });
    
    // Verify the attack succeeded - NFT collection created with non-zero decimals
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = ownedSymbol
    });
    
    // This assertion will pass, proving the vulnerability
    tokenInfo.Decimals.ShouldBe(8);  // NFT collection has non-zero decimals!
    
    // Step 3: Verify fractional amounts are possible
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = ownedSymbol,
        Amount = 50000000,  // 0.5 of the NFT with Decimals=8
        To = DefaultAddress
    });
    
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = ownedSymbol,
        Owner = DefaultAddress
    });
    
    balance.Balance.ShouldBe(50000000);  // Fractional NFT balance exists!
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L23-33)
```csharp
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L6-6)
```csharp
    public const int MaxDecimals = 18;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L22-22)
```csharp
    public const string CollectionSymbolSuffix = "0";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L37-52)
```csharp
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedOwnedSymbolExternalInfoKey,
                    out var ownedSymbol), "OwnedSymbol does not exist.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
            CheckSymbolSeed(ownedSymbol);
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/NftApplicationTests.cs (L54-61)
```csharp
    private TokenInfo NftCollection1155Info => new()
    {
        Symbol = "TP-",
        TokenName = "Trump Digital Trading Cards #1155",
        TotalSupply = TotalSupply,
        Decimals = 0,
        Issuer = Accounts[0].Address,
        IssueChainId = _chainId,
```
