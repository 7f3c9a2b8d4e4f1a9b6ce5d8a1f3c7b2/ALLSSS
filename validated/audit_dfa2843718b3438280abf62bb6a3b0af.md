# Audit Report

## Title
Secret Sharing Threshold Validation Requires 100% Participation Instead of Configured 2/3 Threshold

## Summary
The AEDPoS consensus contract implements Shamir's 2/3 threshold secret sharing for InValue recovery but incorrectly enforces 100% miner participation before attempting secret reconstruction. This defeats the fault-tolerance purpose of threshold cryptography and enables any single miner to prevent all other miners' `PreviousInValue` revelation through a zero-cost griefing attack.

## Finding Description

The vulnerability exists in the secret sharing validation logic where the system checks for complete (n-of-n) participation instead of the configured threshold (t-of-n where t=2/3).

**The Core Issue:**

The system correctly calculates the threshold as 2/3 of miners [1](#0-0) , but then incorrectly validates that ALL miners (100%) have submitted their decrypted pieces [2](#0-1)  before attempting secret reconstruction.

However, the actual secret reconstruction correctly uses the 2/3 threshold [3](#0-2) , proving that the cryptographic scheme only needs 2/3 of the shares, not all of them.

**Attack Vector:**

1. Any active miner can call the public `UpdateValue` method [4](#0-3) 

2. During secret sharing, `PerformSecretSharing` stores `DecryptedPieces` without any threshold validation [5](#0-4) 

3. The attacker simply omits their `DecryptedPieces` from the `UpdateValueInput` transaction

4. Later, when `RevealSharedInValues` attempts to reconstruct other miners' `PreviousInValue`, it fails the 100% participation check and skips revelation [6](#0-5) 

5. The system falls back to a deterministic "fake" value computed from the miner's public key and block height [7](#0-6) 

**Why This Bypasses Protections:**

- `PreviousInValue` validation explicitly allows `Hash.Empty` [8](#0-7) , so the transaction succeeds even without proper revelation

- Evil miner detection only checks `MissedTimeSlots` [9](#0-8) , not whether miners submitted `DecryptedPieces`, so the attacker faces no consequences

## Impact Explanation

**1. Defeats Threshold Cryptography Design:**
Shamir's Secret Sharing is specifically designed to reconstruct secrets when only t-of-n parties cooperate. The implementation in `SecretSharingHelper` correctly supports this [10](#0-9) , but the validation logic requires 100% participation, completely defeating the fault-tolerance benefit.

**2. Enables Griefing Attack:**
Any single malicious miner can prevent ALL other miners' `PreviousInValue` from being revealed by withholding their `DecryptedPiece`. This affects the entire miner set, not just the attacker's target. Since there's no punishment mechanism for this behavior, the attack has zero cost.

**3. Weakens Consensus Randomness:**
The commit-reveal scheme for `InValue` is critical for randomness generation. When `PreviousInValue` cannot be revealed through secret sharing, miners can selectively use the predictable deterministic fallback instead of their true `InValue`, potentially manipulating the consensus randomness generation for mining order or other purposes.

**4. Breaks Security Guarantee:**
The AEDPoS consensus design assumes that `PreviousInValue` can be recovered even if a minority of miners are uncooperative. By requiring unanimous participation, this security guarantee is violated.

**Severity: HIGH** - The vulnerability fundamentally breaks the threshold cryptography design, enables no-cost griefing attacks, and weakens the consensus randomness scheme.

## Likelihood Explanation

**Attacker Capabilities:** Any active miner in the consensus set can execute this attack through the public `UpdateValue` method. No special privileges beyond being a block producer are required.

**Attack Complexity:** Trivial - the attacker simply omits the `DecryptedPieces` field from their `UpdateValueInput` message. This is a passive attack (omission) rather than active manipulation, requiring no sophisticated techniques.

**Feasibility Conditions:**
- Attacker must be an active miner (publicly accessible role)
- No special preconditions needed
- Attack succeeds even if 99% of miners are honest (only one malicious miner needed)
- Zero economic cost to the attacker

**Detection Difficulty:** The attack is virtually indistinguishable from genuine network issues or temporary node unavailability, making it difficult to prove malicious intent versus technical difficulties.

**Probability: HIGH** - The attack is incentive-compatible for miners who want to:
1. Weaken competitors by preventing their `PreviousInValue` verification
2. Create consensus instability
3. Manipulate the randomness mechanism for favorable mining order

## Recommendation

Change the validation logic to use the configured threshold instead of requiring 100% participation:

In `AEDPoSContract_SecretSharing.cs`, change line 36 from:
```
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

To:
```
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This aligns the operational check with the cryptographic capability and the configured 2/3 threshold, restoring the intended fault-tolerance property of threshold secret sharing.

Additionally, consider:
1. Adding validation during `PerformSecretSharing` to warn if insufficient pieces are submitted
2. Implementing punishment mechanisms for miners who consistently fail to submit `DecryptedPieces`
3. Adding monitoring to detect systematic withholding patterns

## Proof of Concept

The existing test demonstrates that secret reconstruction works correctly with only the threshold (2/3) of pieces [11](#0-10) , confirming that the validation check at line 36 is unnecessarily strict and defeats the purpose of threshold cryptography.

To prove the vulnerability:

1. Set up a consensus round with N miners (e.g., 5 miners)
2. Have one malicious miner call `UpdateValue` without including `DecryptedPieces`
3. Observe that when other miners attempt to reveal `PreviousInValue` via `RevealSharedInValues`, the reconstruction fails despite having 4 out of 5 pieces (80% > 66% threshold)
4. Verify that the system falls back to the deterministic fake value instead of using the cryptographically valid 2/3 reconstruction

The discrepancy between the threshold calculation (2/3) and the validation check (100%) is directly observable in the source code and represents a clear implementation bug.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L50-50)
```csharp
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-96)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L179-181)
```csharp
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-44)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/InValueRecoveryTest.cs (L52-58)
```csharp
            if (decryptedValues.Count >= MinimumCount)
            {
                decryptResult = SecretSharingHelper.DecodeSecret(
                    decryptedValues.Values.ToList(),
                    Enumerable.Range(1, MinimumCount).ToList(), MinimumCount);
                break;
            }
```
