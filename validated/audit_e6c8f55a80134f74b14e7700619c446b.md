# Audit Report

## Title
Continuous Blocks Validation Bypass via ProvidedRound Manipulation in UpdateValue/TinyBlock Behaviors

## Summary
A malicious miner can bypass the continuous blocks validation limit by manipulating the `RoundNumber` field in the consensus header extra data to a value ≤ 2, allowing unlimited consecutive block production and violating core AEDPoS consensus fairness guarantees.

## Finding Description

The AEDPoS consensus enforces a maximum of 8 consecutive blocks per miner to ensure fair participation. However, this protection can be completely bypassed for `UpdateValue` and `TinyBlock` behaviors through manipulation of untrusted header data.

**Root Cause Analysis:**

The `ContinuousBlocksValidationProvider` conditionally applies the continuous blocks check only when `ProvidedRound.RoundNumber > 2`: [1](#0-0) 

The `ProvidedRound` comes directly from untrusted consensus header extra data provided by the block producer: [2](#0-1) 

For `UpdateValue` and `TinyBlock` behaviors, the validation pipeline excludes `RoundTerminateValidationProvider`, which would normally validate round number transitions: [3](#0-2) 

During recovery, the `BaseRound` structure only copies specific miner information fields and explicitly does NOT copy the `RoundNumber`: [4](#0-3) 

The `TimeSlotValidationProvider` validates time slots using `RoundId` (not `RoundNumber`): [5](#0-4) 

Since `RoundId` is calculated from `ExpectedMiningTime.Seconds` sum, not from `RoundNumber`: [6](#0-5) 

**Attack Execution:**

1. Malicious miner produces 8 consecutive blocks, exhausting the limit defined in: [7](#0-6) 

2. Their `LatestPubkeyToTinyBlocksCount.BlocksCount` becomes negative

3. Attacker queries current round information (e.g., Round 100) and crafts a fake `Round` structure where:
   - `RoundNumber = 2` (to bypass the check)
   - All `ExpectedMiningTime` values remain identical to the current round
   - `RoundId` remains unchanged (same sum of `ExpectedMiningTime.Seconds`)

4. During validation, `ContinuousBlocksValidationProvider` checks `ProvidedRound.RoundNumber > 2` → evaluates to `false`, skipping the entire continuous blocks validation

5. No other validator catches this discrepancy for `UpdateValue`/`TinyBlock` behaviors

6. The miner successfully produces another block, bypassing the 8-block limit

While `State.CurrentRoundNumber` has strict increment validation: [8](#0-7) 

This protection only applies to actual round transitions (`NextRound`/`NextTerm`), not to the `ProvidedRound` data used for validation decisions in `UpdateValue`/`TinyBlock` flows.

The header extraction only validates signature matching, not round structure integrity: [9](#0-8) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability fundamentally breaks the AEDPoS consensus fairness mechanism. The continuous blocks limit exists to:
- Prevent single-miner monopolization of block production
- Ensure fair reward distribution among all miners
- Maintain network decentralization
- Guarantee timely participation opportunities for all miners

By bypassing this check, a malicious miner can:

1. **Monopolize Block Production**: Produce unlimited consecutive tiny blocks, effectively controlling the chain during their time slot
2. **Exclude Honest Miners**: Prevent other miners from producing blocks and earning rewards
3. **Violate Consensus Guarantees**: Break the core AEDPoS fairness rules limiting consecutive production
4. **Reduce Decentralization**: Concentrate power in the hands of malicious actors
5. **Impact Chain Liveness**: If the malicious miner dominates, overall network health degrades

The tracking mechanism that should enforce this limit becomes ineffective: [10](#0-9) 

## Likelihood Explanation

**Probability: HIGH**

1. **Low Attack Barrier**: Any active miner can exploit this - no special permissions needed beyond normal mining rights
2. **Simple Execution**: Attack requires only:
   - Querying public round information
   - Modifying a single field in the consensus header
   - No cryptographic tricks or complex state manipulation
3. **Repeatable**: Exploitable on every block after exceeding the limit
4. **Hard to Detect**: State remains consistent (using correct `BaseRound`) while validation is bypassed
5. **No Prerequisites**: No governance votes, special setup, or complex preconditions required

## Recommendation

Add `RoundNumber` validation for `UpdateValue` and `TinyBlock` behaviors by either:

**Option 1**: Include `RoundTerminateValidationProvider` for all behaviors that modify `BaseRound`, or create a simplified round number validator that ensures `ProvidedRound.RoundNumber` matches `BaseRound.RoundNumber` for non-round-transitioning behaviors.

**Option 2**: Modify `ContinuousBlocksValidationProvider` to use `BaseRound.RoundNumber` instead of `ProvidedRound.RoundNumber` for the conditional check, since `BaseRound` comes from trusted state storage.

**Recommended Fix (Option 2 - simpler)**:
```csharp
// In ContinuousBlocksValidationProvider.cs
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // Use BaseRound.RoundNumber (from trusted state) instead of ProvidedRound.RoundNumber
    if (validationContext.BaseRound.RoundNumber > 2 && 
        validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
    {
        var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
        if (latestPubkeyToTinyBlocksCount != null &&
            latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
            latestPubkeyToTinyBlocksCount.BlocksCount < 0)
        {
            validationResult.Message = "Sender produced too many continuous blocks.";
            return validationResult;
        }
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

A complete PoC test would require the following setup and execution:

```csharp
[Fact]
public async Task ContinuousBlocksValidation_CanBeBypassed_ViaFakeRoundNumber()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeContracts();
    
    // Setup: Produce 8 consecutive blocks by the same miner (exhaust limit)
    for (int i = 0; i < 8; i++)
    {
        await ProduceBlockWithUpdateValue(miner1KeyPair);
    }
    
    // At this point, LatestPubkeyToTinyBlocksCount.BlocksCount should be negative
    var tinyBlockCount = await GetLatestPubkeyToTinyBlocksCount();
    Assert.True(tinyBlockCount.BlocksCount < 0);
    
    // Attack: Create a block with UpdateValue behavior
    // but with fake RoundNumber = 2 in consensus header extra data
    var currentRound = await GetCurrentRound();
    var fakeRound = currentRound.Clone();
    fakeRound.RoundNumber = 2; // Manipulate to bypass check
    // Keep all ExpectedMiningTime values identical so RoundId stays same
    
    // Expected: Block should be rejected due to continuous blocks limit
    // Actual: Block is accepted because validation is bypassed
    var result = await ProduceBlockWithFakeRoundNumber(miner1KeyPair, fakeRound);
    
    // Vulnerability: Block was accepted when it should have been rejected
    Assert.True(result.Success); // This proves the bypass
    
    // Verify the miner produced more than 8 consecutive blocks
    var newTinyBlockCount = await GetLatestPubkeyToTinyBlocksCount();
    Assert.True(newTinyBlockCount.BlocksCount < tinyBlockCount.BlocksCount); // Even more negative
}
```

The test demonstrates that by setting `fakeRound.RoundNumber = 2` in the consensus header extra data while keeping all other fields identical, a miner can bypass the continuous blocks validation and produce unlimited consecutive blocks, violating the 8-block limit enforced by the protocol.

## Notes

This vulnerability is particularly severe because:
1. It breaks a **fundamental consensus fairness guarantee**
2. The validation logic trusts **untrusted user-provided data** (`ProvidedRound` from header)
3. The bypass is **architectural** - the validation provider selection for `UpdateValue`/`TinyBlock` intentionally excludes round number validation
4. Detection is difficult since **chain state remains consistent** (only validation is bypassed)
5. Any active miner can exploit this **without detection** until the network notices unfair block distribution

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-47)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }

    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L13-19)
```csharp
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```
