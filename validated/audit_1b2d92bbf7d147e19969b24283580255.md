# Audit Report

## Title
Consensus Denial-of-Service via Unvalidated TuneOrderInformation Leading to GetMiningInterval Crash

## Summary
A malicious miner can inject invalid `FinalOrderOfNextRound` values through the unvalidated `TuneOrderInformation` field in `UpdateValueInput`, creating a corrupted round where no miners have Order 1 or 2. This causes `GetMiningInterval()` to crash with an `IndexOutOfRangeException` when any miner attempts to retrieve consensus commands, permanently halting block production until manual chain intervention.

## Finding Description

The AEDPoS consensus system fails to validate that `TuneOrderInformation` values maintain the critical invariant that miner Order values must form a complete sequence [1, 2, ..., N]. This allows a malicious miner to corrupt round state, breaking the core assumption in `GetMiningInterval()` that Order 1 and 2 always exist.

**Root Cause 1: Unvalidated TuneOrderInformation Application**

In `ProcessUpdateValue`, the `TuneOrderInformation` dictionary is directly applied to miners' `FinalOrderOfNextRound` without any validation: [1](#0-0) 

This allows arbitrary Order values to be set, including mappings like {Miner1→3, Miner2→4, Miner3→5, Miner4→6} that exclude Orders 1 and 2.

**Root Cause 2: GetMiningInterval Assumes Order 1 and 2 Exist**

The `GetMiningInterval()` method filters miners by Order 1 or 2 and unconditionally accesses the second element: [2](#0-1) 

If no miners have Order 1 or 2, `firstTwoMiners` has fewer than 2 elements, and accessing `firstTwoMiners[1]` throws `IndexOutOfRangeException`.

**Root Cause 3: GenerateNextRoundInformation Uses Corrupted Values**

When transitioning to the next round, `FinalOrderOfNextRound` becomes the `Order` field directly: [3](#0-2) 

Invalid `FinalOrderOfNextRound` values propagate to become invalid Order values in the new round state.

**Root Cause 4: Validation Gaps**

The existing validators fail to catch this attack:

**NextRoundMiningOrderValidationProvider** only validates count equality, not actual order values: [4](#0-3) 

This passes as long as the number of distinct `FinalOrderOfNextRound > 0` equals miners who produced blocks, regardless of whether those orders are [1,2,3,4] or [3,4,5,6].

**CheckRoundTimeSlots** only validates time intervals, not order sequence: [5](#0-4) 

It sorts miners by Order but never verifies that Order values are sequential starting from 1.

**UpdateValueValidationProvider** doesn't validate `TuneOrderInformation` at all: [6](#0-5) 

**Attack Execution Path:**

1. Malicious miner produces UpdateValue block with crafted `TuneOrderInformation = {Miner1→3, Miner2→4, Miner3→5, Miner4→6}`
2. `ProcessUpdateValue` applies these values without validation
3. Current round state corrupted with invalid `FinalOrderOfNextRound` values
4. Next miner transitions to NextRound
5. `GenerateNextRoundInformation` creates round with Order values [3,4,5,6]
6. New round passes `CheckRoundTimeSlots` (time intervals still valid) and `NextRoundMiningOrderValidationProvider` (count matches)
7. Corrupted round stored in state
8. Any miner calls `GetConsensusCommand` to produce next block
9. `CommandStrategyBase` property `MiningInterval` triggers `GetMiningInterval()`: [7](#0-6) 

10. Exception thrown - no miners have Order 1 or 2
11. All miners unable to produce blocks - consensus halted

## Impact Explanation

**Severity: HIGH** - Complete Consensus Denial-of-Service

This vulnerability causes catastrophic operational failure:

- **Total Block Production Halt**: All miners crash when attempting to retrieve consensus commands, stopping block production entirely
- **Network-Wide Impact**: Affects every node in the network, not isolated to individual miners
- **Persistent Failure**: Corrupted round remains in state; automatic recovery is impossible
- **Manual Intervention Required**: Chain operators must manually fork or patch the consensus contract to restore functionality
- **State Integrity Violation**: Breaks the fundamental consensus invariant that miner Order values must be [1, N]

While no funds are directly stolen, this represents a complete breakdown of the blockchain's operational integrity - the most severe availability impact possible in a consensus system.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH** - Single Malicious Miner Can Execute

The attack has low barriers to execution:

**Attacker Requirements:**
- Must be an authorized miner in current round (passes PreCheck): [8](#0-7) 

- Can produce valid blocks with consensus transactions

**Attack Simplicity:**
- Single `UpdateValue` transaction with malicious `TuneOrderInformation` field
- No complex timing requirements or race conditions
- Deterministic and immediately effective
- No economic cost beyond normal block production

**Realistic Scenarios:**
- Compromised miner node
- Malicious election winner
- Insider threat from mining pool operator

**Detection Difficulty:**
- Malicious `TuneOrderInformation` appears legitimate until next round activates
- No warning or alert mechanisms before consensus breaks
- Root cause analysis requires deep inspection of round state

Given that miners rotate regularly through election and any single miner can execute this attack with one transaction, the probability is substantial in adversarial scenarios.

## Recommendation

Add validation in `ProcessUpdateValue` to ensure `TuneOrderInformation` values form a valid sequential range [1, N]:

```csharp
// Validate TuneOrderInformation before applying
if (updateValueInput.TuneOrderInformation.Any())
{
    var ordersToSet = updateValueInput.TuneOrderInformation.Values.ToList();
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Check all orders are in valid range [1, N]
    if (ordersToSet.Any(o => o < 1 || o > minersCount))
        Assert(false, "Invalid order value in TuneOrderInformation");
    
    // Check for duplicates
    if (ordersToSet.Distinct().Count() != ordersToSet.Count)
        Assert(false, "Duplicate order values in TuneOrderInformation");
    
    // Check that after applying, all orders [1, N] are covered
    var finalOrders = currentRound.RealTimeMinersInformation.Values
        .Select(m => updateValueInput.TuneOrderInformation.ContainsKey(m.Pubkey) 
            ? updateValueInput.TuneOrderInformation[m.Pubkey] 
            : m.FinalOrderOfNextRound)
        .Where(o => o > 0)
        .OrderBy(o => o)
        .ToList();
    
    var expectedOrders = Enumerable.Range(1, finalOrders.Count).ToList();
    if (!finalOrders.SequenceEqual(expectedOrders))
        Assert(false, "TuneOrderInformation creates invalid order sequence");
}

foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

Alternatively, add a defensive check in `GetMiningInterval()`:

```csharp
public int GetMiningInterval()
{
    if (RealTimeMinersInformation.Count == 1)
        return 4000;

    var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
        .ToList();
    
    // Defensive check
    if (firstTwoMiners.Count < 2)
        return 4000; // Fallback to default interval

    return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
        .Milliseconds());
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousTuneOrderInformation_ShouldCauseConsensusCrash()
{
    // Setup: Create a round with 4 miners
    var miners = new[] { "miner1", "miner2", "miner3", "miner4" };
    var round = GenerateTestRound(miners);
    
    // Malicious miner creates UpdateValueInput with invalid TuneOrderInformation
    // that skips orders 1 and 2, using [3,4,5,6] instead
    var maliciousInput = new UpdateValueInput
    {
        TuneOrderInformation =
        {
            { miners[0], 3 },
            { miners[1], 4 },
            { miners[2], 5 },
            { miners[3], 6 }
        },
        // ... other required fields
    };
    
    // Process the malicious update (should pass current validators)
    ProcessUpdateValue(maliciousInput);
    
    // Generate next round (FinalOrderOfNextRound becomes Order)
    var nextRound = new Round();
    round.GenerateNextRoundInformation(Context.CurrentBlockTime, BlockchainStartTimestamp, out nextRound);
    
    // Verify: Next round has invalid Order values [3,4,5,6]
    var orders = nextRound.RealTimeMinersInformation.Values.Select(m => m.Order).OrderBy(o => o).ToList();
    Assert.Equal(new[] { 3, 4, 5, 6 }, orders);
    
    // Attempt to get mining interval - should crash
    var exception = Assert.Throws<IndexOutOfRangeException>(() => 
    {
        var interval = nextRound.GetMiningInterval();
    });
    
    Assert.NotNull(exception); // Consensus is now broken
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L37-37)
```csharp
        protected int MiningInterval => CurrentRound.GetMiningInterval();
```
