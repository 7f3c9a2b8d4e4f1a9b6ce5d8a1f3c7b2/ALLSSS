# Audit Report

## Title
Authorization Bypass in CreateScheme Allows Attacker to Pollute Victim's Manager Scheme List Causing Bounded DoS

## Summary
The `CreateScheme` function in the Profit contract lacks authorization checks when setting an arbitrary address as the scheme manager. Any attacker can create schemes designating a victim as the manager without consent, polluting the victim's managing scheme list up to approximately 4000 schemes (128KB state limit), causing bounded DoS when querying `GetManagingSchemeIds`.

## Finding Description

The vulnerability exists in the `CreateScheme` function where it accepts an arbitrary `input.Manager` parameter without verifying the caller has authorization to assign that role. [1](#0-0) 

The function accepts any address from `input.Manager` and defaults to `Context.Sender` only if null. There is no assertion requiring `manager == Context.Sender`.

The scheme ID is then added to the specified manager's list without permission verification: [2](#0-1) 

The function only validates basic parameters: [3](#0-2) 

No authorization check exists on the manager field assignment, allowing arbitrary manager designation.

**Attack Execution Path:**
1. Attacker calls `CreateScheme` with `input.Manager` set to victim's address
2. Scheme is created with victim as manager without consent verification  
3. Scheme ID added to `State.ManagingSchemeIds[victim]`
4. Attacker repeats up to state size limit

**State Size Bound:** [4](#0-3) 

With 128KB limit and 32-byte Hash objects, approximately 4096 schemes maximum per manager address.

**Unbounded View Method:** [5](#0-4) 

Returns entire list without pagination, forcing clients to process up to 128KB when querying a victim's schemes.

## Impact Explanation

**Operational DoS Impact:**
- Victim's `GetManagingSchemeIds` returns up to ~4000 unwanted scheme IDs (128KB data)
- Clients/nodes processing this experience degraded performance with memory and CPU overhead
- Victim's legitimate scheme management interface polluted with attacker-created schemes
- Applications displaying scheme lists must process thousands of malicious entries

**Authorization Violation:**
- Victims become managers of schemes they never created or authorized
- Violates security invariant that users control their own manager role assignments

**Cleanup Cost:**
While victims can call `ResetManager` to remove schemes, they must:
- Call it up to 4000 times (once per malicious scheme)
- Pay transaction fees for each call (default 1 ELF per call)
- Incur significant defensive costs to restore clean state

**Severity: Medium** due to:
1. Clear authorization bypass requiring no victim consent
2. Bounded but significant DoS (128KB, ~4000 schemes)
3. Practical exploitability with reasonable cost
4. Operational degradation rather than direct fund loss

## Likelihood Explanation

**Attacker Capabilities:**
- Any address with sufficient ELF tokens for transaction fees
- No special permissions or trusted role required

**Attack Complexity:**
Simple attack requiring only repeated calls to a public method. [6](#0-5) 

Transaction fee is 10 ELF per `CreateScheme` call.

**Feasibility:**
- Maximum attack cost: ~40,000 ELF to create 4000 schemes
- Smaller-scale attacks (100-500 schemes) cost 1,000-5,000 ELF and still cause noticeable degradation
- No rate limiting or scheme creation caps per manager exist
- Economically feasible for motivated attackers (competitors, griefers)

**Detection/Mitigation:**
- Attack is publicly visible on-chain
- Victim must call `ResetManager` up to 4000 times at their own gas cost to cleanup
- No built-in protection or reversal mechanism

## Recommendation

Add an authorization check in `CreateScheme` to require that only the sender can be designated as manager, or implement explicit consent mechanism:

```csharp
public override Hash CreateScheme(CreateSchemeInput input)
{
    ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);
    
    // Add authorization check
    if (input.Manager != null)
    {
        Assert(input.Manager == Context.Sender, 
            "Cannot create scheme with a different address as manager without their consent.");
    }
    
    var manager = input.Manager ?? Context.Sender;
    // ... rest of function
}
```

Alternatively, implement a two-step process where the designated manager must explicitly accept the role before being added to their managing scheme list.

## Proof of Concept

```csharp
[Fact]
public async Task AuthorizationBypass_PollutesVictimManagerList()
{
    // Attacker creates scheme with victim as manager
    var victimAddress = Address.FromPublicKey(VictimKeyPair.PublicKey);
    var attackerStub = GetProfitContractStub(AttackerKeyPair);
    
    // Attack: Create scheme designating victim as manager
    var createResult = await attackerStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        Manager = victimAddress,  // Victim address without consent
        ProfitReceivingDuePeriodCount = 10
    });
    
    var schemeId = createResult.Output;
    
    // Verify scheme exists with victim as manager
    var scheme = await attackerStub.GetScheme.CallAsync(schemeId);
    scheme.Manager.ShouldBe(victimAddress);
    
    // Verify scheme added to victim's managing list
    var victimSchemes = await attackerStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = victimAddress });
    victimSchemes.SchemeIds.ShouldContain(schemeId);
    
    // Victim never called CreateScheme but is now manager
}
```

## Notes

The protobuf definition confirms the `manager` field is optional and user-controllable: [7](#0-6) 

This authorization bypass violates the principle that users should explicitly consent before being assigned management roles that affect their state and impose cleanup costs.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L48-59)
```csharp
        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```

**File:** protobuf/profit_contract.proto (L120-133)
```text
message CreateSchemeInput {
    // Period of profit distribution.
    int64 profit_receiving_due_period_count = 1;
    // Whether all the schemes balance will be distributed during distribution each period.
    bool is_release_all_balance_every_time_by_default = 2;
    // Delay distribute period.
    int32 delay_distribute_period_count = 3;
    // The manager of this scheme, the default is the creator.
    aelf.Address manager = 4;
    // Whether you can directly remove the beneficiary.
    bool can_remove_beneficiary_directly = 5;
    // Use to generate scheme id.
    aelf.Hash token = 6;
}
```
