# Audit Report

## Title
Infinite Loop in GenerateSymbolNumber() Due to Fixed Random Hash Causes Gas Exhaustion on Symbol Collision

## Summary
The `GenerateSymbolNumber()` function in the NFT contract contains a critical infinite loop bug that causes gas exhaustion when a symbol number collision occurs. The root cause is that `randomHash` is computed once before the do-while loop but never regenerated inside it, causing the deterministic `ConvertHashToInt64` function to return identical values on every iteration.

## Finding Description

The vulnerability exists in the NFT contract's symbol number generation logic. When creating an NFT protocol, the system generates a random numeric identifier. However, the implementation has a fatal flaw in collision handling. [1](#0-0) 

The `randomHash` is computed once before entering the do-while loop by combining random bytes from the consensus contract with the sender's address hash. [2](#0-1) 

Inside the loop, this unchanging `randomHash` is converted to a number and checked against existing symbols. The critical issue is that `randomHash` never changes between iterations. [3](#0-2) 

The `ConvertHashToInt64` method is purely deterministic - it uses BigInteger modulo arithmetic to convert a hash to a bounded integer. Given identical input parameters, it will always return the same output.

**Root Cause Analysis**: When a collision occurs (the generated number exists in `IsCreatedMap`), the while condition evaluates to true and the loop continues. However, since `randomHash` is static and `ConvertHashToInt64` is deterministic, the exact same `randomNumber` is generated on every iteration, creating an inescapable infinite loop that only terminates through gas exhaustion. [4](#0-3) 

The `IsCreatedMap` tracks which symbol numbers have been used, but there is no maximum iteration counter, no fallback mechanism, and no hash regeneration logic to escape collisions.

**Execution Path**: [5](#0-4) 

The public `Create` method (accessible to any user) calls `GetSymbol()` which invokes the vulnerable `GenerateSymbolNumber()` function. [6](#0-5) 

After generation, the number is marked as used in `IsCreatedMap`. [7](#0-6) 

The initial number length is 9 digits, providing 900 million possible values (100,000,000 to 999,999,999).

## Impact Explanation

**Operational Impact - DoS of NFT Protocol Creation**:
- Users attempting to create NFT protocols will experience complete transaction failures when symbol collisions occur
- All transaction gas is consumed but no protocol is created, resulting in direct financial loss
- The collision probability increases quadratically as more protocols are created (birthday paradox)
- With 900 million possible 9-digit values, collision probability becomes significant after ~30,000 protocols (~0.05%) and exceeds 5% after ~300,000 protocols

**Affected Parties**:
- Any user calling the public `Create` method on the mainchain
- The entire NFT ecosystem as protocol creation becomes increasingly unreliable
- Legitimate users who lose gas fees without receiving their protocol

**Severity Justification**: HIGH - This vulnerability causes guaranteed DoS with financial loss through gas exhaustion, affects core protocol functionality (NFT protocol creation), and degrades progressively over time. While no existing balances are stolen, users lose transaction fees and the protocol creation mechanism becomes unusable at scale.

## Likelihood Explanation

**Attacker Capabilities**: No special privileges required - the `Create` method is public and has no authorization checks beyond chain ID validation. Any user can trigger this code path.

**Attack Vectors**:
- **Natural occurrence**: Happens probabilistically as the protocol accumulates usage
- **Deliberate exploitation**: An attacker analyzing block heights and sender addresses could predict collisions and deliberately trigger them for specific users
- **Cost**: Only standard gas for the Create transaction

**Feasibility Analysis**:
- Occurs naturally once sufficient protocols exist to create meaningful collision probability
- No authorization gates prevent repeated creation attempts
- Random number generation depends on previous block height and sender address, which are observable on-chain
- Deterministic behavior means the same user in the same block hitting the same collision will always fail

**Probability Assessment**:
- Initially low when few protocols exist
- Increases quadratically following birthday paradox dynamics
- Becomes inevitable for some percentage of users as ecosystem scales
- No recovery mechanism exists - retrying may encounter different collisions with no guarantee of success

## Recommendation

Regenerate the random hash inside the collision loop to ensure each iteration attempts a different number:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    int attempts = 0;
    const int maxAttempts = 100; // Add safety limit
    
    do
    {
        // Generate NEW random hash on each iteration
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1).Add(attempts) // Vary by attempt
        }.ToBytesValue());
        
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(attempts) // Add entropy
        );
        
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        attempts++;
        
        // Failsafe: expand range if too many collisions
        if (attempts >= maxAttempts)
        {
            // Trigger range expansion logic or revert with clear error
            Assert(false, "Unable to generate unique symbol number after maximum attempts");
        }
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

Key improvements:
1. Regenerate `randomHash` inside the loop with additional entropy (attempt counter)
2. Add maximum iteration counter as failsafe
3. Provide clear error message if generation fails
4. Consider expanding the number range dynamically if collisions become frequent

## Proof of Concept

The following test would demonstrate the vulnerability if run against the current codebase:

```csharp
[Fact]
public async Task GenerateSymbolNumber_InfiniteLoop_OnCollision()
{
    // Setup: Create initial protocol to populate IsCreatedMap
    var createInput = new CreateInput
    {
        NftType = NFTType.Art.ToString(),
        ProtocolName = "Test Protocol",
        TotalSupply = 1000,
        BaseUri = "https://test.com/",
        IsBurnable = true
    };
    
    var result = await NFTContractStub.Create.SendAsync(createInput);
    var symbol = result.Output.Value;
    
    // Extract the numeric part and artificially populate IsCreatedMap
    // to force a collision on next generation attempt
    var numericPart = symbol.Substring(2); // Skip 2-char prefix
    var collisionNumber = long.Parse(numericPart);
    
    // Mock: Manually set IsCreatedMap to simulate collision
    // In real scenario, this happens naturally as protocols accumulate
    State.IsCreatedMap[collisionNumber] = true;
    
    // Attempt to create another protocol - should timeout with gas exhaustion
    var createInput2 = new CreateInput
    {
        NftType = NFTType.Art.ToString(),
        ProtocolName = "Test Protocol 2",
        TotalSupply = 1000,
        BaseUri = "https://test2.com/",
        IsBurnable = true
    };
    
    // This will consume all gas in infinite loop
    // Expected: Transaction fails with OutOfGas error
    var exception = await Assert.ThrowsAsync<Exception>(
        async () => await NFTContractStub.Create.SendAsync(createInput2)
    );
    
    Assert.Contains("out of gas", exception.Message.ToLower());
}
```

This test demonstrates that when `IsCreatedMap` contains the number that would be generated, the transaction enters an infinite loop and exhausts all gas without successfully creating a protocol.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-27)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-77)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L79-82)
```csharp
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-177)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L10-10)
```csharp
    public MappedState<long, bool> IsCreatedMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
