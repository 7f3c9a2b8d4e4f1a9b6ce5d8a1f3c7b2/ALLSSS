# Audit Report

## Title
Scheme Manager Can Modify Critical Parameters After User Registration, Breaking Withdrawal and Lock Period Expectations

## Summary
The TokenHolder contract's `CreateScheme` method lacks protection against repeated invocation, allowing scheme managers to overwrite critical parameters (Symbol, MinimumLockMinutes, AutoDistributeThreshold) after users have locked tokens. This creates a parameter mismatch between lock and unlock operations, causing permanent fund lockup or arbitrary lock period extensions.

## Finding Description

The `CreateScheme` method unconditionally overwrites scheme parameters without any existence check or validation. [1](#0-0) 

Each invocation creates a NEW scheme in the underlying Profit contract with a different SchemeId, and all scheme IDs are tracked in a list per manager. [2](#0-1) 

When users register via `RegisterForProfits`, tokens are locked using the CURRENT scheme parameters. [3](#0-2) 

However, when users withdraw, the contract retrieves the CURRENT scheme parameters from state, which may have been overwritten. [4](#0-3) 

MultiToken's lock/unlock operations are symbol-specific. The `Lock` method transfers tokens of a specific symbol to a virtual address [5](#0-4) , `GetLockedAmount` queries balances for a specific symbol [6](#0-5) , and `Unlock` transfers back tokens of a specific symbol [7](#0-6) .

If a manager changes the Symbol parameter from "ELF" to "BTC" after users lock ELF tokens, the withdrawal function will query and attempt to unlock "BTC" tokens, leaving the originally locked "ELF" tokens permanently inaccessible since the symbol mismatch prevents retrieval.

## Impact Explanation

**Symbol Modification Attack:** When a manager changes the Symbol parameter after users have locked tokens, the `Withdraw` function queries `GetLockedAmount` with the new symbol, returning 0 since tokens were locked under the original symbol. The unlock operation similarly fails to release the originally locked tokens because it attempts to unlock the wrong symbol. This results in permanent fund lockup with no recovery mechanism, as there is no way to reference the original lock parameters.

**MinimumLockMinutes Extension Attack:** A manager can arbitrarily extend the lock period by calling `CreateScheme` with increased `MinimumLockMinutes` values. Users who registered expecting a 1-day lock period could find their funds locked for 30 days or longer. Since this can be repeated indefinitely, it effectively enables permanent fund seizure.

**AutoDistributeThreshold Manipulation:** Modifying distribution thresholds alters profit distribution behavior for existing participants who registered under different expectations, disrupting anticipated reward flows and potentially preventing distributions altogether.

This violates the fundamental security guarantee that users control their locked tokens and can withdraw them after the agreed-upon lock period expires.

## Likelihood Explanation

**Reachable Entry Point:** `CreateScheme` is a public method with no authorization restrictions beyond `Context.Sender`, making it callable by any address that wants to become a scheme manager.

**Feasible Preconditions:** The attacker must be the scheme manager, which is simply the address that called `CreateScheme`. This is not a privileged admin role but a standard user capability available to anyone. Any scheme creator, whether malicious from inception or later compromised, can execute this attack.

**Execution Practicality:** The attack requires only two simple transactions: (1) Initial `CreateScheme` call to establish a legitimate-looking scheme and attract users, then (2) Second `CreateScheme` call with modified parameters. No complex contract interactions, timing windows, race conditions, or external dependencies are required.

**Economic Rationality:** Attack cost is minimal (two transaction gas fees), but enables trapping arbitrary amounts of user funds. A malicious scheme manager could profit by continuing to receive user contributions and profit distributions while preventing stake withdrawals, or by extorting users to return their funds off-chain.

## Recommendation

Add a state check in `CreateScheme` to prevent multiple scheme creations per manager:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager.");
    
    // ... rest of existing logic
}
```

Alternatively, implement a scheme update mechanism that:
1. Requires existing users to opt-in to parameter changes
2. Only applies new parameters to new registrations after a change
3. Preserves original lock parameters for each user's lockId

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_Twice_CausesWithdrawalFailure()
{
    // Manager creates scheme with Symbol="ELF", MinimumLockMinutes=1440
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1440
    });
    
    // User registers and locks 1000 ELF
    await TokenHolderStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = ManagerAddress,
        Amount = 1000_00000000
    });
    
    // Manager calls CreateScheme again with Symbol="BTC"
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "BTC",
        MinimumLockMinutes = 1440
    });
    
    // Advance time past lock period
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(1500));
    
    // User attempts withdrawal - should fail or return 0 due to symbol mismatch
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = UserAddress,
        Symbol = "BTC", // Now queries BTC instead of ELF
        LockId = lockId
    });
    
    Assert.Equal(0, lockedAmount.Amount); // Returns 0 because user locked ELF, not BTC
    // User's ELF tokens remain permanently locked
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-166)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-236)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-212)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-242)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```
