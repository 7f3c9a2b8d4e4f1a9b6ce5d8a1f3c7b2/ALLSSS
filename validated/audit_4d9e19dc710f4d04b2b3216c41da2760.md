# Audit Report

## Title
Banned Candidates Can Be Selected As Active Miners Through Missing Ban Validation

## Summary
The Election contract's `GetPreviousTermSnapshotWithNewestPubkey()` function replaces banned candidates with their newest pubkey without validating if the replacement is also banned. This allows banned nodes to bypass the ban mechanism and become active miners, directly violating the consensus security invariant that banned entities cannot participate in block production.

## Finding Description

This vulnerability manifests through a multi-contract flow with **three missing validation points** that compound into a complete security bypass.

**Missing Ban Check #1 - GetPreviousTermSnapshotWithNewestPubkey():**

When processing banned candidates from the previous term's election snapshot, the function retrieves their newest pubkey via `GetNewestPubkey()` but fails to validate if this replacement pubkey is also banned. [1](#0-0) 

The validation only checks if `newestPubkey == null`, `newestPubkey == bannedCandidate`, or if it already exists in the snapshot. Despite `IsPubkeyBanned()` being readily available [2](#0-1) , it is never called on the replacement pubkey before adding it to the snapshot.

**Missing Ban Check #2 - GetMinerReplacementInformation():**

Alternative candidates are selected from the snapshot without any ban validation. The code filters out initial miners and current miners but completely omits the ban check. [3](#0-2) 

This contrasts with the **inconsistent handling** of initial miner fallbacks in the same function, where ban validation IS performed: [4](#0-3) 

The fact that initial miners are checked with `!State.BannedPubkeyMap[k]` proves the ban check should also apply to alternative candidates.

**Missing Ban Check #3 - GenerateNextRoundInformation():**

The consensus contract receives alternative candidates and directly adds them to the active miner list without any validation. [5](#0-4) 

**Why Existing Protections Fail:**

When a pubkey is replaced via `ReplaceCandidatePubkey()`, the old pubkey is correctly banned [6](#0-5) , and the replacement mapping chain is established [7](#0-6) .

If the new pubkey is subsequently marked as evil via `UpdateCandidateInformation()`, it also becomes banned [8](#0-7) .

However, the replacement mapping persists unchanged. When `GetNewestPubkey()` is called [9](#0-8) , it returns the banned replacement without any awareness of the ban status.

## Impact Explanation

**Critical Consensus Integrity Violation:**

This vulnerability allows banned/evil nodes to become active miners and participate in block production, fundamentally undermining the consensus security model.

**Concrete Harms:**
- **Banned miners produce blocks:** Evil nodes marked as banned can continue mining and earning rewards
- **Security model breach:** The entire ban mechanism is rendered ineffective for replaced pubkeys  
- **Continued malicious behavior:** Nodes identified as evil can continue participating in consensus, potentially enabling censorship attacks, block withholding, or manipulation of round information
- **Economic impact:** Banned entities receive mining rewards they should not be entitled to
- **Trust violation:** The protocol's guarantee that banned entities are excluded from consensus is broken

**Severity: HIGH** - This is a direct bypass of a critical security control mechanism. The ban system exists specifically to protect consensus integrity by removing malicious actors, and this vulnerability completely undermines that protection.

## Likelihood Explanation

**Attack Requirements:**
1. Candidate announces election (public operation)
2. Candidate replaces pubkey A → B via `ReplaceCandidatePubkey` (legitimate admin operation available to all candidates)
3. Pubkey B is marked as evil through `UpdateCandidateInformation()` or `RemoveEvilNode()` (happens through normal consensus monitoring)
4. Pubkey A was in previous term's election snapshot with votes
5. Evil miner replacement occurs during consensus round generation (automatic)

**Complexity: LOW-MEDIUM**
- All operations are standard, legitimate contract calls
- No privilege escalation required beyond normal candidate operations
- No timing constraints or race conditions required
- Execution happens automatically during consensus flow

**Feasibility: HIGH**
- The scenario can occur naturally when a candidate legitimately replaces their pubkey (e.g., key rotation), and the new pubkey is later identified as evil
- It can also be deliberately orchestrated by an attacker who controls both pubkeys
- Detection is difficult as it appears as normal miner replacement

**Probability: MEDIUM-HIGH** - While requiring a specific sequence of events, all steps are routine operations that can occur naturally or be deliberately triggered. The automatic nature of consensus round generation means no additional attacker action is needed once the setup is complete.

## Recommendation

Add ban validation checks at all three points:

**Fix #1 - GetPreviousTermSnapshotWithNewestPubkey():**
```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    // Add ban check for newest pubkey
    if (newestPubkey == null || newestPubkey == bannedCandidate ||
        snapshot.ElectionResult.ContainsKey(newestPubkey) ||
        IsPubkeyBanned(newestPubkey)) continue;
    var electionResult = snapshot.ElectionResult[bannedCandidate];
    snapshot.ElectionResult.Add(newestPubkey, electionResult);
    if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
}
```

**Fix #2 - GetMinerReplacementInformation():**
```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    .Where(cs => !State.InitialMiners.Value.Value.Contains(
        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    .Where(cs => !State.BannedPubkeyMap[cs.Key]) // Add ban check
    .OrderByDescending(s => s.Value).ToList();
```

**Fix #3 - GenerateNextRoundInformation():**
```csharp
for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
{
    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
    
    // Add ban validation
    if (State.ElectionContract.IsPubkeyBanned.Call(new StringValue { Value = alternativeCandidatePubkey }))
        continue;
        
    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
    // ... rest of replacement logic
}
```

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario:

1. Initial state: Candidate with pubkey A participates in term N and receives votes
2. Candidate calls `ReplaceCandidatePubkey(A, B)` - A is banned, mapping A→B is created
3. Consensus monitoring detects evil behavior and calls `UpdateCandidateInformation(B, IsEvilNode=true)` - B is banned
4. Term N+1 begins, `GenerateNextRoundInformation()` is called automatically
5. Flow executes: `GetMinerReplacementInformation()` → `GetPreviousTermSnapshotWithNewestPubkey()` → `GetNewestPubkey(A)` returns B
6. B is added to snapshot without ban check, selected as alternative candidate without ban check, and added to active miners without ban check
7. Result: Banned pubkey B is now an active miner and can produce blocks

The vulnerability is confirmed by:
- No `IsPubkeyBanned(newestPubkey)` call exists in the codebase (verified via grep search)
- No `BannedPubkeyMap` check exists for alternative candidates (verified via grep search)
- Inconsistent validation: initial miners ARE checked for ban status, but alternative candidates from snapshot are NOT

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L149-157)
```csharp
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-338)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L288-291)
```csharp
        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```
