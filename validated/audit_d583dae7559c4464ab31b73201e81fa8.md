# Audit Report

## Title
Missing Authorization and Negative DepositBalance Corruption in TokenConverter EnableConnector

## Summary
The `EnableConnector()` function in the TokenConverter contract lacks authorization controls, allowing any user to enable connector pairs with zero deposit balance. This creates an accounting vulnerability where subsequent `Sell()` operations can drive `DepositBalance` negative, corrupting state and enabling cross-connector fund theft when multiple connector pairs share the same base token pool.

## Finding Description

The vulnerability consists of three interconnected control failures:

**1. Missing Authorization Check**

The `EnableConnector()` function has no authorization validation, unlike other connector management functions. [1](#0-0) 

Other management functions properly enforce authorization:
- `UpdateConnector()` [2](#0-1) 
- `AddPairConnector()` [3](#0-2) 
- `SetFeeRate()` [4](#0-3) 

**2. Zero-Deposit Initialization**

When `GetNeededDeposit()` returns `NeedAmount = 0`, the function sets `State.DepositBalance[toConnector.Symbol] = 0` without validation. This occurs when the contract holds sufficient resource tokens. [5](#0-4) 

**3. Unconditional DepositBalance Decrement**

The `Sell()` function decrements `DepositBalance` without checking sufficiency, allowing negative values. [6](#0-5) 

The `Sub()` operation uses checked arithmetic to prevent overflow, but signed long types can legitimately hold negative values without triggering overflow exceptions. [7](#0-6) 

**4. Negative Balance Used in Pricing**

The corrupted `DepositBalance` affects all pricing via `GetSelfBalance()`, which returns `VirtualBalance + DepositBalance` for deposit connectors. [8](#0-7) 

When `DepositBalance` is negative, `GetSelfBalance()` returns a reduced value, affecting Bancor pricing calculations until the balance becomes non-positive, at which point Bancor validation rejects trades. [9](#0-8) 

## Impact Explanation

**HIGH Severity Impact:**

1. **Cross-Connector Fund Theft**: All connector pairs share a single base token pool (defined by `State.BaseTokenSymbol`), but maintain separate `DepositBalance` accounting. [10](#0-9)  When one connector's `DepositBalance` goes negative, it effectively "borrows" base tokens that belong to other connectors' reserves, causing fund loss for legitimate users who deposited properly.

2. **Permanent State Corruption**: Once `DepositBalance` becomes negative, it remains corrupted indefinitely, affecting all future operations on that connector pair and reducing the shared base token pool available to other connectors.

3. **Pricing Corruption**: The reduced `GetSelfBalance()` creates mispriced trades until the balance becomes non-positive, at which point the connector enters a DoS state.

**Affected Parties:**
- Users of legitimately-funded connector pairs lose access to their deposited base tokens
- Protocol loses funds through mispriced swaps before DoS threshold
- New connector pairs can be griefed by enabling them with zero deposits

## Likelihood Explanation

**MEDIUM-HIGH Likelihood:**

1. **No Authorization Required**: The missing `AssertPerformedByConnectorController()` check allows any user to call `EnableConnector()`.

2. **Realistic Preconditions**: The vulnerability triggers when:
   - Multiple connector pairs exist on the same TokenConverter instance
   - The contract holds resource tokens from various sources (initial distributions, fees, other connectors)
   - Resource tokens circulate outside the TokenConverter (via direct transfers, minting, airdrops)
   - Users sell tokens they obtained outside the TokenConverter

3. **Attack Complexity**: Straightforward - wait for controller to add a new connector pair, then immediately call `EnableConnector()` with parameters yielding zero deposit.

4. **Natural Occurrence**: Can trigger non-maliciously when operators enable connectors for tokens with pre-existing circulation.

## Recommendation

Add authorization check to `EnableConnector()`:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    AssertPerformedByConnectorController(); // Add this line
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    // ... rest of function
}
```

Additionally, add validation to prevent zero deposits:

```csharp
var needDeposit = GetNeededDeposit(input);
Assert(needDeposit.NeedAmount > 0, "Cannot enable connector with zero deposit");
```

And add sufficiency check in `Sell()`:

```csharp
Assert(State.DepositBalance[toConnector.Symbol] >= amountToReceive, 
    "Insufficient deposit balance");
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario:

1. Initialize TokenConverter with connector pair A (properly funded with DepositBalance = 10,000)
2. Controller calls `AddPairConnector()` to add connector pair B
3. Ensure TokenConverter holds all of token B's supply
4. Attacker calls `EnableConnector()` for token B with `AmountToTokenConvert = 0`, resulting in `DepositBalance[B] = 0`
5. Token B is distributed to users outside TokenConverter
6. User calls `Sell()` for token B
7. `DepositBalance[B]` becomes negative
8. Contract's actual base token balance is depleted below what connector A's users are owed
9. Users of connector A cannot fully redeem their deposits

The test would verify that after step 8, `DepositBalance[A] + DepositBalance[B] < actual contract base token balance`, proving cross-connector fund theft.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-267)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
        var feeRate = AssertedDecimal(input.Value);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L15-19)
```csharp
    public StringState BaseTokenSymbol { get; set; }
    public StringState FeeRate { get; set; }
    public MappedState<string, Connector> Connectors { get; set; }
    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public MappedState<string, long> DepositBalance { get; set; }
```
