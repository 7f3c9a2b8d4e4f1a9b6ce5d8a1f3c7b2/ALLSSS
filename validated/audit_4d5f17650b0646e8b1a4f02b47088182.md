# Audit Report

## Title
Precision Loss in Individual Beneficiary Profit Claims Locks Tokens Permanently

## Summary
The Profit Contract's `SafeCalculateProfits()` function performs decimal-to-long conversion with truncation when calculating individual beneficiary shares. When multiple beneficiaries claim from the same period, the sum of their truncated claims is less than the total distributed amount, permanently locking the remainder in period-specific virtual addresses with no recovery mechanism.

## Finding Description

The root cause lies in the `SafeCalculateProfits()` function which converts long integers to decimal, performs division, and casts back to long with truncation: [1](#0-0) 

This function is used in two contexts with different security outcomes:

**1. Sub-scheme distribution (safe):** When distributing to sub-schemes via `DistributeProfitsForSubSchemes()`, the code tracks `remainAmount` after each truncated calculation: [2](#0-1) 

The remainder is then transferred to the period virtual address: [3](#0-2) 

**2. Individual beneficiary claims (vulnerable):** When beneficiaries claim their profits via `ProfitAllPeriods()`, each claim is calculated independently without any remainder tracking: [4](#0-3) 

Specifically, line 873-874 calculates the amount using the truncating function, and lines 887-895 transfer this amount from the period's virtual address to the beneficiary. There is no mechanism to aggregate claims or verify that the sum equals the distributed total.

**Why tokens become permanently locked:**

Each period has a unique virtual address generated by hashing the scheme ID and period number: [5](#0-4) 

When `DistributeProfits` is called, it creates a `DistributedProfitsInfo` containing the total amount and total shares for that period's virtual address. Each beneficiary then independently calculates their truncated share from these fixed values. Once all beneficiaries have claimed, any remainder due to truncation stays locked in the period's virtual address permanently because:

1. **No new beneficiaries can be added to past periods** - beneficiaries are added with `StartPeriod = CurrentPeriod + DelayDistributePeriodCount`: [6](#0-5) 

2. **No admin rescue function exists** - I verified all public methods in ProfitContract.cs and found no mechanism to recover funds from period virtual addresses

3. **The virtual address is derived cryptographically** with no private key

4. **Beneficiaries cannot claim multiple times** from the same period - LastProfitPeriod is updated to prevent double claims: [7](#0-6) 

## Impact Explanation

**Direct Fund Loss:**
Tokens are permanently locked and removed from circulation. For example, with 3 beneficiaries holding 1 share each (total 3 shares) claiming from a period that distributed 100 tokens:
- Each beneficiary receives: `(long)(100 * 1 / 3)` = `(long)(33.333...)` = 33 tokens
- Total claimed: 99 tokens
- **Permanently locked: 1 token in the period's virtual address**

**Systemic Scale:**
- Occurs in every distribution period where `(totalAmount * shares / totalShares)` produces a remainder
- Common scenarios: odd numbers of equal beneficiaries, any shares that don't evenly divide amounts
- Affects most profit schemes in practice
- Accumulates across hundreds of schemes over thousands of periods
- Could lock millions of tokens protocol-wide over time

**Affected Parties:**
- All beneficiaries collectively lose the locked remainder
- Protocol loses economic efficiency as tokens are removed from circulation
- Token utility degrades as supply effectively decreases

## Likelihood Explanation

**Probability: HIGH**

This vulnerability triggers automatically during normal profit distribution operations without any attacker action:

1. **Entry point:** Any beneficiary calling `ClaimProfits()` via the public method: [8](#0-7) 

2. **Mathematical certainty:** Occurs whenever shares don't evenly divide amounts, which is common in typical profit distribution scenarios

3. **No special privileges required:** All beneficiaries can claim their profits normally

4. **Frequency:** Affects every profit distribution period where division produces a non-zero remainder after truncation

## Recommendation

Implement remainder tracking in the `ProfitAllPeriods()` method similar to how `DistributeProfitsForSubSchemes()` handles it. One approach:

1. Track the total amount claimed by all beneficiaries in the `DistributedProfitsInfo` for each period
2. When the last eligible beneficiary claims, calculate the actual remainder from the period virtual address balance and transfer it to them
3. Alternatively, distribute the remainder to beneficiaries proportionally or to the first/last claimer

## Proof of Concept

The vulnerability can be demonstrated with this test scenario:

```csharp
// Setup: Create scheme with 3 beneficiaries, 1 share each
// Distribute 100 tokens in period 1
// Each beneficiary claims:
//   Beneficiary 1: SafeCalculateProfits(100, 1, 3) = (long)(33.333...) = 33
//   Beneficiary 2: SafeCalculateProfits(100, 1, 3) = (long)(33.333...) = 33
//   Beneficiary 3: SafeCalculateProfits(100, 1, 3) = (long)(33.333...) = 33
// Total claimed: 99 tokens
// Remaining in period virtual address: 1 token (permanently locked)
```

## Notes

The asymmetric behavior between sub-scheme distribution (which tracks remainder) and individual beneficiary claims (which doesn't) indicates this was likely an oversight rather than intentional design. The `SafeCalculateProfits` function itself is not flawed - it's the lack of remainder accounting in the beneficiary claim flow that creates the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-604)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L606-649)
```csharp
    private long DistributeProfitsForSubSchemes(string symbol, long totalAmount, Scheme scheme, long totalShares)
    {
        Context.LogDebug(() => $"Sub schemes count: {scheme.SubSchemes.Count}");
        var remainAmount = totalAmount;
        foreach (var subSchemeShares in scheme.SubSchemes)
        {
            Context.LogDebug(() => $"Releasing {subSchemeShares.SchemeId}");

            // General ledger of this sub profit scheme.
            var subItemVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeShares.SchemeId);

            if (State.TokenContract.Value == null)
                State.TokenContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
            if (distributeAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());

            remainAmount = remainAmount.Sub(distributeAmount);

            // Update current_period of detail of sub profit scheme.
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;

            State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;

            // Update sub scheme.
            var subScheme = State.SchemeInfos[subSchemeShares.SchemeId];
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
        }

        return remainAmount;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L750-750)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-961)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L57-59)
```csharp
    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
```
