# Audit Report

## Title
Unvalidated RevealedInValues Allow PreviousInValue Poisoning Leading to Miner DoS

## Summary
The `UpdateLatestSecretPieces()` function in the AEDPoS consensus contract accepts `RevealedInValues` from off-chain trigger information without cryptographic validation and uses them to set other miners' `PreviousInValue` state. A malicious consensus miner can inject fake revealed values to poison victim miners' `PreviousInValue`, causing their subsequent blocks to fail validation and resulting in targeted denial-of-service attacks against specific miners.

## Finding Description

The vulnerability exists in the secret sharing mechanism of the AEDPoS consensus protocol. When a miner produces a block with secret sharing enabled, they provide `AElfConsensusTriggerInformation` containing `RevealedInValues` for other miners who may have failed to mine in previous rounds.

**Root Cause - Missing Cryptographic Validation:**

The `UpdateLatestSecretPieces()` function blindly trusts `RevealedInValues` from trigger information without any cryptographic verification. It only checks that the target miner exists and their `PreviousInValue` is currently `Hash.Empty` or null: [1](#0-0) 

Compare this to the legitimate `RevealSharedInValues()` method which performs proper cryptographic reconstruction using Shamir's Secret Sharing: [2](#0-1) 

**Attack Vector - Off-Chain Control:**

The trigger information originates from the miner's off-chain node, specifically from `SecretSharingService.GetRevealedInValues()`: [3](#0-2) 

Since this is off-chain code running on the miner's own node, a malicious miner can modify the service to return arbitrary fake values: [4](#0-3) 

**Validation Gap:**

Block validation only checks the block producer's own `PreviousInValue`, NOT the revealed values for other miners. The validation uses `validationContext.SenderPubkey` which is the block producer: [5](#0-4) 

**Protection Bypass:**

Once a `PreviousInValue` is set (even to a fake value), the conditional check in `ApplyNormalConsensusData` prevents legitimate updates from overwriting it: [6](#0-5) 

**State Persistence:**

The poisoned value persists across rounds through `SupplyCurrentRoundInformation()`: [7](#0-6) 

And propagates during validation through `RecoverFromUpdateValue()`: [8](#0-7) 

**Attack Execution:**
1. Victim miner V fails to mine in Round N, leaving V's `PreviousInValue` as `Hash.Empty` for Round N+1
2. Malicious miner M modifies their off-chain node to inject `RevealedInValues[V] = FakeHash`
3. M produces a block in Round N+1 before V mines
4. `UpdateLatestSecretPieces` sets V's `PreviousInValue` to `FakeHash` without validation
5. The block passes validation (only M's own `PreviousInValue` is checked)
6. When V attempts to mine, `ApplyNormalConsensusData` doesn't overwrite the poisoned value
7. V's block fails validation: `Hash(FakeHash) â‰  V's previous OutValue`
8. V's block is rejected, V loses mining rewards

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation**

This vulnerability enables targeted denial-of-service attacks against specific consensus miners, breaking fundamental consensus guarantees:

**Consensus Integrity Impact:**
- Allows arbitrary exclusion of honest miners from block production
- Violates the Byzantine fault tolerance model by enabling undetectable censorship
- Disrupts the predictable miner schedule and consensus reliability
- Can be repeated to permanently exclude specific miners when combined with repeated attacks

**Economic Impact:**
- Victim miners lose block production rewards for rejected blocks
- Mining reputation metrics (ProducedBlocks, MissedTimeSlots) are negatively affected
- Impacts future mining slot assignments and election standings
- Provides direct economic advantage to attackers by eliminating competition

**Network Impact:**
- Reduces overall block production rate if multiple miners are targeted
- Creates uncertainty in transaction finality and throughput
- The poisoned state can persist for multiple rounds via state propagation mechanisms

The attack is particularly severe because it's undetectable from the victim's perspective (their node functions correctly but blocks are rejected) and requires no special cryptographic capabilities beyond consensus miner status.

## Likelihood Explanation

**MEDIUM Likelihood**

**Attacker Requirements:**
- Must be an authorized consensus miner (realistic in Byzantine fault tolerance threat models)
- Must modify off-chain node software to inject fake `RevealedInValues` (feasible - miners control their own nodes)
- No additional cryptographic capabilities required

**Attack Complexity:**
- LOW - Simple modification to `SecretSharingService` to return fake values
- No precise timing required beyond producing a block before the victim in the same round
- No multi-step coordination or complex setup needed

**Preconditions:**
- Secret sharing must be enabled (checked via configuration): [9](#0-8) 

- Victim must have missed mining in a previous round (COMMON due to network latency, maintenance, node restarts, or network attacks)
- Attacker must produce a block before victim in the subsequent round (probability 1/N where N = miner count)

**Economic Incentives:**
- Strong financial incentive in competitive mining scenarios to exclude rivals
- Zero cost to attacker (only software modification)
- Potential benefit: increased share of block rewards by eliminating competition

The combination of low attack complexity, common preconditions, and strong economic incentives makes this vulnerability practically exploitable.

## Recommendation

**Primary Fix - Add Cryptographic Validation:**

Modify `UpdateLatestSecretPieces()` to validate revealed values using the same cryptographic reconstruction as `RevealSharedInValues()`. Only accept revealed values that can be reconstructed from the decrypted secret pieces:

```csharp
private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
    AElfConsensusTriggerInformation triggerInformation)
{
    // ... existing encrypted/decrypted pieces handling ...
    
    foreach (var revealedInValue in triggerInformation.RevealedInValues)
    {
        if (!updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
            continue;
            
        var targetMiner = updatedRound.RealTimeMinersInformation[revealedInValue.Key];
        
        // Skip if already set
        if (targetMiner.PreviousInValue != Hash.Empty && targetMiner.PreviousInValue != null)
            continue;
        
        // CRITICAL: Validate the revealed value using secret sharing reconstruction
        var minersCount = updatedRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        
        if (targetMiner.EncryptedPieces.Count < minimumCount || 
            targetMiner.DecryptedPieces.Count < minersCount)
            continue;
        
        // Reconstruct the value cryptographically
        var orders = targetMiner.DecryptedPieces.Select((t, i) =>
                updatedRound.RealTimeMinersInformation.Values
                    .First(m => m.Pubkey == targetMiner.DecryptedPieces.Keys.ToList()[i]).Order)
            .ToList();
        
        var sharedParts = targetMiner.DecryptedPieces.Values.ToList()
            .Select(s => s.ToByteArray()).ToList();
        
        var reconstructedValue = HashHelper.ComputeFrom(
            SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
        
        // Only accept if the provided value matches the cryptographically reconstructed value
        if (reconstructedValue == revealedInValue.Value)
        {
            targetMiner.PreviousInValue = revealedInValue.Value;
        }
    }
}
```

**Secondary Fix - Allow Legitimate Overwrites:**

Modify `ApplyNormalConsensusData` to allow miners to overwrite their own `PreviousInValue` with validated values from their trigger information, even if already set:

```csharp
public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

    RealTimeMinersInformation[pubkey].OutValue = outValue;
    RealTimeMinersInformation[pubkey].Signature = signature;
    
    // Allow the miner to update their own PreviousInValue if they provide a valid one
    if (previousInValue != null && previousInValue != Hash.Empty)
    {
        RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
    }
    else if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
             RealTimeMinersInformation[pubkey].PreviousInValue == null)
    {
        RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
    }
    
    // ... rest of the method ...
}
```

## Proof of Concept

The vulnerability can be demonstrated by creating a malicious implementation of `ISecretSharingService` that returns fake revealed values, then verifying that blocks produced with these fake values successfully poison the victim's state:

```csharp
public class MaliciousSecretSharingServiceTest
{
    [Fact]
    public async Task MaliciousMinerCanPoisonVictimPreviousInValue()
    {
        // Setup: 3 miners (Attacker, Victim, Honest)
        // Round N: Victim fails to mine (PreviousInValue = Hash.Empty for Round N+1)
        // Round N+1: Attacker mines first with fake RevealedInValues[Victim] = FakeHash
        
        var fakeHash = HashHelper.ComputeFrom("fake_value");
        
        // Attacker's trigger information includes poisoned revealed value
        var maliciousTriggerInfo = new AElfConsensusTriggerInformation
        {
            Pubkey = attackerPubkey,
            InValue = attackerInValue,
            PreviousInValue = attackerPreviousInValue,
            Behaviour = AElfConsensusBehaviour.UpdateValue,
            RevealedInValues = { { victimPubkey, fakeHash } }  // POISONED
        };
        
        // Attacker produces block - should succeed
        var attackerBlock = await consensusService.GetConsensusExtraData(maliciousTriggerInfo);
        var validationResult = await consensusService.ValidateConsensusBeforeExecution(attackerBlock);
        Assert.True(validationResult.Success); // Block accepted
        
        // Verify victim's PreviousInValue is poisoned
        var currentRound = await consensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
        Assert.Equal(fakeHash, currentRound.RealTimeMinersInformation[victimPubkey].PreviousInValue);
        
        // Victim attempts to mine with correct PreviousInValue
        var victimTriggerInfo = new AElfConsensusTriggerInformation
        {
            Pubkey = victimPubkey,
            InValue = victimInValue,
            PreviousInValue = victimCorrectPreviousInValue,  // CORRECT VALUE
            Behaviour = AElfConsensusBehaviour.UpdateValue
        };
        
        var victimBlock = await consensusService.GetConsensusExtraData(victimTriggerInfo);
        var victimValidation = await consensusService.ValidateConsensusBeforeExecution(victimBlock);
        
        // Victim's block fails validation because poisoned value persists
        Assert.False(victimValidation.Success);
        Assert.Contains("Incorrect previous in value", victimValidation.Message);
    }
}
```

**Notes:**

This vulnerability represents a critical flaw in the secret sharing mechanism that allows malicious consensus miners to censor specific miners through state poisoning. The attack is particularly insidious because:

1. The victim's node operates correctly but produces blocks that are rejected
2. The attack is undetectable without deep inspection of the consensus state
3. No cryptographic capabilities beyond miner status are required
4. The poisoned state persists across multiple rounds

The fix requires adding proper cryptographic validation to `UpdateLatestSecretPieces()` to ensure revealed values match the secret sharing reconstruction, preventing malicious miners from injecting arbitrary fake values.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L84-92)
```csharp
    public Dictionary<string, Hash> GetRevealedInValues(long roundId)
    {
        _revealedInValues.TryGetValue(roundId, out var revealedInValues);
        Logger.LogDebug($"[GetRevealedInValues]Round id: {roundId}");
        if (revealedInValues != null)
            Logger.LogDebug($"Revealed {revealedInValues.Count} in values for round of id {roundId}");

        _revealedInValues.Remove(roundId);
        return revealedInValues ?? new Dictionary<string, Hash>();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-193)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L28-29)
```csharp
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
```
