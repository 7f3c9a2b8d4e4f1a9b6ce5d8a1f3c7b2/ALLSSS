# Audit Report

## Title
First-Time Miners Can Claim Welcome Rewards Through Pubkey Replacement

## Summary
A first-time miner can replace their public key during their first term and the replacement pubkey will incorrectly receive welcome rewards at term end. This occurs because the replacement pubkey inherits `LatestMinedTerm = 0` from the original pubkey, causing it to be misidentified as a new miner eligible for welcome rewards despite the entity having already participated in mining.

## Finding Description

The vulnerability exists in the interaction between Election, Consensus, and Treasury contracts during pubkey replacement:

**Step 1: Pubkey Replacement During First Term**

When a first-time miner calls `ReplaceCandidatePubkey` during their first term, the Election contract notifies the Consensus contract via `RecordCandidateReplacement`. [1](#0-0) 

The Consensus contract updates the current round to replace the old pubkey with the new pubkey in `RealTimeMinersInformation` and persists this change to storage. [2](#0-1) 

**Step 2: Treasury Transfer Without Validation**

The Consensus contract then notifies the Treasury contract by calling `RecordMinerReplacement`, critically without setting the `IsOldPubkeyEvil` field (which defaults to `false` in protobuf). [3](#0-2) 

The protobuf definition confirms the boolean field defaults to false: [4](#0-3) 

The Treasury contract's `RecordMinerReplacement` transfers `LatestMinedTerm` from old to new pubkey without validating whether the old pubkey has completed any mining terms. For a first-time miner in their first term, this means transferring `LatestMinedTerm = 0`. [5](#0-4) 

**Step 3: Misidentification as New Miner**

At term end, the `Release` function retrieves `previousTermInformation` from the Consensus contract. [6](#0-5) 

The `GetPreviousTermInformation` method retrieves the last round of the term from storage, which now contains the replacement pubkey (not the original) because the round was updated during replacement. [7](#0-6) 

The `Release` function identifies new miners by checking if `LatestMinedTerm[p] == 0`. The replacement pubkey passes this check and is incorrectly added to the `newElectedMiners` list. [8](#0-7) 

**Step 4: Welcome Reward Allocation**

`UpdateWelcomeRewardWeights` is called with the replacement pubkey in the `newElectedMiners` list and adds it as a beneficiary for welcome rewards with 1 share. [9](#0-8) 

**Step 5: State Update**

Finally, `UpdateStateAfterDistribution` updates `LatestMinedTerm` for the replacement pubkey, preventing it from claiming welcome rewards again in future terms. [10](#0-9) 

The Treasury initialization confirms "Welcome Reward" is explicitly designed as one of three miner reward sub-schemes for incentivizing new miners. [11](#0-10) 

## Impact Explanation

**Direct Financial Impact:** The replacement pubkey receives welcome rewards that should only be distributed to genuinely new miners. This misallocates treasury funds from the welcome reward pool, which has a configurable weight in miner reward distribution (default 1/4 of miner rewards based on `WelcomeRewardWeight = 1` out of total weight 4). [12](#0-11) 

**Affected Parties:**
- Legitimate new miners receive diluted welcome rewards as the fixed pool is shared with illegitimate recipients
- The protocol's economic incentive model is violated as welcome rewards are designed as a one-time bonus for new participation

**Severity Assessment:** HIGH - This directly misallocates treasury funds, can be systematically exploited by any first-time miner, and undermines the protocol's intended economic incentive structure for onboarding new miners.

## Likelihood Explanation

**Attack Feasibility:** Any first-time elected miner can exploit this vulnerability. The miner must have authority to call `ReplaceCandidatePubkey`, which requires being the candidate admin. [13](#0-12) 

**Attack Complexity:** LOW - The exploit requires only:
1. Being elected as a miner for the first time (legitimate participation)
2. Calling `ReplaceCandidatePubkey` during the first term
3. No race conditions or timing constraints beyond staying within the first term

**Detection Difficulty:** The exploitation is indistinguishable from legitimate pubkey replacements for operational security reasons (e.g., key rotation).

**Probability:** HIGH - First-time miners regularly join the network, and the vulnerability can be triggered either intentionally for extra rewards or accidentally during legitimate key rotation.

## Recommendation

Add validation in `RecordMinerReplacement` to prevent transferring `LatestMinedTerm = 0` for first-term replacements. The fix should check if the old pubkey has completed at least one term before transferring the state:

```csharp
if (!input.IsOldPubkeyEvil)
{
    var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
    // Only transfer if the old pubkey has actually completed a term
    if (latestMinedTerm > 0)
    {
        State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
    }
    State.LatestMinedTerm.Remove(input.OldPubkey);
}
```

Alternatively, store whether a pubkey replacement occurred during a term and exclude such pubkeys from welcome reward eligibility checks in the `Release` function.

## Proof of Concept

```csharp
[Fact]
public async Task FirstTimeMiner_ReplacePubkey_IncorrectlyReceivesWelcomeRewards()
{
    // Setup: Initialize contracts and elect initial miners for term 1
    await InitializeContractsAsync();
    
    // A new candidate announces and gets elected for the first time
    var firstTimeMinerKeyPair = NewCandidateKeyPairs.First();
    var candidateAdmin = CandidateAdminKeyPairs.First();
    await AnnounceAndVoteForCandidate(firstTimeMinerKeyPair, candidateAdmin);
    
    // Candidate gets elected in term 1 (their first term)
    await MineBlocksToNextTermAsync(); // Now in term 1
    
    // During term 1, before it ends, the first-time miner replaces their pubkey
    var replacementKeyPair = NewCandidateKeyPairs.Skip(1).First();
    var candidateAdminStub = GetElectionStub(candidateAdmin);
    await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = firstTimeMinerKeyPair.PublicKey.ToHex(),
        NewPubkey = replacementKeyPair.PublicKey.ToHex()
    });
    
    // Verify LatestMinedTerm is 0 for replacement pubkey
    var latestMinedTerm = await TreasuryStub.GetLatestMinedTerm.CallAsync(
        new StringValue { Value = replacementKeyPair.PublicKey.ToHex() });
    latestMinedTerm.Value.ShouldBe(0);
    
    // Term 1 ends - Release is called
    await MineBlocksToNextTermAsync(); // Triggers Release for term 1
    
    // Verify replacement pubkey was incorrectly added to welcome rewards
    var welcomeSchemeId = await TreasuryStub.GetWelcomeRewardSchemeId.CallAsync(new Empty());
    var beneficiaries = await ProfitStub.GetScheme.CallAsync(welcomeSchemeId);
    
    // The replacement pubkey should NOT be in welcome rewards (but it is - vulnerability)
    var replacementAddress = Address.FromPublicKey(replacementKeyPair.PublicKey);
    beneficiaries.TotalShares.ShouldBeGreaterThan(0); // Vulnerability: received 1 share
    
    // This proves the replacement pubkey incorrectly received welcome rewards
    // despite the entity having already mined in term 1 under the original pubkey
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-146)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L149-154)
```csharp
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });
```

**File:** protobuf/treasury_contract.proto (L154-159)
```text
message RecordMinerReplacementInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
    int64 current_term_number = 3;
    bool is_old_pubkey_evil = 4;
}
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L51-54)
```csharp
        var profitItemNameList = new List<string>
        {
            "Treasury", "MinerReward", "Subsidy", "Welfare", "Basic Reward", "Flexible Reward",
            "Welcome Reward"
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L136-139)
```csharp
        var previousTermInformation = State.AEDPoSContract.GetPreviousTermInformation.Call(new Int64Value
        {
            Value = input.PeriodNumber
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L155-156)
```csharp
        maybeNewElectedMiners = maybeNewElectedMiners
            .Where(p => State.LatestMinedTerm[p] == 0 && !GetInitialMinerList().Contains(p)).ToList();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L480-488)
```csharp
    private MinerRewardWeightSetting GetDefaultMinerRewardWeightSetting()
    {
        return new MinerRewardWeightSetting
        {
            BasicMinerRewardWeight = 2,
            WelcomeRewardWeight = 1,
            FlexibleRewardWeight = 1
        };
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L583-588)
```csharp
        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L766-769)
```csharp
    private void UpdateStateAfterDistribution(Round previousTermInformation, List<string> currentMinerList)
    {
        foreach (var miner in currentMinerList) State.LatestMinedTerm[miner] = previousTermInformation.TermNumber;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L872-877)
```csharp
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L440-457)
```csharp
    public override Round GetPreviousTermInformation(Int64Value input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[input.Value.Add(1)].Sub(1);
        var round = State.Rounds[lastRoundNumber];
        if (round == null || round.RoundId == 0) return new Round();
        var result = new Round
        {
            TermNumber = input.Value
        };
        foreach (var minerInRound in round.RealTimeMinersInformation)
            result.RealTimeMinersInformation[minerInRound.Key] = new MinerInRound
            {
                Pubkey = minerInRound.Value.Pubkey,
                ProducedBlocks = minerInRound.Value.ProducedBlocks
            };

        return result;
    }
```
