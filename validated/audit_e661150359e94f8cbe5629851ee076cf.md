# Audit Report

## Title
LIB Calculation Fails When Insufficient Miners Participated in Previous Round

## Summary
The Last Irreversible Block (LIB) calculation can fail throughout an entire round when sufficient miners participate in that round, if too few miners mined in the previous round. This occurs because the LIB algorithm retrieves miners who mined in the current round but evaluates their `ImpliedIrreversibleBlockHeight` values from the previous round, filtering out miners with zero heights who didn't mine previously.

## Finding Description

The AEDPoS consensus mechanism calculates LIB by examining miners who successfully mined in the current round and retrieving their implied irreversible block heights from the previous round. The vulnerability exists due to the interaction between several components:

**LIB Calculation Logic**: The `LastIrreversibleBlockHeightCalculator.Deconstruct()` method retrieves all miners who have mined in the current round, then looks up their `ImpliedIrreversibleBlockHeight` values from the previous round stored in state. [1](#0-0) 

**Zero Height Filtering**: The `GetSortedImpliedIrreversibleBlockHeights` method explicitly filters out all miners with `ImpliedIrreversibleBlockHeight <= 0`, only considering miners who have positive height values. [2](#0-1) 

**Consensus Threshold Requirement**: The system requires at least `MinersCountOfConsent = (total_miners * 2) / 3 + 1` miners with non-zero heights for successful LIB calculation. [3](#0-2)  If fewer heights are available after filtering, LIB returns 0. [4](#0-3) 

**Height Update Mechanism**: Miners only update their `ImpliedIrreversibleBlockHeight` when they successfully mine a block via `ProcessUpdateValue`. [5](#0-4)  Miners who miss their time slots retain the default protobuf value of 0. [6](#0-5) 

**Round Retrieval**: Previous round information is retrieved from state without modification. [7](#0-6) 

**Execution Scenario** (with 17 miners, requiring 12 for consensus):
- **Round N**: Only 11 out of 17 miners successfully mine blocks. These 11 miners set their `ImpliedIrreversibleBlockHeight` in Round N. The 6 miners who missed retain height=0 in Round N. Round N is saved to state.
- **Round N+1**: All 17 miners successfully participate and mine blocks.
- **LIB Calculation in Round N+1**: When calculating LIB during block processing, the calculator retrieves miners who have mined in Round N+1, then looks up their heights from Round N. [8](#0-7)  Since only 11 miners have non-zero heights from Round N, and the filtering removes all zero heights, only 11 heights remain. With 11 < 12 (MinersCountOfConsent), LIB calculation returns 0 throughout the entire Round N+1, and no `IrreversibleBlockFound` event is fired.

## Impact Explanation

This vulnerability causes **consensus liveness degradation** with the following concrete impacts:

1. **Finality Stall**: When LIB calculation returns 0, no `IrreversibleBlockFound` event is fired, preventing the blockchain's Last Irreversible Block height from advancing throughout the affected round. This stalls block finality for all transactions in that round.

2. **Cross-Chain Operations Disruption**: Cross-chain indexing operations require irreversible block confirmation. The system validates LIB existence before performing cross-chain data retrieval and indexing operations. A stalled LIB prevents cross-chain transactions from progressing, as they require irreversible block confirmations for security.

3. **Validator Impact**: Block validators cannot reliably confirm irreversible block heights during the stall period, affecting synchronization and validation operations across the network.

4. **Temporary DoS**: The system experiences availability degradation affecting dependent services that rely on finality guarantees.

**Severity Justification**: Medium - This is an availability/liveness issue rather than a fund-at-risk vulnerability. The impact is temporary and self-healing once miners achieve consistent participation across multiple consecutive rounds (LIB resumes in Round N+2 after sufficient miners mine in Round N+1). However, during network instability, high latency periods, or coordinated downtime, this can cause extended finality stalls affecting critical operations.

**Quantified Impact**: With 17 miners (typical production configuration), if more than 5 miners (>29% of the network) miss their time slots in one round, the next round's LIB calculation will fail even if all miners participate in that next round. The mathematical threshold is: if fewer than MinersCountOfConsent miners successfully mine in Round N, then LIB calculation fails throughout Round N+1 regardless of participation in Round N+1.

## Likelihood Explanation

**Natural Occurrence Probability**: HIGH

This vulnerability occurs naturally without any malicious actor:
- Network instability, high latency, or temporary connectivity issues commonly cause miners to miss time slots in distributed blockchain networks
- Miner node maintenance, software updates, restarts, or brief outages naturally result in missed time slots
- The Byzantine fault tolerance threshold (1/3 or ~33%) is very close to the failure threshold (6 out of 17 miners or ~35%), making this scenario realistic in production environments where network conditions fluctuate
- Production blockchain networks regularly experience periods where multiple nodes have degraded performance simultaneously

**Attack Feasibility**: MEDIUM

While no malicious behavior by consensus miners is required (missing slots forfeits mining rewards, making it economically irrational), external attackers could exploit this:
- DDoS attacks targeting specific miner nodes could force them to miss time slots
- Network partition attacks could temporarily isolate miners
- The attack requires disrupting more than 29% of miners for one round, which is feasible for sophisticated attackers

**Preconditions**:
- Standard consensus operation with no special configuration required
- More than (MinersCountOfConsent - 1) miners fail to mine in one round due to network issues or external disruption
- Normal mining continues in subsequent rounds

**Detection**: The issue manifests as LIB height not advancing for an entire round, which may be difficult to distinguish from normal consensus variations, making it a low-detectability issue that could persist unnoticed.

## Recommendation

Modify the LIB calculation logic to use a threshold based on miners who actually participated in the previous round, rather than the total network size. The fix should:

1. Calculate `MinersCountOfConsent` based on the count of miners who successfully mined in the previous round (those with non-zero heights), rather than the total miner count in the current round.

2. Alternatively, implement a fallback mechanism that uses the last confirmed LIB when insufficient heights are available from the previous round, ensuring LIB continues advancing even during periods of reduced participation.

3. Add bounds checking to ensure the threshold never exceeds the number of miners who actually participated in the previous round.

The recommended fix in `Round_ImpliedIrreversibleBlockHeight.cs` would adjust the threshold calculation to account for actual previous round participation rather than using a fixed network-size-based threshold.

## Proof of Concept

```csharp
// Test scenario demonstrating LIB calculation failure
// Setup: 17 miners, MinersCountOfConsent = 12
// Round N: Only 11 miners successfully mine (6 miss their slots)
// Round N+1: All 17 miners mine
// Expected: LIB calculation returns 0 in Round N+1 despite full participation

public void TestLIBFailureWithInsufficientPreviousRoundParticipation()
{
    // Arrange: Create Round N with only 11 miners having mined
    var roundN = CreateRoundWithMiners(17);
    MarkMinersAsMined(roundN, 11); // Only 11 of 17 miners successfully mined
    
    // Create Round N+1 with all 17 miners having mined
    var roundNPlusOne = CreateRoundWithMiners(17);
    MarkMinersAsMined(roundNPlusOne, 17); // All 17 miners mined in current round
    
    // Act: Calculate LIB using current round (N+1) and previous round (N)
    var calculator = new LastIrreversibleBlockHeightCalculator(roundNPlusOne, roundN);
    calculator.Deconstruct(out var libHeight);
    
    // Assert: LIB calculation should return 0 because only 11 heights from 
    // previous round are non-zero, which is less than MinersCountOfConsent (12)
    Assert.Equal(0, libHeight);
    
    // Verify: MinersCountOfConsent = (17 * 2) / 3 + 1 = 12
    Assert.Equal(12, roundNPlusOne.MinersCountOfConsent);
    
    // Verify: Only 11 non-zero heights available from previous round
    var minedMiners = roundNPlusOne.GetMinedMiners().Select(m => m.Pubkey).ToList();
    var heights = roundN.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
    Assert.Equal(11, heights.Count);
}
```

## Notes

This vulnerability represents a design flaw in the LIB calculation algorithm where the consensus threshold (`MinersCountOfConsent`) is calculated based on the total network size in the current round, but the available data for comparison comes from miners who participated in the previous round. This creates a mismatch that can cause LIB calculation failures even when the current round has full participation.

The issue is particularly concerning because:
1. It can occur naturally during normal network operations without malicious behavior
2. The failure threshold (>29% missed slots) is very close to the Byzantine fault tolerance assumption (33%)
3. It affects cross-chain operations that depend on LIB for security guarantees
4. The round-long finality stall impacts all blocks produced during the affected round

The self-healing nature (recovery in Round N+2) mitigates the severity from High to Medium, but the issue should be addressed to improve consensus robustness during periods of network instability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-25)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-29)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-281)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** protobuf/aedpos_contract.proto (L300-300)
```text
    int64 implied_irreversible_block_height = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L56-63)
```csharp
    private bool TryToGetPreviousRoundInformation(out Round previousRound)
    {
        previousRound = new Round();
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        if (roundNumber < 2) return false;
        var targetRoundNumber = roundNumber.Sub(1);
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
```
