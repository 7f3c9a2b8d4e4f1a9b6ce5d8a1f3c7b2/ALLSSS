# Audit Report

## Title
Malicious Miner Can DoS Critical System Operations By Injecting Invalid Hex Strings Via NextRound

## Summary
A malicious current miner can inject invalid hex strings into the `RealTimeMinersInformation` dictionary when calling `NextRound`, causing unhandled exceptions in subsequent calls to `IsCurrentMiner`. This blocks critical operations including transaction fee claiming, resource token donation, and cross-chain indexing until the malicious round expires.

## Finding Description

The vulnerability exists in the consensus round update flow where `NextRound` accepts arbitrary string keys in `RealTimeMinersInformation` without validating hex format. [1](#0-0) 

When a miner calls `NextRound`, the input is converted to a `Round` object by directly copying the `RealTimeMinersInformation` dictionary without any hex format validation. [2](#0-1) 

The validation system checks round number, InValue nullity, and mining order, but never validates the hex format of pubkey strings. [3](#0-2) [4](#0-3) 

The malicious data is stored directly when `ProcessNextRound` calls `AddRoundInformation`. [5](#0-4) 

Later, when `IsCurrentMiner` is called, it attempts to convert addresses to pubkeys by iterating through all stored keys and calling `ByteArrayHelper.HexStringToByteArray` on each key. [6](#0-5) 

The `ByteArrayHelper.HexStringToByteArray` method uses `Convert.ToByte(hex.Substring(i, 2), 16)` which throws a `FormatException` for invalid hex characters like "xyz". [7](#0-6) 

This blocks critical operations that require miner permission checks:

**Transaction Fee Claiming:** [8](#0-7) 

**Resource Token Donation:** [9](#0-8) 

**Cross-Chain Indexing Proposal:** [10](#0-9) 

**Cross-Chain Indexing Release:** [11](#0-10) 

**Permission Check Implementation:** [12](#0-11) [13](#0-12) 

## Impact Explanation

**HIGH Severity** - The DoS affects multiple consensus-critical operations:

1. **Economic Disruption**: ALL miners lose the ability to claim transaction fees, not just the attacker. The system-generated fee claim transactions will fail with exceptions.
2. **Resource Token Model Break**: `DonateResourceToken` fails system-wide, preventing the resource fee distribution mechanism from functioning.
3. **Cross-Chain Communication Halt**: Side chains cannot index parent chain data, and parent chains cannot index side chain data, breaking cross-chain functionality completely.
4. **Network-Wide Impact**: Affects the entire blockchain until the malicious round expires (1-2 rounds, potentially several hours depending on configuration).

The vulnerability breaks the core security guarantee that authorized miners can execute critical system operations. This is not a simple revert - it's an unhandled exception that propagates up and causes transaction failures.

## Likelihood Explanation

**HIGH Likelihood:**
- Attack requires only current miner status, which is achievable through normal election processes
- A single malicious or compromised miner is sufficient
- Attack is trivial to execute: simply add one malformed key (e.g., "xyz" instead of a valid hex pubkey) to `RealTimeMinersInformation` when calling `NextRound`
- No detection mechanisms exist - the malicious data appears valid to all other validators since only the miner permission check at entry is performed
- Impact is immediate and deterministic - the first call to any operation requiring `IsCurrentMiner` will fail

The permission check for `NextRound` only verifies the sender is a current miner via `PreCheck`, but does not validate the content validity of the proposed round data. [14](#0-13) 

## Recommendation

Add hex format validation to the `NextRound` input processing before storing the round information. This can be implemented in two ways:

**Option 1:** Add a validation provider that checks all keys in `RealTimeMinersInformation` are valid hex strings:

```csharp
public class PubkeyFormatValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        
        foreach (var key in providedRound.RealTimeMinersInformation.Keys)
        {
            try
            {
                ByteArrayHelper.HexStringToByteArray(key);
            }
            catch
            {
                validationResult.Message = $"Invalid pubkey hex format: {key}";
                return validationResult;
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Add this provider to the validation pipeline in `AEDPoSContract_Validation.cs` for NextRound behavior.

**Option 2:** Add try-catch protection in `ConvertAddressToPubkey` to handle invalid hex gracefully:

```csharp
private string ConvertAddressToPubkey(Address address)
{
    if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
    var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
    if (TryToGetPreviousRoundInformation(out var previousRound))
        possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

    return possibleKeys.FirstOrDefault(k =>
    {
        try
        {
            return Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address;
        }
        catch
        {
            return false; // Skip invalid hex keys
        }
    });
}
```

**Recommendation:** Implement Option 1 as it prevents malicious data from being stored in the first place, rather than working around it after storage. This is the more robust security approach.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousNextRound_BlocksIsCurrentMiner_Test()
{
    // Arrange: Setup initial round with valid miners
    await InitialAElfConsensusContract();
    var currentMiner = SampleAccount.Accounts.First().KeyPair;
    
    // Act 1: Inject malicious round with invalid hex string
    var maliciousNextRoundInput = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = 
        {
            { "xyz", new MinerInRound { Pubkey = "xyz" } }, // Invalid hex!
            { currentMiner.PublicKey.ToHex(), new MinerInRound 
              { 
                  Pubkey = currentMiner.PublicKey.ToHex(),
                  OutValue = Hash.FromString("test")
              } 
            }
        }
    };
    
    await AElfConsensusContractStub.NextRound.SendAsync(maliciousNextRoundInput);
    
    // Act 2: Try to check if current miner - should throw FormatException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await AElfConsensusContractStub.IsCurrentMiner.CallAsync(
            Address.FromPublicKey(currentMiner.PublicKey));
    });
    
    // Assert: Verify exception is due to invalid hex format
    Assert.Contains("FormatException", exception.ToString());
}
```

## Notes

This vulnerability demonstrates a critical gap in input validation for consensus round updates. While the system properly checks miner permissions, it fails to validate the semantic correctness of the data being submitted. The impact is severe because it affects all miners system-wide, not just the attacker, and disrupts multiple critical blockchain operations simultaneously.

The root cause is the assumption that current miners will always provide well-formed data. However, in a Byzantine threat model, we must assume that any authorized party could be malicious or compromised. The fix should validate all externally-provided data, even from trusted roles.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-134)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-906)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
        Context.LogDebug(() => $"Claim transaction fee. {input}");
        State.LatestTotalTransactionFeesMapHash.Value = HashHelper.ComputeFrom(input);
        foreach (var bill in input.Value)
        {
            var symbol = bill.Key;
            var amount = bill.Value;
            ModifyBalance(Context.Self, symbol, amount);
            Context.Fire(new TransactionFeeClaimed
            {
                Symbol = symbol,
                Amount = amount,
                Receiver = Context.Self
            });
            
            TransferTransactionFeesToFeeReceiver(symbol, amount);
        }

        Context.LogDebug(() => "Finish claim transaction fee.");

        return new Empty();
    }

    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-920)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```
