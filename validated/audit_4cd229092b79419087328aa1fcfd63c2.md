# Audit Report

## Title
Partial Miner Replacement Causes isMinerListChanged Flag to Be Set Incorrectly, Allowing Banned Miners to Continue Mining

## Summary
When the Election contract returns fewer alternative candidates than evil miners during miner replacement, the consensus contract processes only partial replacements but incorrectly sets `isMinerListChanged=true`. This leaves banned miners active in the consensus round while triggering side effects designed for complete miner list changes, including disabling secret sharing and bypassing certain mining permission checks.

## Finding Description

The vulnerability exists in the miner replacement logic within `GenerateNextRoundInformation()`. The replacement loop iterates based on `minerReplacementInformation.AlternativeCandidatePubkeys.Count` rather than the total count of evil miners that need to be replaced. [1](#0-0) 

The Election contract's `GetMinerReplacementInformation()` method can return mismatched counts when the candidate pool is insufficient. It explicitly takes the minimum count between available candidates and evil miners, and even with initial miner fallback, may not provide enough alternatives. [2](#0-1) 

**Root Cause:** The consensus contract assumes a 1-to-1 correspondence between evil miners and alternatives. When `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`, only the first N evil miners (where N = AlternativeCandidatePubkeys.Count) are replaced. The loop at lines 311-339 removes only the evil miners for which alternatives exist, but line 341 unconditionally sets `isMinerListChanged = true` if any alternatives exist, even though some banned miners remain in `currentRound.RealTimeMinersInformation`.

**Why Existing Protections Fail:**

1. The `MiningPermissionValidationProvider` only checks if a pubkey exists in `RealTimeMinersInformation.Keys`, not whether it's banned [3](#0-2) 

2. The `IsCurrentMiner` method skips the miner list membership check when `IsMinerListJustChanged=true` [4](#0-3) 

3. The flag is directly propagated to the next round via `Round.GenerateNextRoundInformation()`, setting `IsMinerListJustChanged=true` in the new round structure [5](#0-4) 

The unreplaced evil miners are carried over to the next round because they remain in the modified `currentRound.RealTimeMinersInformation` dictionary when `GenerateNextRoundInformation()` is called at line 345-346, which then copies all miners from the current round to build the next round.

## Impact Explanation

**Consensus Integrity Violation:**
- Banned miners who should be removed remain active and can produce blocks
- The unreplaced banned miner retains their time slot, order, and block production privileges  
- This violates the core security invariant that evil miners must be excluded from consensus participation

**Secret Sharing Disruption:**
When `IsMinerListJustChanged=true`, the secret sharing mechanism is disabled by skipping the `SecretSharingInformation` event [6](#0-5) 

This is intended for legitimate miner list changes but occurs even when banned miners remain, potentially breaking the random number generation mechanism critical for consensus security.

**Altered Consensus Behavior:**
The `IsMinerListJustChanged` flag affects multiple consensus logic paths including extra block producer selection and miner validation. Unreplaced evil miners may gain or lose block production opportunities incorrectly due to the flag being set when the miner list change is incomplete.

**Severity:** HIGH - Banned miners continue participating in consensus despite being marked as evil, directly undermining the protocol's security model and miner accountability mechanism.

## Likelihood Explanation

**Reachable Entry Point:** The vulnerability is triggered through the normal consensus flow when `ProcessNextRound` calls `GenerateNextRoundInformation` during round transitions [7](#0-6) 

**Feasible Preconditions:**
1. Main chain operation (checked at line 299)
2. Same term operation (not transitioning to new term, checked at line 299)
3. Multiple miners flagged as evil in `BannedPubkeyMap`
4. Limited candidate pool - election snapshot has fewer qualified candidates than evil miners
5. Initial miners either banned or already in the current miner list

**Execution Practicality:**
This scenario naturally occurs when:
- Network has a small candidate pool (common in side chains or early mainnet phases)
- Multiple miners violate consensus rules simultaneously (e.g., mass downtime event)
- Initial miners have also been compromised or banned

**Economic Rationality:** No attack cost required - this is a natural failure mode when legitimate banning mechanisms encounter insufficient replacement candidates. It represents a protocol design flaw rather than an exploitable attack vector.

**Probability:** MEDIUM - More likely in smaller networks with limited candidates or during security incidents involving multiple miners, but not an everyday occurrence on established networks with healthy candidate pools.

## Recommendation

Modify the miner replacement logic to handle partial replacement scenarios correctly:

1. **Only set `isMinerListChanged = true` when ALL evil miners are successfully replaced:**
   - Check if `minerReplacementInformation.AlternativeCandidatePubkeys.Count == minerReplacementInformation.EvilMinerPubkeys.Count`
   - Only set the flag when complete replacement occurs

2. **Add explicit ban checks in validation providers:**
   - Enhance `MiningPermissionValidationProvider` to check `State.BannedPubkeyMap` in addition to miner list membership
   - Prevent banned miners from producing blocks even if they remain in `RealTimeMinersInformation`

3. **Extend the replacement loop to process all evil miners:**
   - When insufficient alternatives exist, remove all evil miners from the next round even without replacements
   - Adjust the miner count accordingly and redistribute time slots

4. **Add logging/events when partial replacement occurs:**
   - Fire a warning event when not all evil miners can be replaced
   - Allow governance to respond to insufficient candidate situations

## Proof of Concept

A test demonstrating this vulnerability would:
1. Initialize a network with N miners where M > N/2 are marked as evil
2. Set up the Election contract to return only N/2 alternative candidates
3. Trigger a round transition via `ProcessNextRound`
4. Verify that some evil miners remain in the new round's `RealTimeMinersInformation`
5. Confirm `IsMinerListJustChanged = true` is set
6. Demonstrate that unreplaced evil miners can successfully produce blocks in the next round

The test would validate that the unreplaced evil miners pass `MiningPermissionValidationProvider` checks and can execute mining operations despite being flagged as evil in `BannedPubkeyMap`.

## Notes

This vulnerability highlights a critical gap between the consensus contract's miner management and the Election contract's candidate availability. The issue is particularly concerning because:

1. **Silent Failure:** The system continues operating with banned miners active but provides no indication that miner replacement was incomplete

2. **Cascading Effects:** The incorrectly set `IsMinerListJustChanged` flag triggers multiple side effects (disabled secret sharing, altered validation logic) that assume a complete miner list change occurred

3. **Attack Surface:** While not requiring attacker action, this creates a security window where compromised miners can continue operating after being detected and flagged

The fix requires coordination between the Consensus and Election contracts to ensure either complete miner replacement or graceful degradation when insufficient candidates are available.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-398)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-14)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-110)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L37-39)
```csharp
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
```
