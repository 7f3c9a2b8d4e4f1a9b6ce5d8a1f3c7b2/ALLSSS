# Audit Report

## Title
LIB Monotonicity Violation via Unvalidated NextRound and TinyBlock Consensus Behaviors

## Summary
The `LibInformationValidationProvider` is only applied to `UpdateValue` behavior, while `NextRound` and `TinyBlock` behaviors also modify LIB-related values in consensus state without validation. A malicious miner can exploit this selective validation gap to submit consensus data with regressed Last Irreversible Block (LIB) heights, violating the critical monotonicity invariant and poisoning consensus state.

## Finding Description

**Root Cause:** Inconsistent validation provider registration creates an exploitable gap in LIB monotonicity enforcement across different consensus behaviors.

The `LibInformationValidationProvider` validates that LIB values do not regress by checking that `ConfirmedIrreversibleBlockHeight`, `ConfirmedIrreversibleBlockRoundNumber`, and per-miner `ImpliedIrreversibleBlockHeight` do not decrease. [1](#0-0) 

However, this validator is **only** registered for `UpdateValue` behavior in the validation provider list. [2](#0-1) 

**Vulnerability Path 1 - NextRound:**

When a miner produces a NextRound block, the `NextRoundInput` contains `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields that are directly copied into the `Round` object without validation. [3](#0-2) 

The NextRound behavior case only adds `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` - notably **excluding** `LibInformationValidationProvider`. [4](#0-3) 

The ProcessNextRound method directly stores the provided round to state via `AddRoundInformation(nextRound)` without any LIB monotonicity check. [5](#0-4) 

**Vulnerability Path 2 - TinyBlock:**

TinyBlock behavior includes `ImpliedIrreversibleBlockHeight` in its simplified round data. [6](#0-5) 

During validation, the `RecoverFromTinyBlock` method applies the provided `ImpliedIrreversibleBlockHeight` to the miner's state. [7](#0-6) 

TinyBlock behavior has no case in the validation switch statement, so it only receives basic providers (MiningPermissionValidationProvider, TimeSlotValidationProvider, ContinuousBlocksValidationProvider) without `LibInformationValidationProvider`. [8](#0-7) 

The updated round with regressed LIB value is then stored to state. [9](#0-8) 

**Attack Vector:**

A malicious miner controls the consensus extra data placed in the block header they produce. The validation service iterates through registered providers but only executes those that were added to the list. [10](#0-9) 

Since `LibInformationValidationProvider` is not registered for NextRound or TinyBlock behaviors, a miner can:
1. Modify `ConfirmedIrreversibleBlockHeight`/`ConfirmedIrreversibleBlockRoundNumber` in NextRoundInput to lower values
2. Or modify `ImpliedIrreversibleBlockHeight` in TinyBlock round data to a lower value
3. Submit the block with malicious consensus extra data
4. Pass validation (since the LIB check is not executed)
5. Have the regressed LIB values permanently stored to consensus state

## Impact Explanation

**Critical Consensus Invariant Violation:**
Last Irreversible Block height is a fundamental consensus safety property that must be monotonically increasing. Regressing LIB values violates this invariant and breaks the finality guarantees that the entire system depends on.

**State Poisoning and Cascade Effect:**
Once a malicious round with lowered LIB is stored to state, all subsequent consensus operations build upon this corrupted baseline. Future UpdateValue operations that do include LIB validation will compare against the already-poisoned state values, enabling cascading LIB regressions across multiple rounds.

**Cross-Chain Integrity Impact:**
LIB determines which blocks are considered finalized for cross-chain operations. While the system-level LIB tracking has protections, the consensus contract's Round state would diverge from the actual chain LIB, creating inconsistency that could affect cross-chain indexing operations querying consensus state.

**No Recovery Mechanism:**
The codebase contains no automatic detection or recovery mechanism for regressed LIB values in consensus state. Once poisoned, the state remains corrupted until manual intervention.

## Likelihood Explanation

**High Likelihood - Directly Exploitable:**

**Public Entry Points:** Both `NextRound` and `UpdateTinyBlockInformation` are public methods callable by authorized miners. [11](#0-10) [12](#0-11) 

**Minimal Prerequisites:**
- Attacker must be in the active miner set (realistic for a compromised validator node)
- No additional privileges beyond normal miner consensus participation required
- Executable during attacker's assigned time slot

**Attack Execution:**
The consensus extra data is generated by the block producer and included in the block header. [13](#0-12) 

A malicious miner can modify this data before block creation, and the validation will execute without the LIB monotonicity check.

**No Economic Deterrent:**
- Attack cost is equivalent to normal block production (negligible)
- No slashing mechanism specifically targeting this validation bypass
- Attack is detectable in logs but not preventable by existing validation logic

## Recommendation

Add `LibInformationValidationProvider` to the validation provider list for all consensus behaviors that modify LIB-related values, not just `UpdateValue`.

**Fix for NextRound behavior:**
```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

**Fix for TinyBlock behavior:**
Add a new case in the switch statement:
```csharp
case AElfConsensusBehaviour.TinyBlock:
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

This ensures LIB monotonicity is enforced consistently across all consensus state transitions.

## Proof of Concept

```csharp
// Test demonstrating LIB regression via NextRound without validation
[Fact]
public async Task NextRound_Should_RejectRegressedLIB_ButDoesNot()
{
    // Setup: Initialize consensus with LIB at height 100
    var currentRound = GenerateRoundWithLIB(
        roundNumber: 5, 
        confirmedIrreversibleBlockHeight: 100,
        confirmedIrreversibleBlockRoundNumber: 4);
    
    await StoreRoundToState(currentRound);
    
    // Attack: Miner submits NextRoundInput with REGRESSED LIB (99 < 100)
    var maliciousNextRoundInput = new NextRoundInput
    {
        RoundNumber = 6,
        ConfirmedIrreversibleBlockHeight = 99, // REGRESSED!
        ConfirmedIrreversibleBlockRoundNumber = 3, // REGRESSED!
        RealTimeMinersInformation = { currentRound.RealTimeMinersInformation },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Execute: This should fail but actually succeeds
    var result = await ConsensusStub.NextRound.SendAsync(maliciousNextRoundInput);
    
    // Verify: Transaction succeeded (when it should have failed)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: State is now poisoned with regressed LIB
    var storedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    storedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(99); // Confirms regression!
    
    // This proves LIB monotonicity was violated without validation rejection
}
```

**Notes:**
- This vulnerability represents a fundamental gap in the consensus validation architecture where critical invariant enforcement is applied inconsistently across different consensus behaviors.
- The selective validation approach breaks the security assumption that LIB values are always monotonically increasing in consensus state.
- The issue affects both mainchain and sidechain consensus operations since the validation logic is shared.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-30)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-82)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = minerInRound.Pubkey,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight
                }
            }
        };

        foreach (var otherPubkey in RealTimeMinersInformation.Keys.Except(new List<string> { pubkey }))
            round.RealTimeMinersInformation.Add(otherPubkey, new MinerInRound());

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ValidationService.cs (L16-26)
```csharp
    public ValidationResult ValidateInformation(ConsensusValidationContext validationContext)
    {
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result =
                headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L108-112)
```csharp
    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```
