# Audit Report

## Title
Miner Time Manipulation via Unvalidated ActualMiningTime in Consensus Extra Data

## Summary
Miners can manipulate their `ActualMiningTimes` by crafting consensus extra data with false timestamps that differ from `Context.CurrentBlockTime`. The consensus validation logic fails to verify that the reported `ActualMiningTime` matches the actual block time, enabling manipulation of term transitions, time slot calculations, and consensus timing mechanisms.

## Finding Description

The vulnerability exists in how `ActualMiningTime` values are validated when miners produce blocks. The protocol assumes that `ActualMiningTime` represents the actual block production time (`Context.CurrentBlockTime`), but this invariant is never enforced.

**Legitimate Flow:**

When generating consensus extra data, the system legitimately adds `Context.CurrentBlockTime` to the miner's `ActualMiningTimes` collection. [1](#0-0) 

The `ExtractInformationToUpdateConsensus` method extracts the last `ActualMiningTime` to include in the `UpdateValueInput`. [2](#0-1) 

**Missing Validation - Root Cause:**

The critical flaw is that no validation exists to ensure the provided `ActualMiningTime` equals `Context.CurrentBlockTime`. The validation gaps are:

1. **Hash Comparison Bypass**: The `GetCheckableRound` method explicitly clears all `ActualMiningTimes` before computing the hash, meaning hash comparison cannot detect manipulated timestamps. [3](#0-2) 

2. **Insufficient Time Slot Validation**: The `TimeSlotValidationProvider` validates the miner's PREVIOUS `ActualMiningTimes` from state (checking they were within their time slot), but does NOT validate that the NEW `ActualMiningTime` being added equals `Context.CurrentBlockTime`. [4](#0-3) 

3. **Direct State Update**: The `ProcessUpdateValue` method directly adds the provided `ActualMiningTime` to state without any validation against `Context.CurrentBlockTime`. [5](#0-4) 

**Attack Execution:**

A malicious miner can craft custom `AElfConsensusHeaderInformation` with a manipulated `ActualMiningTime` value (different from `Context.CurrentBlockTime`). The consensus extra data in the block header is simplified via `GetUpdateValueRound`, which copies the manipulated `ActualMiningTimes`. [6](#0-5) 

During validation, `RecoverFromUpdateValue` merges this manipulated data into the current round without checking timestamp validity. [7](#0-6) 

The block passes all validations because no validator checks equality to `Context.CurrentBlockTime`, and the hash comparison used in `ValidateConsensusAfterExecution` explicitly excludes `ActualMiningTimes` from the checkable round. [8](#0-7) 

## Impact Explanation

**MEDIUM-HIGH SEVERITY** - This vulnerability compromises consensus integrity through multiple attack vectors:

1. **Term Transition Manipulation**: The `NeedToChangeTerm` function uses `ActualMiningTimes.Last()` from each miner to determine when to change consensus terms. [9](#0-8) 

If two-thirds of miners report manipulated timestamps, they can delay or accelerate term changes, violating the protocol's term transition timing guarantees.

2. **Round 1 Time Slot Distortion**: In the first round, `IsTimeSlotPassed` uses `FirstMiner().ActualMiningTimes.First()` as the reference time for calculating time slot boundaries. [10](#0-9) 

If the first miner manipulates this timestamp, all subsequent miners' time slot calculations are affected, potentially allowing miners to produce blocks out of turn or denying legitimate mining opportunities.

3. **Consensus Timing Integrity**: Various time-based consensus decisions rely on accurate `ActualMiningTimes`, including calculations for when miners can produce tiny blocks and terminate rounds.

The manipulated values are permanently stored in state and affect all future consensus calculations that depend on historical mining times.

## Likelihood Explanation

**MEDIUM** - This vulnerability is exploitable with moderate likelihood:

**Attacker Profile**: Any scheduled miner in the AEDPoS consensus system can execute this attack during their allocated block production time slot. No special privileges beyond normal miner status are required.

**Attack Complexity**: LOW
1. Miner waits for their scheduled mining turn
2. Instead of using the output from `GetConsensusExtraData` directly, miner crafts custom consensus extra data with manipulated `ActualMiningTime`
3. Miner produces and broadcasts block with crafted consensus extra data
4. Block passes all validations and manipulated timestamp is stored in contract state

**Preconditions**: 
- Attacker must be in the current miner list (normal operational requirement for miners)
- No governance control or special permissions needed beyond being a validator

**Detection**: While the manipulated timestamps pass on-chain validation, discrepancies could potentially be detected through external monitoring that compares block timestamps with claimed `ActualMiningTimes`. However, without such monitoring, the manipulation appears as legitimate mining activity in the contract state.

**Constraints**: While individual miner manipulation has limited impact, coordinated manipulation by 2/3 of miners could significantly affect term transitions. Single-miner attacks can still distort time slot calculations in round 1 and affect local consensus timing decisions.

## Recommendation

Add validation in `ProcessUpdateValue` to ensure the provided `ActualMiningTime` matches `Context.CurrentBlockTime`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // Add validation: ActualMiningTime must equal block timestamp
    Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime,
        "ActualMiningTime must match the current block timestamp.");
    
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of the method
}
```

Additionally, consider adding validation in `ValidateConsensusBeforeExecution` to detect timestamp manipulation before execution, though the `ProcessUpdateValue` check is the critical protection point.

## Proof of Concept

The vulnerability can be demonstrated by examining the validation flow:

1. A miner produces a block at time T (Context.CurrentBlockTime = T)
2. The miner crafts consensus extra data claiming ActualMiningTime = T' (where T' â‰  T)
3. The simplified Round in the block header contains ActualMiningTimes = [T']
4. `ValidateConsensusBeforeExecution` runs but finds no validator checking that T' == T
5. `ProcessUpdateValue` executes and stores T' without validation
6. The manipulated timestamp T' is now permanently in state and will be used by `NeedToChangeTerm`, `IsTimeSlotPassed`, and other consensus functions

The proof is in the code inspection showing:
- No equality check exists between ActualMiningTime and Context.CurrentBlockTime
- Hash validation explicitly excludes ActualMiningTimes from comparison
- Direct state update occurs without timestamp validation

## Notes

This vulnerability represents a consensus timing integrity issue where miners can lie about when they actually produced blocks. While the block timestamp itself (Context.CurrentBlockTime) remains accurate and signed by the miner, the separate ActualMiningTime field stored in consensus state can be manipulated. This breaks the protocol's assumption that ActualMiningTime represents the true block production time, affecting consensus scheduling and term transition logic.

The severity is MEDIUM-HIGH rather than CRITICAL because:
- Single-miner impact is limited to time slot calculation distortion
- Term transition manipulation requires 2/3 miner collusion
- External monitoring could detect timestamp discrepancies
- No direct fund loss or token supply impact

However, the vulnerability does compromise core consensus timing guarantees and should be addressed to maintain protocol integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L92-98)
```csharp
        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L28-28)
```csharp
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L20-20)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
