# Audit Report

## Title
Missing Authorization Check in SetPrimaryTokenSymbol Allows Unauthorized Primary Token Configuration

## Summary
The `SetPrimaryTokenSymbol` function in the MultiToken contract lacks authorization validation, allowing any user to set the chain's primary token symbol when it remains uninitialized. This critical configuration controls transaction fee calculations and can be exploited to cause chain-wide denial of service or fee system manipulation.

## Finding Description

The `SetPrimaryTokenSymbol` function only validates that (1) the primary token hasn't been set yet, and (2) the provided symbol corresponds to an existing token, without verifying the caller's authority. [1](#0-0) 

This represents a critical inconsistency with other administrative functions in the same contract. Methods like `AddAddressToCreateTokenWhiteList` [2](#0-1) , `RemoveAddressFromCreateTokenWhiteList` [3](#0-2) , and `SetTokenIssuerAndOwnerModificationEnabled` [4](#0-3)  all properly implement authorization using `AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress)`.

The authorization helper method `AssertSenderAddressWith` validates that `Context.Sender` equals the required address, throwing an assertion error if unauthorized. [5](#0-4) 

The primary token symbol is intended to be set during genesis initialization: on the main chain by the Economic contract [6](#0-5) , or on side chains by TokenContractInitializationProvider. [7](#0-6) 

However, the initialization provider returns an empty method list if `initializationData` is null, leaving the primary token unset with no initialization calls. [8](#0-7) 

## Impact Explanation

The primary token symbol directly controls transaction size fee calculations. The fee charging logic uses `State.ChainPrimaryTokenSymbol.Value` to determine which token to charge for transaction size fees. [9](#0-8) 

Critically, if `State.ChainPrimaryTokenSymbol.Value` is null, the fee charging functions return success without charging any fees. [10](#0-9) [11](#0-10) 

An attacker who sets an arbitrary token as the primary token could:
1. **Break the fee system entirely**: Set a non-existent or zero-balance token, causing all transaction fee charges to fail and effectively halting the chain
2. **Enable fee manipulation**: Set a token they control to manipulate fee calculations and economic incentives
3. **Cause chain-wide DoS**: Make it impossible for legitimate users to pay transaction fees in the expected token

The impact severity is **CRITICAL** as it affects the entire chain's operability, economic model, and ability to process transactions.

## Likelihood Explanation

The exploit requires that `ChainPrimaryTokenSymbol` remains unset after chain initialization, which could occur if:
1. A side chain is deployed with null initialization configuration (initializationData is null) [12](#0-11) 
2. Genesis initialization fails or is interrupted before SetPrimaryTokenSymbol is called
3. The Economic contract initialization fails on the main chain
4. A test or development deployment skips proper initialization procedures

While production deployments should follow proper initialization sequences, the code provides no enforcement mechanism or authorization guard. The absence of an authorization check violates defensive programming principlesâ€”even if "proper configuration" is expected, critical functions must validate caller authority.

The attack complexity is **LOW**: once the precondition exists (unset primary token), an attacker needs only to call SetPrimaryTokenSymbol with any valid token symbol. The attack cost is minimal (one transaction), and while detection would be immediate, remediation could be impossible since the function can only be called once.

## Recommendation

Add authorization validation to the `SetPrimaryTokenSymbol` function to ensure only the Parliament controller can set the primary token symbol:

```csharp
public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
{
    AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
    Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");
    
    State.ChainPrimaryTokenSymbol.Value = input.Symbol;
    Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
    return new Empty();
}
```

This ensures consistency with other administrative functions and prevents unauthorized modification of this critical system parameter.

## Proof of Concept

```csharp
// Test scenario: SetPrimaryTokenSymbol called by unauthorized user
[Fact]
public async Task UnauthorizedUserCanSetPrimaryTokenSymbol()
{
    // Precondition: ChainPrimaryTokenSymbol is not set (null initialization)
    // This could happen if initializationData is null during deployment
    
    // Create a token that attacker will set as primary
    var maliciousToken = "ATTACK";
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = maliciousToken,
        TokenName = "Attack Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultSender,
        IsBurnable = true
    });
    
    // Attacker (any user) calls SetPrimaryTokenSymbol
    var attackerStub = GetTokenContractStub(Accounts[1].KeyPair);
    var result = await attackerStub.SetPrimaryTokenSymbol.SendAsync(new SetPrimaryTokenSymbolInput
    {
        Symbol = maliciousToken
    });
    
    // Verify the attack succeeded
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var primaryToken = await TokenContractStub.GetPrimaryTokenSymbol.CallAsync(new Empty());
    primaryToken.Value.ShouldBe(maliciousToken);
    
    // Now all transaction fees will be charged in ATTACK token
    // causing chain-wide DoS if users don't have this token
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L139-147)
```csharp
    public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
    {
        Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");

        State.ChainPrimaryTokenSymbol.Value = input.Symbol;
        Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L462-467)
```csharp
    public override Empty AddAddressToCreateTokenWhiteList(Address input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        State.CreateTokenWhiteListMap[input] = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L469-474)
```csharp
    public override Empty RemoveAddressFromCreateTokenWhiteList(Address input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        State.CreateTokenWhiteListMap.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L661-669)
```csharp
    public override Empty SetTokenIssuerAndOwnerModificationEnabled(SetTokenIssuerAndOwnerModificationEnabledInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input != null, "Invalid input.");

        State.TokenIssuerAndOwnerModificationDisabled.Value = !input.Enabled;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L170-173)
```csharp
    private void AssertSenderAddressWith(Address address)
    {
        Assert(Context.Sender == address, "Unauthorized behavior.");
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L66-68)
```csharp
        State.TokenContract.SetPrimaryTokenSymbol.Send(new SetPrimaryTokenSymbolInput
            { Symbol = input.NativeTokenSymbol });
    }
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L24-32)
```csharp
    public virtual List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        var methodList = new List<ContractInitializationMethodCall>();
        var initializationData = _tokenContractInitializationDataProvider.GetContractInitializationData();

        // For the main chain, we use the economic contract to initialize the token contract.
        // So no initialization methods are required in here.
        // But for the side chain, which has no economic contract, we need initialize token contract.
        if (initializationData != null)
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L85-92)
```csharp
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = chainPrimaryTokenInfo.Symbol
                    }.ToByteString()
                });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L28-32)
```csharp
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L58-62)
```csharp
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L385-385)
```csharp
        var symbolToPayTxFee = State.ChainPrimaryTokenSymbol.Value;
```
