# Audit Report

## Title
Miner Replacement Accepts Historical Candidates Without Current Stake Validation

## Summary
The miner replacement mechanism in AEDPoS consensus allows former candidates who have quit election and recovered their deposits to become miners by selecting replacements from historical term snapshots without validating current candidate status, active votes, or locked stake. This enables unauthorized parties to gain mining privileges and earn block rewards without any capital at risk, fundamentally breaking the economic security model.

## Finding Description

The vulnerability spans two contracts with a critical validation gap in the miner replacement flow:

**In the AEDPoS Consensus Contract:**

During round generation within the same term, the consensus contract calls the Election contract to identify evil miners and obtain replacement candidates. [1](#0-0) 

The returned alternative candidates are directly added to the current round's miner list by transferring the evil miner's consensus information to them, without any validation of current candidacy status or stake. [2](#0-1) 

**In the Election Contract:**

The `GetMinerReplacementInformation` method retrieves candidate data from a previous term snapshot rather than current state. [3](#0-2) 

The snapshot retrieval method `GetPreviousTermSnapshotWithNewestPubkey()` filters candidates only by checking if they are currently banned, with no validation of current candidate status or active votes. [4](#0-3) 

Alternative candidates are selected from this historical snapshot based on vote amounts recorded at the previous term's end. [5](#0-4) 

**Critical Gap - Snapshot Creation vs. Current State:**

Term snapshots are created at term end by iterating through all candidates and recording their vote amounts at that specific point in time. [6](#0-5) 

However, candidates can quit election during the subsequent term by calling `QuitElection()`, which sets their `IsCurrentCandidate` flag to false and returns their 100,000 ELF deposit. [7](#0-6) 

The constant value for the deposit is 100,000 ELF (100_000_00000000 with 8 decimals). [8](#0-7) 

**Why Existing Protections Fail:**

Mining permission validation only checks if a pubkey exists in the current round's `RealTimeMinersInformation` keys, with no validation of stake or candidate status. [9](#0-8) 

Once a pubkey is added to the miner list through the replacement mechanism, they can produce blocks without any further checks regarding their current stake, deposit, or candidacy status.

## Impact Explanation

**Consensus Security Breach:**
Unauthorized entities without any locked capital can become miners and participate in block production. This fundamentally violates the Proof-of-Stake security model where miners must have "skin in the game."

**Economic Exploitation:**
- Attackers earn mining rewards (distributed per block) without any capital at risk
- If the unauthorized miner misbehaves (double-signing, censorship, downtime), there is no stake to slash
- Legitimate miners have their rewards diluted by additional unauthorized participants

**Systemic Risk:**
- All token holders are affected through reward dilution
- Network security is compromised by miners with no economic incentive to act honestly
- The attack is undetectable on-chain as the miner appears legitimate in the miner list

This is **CRITICAL** severity because it allows complete bypass of the stake requirement that underpins the entire consensus security model. An attacker gains mining privileges, extracts economic value, and can potentially disrupt consensus without any deposit, locked tokens, or even active candidate registration.

## Likelihood Explanation

**Attack Complexity: LOW**

The attacker only needs to:
1. Register as a candidate in Term N (requires 100,000 ELF deposit)
2. Obtain sufficient votes to rank high (achievable through legitimate voting or vote buying)
3. Wait for Term N to end (predictable timing based on `State.TimeEachTerm.Value`)
4. Call `QuitElection()` in Term N+1 to recover the 100,000 ELF deposit
5. Wait for natural evil miner detection (occurs when miners miss their time slots)

**Preconditions: REALISTIC**

- Term transitions are deterministic and occur at regular intervals
- Evil miner detection is a built-in system feature that occurs naturally when miners fail to produce blocks
- Vote lock periods are finite (MinimumLockTime to MaximumLockTime), allowing votes to expire
- No special permissions or exploits required - only standard contract interactions

**Detection: DIFFICULT**

- The unauthorized miner appears identical to legitimate miners in the miner list
- No on-chain signals differentiate them from authorized miners
- The replacement occurs through normal consensus flow without anomalous transactions
- Monitoring would require off-chain tracking of candidate quit events correlated with subsequent miner replacements

**Overall Likelihood: HIGH** - All attack preconditions are achievable within normal system operation, and the attack can be executed repeatedly across multiple terms.

## Recommendation

Add current-state validation to the miner replacement selection process:

**In Election Contract (`ViewMethods.cs`):**

Modify `GetMinerReplacementInformation` or `GetPreviousTermSnapshotWithNewestPubkey` to filter candidates based on current state:

```csharp
// In GetPreviousTermSnapshotWithNewestPubkey or when selecting alternatives:
var bannedCandidates = snapshot.ElectionResult.Keys
    .Where(pubkey => IsPubkeyBanned(pubkey) || 
                     State.CandidateInformationMap[pubkey] == null ||
                     !State.CandidateInformationMap[pubkey].IsCurrentCandidate ||
                     State.CandidateVotes[pubkey] == null ||
                     State.CandidateVotes[pubkey].ObtainedActiveVotedVotesAmount == 0)
    .ToList();
```

This ensures that only candidates who:
1. Are not banned
2. Have current candidate information registered
3. Have `IsCurrentCandidate` set to true
4. Have active votes in the current term

can be selected as replacement miners.

**Alternative approach:**

Implement a minimum deposit requirement that must be maintained throughout the term, separate from the announcement deposit, to ensure all potential replacement candidates have stake at risk.

## Proof of Concept

```csharp
[Fact]
public async Task MinerReplacement_AcceptsQuitCandidateWithoutStake()
{
    // Setup: Register candidate in Term 1
    var candidateKeyPair = GenerateKeyPair();
    await RegisterCandidateAsync(candidateKeyPair, 100_000_00000000); // Locks 100k ELF
    
    // Get votes to rank high
    await VoteForCandidateAsync(candidateKeyPair.PublicKey, 1000000_00000000);
    
    // Term 1 ends - snapshot taken with candidate's votes
    await NextTermAsync();
    
    // Term 2 starts - candidate quits and recovers deposit
    await QuitElectionAsync(candidateKeyPair); // Recovers 100k ELF, IsCurrentCandidate = false
    
    // Verify candidate has no stake
    var candidateInfo = await GetCandidateInformationAsync(candidateKeyPair.PublicKey);
    Assert.False(candidateInfo.IsCurrentCandidate);
    
    // Evil miner is detected during Term 2
    var evilMinerPubkey = GetCurrentMiners()[0];
    await MarkMinerAsEvilAsync(evilMinerPubkey);
    
    // Trigger miner replacement
    await GenerateNextRoundAsync();
    
    // VULNERABILITY: Quit candidate becomes miner without stake
    var currentMiners = await GetCurrentMinersAsync();
    Assert.Contains(candidateKeyPair.PublicKey.ToHex(), currentMiners);
    
    // Verify the candidate can mine blocks and earn rewards
    await MineBlockAsAsync(candidateKeyPair);
    var rewards = await GetMinerRewardsAsync(candidateKeyPair.PublicKey);
    Assert.True(rewards > 0); // Earning rewards without any stake at risk
}
```

**Notes:**

The vulnerability exists because miner replacement relies on historical election snapshots rather than current candidate state. When a candidate quits election after a snapshot is taken, they remain eligible for selection as a replacement miner despite having no current stake, active votes, or even candidate status. This breaks the fundamental security assumption that all miners must have capital at risk, enabling unauthorized parties to extract mining rewards and potentially disrupt consensus without economic consequences.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-339)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L130-148)
```csharp
    private TermSnapshot GetPreviousTermSnapshotWithNewestPubkey()
    {
        var termNumber = State.CurrentTermNumber.Value.Sub(1);
        var snapshot = State.Snapshots[termNumber];
        if (snapshot == null) return null;
        var invalidCandidates = snapshot.ElectionResult.Where(r => r.Value <= 0).Select(r => r.Key).ToList();
        Context.LogDebug(() => $"Invalid candidates count: {invalidCandidates.Count}");
        foreach (var invalidCandidate in invalidCandidates)
        {
            Context.LogDebug(() => $"Invalid candidate detected: {invalidCandidate}");
            if (snapshot.ElectionResult.ContainsKey(invalidCandidate)) snapshot.ElectionResult.Remove(invalidCandidate);
        }

        if (!snapshot.ElectionResult.Any()) return snapshot;

        var bannedCandidates = snapshot.ElectionResult.Keys.Where(IsPubkeyBanned).ToList();
        Context.LogDebug(() => $"Banned candidates count: {bannedCandidates.Count}");
        if (!bannedCandidates.Any()) return snapshot;
        Context.LogDebug(() => "Getting snapshot and there's miner replaced during current term.");
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-363)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L459-479)
```csharp
    private void SavePreviousTermInformation(TakeElectionSnapshotInput input)
    {
        var snapshot = new TermSnapshot
        {
            MinedBlocks = input.MinedBlocks,
            EndRoundNumber = input.RoundNumber
        };

        if (State.Candidates.Value == null) return;

        foreach (var pubkey in State.Candidates.Value.Value)
        {
            var votes = State.CandidateVotes[pubkey.ToHex()];
            var validObtainedVotesAmount = 0L;
            if (votes != null) validObtainedVotesAmount = votes.ObtainedActiveVotedVotesAmount;

            snapshot.ElectionResult.Add(pubkey.ToHex(), validObtainedVotesAmount);
        }

        State.Snapshots[input.TermNumber] = snapshot;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-254)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
