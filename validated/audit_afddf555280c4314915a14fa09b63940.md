# Audit Report

## Title
Hex Case Mismatch in Pubkey Replacement Causes Active Miner Denial of Service

## Summary
The `RecordCandidateReplacement` method in the AEDPoS consensus contract accepts pubkey strings without normalizing hex case before storing them as dictionary keys in `RealTimeMinersInformation`. When a replaced miner attempts to retrieve consensus commands, the system converts their pubkey bytes to lowercase hex, causing a dictionary key mismatch if the replacement was stored with uppercase or mixed case. This prevents the affected miner from producing blocks.

## Finding Description

The vulnerability exists in the pubkey replacement flow between the Election and Consensus contracts:

**Root Cause:** The `RecordCandidateReplacement` method directly uses the `input.NewPubkey` string as a dictionary key without normalizing its hex case. [1](#0-0) 

The protobuf definition confirms both pubkeys are plain strings without case constraints: [2](#0-1) 

**Entry Point:** Candidate admins call `ReplaceCandidatePubkey`, which sends these user-provided strings to the consensus contract: [3](#0-2) 

**Failure Point:** When miners request consensus commands, the system converts their pubkey bytes to lowercase hex using `ToHex()`, then performs a case-sensitive dictionary lookup via `IsInMinerList()`: [4](#0-3) 

The `IsInMinerList` method performs case-sensitive string comparison: [5](#0-4) 

**Hex Conversion Guarantee:** The `ToHex()` method always produces lowercase hex characters ('a'-'f') for values 10-15: [6](#0-5) 

**Established Convention:** All initial miner list creation uses `ToHex()`, establishing lowercase as the expected format: [7](#0-6) 

**Exploit Scenario:**
1. A miner is currently active with lowercase pubkey "04abcd..." in `RealTimeMinersInformation`
2. Admin calls `ReplaceCandidatePubkey` with correctly-cased `OldPubkey` but uppercase `NewPubkey = "04EFGH..."`
3. The consensus contract's `RecordCandidateReplacement` removes the old key and adds the uppercase key
4. The replaced miner attempts to produce blocks by calling `GetConsensusCommand` with their new pubkey bytes
5. The system converts these bytes to lowercase "04efgh..." via `ToHex()`
6. Dictionary lookup fails because the key is stored as "04EFGH..." (uppercase)
7. Miner receives `InvalidConsensusCommand` and cannot produce blocks

## Impact Explanation

**Consensus Disruption:**
- The affected miner cannot retrieve valid consensus commands, completely preventing block production
- Network consensus capacity is reduced by one miner until remediation
- The miner loses all block rewards during the outage period
- If multiple miners are affected through repeated admin errors, network liveness could be severely impacted

**Affected Parties:**
- The miner whose pubkey was replaced with non-lowercase hex loses the ability to mine
- The blockchain network suffers reduced consensus participation and potentially slower block times
- Token holders may experience degraded network performance

**Severity Assessment:**
- **Medium Severity** - No direct fund theft but operational disruption to critical consensus mechanism
- Can be remediated by calling `ReplaceCandidatePubkey` again with correctly-cased hex strings
- Requires admin-level action to trigger, limiting attack surface
- Detection is immediate (miner fails to produce blocks) but may not be obvious to non-technical admins
- Impact scales linearly with number of affected miners

## Likelihood Explanation

**Triggering Conditions:**
- Requires being a candidate admin authorized to call `ReplaceCandidatePubkey` [8](#0-7) 
- Must provide new pubkey in non-lowercase format (uppercase or mixed case)
- No special cryptographic or timing knowledge required

**Attack Complexity:**
- Very low complexity: Single transaction with uppercase hex string
- No race conditions or complex state manipulation
- Deterministic outcome once executed

**Feasibility:**
- However, **no contract-level validation enforces lowercase hex**
- The `ByteArrayHelper.HexStringToByteArray` method accepts both uppercase and lowercase: [9](#0-8) 
- Manual API calls, CLI tools, or UI inputs could provide uppercase strings
- More likely to be accidental (admin copy-pasting from external source) than intentional

**Probability:**
- **Moderate likelihood** - Requires deviation from documented patterns but nothing prevents it
- Higher probability in production where admins may obtain hex strings from various sources
- Detection is immediate but root cause may not be obvious

## Recommendation

Add hex case normalization in the `RecordCandidateReplacement` method before using pubkey strings as dictionary keys:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    // Normalize hex case to lowercase
    var oldPubkey = input.OldPubkey?.ToLower();
    var newPubkey = input.NewPubkey?.ToLower();

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(oldPubkey)) return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[oldPubkey];
    realTimeMinerInformation.Pubkey = newPubkey;
    currentRound.RealTimeMinersInformation.Remove(oldPubkey);
    currentRound.RealTimeMinersInformation.Add(newPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == oldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = newPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = oldPubkey,
        NewPubkey = newPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Alternatively, add validation in `ReplaceCandidatePubkey` to enforce lowercase hex format before sending to the consensus contract.

## Proof of Concept

```csharp
[Fact]
public async Task HexCaseMismatch_CausesConsensusCommandFailure()
{
    // Setup: Create initial miner with lowercase pubkey
    var minerKeyPair = CryptoHelper.GenerateKeyPair();
    var lowercasePubkey = minerKeyPair.PublicKey.ToHex(); // lowercase by default
    
    // Initialize consensus with lowercase pubkey
    await InitializeConsensusWithMiner(lowercasePubkey);
    
    // Replace candidate pubkey with UPPERCASE version
    var uppercasePubkey = lowercasePubkey.ToUpper();
    var admin = GetCandidateAdmin(lowercasePubkey);
    
    var result = await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = lowercasePubkey,
            NewPubkey = uppercasePubkey // UPPERCASE
        });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Miner attempts to get consensus command
    var consensusCommand = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = minerKeyPair.PublicKey }); // bytes convert to lowercase
    
    // Assert: Miner receives InvalidConsensusCommand
    consensusCommand.ShouldBe(ConsensusCommandProvider.InvalidConsensusCommand);
    
    // Verify: Miner cannot produce blocks
    var canMine = await AEDPoSContractStub.IsCurrentMiner.CallAsync(
        Address.FromPublicKey(minerKeyPair.PublicKey));
    canMine.Value.ShouldBeFalse(); // Miner is blocked from consensus
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** protobuf/aedpos_contract.proto (L452-455)
```text
message RecordCandidateReplacementInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-181)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-27)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L22-29)
```csharp
            for (int bx = 0, cx = offset; bx < bytes.Length; ++bx, ++cx)
            {
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```
