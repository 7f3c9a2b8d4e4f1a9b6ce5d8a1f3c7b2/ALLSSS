# Audit Report

## Title
Referendum Organization Self-Modification Deadlock via Unreachable Thresholds and Inaccessible Whitelists

## Summary
The Referendum contract allows organizations to modify their own voting thresholds and proposer whitelists through proposals, but the validation logic does not verify that thresholds are achievable relative to token supply or that whitelist addresses are accessible. Once an organization sets impossible-to-meet thresholds or a whitelist containing only inaccessible addresses, it permanently loses governance capability with no recovery mechanism.

## Finding Description

The vulnerability exists in two organization self-modification functions that lack sufficient validation.

**ChangeOrganizationThreshold** allows threshold modification when called by the organization address itself (via released proposal). [1](#0-0) 

**ChangeOrganizationProposerWhiteList** allows whitelist modification under the same conditions. [2](#0-1) 

When a proposal is released, it executes via the virtual address mechanism, setting `Context.Sender` to the organization address. [3](#0-2) 

**Root Cause: Insufficient Validation**

The `Validate` function performs inadequate checks. [4](#0-3) 

This validation only ensures:
- Token symbol exists
- ProposerWhiteList is not empty (count > 0)
- `MinimalApprovalThreshold <= MinimalVoteThreshold`
- `MinimalApprovalThreshold > 0`
- Thresholds are non-negative

**Critical Missing Validations:**

1. **No Token Supply Feasibility Check**: The validation does not compare `MinimalVoteThreshold` or `MinimalApprovalThreshold` against the token's total or circulating supply. An organization could set `MinimalVoteThreshold = 10^18` for a token with only 10^6 total supply.

2. **No Whitelist Accessibility Check**: The validation only checks that the whitelist count is greater than zero via the `Empty()` helper. [5](#0-4)  It does not verify whether addresses have known private keys, are burn addresses, or belong to cooperative parties.

3. **Proposal Creation Requires Whitelisted Addresses**: Only whitelisted proposers can create proposals. [6](#0-5) 

4. **Proposal Release Requires Meeting Thresholds**: The `IsReleaseThresholdReached` function checks if vote counts meet the configured thresholds. [7](#0-6)  If `MinimalVoteThreshold` exceeds the token supply, this condition can never be satisfied.

**No Recovery Mechanism**: Unlike Parliament contract which has emergency response organizations [8](#0-7) , the Referendum contract provides no admin override, emergency function, or time-based reset capability. The only way to modify organization parameters is through the organization's own proposal process, creating an unbreakable deadlock when thresholds become unreachable.

**Attack Execution Path:**
1. Whitelisted proposer creates proposal calling `ChangeOrganizationThreshold` with unreachable thresholds
2. Proposal gets approved under current (valid) thresholds
3. Proposer calls `Release()` which verifies thresholds using OLD values
4. Release executes via `SendVirtualInlineBySystemContract` with organization address as sender
5. New thresholds are set and pass validation (no supply check performed)
6. All future proposals now require votes exceeding token supply
7. No proposal can ever reach `MinimalVoteThreshold`
8. Organization is permanently deadlocked

The same attack works for whitelists: setting a whitelist containing only inaccessible addresses prevents any future proposals from being created.

## Impact Explanation

**High Severity - Permanent Governance DoS**

The impact is severe because:

1. **Complete Loss of Function**: The affected organization loses 100% of governance capability permanently. No proposals can be created (if whitelist is inaccessible) or released (if thresholds are unreachable).

2. **Irreversible**: No recovery mechanism exists. The deadlock is permanent.

3. **Asset Freeze**: Any funds, permissions, or authority controlled by the organization become permanently inaccessible. If the organization manages protocol parameters, token minting rights, or treasury funds, these become frozen.

4. **Broad Impact**: Affects all stakeholders - token holders lose governance participation rights, contracts depending on the organization for configuration updates fail, and services managed by the organization become unmaintainable.

5. **Cascade Effects**: If the deadlocked organization manages critical system parameters (cross-chain indexing, consensus configuration, fee schedules), the entire protocol could be impacted.

## Likelihood Explanation

**Medium to High Likelihood**

The likelihood is elevated due to multiple realistic trigger scenarios:

**Accidental Misconfiguration (High Probability)**:
- Legitimate operators could easily make typos when entering threshold values (adding extra zeros: intending 1,000,000 but entering 1,000,000,000)
- Confusion about token decimals
- Copy-paste errors from different token contexts
- No warnings or safeguards during proposal creation
- Token holders may not carefully review technical threshold parameters in proposals

**Malicious Attack (Medium Probability)**:
- Requires attacker to be in proposer whitelist (moderate barrier)
- Must convince token holders to approve the malicious proposal (requires social engineering or obfuscation)
- However, thresholds can be hidden in complex multi-call proposals
- Disgruntled organization members with whitelist access could exploit during governance disputes

**Low Attack Complexity**:
- Only requires one successful proposal to pass
- No need for complex contract interactions or timing exploits
- Attack is deterministic once proposal is released

**No Detection Before Execution**:
- Current validation provides no warnings about unrealistic thresholds
- Token holders cannot easily verify threshold feasibility during voting
- No simulation or dry-run capability to detect the issue

## Recommendation

Add token supply validation checks in the `Validate` function in `Referendum_Helper.cs`:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol), "Token not exists.");
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // NEW: Check thresholds against token supply
    Assert(proposalReleaseThreshold.MinimalVoteThreshold <= tokenInfo.Supply, 
           "MinimalVoteThreshold exceeds token supply.");
    Assert(proposalReleaseThreshold.MinimalApprovalThreshold <= tokenInfo.Supply, 
           "MinimalApprovalThreshold exceeds token supply.");
    
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

Additionally, consider implementing:
1. An emergency recovery mechanism similar to Parliament's emergency response organization
2. Warning events when thresholds approach total supply
3. Whitelist validation to prevent setting whitelists with only zero addresses or known burn addresses

## Proof of Concept

```csharp
[Fact]
public async Task ReferendumOrganization_UnreachableThreshold_PermanentDeadlock_Test()
{
    // Setup: Create organization with initial valid thresholds
    var initialMinimalVoteThreshold = 5000;
    var organizationAddress = await CreateOrganizationAsync(
        initialMinimalVoteThreshold, 
        initialMinimalVoteThreshold, 
        10000, 10000, 
        new[] { DefaultSender });
    
    // Get token supply (from test base: 10000000_00000000 issued to DefaultSender)
    var tokenSupply = await GetBalanceAsync("ELF", DefaultSender);
    
    // Create proposal to change threshold to unreachable value (exceeding token supply)
    var unreachableThreshold = tokenSupply + 1_00000000;
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ToAddress = ReferendumContractAddress,
        ContractMethodName = nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        Params = new ProposalReleaseThreshold
        {
            MinimalVoteThreshold = unreachableThreshold,
            MinimalApprovalThreshold = unreachableThreshold,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        }.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1),
        Title = "Change Threshold",
        Description = "Test"
    };
    
    var proposalId = await ReferendumContractStub.CreateProposal.SendAsync(proposalInput);
    
    // Approve with sufficient votes under OLD threshold
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = await ReferendumContractStub.GetProposalVirtualAddress.CallAsync(proposalId.Output),
        Symbol = "ELF",
        Amount = initialMinimalVoteThreshold
    });
    await ReferendumContractStub.Approve.SendAsync(proposalId.Output);
    
    // Release proposal - this should succeed and set unreachable threshold
    var releaseResult = await ReferendumContractStub.Release.SendAsync(proposalId.Output);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify new threshold was set
    var updatedOrg = await ReferendumContractStub.GetOrganization.CallAsync(organizationAddress);
    updatedOrg.ProposalReleaseThreshold.MinimalVoteThreshold.ShouldBe(unreachableThreshold);
    
    // Now try to create and release a new proposal - it will be permanently stuck
    var newProposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    
    // Even with ALL available tokens voting, threshold cannot be reached
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = await ReferendumContractStub.GetProposalVirtualAddress.CallAsync(newProposalId),
        Symbol = "ELF",
        Amount = tokenSupply
    });
    await ReferendumContractStub.Approve.SendAsync(newProposalId);
    
    // Verify proposal cannot be released - threshold is unreachable
    var proposal = await ReferendumContractStub.GetProposal.CallAsync(newProposalId);
    proposal.ToBeReleased.ShouldBeFalse(); // Permanent deadlock confirmed
    
    // Attempting to release will fail
    var releaseAttempt = await ReferendumContractStub.Release.SendWithExceptionAsync(newProposalId);
    releaseAttempt.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseAttempt.TransactionResult.Error.ShouldContain("Not approved");
}
```

## Notes

This vulnerability is particularly dangerous because it can occur accidentally through simple human error (typos, decimal confusion) during normal governance operations. The lack of any recovery mechanism means that even a single mistake can permanently brick an organization's governance capabilities. Organizations managing critical protocol infrastructure would become permanently unmaintainable, and any assets or permissions they control would be irreversibly frozen.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L203-210)
```csharp
    public override Empty CreateEmergencyResponseOrganization(Empty input)
    {
        Assert(State.EmergencyResponseOrganizationAddress.Value == null,
            "Emergency Response Organization already exists.");
        AssertSenderAddressWith(State.DefaultOrganizationAddress.Value);
        CreateEmergencyResponseOrganization();
        return new Empty();
    }
```
