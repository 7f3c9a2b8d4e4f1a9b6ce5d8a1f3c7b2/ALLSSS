# Audit Report

## Title
Referendum Contract Allows Setting Unbounded MinimalVoteThreshold Leading to Permanent Governance Lockout

## Summary
The Referendum contract lacks upper bound validation for `MinimalVoteThreshold`, allowing organization thresholds to be set to unreachable values like `Int64.MaxValue`. This creates a permanent governance denial-of-service where no proposals can ever be released, with no recovery mechanism available. Parliament and Association contracts implement proper upper bounds, but Referendum does not.

## Finding Description

The vulnerability exists in the Referendum contract's threshold validation logic. The `Validate` method performs only relative checks between threshold parameters without enforcing any upper bound on `MinimalVoteThreshold`. [1](#0-0) 

An attacker can set both `MinimalVoteThreshold` and `MinimalApprovalThreshold` to `Int64.MaxValue`, which satisfies all validation conditions:
- `MinimalApprovalThreshold <= MinimalVoteThreshold` ✓
- `MinimalApprovalThreshold > 0` ✓  
- `MaximalAbstentionThreshold >= 0` ✓
- `MaximalRejectionThreshold >= 0` ✓

When proposals attempt to release, the `IsReleaseThresholdReached` method checks whether total votes meet the threshold. [2](#0-1) 

With `MinimalVoteThreshold` set to `Int64.MaxValue`, the condition can never be satisfied since realistic token supplies cannot reach this value, preventing all future proposals from being released.

**Critical Design Flaw - No Recovery Mechanism:**

The `ChangeOrganizationThreshold` function can only be called by the organization address itself. [3](#0-2) 

This requires executing through a released proposal via the virtual inline call mechanism. [4](#0-3) 

If no proposals can be released due to the unreachable threshold, the organization cannot fix its own thresholds, creating an unrecoverable state with no emergency override mechanism.

**Inconsistency with Other Governance Contracts:**

Parliament contract enforces upper bound using `AbstractVoteTotal` (value of 10000). [5](#0-4) [6](#0-5) 

Association contract enforces upper bound using organization member count. [7](#0-6) 

Referendum is the only governance contract missing this critical protection.

## Impact Explanation

**Severity: HIGH - Permanent Governance Denial-of-Service**

Once exploited, the organization's governance becomes permanently non-functional:

1. **Complete Governance Lockout**: All future proposals can never reach release threshold, preventing any governance actions including upgrades, parameter changes, or fund releases.

2. **Irreversible State**: The attack creates an unrecoverable state. Since `ChangeOrganizationThreshold` can only be called through a released proposal, and proposals cannot be released, there is no path to recovery. No emergency mechanisms exist for Referendum organizations (unlike Parliament which has emergency response organization).

3. **Systemic Impact**: All members of the affected organization lose governance rights permanently. If critical protocol operations are controlled by the affected Referendum organization, the entire protocol's ability to adapt becomes compromised.

4. **Design Vulnerability**: This represents a fundamental design flaw where token-based governance lacks the same safety bounds as member-based governance (Parliament/Association).

## Likelihood Explanation

**Likelihood: MEDIUM - Requires Governance Approval but Feasible**

**Attack Prerequisites:**
- Attacker must be in the organization's proposer whitelist
- Must successfully pass one malicious proposal through current voting thresholds

**Attack Complexity: LOW**
1. Create proposal calling `ChangeOrganizationThreshold` with extreme values
2. Pass proposal through normal voting (one-time requirement)
3. Release proposal
4. Organization is permanently locked

**Feasibility Factors:**
- **Social Engineering**: Attack can be disguised as "strengthening governance security requirements"
- **Insider Threat**: Single malicious whitelisted proposer can initiate
- **Economic Cost**: Only standard gas fees required
- **Detection**: Extreme values may not be immediately noticed until next proposal fails

While requiring proposal approval is a significant barrier (lowering likelihood from HIGH to MEDIUM), the combination of low cost, irreversible impact, and potential for social engineering makes this a realistic threat. The lack of upper bound validation is an objective security weakness compared to Parliament and Association contracts.

## Recommendation

Add upper bound validation to the Referendum contract's `Validate` method, consistent with Parliament and Association contracts. The upper bound should be based on realistic token supply or a reasonable maximum value.

Recommended fix in `Referendum_Helper.cs` `Validate` method:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    var maxRealisticThreshold = tokenInfo.Supply > 0 ? tokenInfo.Supply : long.MaxValue / 2;
    
    return proposalReleaseThreshold.MinimalVoteThreshold <= maxRealisticThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

Alternatively, use a fixed maximum like Parliament's `AbstractVoteTotal` approach with a normalized percentage-based threshold system.

## Proof of Concept

```csharp
[Fact]
public async Task ReferendumContract_UnboundedThreshold_CausesGovernanceLockout()
{
    // Setup: Create referendum organization with normal thresholds
    var createInput = new CreateOrganizationInput
    {
        TokenSymbol = "ELF",
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1000,
            MinimalVoteThreshold = 1000,
            MaximalAbstentionThreshold = 500,
            MaximalRejectionThreshold = 500
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { DefaultSender } }
    };
    
    var organizationAddress = await ReferendumContractStub.CreateOrganization.SendAsync(createInput);
    
    // Attack: Create proposal to set unbounded threshold
    var maliciousThreshold = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = long.MaxValue,
        MinimalVoteThreshold = long.MaxValue,
        MaximalAbstentionThreshold = 0,
        MaximalRejectionThreshold = 0
    };
    
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ToAddress = ReferendumContractAddress,
        ContractMethodName = nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        Params = maliciousThreshold.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    };
    
    var proposalId = await ReferendumContractStub.CreateProposal.SendAsync(proposalInput);
    
    // Approve and release malicious proposal
    await ApproveWithTokens(proposalId.Output, 1000);
    await ReferendumContractStub.Release.SendAsync(proposalId.Output);
    
    // Verify: Organization now has unbounded threshold
    var org = await ReferendumContractStub.GetOrganization.CallAsync(organizationAddress.Output);
    org.ProposalReleaseThreshold.MinimalVoteThreshold.ShouldBe(long.MaxValue);
    
    // Impact: Create new proposal - it can never be released
    var normalProposal = await ReferendumContractStub.CreateProposal.SendAsync(proposalInput);
    await ApproveWithTokens(normalProposal.Output, 1000000000); // Even with massive votes
    
    var proposalInfo = await ReferendumContractStub.GetProposal.CallAsync(normalProposal.Output);
    proposalInfo.ToBeReleased.ShouldBeFalse(); // Cannot be released - governance permanently locked!
    
    // Recovery attempt fails: Cannot change threshold back because no proposals can be released
    var shouldFail = ReferendumContractStub.Release.SendAsync(normalProposal.Output);
    await Assert.ThrowsAsync<Exception>(() => shouldFail);
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
