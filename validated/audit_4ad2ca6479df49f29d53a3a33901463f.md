# Audit Report

## Title
Negative LIB Height Bypasses Validation in NextRound, Causing Consensus DoS

## Summary
The AEDPoS consensus contract fails to validate that `ConfirmedIrreversibleBlockHeight` is non-negative during `NextRound` transitions. A malicious miner can inject negative LIB values into consensus state, causing all miners to be limited to producing only 1 block at a time, effectively performing a persistent denial-of-service attack on blockchain consensus.

## Finding Description

The vulnerability exists due to a missing validation step in the consensus validation framework that treats different consensus behaviors inconsistently.

**Root Cause**: The `NextRoundInput.Create()` method directly copies `ConfirmedIrreversibleBlockHeight` from the source round without any non-negativity validation. [1](#0-0)  The protobuf schema defines this field as `int64` (signed integer), allowing negative values. [2](#0-1) 

**Validation Gap**: The `ValidateBeforeExecution` method applies different validation providers based on consensus behavior type. For `NextRound` behavior, it only adds `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`, [3](#0-2)  while `UpdateValue` behavior correctly receives LIB validation through `LibInformationValidationProvider`. [4](#0-3) 

The `RoundTerminateValidationProvider` only validates round number incrementing and null InValues, not LIB height validity. [5](#0-4)  In contrast, `LibInformationValidationProvider` would catch negative values by checking if the LIB height decreases. [6](#0-5) 

**Execution Path**: When a malicious miner produces a block with `NextRound` behavior containing negative `ConfirmedIrreversibleBlockHeight`, validation occurs via `ValidateConsensusBeforeExecution`. [7](#0-6)  The validation passes because `LibInformationValidationProvider` is not applied. The consensus transaction executes via `ProcessConsensusInformation`, [8](#0-7)  which processes the NextRound and stores the corrupted round to state via `AddRoundInformation` without validation. [9](#0-8) 

## Impact Explanation

The negative LIB values cause critical malfunction in the consensus mechanism's block production throttling system.

**Direct Impact**: The `GetMaximumBlocksCount()` method reads the corrupted LIB round number from the current round. [10](#0-9)  The `BlockchainMiningStatusEvaluator` uses this to determine mining status. With a negative `libRoundNumber` (e.g., -1) and positive `currentRoundNumber` (e.g., 10), the condition `currentRoundNumber >= libRoundNumber + SevereStatusRoundsThreshold` becomes `10 >= -1 + 8`, which evaluates to TRUE, triggering `Severe` status. [11](#0-10)  This forces the method to return 1, limiting ALL miners to producing only 1 block at a time. [12](#0-11) 

**Persistence**: The negative value propagates to all future rounds because `GenerateNextRoundInformation` copies the LIB height forward without validation. [13](#0-12) 

This represents a severe denial-of-service attack on consensus. The blockchain's throughput is drastically reduced as miners are artificially limited to 1 block per time slot instead of the normal maximum (typically 8+ blocks). The entire network operates in a crippled state until manual intervention or chain recovery.

## Likelihood Explanation

**Attacker Prerequisites**: The attacker must be an active miner in the current miner list, verified by the `PreCheck` method. [14](#0-13) 

**Attack Feasibility**: The attack is straightforward to execute. An elected miner waits for their turn to produce a block with `NextRound` behavior, crafts consensus extra data with negative `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` values, and includes it in the block header. The block passes validation because `ValidateBeforeExecution` does not apply LIB validation for NextRound. The malicious round data is stored to state, and immediately `GetMaximumBlocksCount` returns 1, triggering the DoS. The negative values persist across all future rounds.

**Realistic Scenario**: Any elected miner can perform this attack with modified node software. There are no economic costs beyond normal block production. The attack does not require special state setup or coordination. Detection would occur through `IrreversibleBlockHeightUnacceptable` events and drastically reduced block production rate, but by then the damage is done and persists.

## Recommendation

Add `LibInformationValidationProvider` to the validation providers for `NextRound` behavior in the `ValidateBeforeExecution` method:

```csharp
case AElfConsensusBehaviour.NextRound:
    // Is sender's order of next round correct?
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    // Add LIB validation to prevent negative values
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

Alternatively, add explicit validation in `NextRoundInput.Create()` or `ProcessNextRound()` to ensure `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` are non-negative before storing to state.

## Proof of Concept

```csharp
[Fact]
public async Task NegativeLIBHeightCausesConsensusDoS()
{
    // Setup: Initialize consensus with normal round
    var initialMiners = GenerateMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Malicious miner crafts NextRound with negative LIB values
    var currentRound = await GetCurrentRound();
    var maliciousRound = GenerateNextRound(currentRound);
    maliciousRound.ConfirmedIrreversibleBlockHeight = -1;
    maliciousRound.ConfirmedIrreversibleBlockRoundNumber = -1;
    
    var maliciousInput = NextRoundInput.Create(maliciousRound, GenerateRandomNumber());
    
    // Validation should pass (vulnerability)
    var validationResult = await ValidateConsensusBeforeExecution(
        new AElfConsensusHeaderInformation
        {
            Round = maliciousRound,
            Behaviour = AElfConsensusBehaviour.NextRound,
            SenderPubkey = initialMiners[0].PublicKey
        });
    
    Assert.True(validationResult.Success); // Passes due to missing LibInformationValidationProvider
    
    // Execute NextRound with malicious data
    await ExecuteNextRound(maliciousInput);
    
    // Verify DoS: GetMaximumBlocksCount returns 1
    var maxBlocksCount = await GetMaximumBlocksCount();
    Assert.Equal(1, maxBlocksCount); // Confirms DoS condition
    
    // Verify persistence: negative value propagates to next round
    var nextRound = await GetCurrentRound();
    Assert.Equal(-1, nextRound.ConfirmedIrreversibleBlockHeight);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-16)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
```

**File:** protobuf/aedpos_contract.proto (L472-472)
```text
    int64 confirmed_irreversible_block_height = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L37-39)
```csharp
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-26)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```
