# Audit Report

## Title
Solitary Miner Detection Logic Error Causes False Positive and Potential Chain Halt

## Summary
The `SolitaryMinerDetection()` function contains a critical logic error that incorrectly blocks legitimate miners at the start of new consensus rounds. The function checks if `GetMinedMiners()` returns an empty list and treats this as evidence of solitary mining, but at the start of every new round all miners have `SupposedOrderOfNextRound = 0` by default, causing the method to always return empty. When combined with a network partition scenario where only one miner was operational in the previous two rounds, this causes a false positive that blocks the operational miner from producing blocks, potentially halting the entire chain.

## Finding Description

The vulnerability exists in the `SolitaryMinerDetection()` private method which is invoked before any consensus behavior is determined. [1](#0-0) 

The root cause occurs where `isAlone` is set to true when `GetMinedMiners()` returns zero miners. [2](#0-1) 

The `GetMinedMiners()` method filters miners based on whether their `SupposedOrderOfNextRound` field is non-zero. [3](#0-2) 

When a new round is created via `GenerateNextRoundInformation()`, new `MinerInRound` objects are instantiated without explicitly setting the `SupposedOrderOfNextRound` field. [4](#0-3) 

Since `SupposedOrderOfNextRound` is defined as `int32` in the protobuf definition, it defaults to 0 when not explicitly set. [5](#0-4) 

The `SupposedOrderOfNextRound` field is only set to a non-zero value when a miner produces a block and the value is processed through `ProcessUpdateValue()`. [6](#0-5) 

The value is calculated during block production via `ApplyNormalConsensusData()` using the miner's signature hash. [7](#0-6) 

**Why existing protections fail:**

The logic error treats two fundamentally different states identically:
1. "No one has mined yet in the current round" (empty list at round start)
2. "Only this miner is actively mining" (legitimate solitary mining detection)

At the start of any new round, before any miner produces a normal block, `GetMinedMiners()` will always return an empty list because all `SupposedOrderOfNextRound` values are 0. The subsequent checks validate that only this specific miner mined in the previous 2 rounds, but this doesn't confirm the miner is currently mining alone—it only confirms past behavior during a network partition period. [8](#0-7) 

## Impact Explanation

**Harm:** Complete consensus halt (DoS) preventing any block production across the entire blockchain network.

**Scenario:**
1. During rounds N-2 and N-1, a network partition or infrastructure failure causes only MinerA to successfully produce blocks while other miners are offline or partitioned
2. MinerA produces a NextRound block to transition to round N via `ProcessNextRound()` [9](#0-8) 
3. The new round N is created with all miners having `SupposedOrderOfNextRound = 0`
4. MinerA attempts to produce the first normal block in round N
5. When the public `GetConsensusCommand()` is called [10](#0-9) , `SolitaryMinerDetection()` checks the current round and finds `GetMinedMiners()` returns empty
6. The function incorrectly concludes MinerA is mining alone and returns true, causing `GetConsensusCommand()` to return `InvalidConsensusCommand` [11](#0-10) 
7. MinerA is now blocked from producing blocks
8. If the network partition persists and other miners remain offline, no miner can produce blocks
9. The chain halts completely until manual intervention or network recovery

**Who is affected:** The entire blockchain network—all users, dApps, validators, and any services depending on the chain lose access to a functioning blockchain. Transactions cannot be processed, state cannot be updated, and the network becomes completely unavailable.

**Severity justification:** HIGH - This is a critical operational DoS vulnerability affecting consensus availability. While it requires specific preconditions (sustained network partition affecting all but one miner for 2+ rounds), such conditions are realistic in distributed systems. The impact is catastrophic—complete chain halt with no automatic recovery mechanism.

## Likelihood Explanation

**Attacker capabilities:** No malicious attacker is required—this vulnerability triggers automatically through natural network conditions and operational failures.

**Preconditions:**
- Multi-miner network with more than 2 miners and chain past round 3 [12](#0-11) 
- Network partition, infrastructure failure, or synchronized miner downtime affecting all but one miner for 2 consecutive rounds
- The operational miner continues to be the only one available at the start of the next round

**Execution practicality:** The vulnerability triggers automatically through the normal consensus flow when a miner requests a consensus command via the public `GetConsensusCommand()` method. There is no special action required—the solitary detection runs before any block is produced in the new round as part of the standard consensus command generation process.

**Feasibility conditions:** Network partitions, infrastructure failures, and coordinated miner downtime are documented occurrences in distributed blockchain systems. While a partition affecting all but one miner for 2+ consecutive rounds is not frequent, it is realistic enough to represent a genuine operational risk. The probability is MEDIUM—not common but plausible enough to warrant serious concern given the catastrophic impact.

## Recommendation

The `SolitaryMinerDetection()` logic should be modified to avoid checking the current round at the start before any miner has produced a block. The detection should either:

1. **Skip current round check entirely**: Only examine the previous 2 rounds to determine if the miner was alone historically, without checking the current round which will always be empty at round start.

2. **Add temporal check**: Only perform the current round check after sufficient time has passed for at least one miner's time slot, ensuring the empty list represents actual solitary mining rather than normal round initialization.

3. **Check for round age**: Verify that the current round has progressed beyond its first block before using an empty `GetMinedMiners()` result as evidence of solitary mining.

**Recommended fix:**
```csharp
private bool SolitaryMinerDetection(Round currentRound, string pubkey)
{
    var isAlone = false;
    // Skip this detection until 4th round.
    if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
    {
        // Check ONLY previous rounds, not the current round which may be empty at start
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            var minedMiners = previousRound.GetMinedMiners();
            isAlone = minedMiners.Count == 1 &&
                      minedMiners.Select(m => m.Pubkey).Contains(pubkey);
        }

        // check one further round.
        if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                out var previousPreviousRound))
        {
            var minedMiners = previousPreviousRound.GetMinedMiners();
            isAlone = minedMiners.Count == 1 &&
                      minedMiners.Select(m => m.Pubkey).Contains(pubkey);
        }
    }

    return isAlone;
}
```

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario that simulates a network partition:

```csharp
[Fact]
public async Task SolitaryMinerDetection_FalsePositive_At_RoundStart_Test()
{
    // Setup: Initialize blockchain with multiple miners
    InitializeContracts();
    
    // Round 1-3: Normal operation to pass the round 3 threshold
    await BootstrapAndMineRounds(3);
    
    // Round 4-5: Simulate network partition - only MinerA produces blocks
    var minerA = InitialCoreDataCenterKeyPairs[0];
    KeyPairProvider.SetKeyPair(minerA);
    
    // MinerA produces all blocks in round 4
    await ProduceRoundWithSingleMiner(minerA, 4);
    
    // MinerA produces all blocks in round 5  
    await ProduceRoundWithSingleMiner(minerA, 5);
    
    // MinerA produces NextRound block to transition to round 6
    await ProduceNextRoundBlock(minerA);
    
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RoundNumber.ShouldBe(6);
    
    // At start of round 6, before anyone mines, GetMinedMiners returns empty
    var minedMiners = currentRound.GetMinedMiners();
    minedMiners.Count.ShouldBe(0); // All SupposedOrderOfNextRound are 0
    
    // MinerA attempts to get consensus command for first block of round 6
    KeyPairProvider.SetKeyPair(minerA);
    var triggerForCommand = TriggerInformationProvider.GetTriggerInformationForConsensusCommand(new BytesValue());
    var consensusCommand = await AEDPoSContractStub.GetConsensusCommand.CallAsync(triggerForCommand);
    
    // VULNERABILITY: MinerA receives InvalidConsensusCommand despite being legitimate
    var hint = AElfConsensusHint.Parser.ParseFrom(consensusCommand.Hint);
    hint.Behaviour.ShouldBe(AElfConsensusBehaviour.Nothing); // Blocked from mining
    consensusCommand.ArrangedMiningTime.Seconds.ShouldBe(int.MaxValue); // Effectively infinite delay
    
    // Result: Chain cannot progress if network partition persists
}
```

## Notes

This vulnerability represents a fundamental flaw in the solitary miner detection algorithm where temporal state (round initialization) is confused with network state (actual solitary mining). The detection mechanism was designed to prevent a single miner from dominating the network during partitions, but the implementation creates a false positive at every round boundary when the previous rounds showed legitimate solitary mining conditions.

The fix requires careful consideration to maintain the intended safety property (preventing true solitary mining) while avoiding the false positive at round initialization. The recommended solution of checking only previous rounds maintains the safety property while eliminating the timing-dependent false positive.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L23-24)
```csharp
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L70-70)
```csharp
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L74-75)
```csharp
            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L78-92)
```csharp
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** protobuf/aedpos_contract.proto (L288-288)
```text
    int32 supposed_order_of_next_round = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-24)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusCommandProvider.cs (L23-30)
```csharp
        public static ConsensusCommand InvalidConsensusCommand => new()
        {
            ArrangedMiningTime = new Timestamp { Seconds = int.MaxValue },
            Hint = ByteString.CopyFrom(new AElfConsensusHint
            {
                Behaviour = AElfConsensusBehaviour.Nothing
            }.ToByteArray())
        };
```
