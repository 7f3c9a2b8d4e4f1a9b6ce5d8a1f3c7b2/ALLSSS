# Audit Report

## Title
Late UpdateValue Transaction Can Corrupt Next Round Mining Schedule

## Summary
The `ProcessUpdateValue` method fails to validate the `round_id` field in `UpdateValueInput`, allowing late transactions from previous rounds to corrupt mining order calculations for subsequent rounds. This enables miners to manipulate their position in future rounds or falsely appear as having mined in rounds where they did not participate.

## Finding Description

The vulnerability exists in the consensus round update flow where the `round_id` field, explicitly documented for round validation, is never checked.

**Root Cause:**

The `UpdateValueInput` message includes a `round_id` field documented as "To ensure the values to update will be apply to correct round by comparing round id." [1](#0-0) 

This field is properly set when the input is created [2](#0-1) 

However, `ProcessUpdateValue` retrieves the current round from storage and directly updates it without validating that the input's `round_id` matches the current round number [3](#0-2) 

**Attack Flow:**

1. During normal block production, `ApplyNormalConsensusData` calculates `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` based on the miner's signature [4](#0-3) 

2. If the extra block producer calls `NextRound` before the `UpdateValue` transaction is processed, the round advances to Round N+1

3. When the late `UpdateValue` transaction executes, it updates Round N+1 instead of Round N, setting the miner's mining participation indicators in the wrong round [5](#0-4) 

4. When `GenerateNextRoundInformation` creates Round N+2, it identifies miners who mined in Round N+1 by checking `SupposedOrderOfNextRound != 0` [6](#0-5) 

5. The attacker's miner is incorrectly included as having mined in Round N+1, and their `FinalOrderOfNextRound` determines their position in Round N+2 [7](#0-6) 

**Why Existing Protections Fail:**

- `UpdateValueValidationProvider` only validates OutValue, Signature, and PreviousInValue - not round_id [8](#0-7) 

- `PreCheck` only verifies the miner is in the current or previous round's miner list [9](#0-8) 

- `EnsureTransactionOnlyExecutedOnceInOneBlock` prevents multiple consensus transactions per block but not stale transactions from previous rounds [10](#0-9) 

## Impact Explanation

**Consensus Schedule Manipulation:** An attacker can manipulate the mining schedule by injecting false mining participation records into rounds where they did not mine, directly violating consensus integrity.

**Specific Harms:**
1. **False Mining Records**: Miners appear to have mined in rounds where they didn't participate, affecting reward calculations
2. **Position Manipulation**: Attackers influence their mining position in future rounds through fraudulent `FinalOrderOfNextRound` values
3. **Schedule Disruption**: Legitimate miners' expected positions are displaced by corrupted order calculations
4. **Compounding Effect**: Repeated exploitation across multiple rounds leads to sustained mining schedule manipulation

**Severity**: This breaks the fundamental consensus invariant that mining schedules must reflect actual mining participation.

## Likelihood Explanation

**High Exploitability:**

1. **Entry Point**: Any authorized miner can call the public `UpdateValue` method [11](#0-10) 

2. **Natural Timing Window**: The race condition occurs when network latency delays UpdateValue transaction inclusion and NextRound executes first

3. **Minimal Requirements**: Only requires being an authorized miner - no special privileges needed

4. **Intentional Exploitation**: A malicious miner can deliberately delay broadcasting their UpdateValue transaction until after the round transition

5. **Detection Difficulty**: The transaction passes all existing validations and executes successfully

**Probability**: MEDIUM-HIGH - Natural network conditions create the vulnerability window, and malicious actors can deliberately engineer the timing.

## Recommendation

Add round_id validation in `ProcessUpdateValue`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Validate round_id matches current round
    Assert(updateValueInput.RoundId == currentRound.RoundNumber, 
        "UpdateValue transaction round_id does not match current round.");
    
    // ... rest of the method
}
```

This ensures UpdateValue transactions only apply to the round they were generated for, preventing stale consensus data from corrupting future rounds.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Initialize a consensus round (Round N) with multiple miners
2. Have Miner A produce a block and generate an UpdateValue transaction for Round N
3. Have the extra block producer call NextRound, advancing to Round N+1
4. Execute Miner A's delayed UpdateValue transaction (with round_id=N) against Round N+1
5. Verify that Miner A's SupposedOrderOfNextRound is set in Round N+1 despite not mining in that round
6. Show that GenerateNextRoundInformation for Round N+2 incorrectly includes Miner A based on the corrupted Round N+1 data

### Citations

**File:** protobuf/aedpos_contract.proto (L199-200)
```text
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L40-40)
```csharp
            RoundId = RoundIdForValidation,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-260)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-100)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
```
