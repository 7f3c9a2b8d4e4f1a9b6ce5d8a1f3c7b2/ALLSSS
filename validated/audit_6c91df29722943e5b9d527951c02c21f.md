# Audit Report

## Title
Emergency Response Organization Thresholds Require Higher Than Intended Approval Rate Due to Integer Rounding

## Summary
The emergency response organization's hardcoded 9000 threshold (intended as 90%) combined with integer arithmetic in the approval check formula results in requiring 94.12% approval for the default 17-member parliament, and 100% for parliaments with fewer than 10 members. This design flaw reduces fault tolerance and degrades the system's ability to respond to security emergencies.

## Finding Description

The emergency response organization is created with hardcoded thresholds where MinimalApprovalThreshold and MinimalVoteThreshold are both set to 9000, intended to represent 90% approval. [1](#0-0) 

The threshold system uses fixed-point arithmetic where AbstractVoteTotal = 10000 represents 100%. [2](#0-1) 

The approval check uses integer comparison that creates unintended ceiling behavior: [3](#0-2) 

**Root Cause:** The formula `approvedMemberCount * 10000 >= 9000 * parliamentMembers.Count` requires integer values for approvedMemberCount. For 17 members, this evaluates to `approvedMemberCount * 10000 >= 153000`, requiring `approvedMemberCount >= 15.3`. Since only integers are valid, this rounds up to 16 approvals (94.12%), not 15 (88.24%).

**Mathematical Analysis:**
- **17 members (production default)**: Requires 16/17 = 94.12% instead of intended 90%
- **9 members**: Requires 9/9 = 100% instead of intended 90%  
- **10 members**: Requires 9/10 = 90% ✓ (works correctly only when count divides evenly)

The default production parliament consists of 17 miners: [4](#0-3) 

Parliament members are retrieved from the current miner list: [5](#0-4) 

The organization validation method only checks threshold sum constraints, not the actual effective percentage behavior: [6](#0-5) 

**Cannot Self-Correct:** Changing an organization's thresholds requires the organization itself to approve the change via ChangeOrganizationThreshold, which requires Context.Sender to be the organization address: [7](#0-6) 

This creates a circular dependency: fixing the broken threshold requires approval under the broken threshold.

The emergency organization can only be created once: [8](#0-7) 

## Impact Explanation

**High Severity - Governance Availability Degradation**

The emergency response organization is the exclusive authority for removing malicious nodes via RemoveEvilNode: [9](#0-8) 

**Concrete Harms:**

1. **Reduced Fault Tolerance (17-member default)**: The 94.12% actual requirement vs 90% intended means only 1 member can be offline/dissenting instead of ~1.7 members. If 2 miners (11.8%) are unavailable during an emergency, security responses fail despite having 88.2% support.

2. **Unanimous Requirement (small parliaments)**: Parliaments with fewer than 10 members require 100% approval, creating single points of failure where one offline node blocks all emergency actions.

3. **Emergency Response Delays**: During active security incidents requiring rapid malicious node removal, the inflated threshold increases coordination requirements and may allow attackers to remain active longer than the governance design intended.

4. **Irreversible Without Hard Fork**: The circular dependency (requiring broken-threshold approval to fix thresholds) combined with the single-creation constraint means this cannot be corrected through normal governance, requiring a network upgrade.

**Affected Parties:**
- Network operators responding to security incidents
- Honest miners attempting to remove compromised nodes  
- Overall blockchain security during active attacks

## Likelihood Explanation

**Certainty: Deterministic (100%)**

This is a mathematical design flaw, not a conditional attack scenario.

**Triggering Conditions:**
- Manifests automatically when the emergency organization is created
- Default 17-member parliament configuration guarantees 94.12% effective requirement
- No attacker action required
- No special preconditions beyond normal chain operation

**Concrete Scenario:**  
A mining node is compromised and begins malicious behavior. The emergency response organization initiates a proposal to call RemoveEvilNode. Of the 17 parliament members, 15 vote to approve (88.2% support - exceeding the intended 90% when accounting for one compromised node). However, the proposal fails because the formula requires 16 approvals (94.12%). The compromised node remains active, continuing malicious activity that should have been halted under the intended governance threshold.

## Recommendation

Replace the integer comparison formula with proper percentage calculation that uses floor behavior for the minimum required approvals:

```csharp
// Calculate minimum required approvals with proper rounding
var minimumRequiredApprovals = (organization.ProposalReleaseThreshold.MinimalApprovalThreshold * parliamentMembers.Count + AbstractVoteTotal - 1) / AbstractVoteTotal;
var isApprovalEnough = approvedMemberCount >= minimumRequiredApprovals;
```

For the specific case of 9000 threshold with 17 members, this would correctly require `(9000 * 17 + 9999) / 10000 = 162999 / 10000 = 16.2999` → 16 approvals, but the formula should be adjusted to achieve the intended 90% which is `(9000 * 17) / 10000 = 15.3` → **15 approvals** (88.2%).

The correct fix is:

```csharp
var minimumRequiredApprovals = (organization.ProposalReleaseThreshold.MinimalApprovalThreshold * parliamentMembers.Count) / AbstractVoteTotal;
if ((organization.ProposalReleaseThreshold.MinimalApprovalThreshold * parliamentMembers.Count) % AbstractVoteTotal != 0)
    minimumRequiredApprovals++;
var isApprovalEnough = approvedMemberCount > minimumRequiredApprovals || 
    (approvedMemberCount == minimumRequiredApprovals && 
     (organization.ProposalReleaseThreshold.MinimalApprovalThreshold * parliamentMembers.Count) % AbstractVoteTotal == 0);
```

Or more simply, use true percentage calculation:
```csharp
var isApprovalEnough = approvedMemberCount * AbstractVoteTotal > 
    organization.ProposalReleaseThreshold.MinimalApprovalThreshold * parliamentMembers.Count ||
    (approvedMemberCount * AbstractVoteTotal == 
     organization.ProposalReleaseThreshold.MinimalApprovalThreshold * parliamentMembers.Count);
```

However, the existing `>=` should be changed to `>` and threshold adjusted, or the threshold should account for this rounding (e.g., use 8824 for true 90% with 17 members: `15 * 10000 >= 8824 * 17`).

## Proof of Concept

The mathematical proof demonstrates the issue deterministically without requiring a running test:

**For 17 members with 9000 threshold:**
- Formula: `approvedMemberCount * 10000 >= 9000 * 17`
- Evaluates to: `approvedMemberCount * 10000 >= 153000`
- Requires: `approvedMemberCount >= 15.3`
- Integer constraint forces: `approvedMemberCount >= 16`
- Actual percentage: `16/17 = 0.9411764706 = 94.12%`
- **Gap from intended 90%: +4.12 percentage points**

**For 9 members with 9000 threshold:**
- Formula: `approvedMemberCount * 10000 >= 81000`  
- Requires: `approvedMemberCount >= 8.1`
- Integer constraint forces: `approvedMemberCount >= 9`
- Actual percentage: `9/9 = 100%`
- **Gap from intended 90%: +10 percentage points**

The vulnerability is confirmed by code inspection of the threshold creation and approval logic across the cited files.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L83-88)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-159)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L203-210)
```csharp
    public override Empty CreateEmergencyResponseOrganization(Empty input)
    {
        Assert(State.EmergencyResponseOrganizationAddress.Value == null,
            "Emergency Response Organization already exists.");
        AssertSenderAddressWith(State.DefaultOrganizationAddress.Value);
        CreateEmergencyResponseOrganization();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-350)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
```
