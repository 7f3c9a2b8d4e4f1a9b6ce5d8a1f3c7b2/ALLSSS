# Audit Report

## Title
Scheme Overwriting Causes Permanent Token Lock Due to Symbol Mismatch

## Summary
The TokenHolder contract's `CreateScheme` method allows overwriting an existing scheme without validation, causing users who locked tokens under the original scheme to permanently lose access to their funds. When users attempt to withdraw, the contract queries for locked amounts using the new scheme's symbol instead of the original symbol, resulting in a transaction revert and making the tokens irrecoverable.

## Finding Description

The vulnerability occurs due to a critical mismatch between the token symbol used during lock and unlock operations across three contract methods:

**Root Cause - Scheme Overwriting:**
The `CreateScheme` method directly overwrites the scheme data stored at `State.TokenHolderProfitSchemes[Context.Sender]` without any validation to prevent duplicate calls or check for existing user registrations. [1](#0-0) 

**Lock Operation - Original Symbol:**
When users call `RegisterForProfits`, tokens are locked using the current scheme's symbol. The lock ID is generated deterministically based only on manager and user addresses, making it identical across different schemes with the same manager. [2](#0-1) 

The MultiToken contract's `Lock` method transfers tokens from the user to a virtual address computed from the lock ID. [3](#0-2) 

**Withdraw Operation - New Symbol:**
When users call `Withdraw` after the scheme has been overwritten, the contract retrieves the current (new) scheme and uses its symbol to query locked amounts. [4](#0-3) 

**Symbol Mismatch in GetLockedAmount:**
The `GetLockedAmount` method queries the balance of a specific symbol at the virtual address. Since tokens were locked with the original symbol (e.g., "ELF") but the query uses the new symbol (e.g., "USDT"), it returns zero. [5](#0-4) 

**Transaction Revert:**
The withdraw operation attempts to unlock zero tokens, which fails validation in `AssertValidSymbolAndAmount` that requires `amount > 0`. [6](#0-5)  This causes the entire transaction to revert, leaving `State.LockIds[manager][user]` intact.

**No Recovery Path:**
- Users cannot retry `Withdraw` (same revert occurs)
- Users cannot call `RegisterForProfits` again (fails the "Already registered" check) [7](#0-6) 
- The manager cannot unlock tokens (no such method exists)
- Tokens remain permanently locked at the virtual address

## Impact Explanation

This is **HIGH severity** due to:

1. **Complete Fund Loss**: Users lose 100% of their locked tokens with no possibility of recovery
2. **Multiple Users Affected**: All users who registered before the scheme overwrite are simultaneously impacted
3. **No Administrative Recovery**: Neither users nor managers have any mechanism to rescue the locked funds
4. **Protocol Invariant Break**: Violates the fundamental contract guarantee that users can withdraw locked tokens after the minimum lock period expires

The locked tokens remain at the virtual address indefinitely, completely inaccessible to all parties. This represents a direct, permanent loss of user funds.

## Likelihood Explanation

This vulnerability is **HIGHLY LIKELY** to occur because:

1. **Public Entry Point**: `CreateScheme` is a public method accessible to any address [8](#0-7) 

2. **Simple Trigger**: Requires only two calls to `CreateScheme` by the same manager address - no complex state manipulation needed

3. **Accidental Scenario**: A manager might innocently call `CreateScheme` twice thinking they're "updating" scheme parameters (changing symbol or lock duration), without realizing this will brick all existing user deposits

4. **Malicious Scenario**: A malicious manager can intentionally lock user funds to prevent withdrawals, gaining exclusive access to profit distributions

5. **No Warnings**: The contract provides no warnings or checks that would alert the manager about existing user registrations before overwriting

## Recommendation

Implement one of the following fixes:

**Option 1 - Prevent Scheme Overwriting:**
```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists. Cannot overwrite existing scheme.");
    
    // ... rest of the method
}
```

**Option 2 - Store Original Lock Symbol:**
Modify the state to persist the symbol used during lock:
```csharp
// In TokenHolderContractState.cs
public MappedState<Hash, string> LockSymbols { get; set; }

// In RegisterForProfits
State.LockSymbols[lockId] = scheme.Symbol;

// In Withdraw
var originalSymbol = State.LockSymbols[lockId];
var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
{
    Address = Context.Sender,
    LockId = lockId,
    Symbol = originalSymbol  // Use original symbol, not current scheme's symbol
}).Amount;
```

**Option 3 - Allow Scheme Updates Without Overwriting:**
Create a separate `UpdateScheme` method that only modifies certain parameters (like `MinimumLockMinutes`) without changing the token symbol, and prevent `CreateScheme` from being called twice by the same address.

## Proof of Concept

```csharp
// Test demonstrating permanent token lock vulnerability
[Fact]
public async Task SchemeOverwrite_CausesPermanentTokenLock()
{
    // Setup: Manager creates initial scheme with ELF token
    var manager = Accounts[0].Address;
    var user = Accounts[1].Address;
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1000
    });
    
    // User registers and locks 10,000 ELF tokens
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = 10000
    });
    
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 10000
    });
    
    // Verify tokens are locked
    var userBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = user,
        Symbol = "ELF"
    });
    Assert.Equal(0, userBalance.Balance); // Tokens moved to virtual address
    
    // Manager overwrites scheme with USDT token
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 10
    });
    
    // Advance time past minimum lock period
    await AdvanceTime(1001);
    
    // User attempts to withdraw - TRANSACTION REVERTS
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(manager);
    
    // Assert transaction failed with "Invalid amount" error
    Assert.Contains("Invalid amount", withdrawResult.TransactionResult.Error);
    
    // Verify tokens are still locked and user cannot recover them
    var finalBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = user,
        Symbol = "ELF"
    });
    Assert.Equal(0, finalBalance.Balance); // Tokens permanently locked
    
    // Verify user cannot re-register (Already registered error)
    var reRegisterResult = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            SchemeManager = manager,
            Amount = 5000
        });
    Assert.Contains("Already registered", reRegisterResult.TransactionResult.Error);
    
    // RESULT: 10,000 ELF tokens are permanently locked with no recovery mechanism
}
```

## Notes

The vulnerability is exacerbated by the fact that the `UpdateTokenHolderProfitScheme` method retrieves the first scheme ID from the Profit contract using `GetManagingSchemeIds().FirstOrDefault()`, meaning profit distribution operations still reference the original scheme while token operations use the overwritten symbol. [9](#0-8)  This creates an inconsistent state where users are beneficiaries of the correct profit scheme but cannot unlock their tokens due to the symbol mismatch.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L151-151)
```csharp
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-166)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L213-225)
```csharp
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-298)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```
