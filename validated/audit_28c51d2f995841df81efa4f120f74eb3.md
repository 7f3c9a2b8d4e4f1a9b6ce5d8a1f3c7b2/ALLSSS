# Audit Report

## Title
Missing Election Results Validation in NextTerm Allows Current Miners to Bypass Elections and Retain Mining Authority

## Summary
The `NextTerm` method in AEDPoSContract lacks on-chain validation to ensure the miner list in `NextTermInput` matches election results from `GetVictories`. A current miner can call `NextTerm` with an arbitrary miner list (including themselves) even if they lost the election, completely bypassing the voting-based miner selection mechanism and retaining control over block production indefinitely.

## Finding Description

The vulnerability exists in the validation and processing flow of term transitions. When `NextTerm` is called, it goes through the following execution path:

The `NextTerm` method is a public RPC endpoint that calls `ProcessConsensusInformation`: [1](#0-0) 

Access control is performed via `PreCheck()` which allows any current OR previous round miner to call `NextTerm`: [2](#0-1) 

For `NextTerm` behavior, the validation chain only adds `RoundTerminateValidationProvider`: [3](#0-2) 

This validator only checks that term and round numbers increment correctly, but performs NO validation of the miner list contents: [4](#0-3) 

The `ProcessNextTerm` method blindly accepts whatever miner list is provided in `NextTermInput.RealTimeMinersInformation` and sets it as the new miner list without comparing it against election results: [5](#0-4) 

The `NextTermInput` structure allows the caller to specify the full miner list with no on-chain enforcement that it matches `ElectionContract.GetVictories()`: [6](#0-5) 

While the protocol has mechanisms to retrieve election results via `TryToGetVictories` and `GenerateFirstRoundOfNextTerm`, these are only used for off-chain consensus extra data generation, not for on-chain validation: [7](#0-6) 

The `NextTerm` RPC method is publicly accessible: [8](#0-7) 

## Impact Explanation

This is a **critical consensus integrity violation** with the following impacts:

**Consensus Breakdown:**
- Attackers can completely bypass the election system that is fundamental to AEDPoS consensus
- Enables permanent control over block production regardless of voting outcomes
- Violates the core democratic governance model where token holders vote for validators

**Economic Damage:**
- Miners who lost elections retain full block production authority and continue receiving block rewards
- Legitimate election winners are excluded from mining and lose expected rewards
- Block rewards (mining rewards, transaction fees) continue flowing to unelected miners indefinitely
- The economic incentive model based on staking and voting becomes meaningless

**Governance Capture:**
- Community loses ability to remove malicious or underperforming miners through elections
- Small cartel of miners can self-perpetuate control indefinitely
- Voting system becomes ineffective - votes cannot change the miner set
- Protocol credibility is severely damaged

**Affected Parties:**
- All token holders who voted expecting democratic validator selection
- Legitimate election winners excluded from the miner set
- Protocol integrity and long-term viability
- Economic model incentive alignment

## Likelihood Explanation

This vulnerability has **high likelihood** of exploitation:

**Reachable Entry Point:**
The `NextTerm` method is a publicly accessible RPC method that any transaction can invoke.

**Attacker Prerequisites:**
- Must be a current miner (has mining authority in current term)
- Can construct `NextTermInput` with arbitrary miner list including themselves
- Can observe election results on-chain to know they're losing

**Execution Simplicity:**
- Attack requires single transaction calling `NextTerm` with malicious input
- No complex state manipulation needed
- No timing constraints beyond normal term transition
- Passes all existing validation checks (PreCheck + RoundTerminateValidationProvider)

**Economic Incentive:**
- Cost: Standard transaction fee
- Benefit: Retain mining rewards worth potentially millions in tokens over time
- Extremely profitable for miners facing election loss
- Risk-free since appears as legitimate term transition

**Detection Difficulty:**
- No on-chain detection mechanism exists
- Off-chain monitoring might notice discrepancy with expected election results
- However, once executed, malicious miner list is locked in for the term
- Requires governance intervention to fix, which may be controlled by the attackers

## Recommendation

Add validation in `ProcessNextTerm` to verify the provided miner list matches election results:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // ADD THIS VALIDATION
    if (State.IsMainChain.Value)
    {
        var expectedVictories = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = new HashSet<string>(
            expectedVictories.Value.Select(pk => pk.ToHex())
        );
        var providedMiners = new HashSet<string>(
            nextRound.RealTimeMinersInformation.Keys
        );
        
        Assert(
            expectedMiners.SetEquals(providedMiners),
            "Miner list does not match election results."
        );
    }
    
    // ... rest of existing code
}
```

Additionally, consider adding a dedicated validation provider `ElectionResultsValidationProvider` to the validation chain for `NextTerm` behavior in `AEDPoSContract_Validation.cs`.

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_BypassElection_Attack()
{
    // Setup: Initialize system with 3 initial miners
    var initialMiners = new[] { InitialCoreDataCenterKeyPairs[0], InitialCoreDataCenterKeyPairs[1], InitialCoreDataCenterKeyPairs[2] };
    
    // Attacker is current miner
    var attackerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var attackerPubkey = attackerKeyPair.PublicKey.ToHex();
    
    // Someone else wins the election (new miner)
    var legitimateWinner = SampleKeyPairs[0];
    // Simulate election where attacker loses and legitimateWinner wins
    // (Election simulation code omitted for brevity)
    
    // Get current round before attack
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Attacker constructs malicious NextTermInput with themselves still in miner list
    // instead of the legitimate election winner
    var maliciousMinerList = new MinerList
    {
        Pubkeys = { 
            ByteStringHelper.FromHexString(attackerPubkey),  // Attacker keeps themselves
            ByteStringHelper.FromHexString(InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex()),
            ByteStringHelper.FromHexString(InitialCoreDataCenterKeyPairs[2].PublicKey.ToHex())
            // Note: legitimate winner is NOT included
        }
    };
    
    var maliciousNextTermInput = maliciousMinerList.GenerateFirstRoundOfNewTerm(
        MiningInterval,
        await GenerateRandomProofAsync(attackerKeyPair),
        BlockTimeProvider.GetBlockTime(),
        currentRound.RoundNumber,
        currentRound.TermNumber
    );
    
    // Attacker calls NextTerm with malicious input
    var attackerConsensusStub = GetConsensusContractTester(attackerKeyPair);
    var result = await attackerConsensusStub.NextTerm.SendAsync(maliciousNextTermInput);
    
    // Attack succeeds - transaction is mined successfully
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify attacker retained mining authority despite losing election
    var newRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.RealTimeMinersInformation.Keys.ShouldContain(attackerPubkey);
    newRound.RealTimeMinersInformation.Keys.ShouldNotContain(legitimateWinner.PublicKey.ToHex());
    
    // Election was bypassed - attacker retains control
}
```

## Notes

This vulnerability represents a fundamental flaw in the AEDPoS consensus mechanism where the core democratic principle of election-based validator selection is not enforced on-chain. While the system correctly generates election results and uses them for off-chain block generation guidance, there is no on-chain validation that prevents a malicious miner from ignoring these results when transitioning to a new term.

The test helper in `OtherContractsOperation.cs` shows the INTENDED flow where `GetVictories` is called and used to construct the `NextTermInput`, but this is not enforced by the contract itself: [9](#0-8)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-256)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
```

**File:** protobuf/aedpos_contract.proto (L37-39)
```text
    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.Economic.TestBase/OtherContractsOperation.cs (L17-36)
```csharp
    protected async Task NextTerm(ECKeyPair keyPair)
    {
        var miner = GetConsensusContractTester(keyPair);
        var round = await miner.GetCurrentRoundInformation.CallAsync(new Empty());
        var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
        var miners = new MinerList
        {
            Pubkeys =
            {
                victories.Value
            }
        };
        var randomNumber = await GenerateRandomProofAsync(keyPair);
        var firstRoundOfNextTerm =
            miners.GenerateFirstRoundOfNewTerm(EconomicContractsTestConstants.MiningInterval,
                randomNumber, BlockTimeProvider.GetBlockTime(), round.RoundNumber, round.TermNumber);
        var executionResult = (await miner.NextTerm.SendAsync(firstRoundOfNextTerm)).TransactionResult;
        executionResult.Error.ShouldBeNullOrEmpty();
        executionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
```
