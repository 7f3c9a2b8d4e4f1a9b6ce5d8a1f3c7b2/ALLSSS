# Audit Report

## Title
Dictionary Key-Pubkey Mismatch Enables Consensus DoS via Corrupted Round Structure

## Summary
The AEDPoS consensus contract lacks validation to ensure that dictionary keys in `RealTimeMinersInformation` match their corresponding `MinerInRound.Pubkey` values. A malicious miner can exploit this by submitting `NextRoundInput` with mismatched key-Pubkey mappings, corrupting the round structure and preventing legitimate miners from producing blocks, resulting in consensus denial of service.

## Finding Description

The vulnerability exists because the consensus contract fails to validate a critical invariant: dictionary keys in `RealTimeMinersInformation` must equal their corresponding `MinerInRound.Pubkey` values.

**Vulnerable Code Paths:**

The `GetUpdateValueRound()` function propagates existing key-Pubkey mismatches without validation. When iterating through `RealTimeMinersInformation`, it uses `information.Key` as the dictionary key while setting `Pubkey = information.Value.Pubkey`, which may differ: [1](#0-0) 

The `ToRound()` conversion method blindly copies the dictionary structure without any validation: [2](#0-1) 

**Attack Entry Points:**

The `NextRound()` method is publicly accessible and processes user-provided round data: [3](#0-2) 

`ProcessNextRound()` converts the input via `ToRound()` and stores it directly without validating the dictionary structure: [4](#0-3) 

The corrupted round is stored directly via `AddRoundInformation()`: [5](#0-4) 

**Missing Validation:**

The validation framework includes seven providers that check various consensus properties, but NONE validate key-Pubkey consistency: [6](#0-5) 

The `NextRoundMiningOrderValidationProvider` only checks `FinalOrderOfNextRound` values: [7](#0-6) 

The `PreCheck()` method only verifies the sender is in the current miner list, not the structural integrity of the proposed round: [8](#0-7) 

**Exploitation Impact:**

Once a corrupted round is stored, `ProcessUpdateValue()` attempts to access the dictionary using the miner's actual pubkey, which will throw `KeyNotFoundException` if the pubkey is not a dictionary key: [9](#0-8) 

**Invariant Violation:**

The proper round generation always ensures keys equal Pubkey values: [10](#0-9) 

## Impact Explanation

**HIGH SEVERITY - Consensus Denial of Service:**

1. **Immediate Block Production Failure**: Legitimate miners whose actual pubkeys are not dictionary keys will be unable to produce blocks. The dictionary access throws `KeyNotFoundException`, causing transaction failure.

2. **Consensus Halt**: If a malicious miner crafts input affecting multiple miners, those miners cannot participate in consensus, potentially halting the blockchain entirely.

3. **Data Corruption Persistence**: The corrupted round structure persists in state and propagates through subsequent rounds via `GetUpdateValueRound()`, making recovery difficult without governance intervention.

4. **Miner Disenfranchisement**: Legitimate miners lose their ability to participate in consensus and earn rewards despite being properly elected.

## Likelihood Explanation

**HIGH LIKELIHOOD:**

**Attacker Prerequisites:**
- Must be an elected miner in the current miner list
- Achievable through the Election contract's normal voting process
- A single compromised miner is sufficient

**Attack Complexity: LOW**
1. Attacker crafts a `NextRoundInput` with corrupted `RealTimeMinersInformation` where dictionary keys do not match the `Pubkey` fields
2. Attacker produces a block with this corrupted transaction during their designated time slot
3. No cryptographic operations or signature forgery required
4. Validation passes because no validator checks key-Pubkey consistency
5. Corrupted round is stored and immediately affects other miners

**Economic Incentive: HIGH**
- Competitor miners can eliminate rivals from consensus
- Attacker can maintain their own mining capability while disabling others
- Low cost (single transaction) versus high impact (consensus disruption)

## Recommendation

Add validation in the `ToRound()` method and/or in the validation providers to ensure all dictionary keys match their corresponding `MinerInRound.Pubkey` values:

```csharp
// In NextRoundInput.cs ToRound() method
public Round ToRound()
{
    var round = new Round
    {
        RoundNumber = RoundNumber,
        RealTimeMinersInformation = { RealTimeMinersInformation },
        // ... other fields
    };
    
    // Validate key-pubkey consistency
    foreach (var kvp in round.RealTimeMinersInformation)
    {
        Assert(kvp.Key == kvp.Value.Pubkey, 
            $"Dictionary key {kvp.Key} does not match MinerInRound.Pubkey {kvp.Value.Pubkey}");
    }
    
    return round;
}
```

Alternatively, add a new validation provider:

```csharp
public class RoundStructureValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var providedRound = validationContext.ProvidedRound;
        foreach (var kvp in providedRound.RealTimeMinersInformation)
        {
            if (kvp.Key != kvp.Value.Pubkey)
            {
                return new ValidationResult 
                { 
                    Message = $"Invalid round structure: key {kvp.Key} does not match pubkey {kvp.Value.Pubkey}" 
                };
            }
        }
        return new ValidationResult { Success = true };
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Test_KeyPubkeyMismatch_CausesConsensusDoS()
{
    // Setup: Initialize consensus with legitimate miners
    var miners = await InitializeConsensusAsync();
    var maliciousMiner = miners[0];
    var victimMiner = miners[1];
    
    // Malicious miner crafts corrupted NextRoundInput
    var currentRound = await GetCurrentRoundInformationAsync();
    var corruptedRound = currentRound.Clone();
    
    // Store victim miner's data under wrong key
    var victimData = corruptedRound.RealTimeMinersInformation[victimMiner.PublicKey];
    corruptedRound.RealTimeMinersInformation.Remove(victimMiner.PublicKey);
    corruptedRound.RealTimeMinersInformation["WrongKey"] = victimData; // Key != Pubkey
    
    var corruptedInput = NextRoundInput.Create(corruptedRound, randomNumber);
    
    // Malicious miner submits during their time slot
    await ProduceBlockAsync(maliciousMiner, () => 
        ConsensusContract.NextRound(corruptedInput));
    
    // Verification: Victim miner cannot produce blocks
    var exception = await Assert.ThrowsAsync<KeyNotFoundException>(
        async () => await ProduceBlockAsync(victimMiner, () =>
            ConsensusContract.UpdateValue(normalUpdateInput)));
    
    Assert.Contains(victimMiner.PublicKey, exception.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-252)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L62-92)
```csharp
        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```
