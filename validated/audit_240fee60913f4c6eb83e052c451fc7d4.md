# Audit Report

## Title
Division by Zero in Consensus Miner Count Calculation Due to Insufficient MinerIncreaseInterval Validation

## Summary
The `SetMinerIncreaseInterval()` function contains a backwards validation check that only enforces an upper bound, allowing the `MinerIncreaseInterval` to be set to zero or negative values through Parliament governance. This causes deterministic `DivideByZeroException` in critical consensus operations during round processing and term transitions, resulting in complete and irreversible blockchain halt.

## Finding Description

The root cause is an inverted validation assertion in `SetMinerIncreaseInterval()`. [1](#0-0) 

The assertion only checks that the new value is less than or equal to the current value, which allows indefinite decrease including to zero or negative values, but provides no lower bound protection.

The `MinerIncreaseInterval` is initialized with a default value of 31,536,000 seconds (1 year). [2](#0-1)  This value is stored during contract initialization. [3](#0-2) 

Once set to zero, the value is used as a divisor in two critical locations:

**Location 1 - Internal consensus calculation:** [4](#0-3) 

**Location 2 - Miner count determination:** [5](#0-4) 

The `Div()` extension method performs standard C# division which throws `DivideByZeroException` when the divisor is zero. [6](#0-5) 

This is confirmed by unit tests that explicitly verify `DivideByZeroException` is thrown. [7](#0-6) 

These division operations are called during critical consensus operations:

**During first round processing:** [8](#0-7) 

**During term transitions:** [9](#0-8) 

## Impact Explanation

**Complete Blockchain Halt (Critical DoS)**

When `MinerIncreaseInterval` is set to zero, the blockchain becomes completely non-functional:

1. **Consensus Operations Fail**: All round processing and term transitions throw `DivideByZeroException`, preventing block production
2. **No Recovery Mechanism**: Once set to zero, the value cannot be increased back due to the backwards validation check - any attempt to increase fails the assertion
3. **Permanent Failed State**: The blockchain enters an unrecoverable state requiring hard fork or chain restart with state rollback
4. **Network-Wide Impact**: All nodes are affected simultaneously, all users lose access, all transactions stop

The severity is **CRITICAL** because:
- Consensus systems require zero tolerance for availability failures
- Complete operational disruption of the entire blockchain
- No automatic or governance-based recovery path exists (validation prevents increasing the value back)
- Affects all network participants immediately and permanently

## Likelihood Explanation

**Medium Likelihood**

**Required Capabilities:**
- Ability to create and pass a Parliament governance proposal [10](#0-9)  The default controller is Parliament's default organization. [11](#0-10) 

**Attack Complexity: Low**
1. Create Parliament proposal calling `SetMinerIncreaseInterval(0)`
2. Obtain sufficient votes for approval through legitimate governance process
3. Execute the approved proposal
4. Wait for next automatic consensus operation (happens during normal block production)

**Feasibility Factors:**
- Can occur through malicious governance proposal with sufficient support
- Can occur accidentally through misconfiguration by well-intentioned governance actors
- Can occur through social engineering of governance participants
- No technical complexity barriers exist

**Evidence of Validation Failure:**
Existing tests demonstrate the one-way validation. [12](#0-11) 

The test shows that attempting to increase the value fails with "Invalid interval" error, while decreasing succeeds, but never validates against zero as a lower bound.

## Recommendation

Add a lower bound validation to prevent setting `MinerIncreaseInterval` to zero or negative values:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

This ensures the invariant that `MinerIncreaseInterval` must always be positive (since it's used as a divisor) is maintained regardless of governance authority.

## Proof of Concept

```csharp
[Fact]
public async Task SetMinerIncreaseInterval_ZeroValue_CausesDivisionByZero()
{
    // Setup: Initialize contracts
    InitialContracts();
    await BlockMiningService.MineBlockToNextTermAsync();
    InitialAcs3Stubs();
    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
    
    var defaultOrganizationAddress = await ParliamentStubs.First()
        .GetDefaultOrganizationAddress.CallAsync(new Empty());

    // Step 1: Set MinerIncreaseInterval to 0 via Parliament governance
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = 0 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganizationAddress
    });

    // Verify the value was set to 0
    var minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval
        .CallAsync(new Empty());
    minerIncreaseInterval.Value.ShouldBe(0);

    // Step 2: Trigger consensus operation that calls GetMinersCount
    // This will throw DivideByZeroException and halt the blockchain
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await BlockMiningService.MineBlockAsync();
    });
    
    exception.Message.ShouldContain("DivideByZeroException");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L36-40)
```csharp
        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L58-60)
```csharp
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L61-61)
```csharp
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L93-94)
```csharp
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L13-13)
```csharp
    public long MinerIncreaseInterval { get; set; } = 31536000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L31-31)
```csharp
        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L389-390)
```csharp
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-89)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L128-128)
```csharp
                var minersCount = GetMinersCount(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L55-55)
```csharp
        var minersCount = GetMinersCount(input);
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L121-146)
```csharp
        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
```
