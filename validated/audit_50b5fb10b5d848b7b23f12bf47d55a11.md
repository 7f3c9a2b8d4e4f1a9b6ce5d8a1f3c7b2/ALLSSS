# Audit Report

## Title
VotersCount Permanent Inflation Due to Asymmetric Increment/Decrement Logic in Withdraw Function

## Summary
The Vote contract contains a critical logic inconsistency where `VotersCount` is incremented for every vote transaction but only decremented when a voter has no remaining active votes. This asymmetry allows any voter casting multiple votes to permanently inflate the `VotersCount` metric, corrupting voting statistics used throughout the governance system.

## Finding Description

The vulnerability stems from fundamentally different accounting logic between voting and withdrawal operations:

**Vote Operation - Per-Transaction Increment:**
When a vote is cast, the `UpdateVotingResult()` function unconditionally increments `VotersCount` by 1 for every individual vote transaction, regardless of whether the voter has already voted on the same voting item. [1](#0-0) 

**Withdraw Operation - Per-Voter Decrement:**
When withdrawing a vote, the `Withdraw()` function only decrements `VotersCount` if the voter has NO remaining active votes for that voting item. The withdrawal first removes the vote from `ActiveVotes`, then conditionally decrements only when `ActiveVotes.Any()` returns false. [2](#0-1) 

**Mathematical Imbalance:**
- A voter casts N votes → `VotersCount` increases by N
- The voter withdraws N-1 votes → `VotersCount` unchanged (still has 1 active vote)
- The voter withdraws the last vote → `VotersCount` decreases by 1
- **Net effect:** `VotersCount` inflated by (N-1)

**Test Evidence:**
The test suite confirms this behavior. When two voters each cast two votes, `VotersCount` reaches 4, not 2, demonstrating that it tracks total vote transactions rather than unique voters. [3](#0-2) 

Another test shows a single voter (user3) voting multiple times, contributing multiple increments to `VotersCount`. [4](#0-3) 

**Persistence Across Snapshots:**
When taking a snapshot to transition between voting periods, the inflated `VotersCount` is directly copied from the previous snapshot to the new one, making the corruption permanent. [5](#0-4) 

**Exposure to Governance Systems:**
The Election contract's `GetVotersCount()` method directly exposes this corrupted metric, allowing the inflated count to propagate into governance decisions and analytics. [6](#0-5) 

## Impact Explanation

**Direct Governance Impact:**
The `VotersCount` metric serves as a key indicator of voter participation in governance systems. Its permanent inflation corrupts:
- Voter participation statistics displayed to users
- Governance analytics used for decision-making
- Election contract metrics consumed by other systems
- Historical voting records across snapshot transitions

**Severity Assessment - Medium:**
While this vulnerability does not directly result in fund theft or unauthorized privilege escalation, it corrupts critical governance state that is:
1. **Permanent**: The inflation accumulates indefinitely and persists across snapshots
2. **Public**: The metric is exposed via view methods to all consumers
3. **Governance-Critical**: Used by the Election contract and potentially other governance systems
4. **Cumulative**: Each multi-vote scenario adds to the inflation

The corrupted data undermines the integrity of the voting system and can mislead governance participants about actual voter engagement levels.

## Likelihood Explanation

**Attack Feasibility - High:**
- **No Special Privileges**: Any address with sufficient token balance can exploit this
- **Trivial Execution**: Simply vote multiple times, then withdraw votes incrementally
- **No Economic Barrier**: Tokens are returned on withdrawal, making the attack cost-neutral
- **Natural Occurrence**: This happens automatically whenever any user legitimately votes multiple times and withdraws incrementally, whether malicious or not

**Technical Constraints - None:**
- Voting items accept multiple votes from the same voter (confirmed by tests)
- No rate limiting or duplicate vote prevention exists
- Withdrawal is publicly accessible with only voter ownership checks
- The behavior is inherent to the contract logic, not requiring special timing or state manipulation

**Detection Difficulty:**
The inflation is subtle and accumulates gradually without triggering any transaction failures or errors, making it difficult to detect until significantly inflated.

## Recommendation

Implement consistent accounting logic for `VotersCount`. Choose one of two approaches:

**Option 1: Track Unique Voters**
Only increment `VotersCount` on the first vote from a voter for a given voting item:
```csharp
// In UpdateVotingResult
if (!State.VoterParticipation[votingItemId][voter]) {
    votingResult.VotersCount = votingResult.VotersCount.Add(1);
    State.VoterParticipation[votingItemId][voter] = true;
}
```

**Option 2: Track Total Transactions (Do Not Decrement on Withdrawal)**
Remove the decrement logic entirely:
```csharp
// In Withdraw - remove lines 217-218
// VotersCount represents total vote transactions ever made
```

**Recommended: Option 1** - Tracking unique voters provides more meaningful governance metrics and aligns with the semantic meaning of "VotersCount".

## Proof of Concept

```csharp
[Fact]
public async Task VotersCount_Inflation_PoC()
{
    var voter = Accounts[2].KeyPair;
    var votingItem = await RegisterVotingItemAsync(10, 3, true, DefaultSender, 2);
    
    // Voter casts 3 votes
    await Vote(voter, votingItem.VotingItemId, votingItem.Options.First(), 100L);
    await Vote(voter, votingItem.VotingItemId, votingItem.Options.First(), 100L);
    await Vote(voter, votingItem.VotingItemId, votingItem.Options.First(), 100L);
    
    var resultAfterVoting = await GetLatestVotingResult(votingItem.VotingItemId);
    resultAfterVoting.VotersCount.ShouldBe(3); // VotersCount = 3 (incremented 3 times)
    
    // Get vote IDs
    var votedItems = await GetVotedItems(Address.FromPublicKey(voter.PublicKey));
    var voteIds = votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes;
    
    // Withdraw first vote
    await Withdraw(voter, voteIds[0]);
    var resultAfterFirstWithdraw = await GetLatestVotingResult(votingItem.VotingItemId);
    resultAfterFirstWithdraw.VotersCount.ShouldBe(3); // Still 3 (has 2 active votes remaining)
    
    // Withdraw second vote
    await Withdraw(voter, voteIds[1]);
    var resultAfterSecondWithdraw = await GetLatestVotingResult(votingItem.VotingItemId);
    resultAfterSecondWithdraw.VotersCount.ShouldBe(3); // Still 3 (has 1 active vote remaining)
    
    // Withdraw third vote
    await Withdraw(voter, voteIds[2]);
    var resultAfterThirdWithdraw = await GetLatestVotingResult(votingItem.VotingItemId);
    resultAfterThirdWithdraw.VotersCount.ShouldBe(2); // Now 2 (no active votes, decremented by 1)
    
    // NET RESULT: VotersCount permanently inflated by 2
    // Expected: 0 (no active voters)
    // Actual: 2 (inflated)
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L178-178)
```csharp
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L217-218)
```csharp
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L269-269)
```csharp
            VotersCount = previousVotingResult.VotersCount,
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L613-622)
```csharp
        await Vote(voteUser1, votingItem.VotingItemId, votingItem.Options.First(), 100L);
        await Vote(voteUser1, votingItem.VotingItemId, votingItem.Options.First(), 200L);
        var votingResult = await GetLatestVotingResult(votingItem.VotingItemId);
        votingResult.VotersCount.ShouldBe(2);
        votingResult.VotesAmount.ShouldBe(300L);

        await Vote(voteUser2, votingItem.VotingItemId, votingItem.Options.Last(), 100L);
        await Vote(voteUser2, votingItem.VotingItemId, votingItem.Options.Last(), 200L);
        votingResult = await GetLatestVotingResult(votingItem.VotingItemId);
        votingResult.VotersCount.ShouldBe(4);
```

**File:** test/AElf.Contracts.Vote.Tests/Full/VoteForBestLanguageTests.cs (L88-94)
```csharp
            var transactionResult3 = await Vote(user3.KeyPair, registerItem.VotingItemId, options[2], 100);
            transactionResult3.Status.ShouldBe(TransactionResultStatus.Mined);
            transactionResult3 = await Vote(user3.KeyPair, registerItem.VotingItemId, options[2], 100);
            transactionResult3.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingResult = await GetVotingResult(registerItem.VotingItemId, 2);
            votingResult.VotersCount.ShouldBe(7);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L224-229)
```csharp
    public override Int64Value GetVotersCount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotersCount
        };
```
