# Audit Report

## Title
IsUserContract Flag Manipulation via Incorrect Update Path Bypasses ACS Requirements

## Summary
User contract authors can permanently bypass required ACS (AElf Contract Standard) security validations by updating their contracts through the standard contract update path (`ProposeUpdateContract`) instead of the user contract update path (`UpdateUserSmartContract`). This permanently sets the `IsUserContract` flag to false, exempting the contract from all future user contract validation requirements.

## Finding Description

The AElf Genesis contract provides two distinct update mechanisms but fails to enforce their proper usage based on contract type.

The vulnerability chain consists of three critical flaws:

**1. Missing Contract Type Validation**

The `ProposeUpdateContract` method only validates sender authorization but does NOT check whether a user contract must use the user contract update path: [1](#0-0) 

The authorization check allows any contract author to call this method: [2](#0-1) 

**2. Event Field Omission**

When `ProposeUpdateContract` creates the code check proposal, it omits the `IsUserContract` field from the `CodeCheckRequired` event: [3](#0-2) [4](#0-3) 

Compare this with the user contract path which explicitly sets `IsUserContract = true`: [5](#0-4) 

In protobuf3, unset boolean fields default to false: [6](#0-5) 

**3. Code Check Bypass**

The code check service uses the `isUserContract` flag to determine validation requirements. When false, it uses an empty `RequiredAcs` list: [7](#0-6) 

**4. Permanent Flag Corruption**

The `UpdateSmartContract` helper unconditionally overwrites the `IsUserContract` flag: [8](#0-7) 

The standard update path calls this with `false`, permanently corrupting the flag: [9](#0-8) 

While the user contract path correctly calls it with `true`: [10](#0-9) 

## Impact Explanation

**HIGH SEVERITY** - This vulnerability fundamentally breaks the user contract security model:

1. **Permanent Security Bypass**: Once exploited, the contract is permanently exempted from ACS validation requirements (e.g., ACS12 User Contract Standard)

2. **Code Quality Degradation**: Malicious or vulnerable code can be deployed without proper validation checks that user contracts are designed to enforce

3. **Trust Undermining**: The user contract ecosystem relies on these validation requirements to ensure code quality and security

4. **Persistent State Corruption**: The flag change is written to contract state and affects all future updates: [11](#0-10) 

Test evidence confirms the permanent nature of the flag change: [12](#0-11) 

## Likelihood Explanation

**MEDIUM LIKELIHOOD** - The attack requires standard contract author privileges:

**Attacker Prerequisites:**
- Must be the contract author
- Must obtain Parliament governance approval

**Why This Is Realistic:**
1. Contract authors routinely update their contracts for legitimate maintenance
2. The wrong method can be called accidentally (developer confusion) or intentionally (malicious bypass)
3. Parliament reviewers are unlikely to detect this - both methods appear legitimate without deep implementation knowledge
4. The flag manipulation is invisible in proposal parameters
5. No warnings, documentation, or UI distinctions guide proper method selection

The authorization model validates identity but not contract type compatibility, allowing this path: [13](#0-12) 

## Recommendation

Add explicit validation in `ProposeUpdateContract` to prevent user contracts from using this path:

```csharp
public override Hash ProposeUpdateContract(ContractUpdateInput input)
{
    var proposedContractInputHash = CalculateHashFromInput(input);
    RegisterContractProposingData(proposedContractInputHash);

    var contractAddress = input.Address;
    var info = State.ContractInfos[contractAddress];
    Assert(info != null, "Contract not found.");
    
    // ADD THIS CHECK:
    Assert(!info.IsUserContract, "User contracts must use UpdateUserSmartContract method.");
    
    AssertAuthorityByContractInfo(info, Context.Sender);
    // ... rest of method
}
```

Additionally, consider setting the `IsUserContract` field in the `ContractCodeCheckInput` to match the contract's current status as a defense-in-depth measure.

## Proof of Concept

```csharp
[Fact]
public async Task UserContract_UpdatedViaWrongPath_BypassesValidation()
{
    // 1. Deploy a user contract
    var userContractDeploymentInput = new UserContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(TestContractCode)
    };
    
    var deployResult = await SideChainTester.ExecuteContractWithMiningAsync(
        SideBasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.DeployUserSmartContract), 
        userContractDeploymentInput);
    
    var contractAddress = /* extract from deployment result */;
    
    // Verify initial state: IsUserContract = true
    var contractInfo = await GetContractInfo(contractAddress);
    contractInfo.IsUserContract.ShouldBeTrue();
    
    // 2. Update via WRONG path (ProposeUpdateContract instead of UpdateUserSmartContract)
    var contractUpdateInput = new ContractUpdateInput
    {
        Address = contractAddress,
        Code = ByteString.CopyFrom(UpdatedTestContractCode)
    };
    
    // Call ProposeUpdateContract (standard path) - should fail but doesn't!
    var updateResult = await UpdateAsync(Tester, ParliamentAddress, 
        BasicContractZeroAddress, contractUpdateInput);
    
    updateResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 3. Verify exploit: IsUserContract flag is now permanently false
    var updatedInfo = await GetContractInfo(contractAddress);
    updatedInfo.IsUserContract.ShouldBeFalse(); // BUG: Flag was flipped!
    
    // 4. All future updates now bypass user contract validation
    // The contract is permanently exempted from ACS requirements
}
```

## Notes

The vulnerability exists because the contract update system has two parallel paths but no enforcement mechanism to ensure contracts use the appropriate path based on their type. The authorization model only validates identity, not whether the operation is semantically correct for the contract type. This allows legitimate contract authors to accidentally or intentionally circumvent security validations designed to protect the user contract ecosystem.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-184)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L209-216)
```csharp
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = info.Category,
                    IsSystemContract = info.IsSystemContract
                }.ToByteString(),
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L266-272)
```csharp
        Context.Fire(new CodeCheckRequired
        {
            Code = ExtractCodeFromContractCodeCheckInput(input),
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = input.IsSystemContract
        });
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-334)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L464-471)
```csharp
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = info.Category,
            IsSystemContract = false,
            IsUserContract = true
        });
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L507-514)
```csharp
    public override Empty PerformUpdateUserSmartContract(UserContractUpdateInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var proposingInput);

        UpdateSmartContract(input.Address, input.Code.ToByteArray(), proposingInput.Author, true);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-110)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

        var oldCodeHash = info.CodeHash;
        var newCodeHash = HashHelper.ComputeFrom(code);
        Assert(oldCodeHash != newCodeHash, "Code is not changed.");
        AssertContractNotExists(newCodeHash);

        info.CodeHash = newCodeHash;
        info.IsUserContract = isUserContract;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L131-132)
```csharp
        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** protobuf/acs0.proto (L248-261)
```text
message CodeCheckRequired
{
    option (aelf.is_event) = true;
    // The byte array of the contract code.
    bytes code = 1;
    // The id of the proposed contract.
    aelf.Hash proposed_contract_input_hash = 2;
    // The category of contract code(0: C#).
    sint32 category = 3;
    // Indicates if the contract is the system contract.
    bool is_system_contract = 4;
    // Indicates if the contract is the user contract.
    bool is_user_contract = 5;
}
```

**File:** src/AElf.Kernel.CodeCheck/Application/CodeCheckService.cs (L31-40)
```csharp
        var requiredAcs = new RequiredAcs
        {
            AcsList = new List<string>(),
            RequireAll = false
        };
        
        if (isUserContract)
        {
            requiredAcs = await _requiredAcsProvider.GetRequiredAcsInContractsAsync(blockHash, blockHeight);
        }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L519-524)
```csharp
        var updateContractInfo = ContractInfo.Parser.ParseFrom(await Tester.CallContractMethodAsync(
            BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractInfo), newAddress));
        updateContractInfo.Version.ShouldBe(contractInfo.Version + 1);
        updateContractInfo.ContractVersion.ShouldBe("1.2.0.0");
        updateContractInfo.IsUserContract.ShouldBeFalse();
```
