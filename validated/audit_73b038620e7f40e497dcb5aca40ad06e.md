# Audit Report

## Title
Cross-Snapshot Withdrawal Leaves Stale Vote Counts in Subsequent Snapshots

## Summary
The Vote contract's `Withdraw()` function only updates the snapshot where the vote was originally cast, but fails to update subsequent snapshots that have inherited cumulative vote counts. This creates a state inconsistency where withdrawn votes persist in later snapshots' aggregate metrics, leading to inflated `VotesAmount` and `VotersCount` values that can affect governance decisions.

## Finding Description

The vulnerability stems from the interaction between two mechanisms in the Vote contract:

**Snapshot Inheritance Mechanism:**
When `TakeSnapshot()` is called, it creates a new snapshot that inherits `VotersCount` and `VotesAmount` from the previous snapshot as carried-over cumulative metrics. [1](#0-0) 

**Withdrawal Update Mechanism:**
When a voter withdraws their vote via `Withdraw()`, the function retrieves the voting result hash using only the snapshot number stored in the original voting record. [2](#0-1) 

The withdrawal then updates only that specific snapshot's `VotingResult` by subtracting the vote amount and decrementing the voter count. [3](#0-2) 

**Root Cause:**
The withdrawal logic does not iterate through or update any subsequent snapshots that have already inherited the vote counts from the original snapshot. Once `TakeSnapshot()` copies the cumulative counts forward, those copies remain immutable with respect to withdrawals from earlier snapshots.

**Attack Scenario:**
1. Attacker votes with amount X in Snapshot 1, creating a voting record with `SnapshotNumber = 1` [4](#0-3) 
2. Sponsor calls `TakeSnapshot()` to create Snapshot 2, which inherits the cumulative counts [5](#0-4) 
3. Attacker withdraws the vote - only Snapshot 1 is updated while Snapshot 2 retains stale data [6](#0-5) 

## Impact Explanation

**Inflated Governance Metrics:**
The Election contract exposes `GetVotersCount()` and `GetVotesAmount()` methods that query the Vote contract's voting results and return the values directly. [7](#0-6) 

These methods will return inflated values for any snapshot queried after withdrawals from earlier snapshots have occurred.

**Governance Manipulation:**
For each withdrawn vote of amount X from snapshot N, all subsequent snapshots N+1, N+2, etc. retain X in their `VotesAmount` and potentially +1 in their `VotersCount`. This creates a multiplier effect where:
- The same tokens can be counted multiple times in aggregate statistics
- Voter participation appears artificially higher than reality
- Quorum calculations and governance decisions based on these metrics become unreliable

**Evidence from Test Suite:**
The existing test suite actually demonstrates this buggy behavior. In the multi-phase voting test, after user1 withdraws in phase 1, phase 2 expects `VotersCount = 7` when mathematically it should be 6 (2 remaining from phase 1 after withdrawal + 4 new votes in phase 2). The test verifies the inflated count of 7 (3 stale inherited + 4 new). [8](#0-7) 

## Likelihood Explanation

**Attacker Capabilities:**
Any voter can execute this issue with standard voter operations - no special permissions required beyond the ability to vote and withdraw.

**Attack Complexity:**
Very low complexity:
1. Vote in snapshot N with any amount
2. Wait for sponsor to call `TakeSnapshot()` 
3. Call `Withdraw()` with the vote ID
4. Subsequent snapshots now have inflated counts

**Feasibility:**
The issue is always feasible when a voting item has multiple snapshots (`TotalSnapshotNumber > 1`) and withdrawals are allowed (either token locking enabled for voter withdrawal, or disabled for sponsor withdrawal). [9](#0-8) 

**Probability:**
HIGH - This is a systematic flaw that occurs whenever withdrawals happen after snapshot transitions, not an edge case.

## Recommendation

Modify the `Withdraw()` function to update all subsequent snapshots in addition to the original snapshot. When a vote is withdrawn from snapshot N, iterate through all snapshots N+1, N+2, ..., up to the current snapshot number and subtract the withdrawn amount from their `VotesAmount` and decrement `VotersCount` if applicable.

Suggested fix structure:
1. After updating the original snapshot at the voting record's snapshot number
2. Retrieve the current snapshot number from the voting item
3. Iterate from `votingRecord.SnapshotNumber + 1` to `votingItem.CurrentSnapshotNumber`
4. For each subsequent snapshot, apply the same vote count and amount decrements

## Proof of Concept

```csharp
[Fact]
public async Task CrossSnapshot_Withdrawal_Stale_Counts_Test()
{
    // Register voting item with 3 snapshots
    var registerItem = await RegisterVotingItemAsync(100, 2, true, DefaultSender, 3);
    var user = Accounts[1];
    
    // Phase 1: Vote in Snapshot 1
    await Vote(user.KeyPair, registerItem.VotingItemId, registerItem.Options[0], 100);
    var snapshot1Result = await GetVotingResult(registerItem.VotingItemId, 1);
    snapshot1Result.VotersCount.ShouldBe(1);
    snapshot1Result.VotesAmount.ShouldBe(100);
    
    // Take Snapshot - creates Snapshot 2 inheriting counts
    await TakeSnapshot(registerItem.VotingItemId, 1);
    var snapshot2Result = await GetVotingResult(registerItem.VotingItemId, 2);
    snapshot2Result.VotersCount.ShouldBe(1); // Inherited from Snapshot 1
    snapshot2Result.VotesAmount.ShouldBe(100); // Inherited from Snapshot 1
    
    // Withdraw the vote
    var voteIds = await GetVoteIds(user.KeyPair, registerItem.VotingItemId);
    await Withdraw(user.KeyPair, voteIds.ActiveVotes.First());
    
    // Verify Snapshot 1 is updated correctly
    snapshot1Result = await GetVotingResult(registerItem.VotingItemId, 1);
    snapshot1Result.VotersCount.ShouldBe(0);
    snapshot1Result.VotesAmount.ShouldBe(0);
    
    // BUG: Snapshot 2 still has stale counts
    snapshot2Result = await GetVotingResult(registerItem.VotingItemId, 2);
    snapshot2Result.VotersCount.ShouldBe(1); // WRONG - should be 0
    snapshot2Result.VotesAmount.ShouldBe(100); // WRONG - should be 0
}
```

## Notes

The vulnerability affects the Vote contract's core snapshot mechanism, which is used by the Election contract for miner election governance. The impact extends to any governance decisions that rely on accurate vote count aggregations across multiple voting periods. The existing test suite inadvertently validates the buggy behavior rather than catching the issue, indicating this may already be affecting production deployments.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-222)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L264-271)
```csharp
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L224-238)
```csharp
    public override Int64Value GetVotersCount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotersCount
        };
    }

    public override Int64Value GetVotesAmount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotesAmount
        };
    }
```

**File:** test/AElf.Contracts.Vote.Tests/Full/VoteForBestLanguageTests.cs (L93-94)
```csharp
            var votingResult = await GetVotingResult(registerItem.VotingItemId, 2);
            votingResult.VotersCount.ShouldBe(7);
```
