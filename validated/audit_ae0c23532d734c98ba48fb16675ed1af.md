# Audit Report

## Title
Proposer Whitelist Bypass - Removed Proposers Can Execute Approved Proposals

## Summary
The `Release` method in Association, Parliament, and Referendum governance contracts fails to re-validate proposer whitelist membership at execution time. This allows proposers who have been explicitly removed from the whitelist to retain execution authority for previously approved proposals, creating an authorization bypass.

## Finding Description

All three governance contracts implement a proposer whitelist mechanism to control who can create proposals. When creating a proposal, the system validates whitelist membership through `AssertIsAuthorizedProposer`. [1](#0-0) 

However, the `Release` method implements insufficient authorization validation. In the Association contract, it only verifies that the caller is the original proposer without checking current whitelist status. [2](#0-1) 

The same vulnerability pattern exists in Parliament [3](#0-2)  and Referendum [4](#0-3)  contracts.

Organizations can update their proposer whitelist at any time. [5](#0-4)  Once a proposer creates and gets approval for a proposal, removing them from the whitelist does not revoke their ability to execute it.

The execution through `Context.SendVirtualInlineBySystemContract` allows arbitrary contract method calls on behalf of the organization. The only defense mechanism is `ClearProposal`, which only works after proposal expiration. [6](#0-5) 

## Impact Explanation

This authorization bypass has HIGH severity because:

1. **Security Control Failure**: The proposer whitelist is a critical security mechanism. Organizations remove proposers to explicitly revoke their authority, but this control is ineffective for existing approved proposals.

2. **Arbitrary Contract Execution**: Released proposals execute arbitrary contract methods via virtual inline calls, enabling fund transfers, configuration changes, contract upgrades, and permission modifications on behalf of the organization.

3. **No Revocation Mechanism**: Organizations cannot prevent removed proposers from executing approved proposals before expiration. The attack window extends from approval time until expiration (typically days), providing ample opportunity for exploitation.

4. **Real-World Attack Scenarios**:
   - Compromised proposer accounts can still execute approved proposals after removal from whitelist
   - Malicious proposers discovered post-approval cannot be stopped from execution
   - Changed circumstances making proposals harmful cannot be prevented

## Likelihood Explanation

This vulnerability has HIGH likelihood because:

1. **Low Attack Complexity**: 
   - Attacker must initially be whitelisted (normal operational state)
   - Create proposal and obtain approval (standard workflow)
   - Execute after removal from whitelist (single transaction)
   - No special exploits or economic resources required

2. **Realistic Triggering Scenarios**: Account compromise, discovery of malicious intent, and organizational changes are common operational events that organizations must handle through whitelist management.

3. **Wide Attack Window**: The exploitation period extends from approval until expiration, typically measured in days, with no race conditions or timing requirements.

4. **Consistent Pattern**: The vulnerability exists identically across all three governance contract implementations, multiplying the attack surface.

## Recommendation

Add whitelist re-validation in the `Release` method before executing the proposal:

```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // Add whitelist re-validation
    AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, Context.Sender);
    
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    Context.SendVirtualInlineBySystemContract(
        CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), 
        proposalInfo.ToAddress,
        proposalInfo.ContractMethodName, proposalInfo.Params);
    
    // ... rest of method
}
```

Apply this fix to Association, Parliament, and Referendum contracts. This ensures that proposers must maintain whitelist membership throughout the entire proposal lifecycle, from creation through execution.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposerCanStillReleaseApprovedProposal()
{
    // Setup: Create organization with proposer in whitelist
    var organizationAddress = await CreateOrganizationAsync(2, 3, 1, 1, Reviewer1);
    
    // Step 1: Reviewer1 creates proposal while whitelisted
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Step 2: Get sufficient approvals
    var associationContractStubReviewer2 = GetAssociationContractTester(Reviewer2KeyPair);
    var associationContractStubReviewer3 = GetAssociationContractTester(Reviewer3KeyPair);
    await associationContractStubReviewer2.Approve.SendAsync(proposalId);
    await associationContractStubReviewer3.Approve.SendAsync(proposalId);
    
    // Step 3: Organization removes Reviewer1 from whitelist
    var organizationStub = GetAssociationContractTester(organizationAddress);
    await organizationStub.ChangeOrganizationProposerWhiteList.SendAsync(
        new ProposerWhiteList { Proposers = { Reviewer2 } } // Reviewer1 removed
    );
    
    // Step 4: Reviewer1 (now removed) can still release the proposal
    var reviewer1Stub = GetAssociationContractTester(Reviewer1KeyPair);
    var result = await reviewer1Stub.Release.SendAsync(proposalId);
    
    // Vulnerability: Release succeeds even though Reviewer1 is no longer whitelisted
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

## Notes

This vulnerability represents a fundamental gap in the authorization model across all three governance contracts. While the proposer whitelist effectively controls proposal creation, it fails to provide ongoing authorization control over proposal execution. Organizations implementing governance through these contracts should be aware that whitelist removal does not revoke execution rights for already-approved proposals, creating a period of vulnerability until proposal expiration.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
