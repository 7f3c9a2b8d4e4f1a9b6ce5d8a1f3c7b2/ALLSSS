# Audit Report

## Title
Missing Signature Validation Allows Consensus Schedule Manipulation

## Summary
The AEDPoS consensus contract fails to validate that miner-provided signatures match the cryptographically expected value, allowing malicious miners to arbitrarily manipulate their mining order in the next round and control extra block producer selection. This completely undermines the consensus protocol's randomness guarantees.

## Finding Description

The vulnerability exists in how the `UpdateValue` transaction processes miner signatures without cryptographic verification.

During legitimate block production, the signature is correctly calculated by XORing the miner's previousInValue with all signatures from the previous round. [1](#0-0) 

This calculated signature is used during normal consensus operations. [2](#0-1) 

However, the validation provider only checks that the signature field is non-null and non-empty, without verifying that it matches the expected calculated value. [3](#0-2) 

When processing the `UpdateValue` transaction, the signature from user input is directly assigned to the round state without any cryptographic validation against the expected value. [4](#0-3) 

This signature directly determines the miner's position in the next round through modulo arithmetic on the signature value. [5](#0-4) 

Additionally, if the attacker is the first miner by order in the current round, their signature determines which miner becomes the extra block producer in the next round. [6](#0-5) 

## Impact Explanation

**HIGH SEVERITY** - This vulnerability directly compromises the core consensus mechanism:

1. **Consensus Schedule Manipulation**: Miners can choose any mining order (1 to N) in the next round by selecting signature values that produce their desired modulus result. This allows strategic positioning for maximum profit or to coordinate attacks.

2. **Extra Block Producer Control**: The first miner in each round can deterministically select who becomes the extra block producer in the next round, enabling reward manipulation and potential collusion schemes.

3. **Randomness Violation**: The signature mechanism is the primary source of randomness for fair mining schedule distribution. Allowing arbitrary signatures completely eliminates this randomness, making the consensus protocol predictable and manipulable.

4. **Collusion Potential**: Multiple malicious miners can coordinate their signature values to dominate consecutive rounds, concentrating rewards and potentially enabling censorship or other consensus-level attacks.

## Likelihood Explanation

**CERTAIN** - This vulnerability is trivially exploitable:

- **Entry Point**: The `UpdateValue` method is the standard transaction every miner sends during normal block production, making it constantly accessible.

- **Preconditions**: The attacker only needs to be a valid miner in the current validator set, which is the normal operational state for any miner.

- **Execution**: The exploit requires no special timing, state manipulation, or complex transactions. The attacker simply provides an arbitrary Hash value instead of using the correctly calculated signature when constructing their `UpdateValueInput`.

- **Cost**: Zero - changing a hash value in the transaction input costs nothing beyond normal transaction fees.

- **Detection**: Impossible - there is no validation logic that compares the provided signature against the expected `CalculateSignature()` result, so the attack is indistinguishable from legitimate behavior at the contract level.

- **Success Rate**: 100% - every malicious signature is accepted and stored in the round state.

## Recommendation

Add cryptographic validation in `UpdateValueValidationProvider` to verify that the provided signature matches the expected calculated value:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;
    
    var providedSignature = extraData.Round.RealTimeMinersInformation[publicKey].Signature;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty) 
        return true;
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    
    return providedSignature == expectedSignature;
}
```

Then call this validation method in `ValidateHeaderInformation` before accepting the signature.

## Proof of Concept

A malicious miner can exploit this by:

1. Being a valid miner in the current round
2. When their turn comes to produce a block, instead of calling `previousRound.CalculateSignature(previousInValue)`, they choose an arbitrary Hash value
3. They construct their `UpdateValueInput` with this arbitrary signature
4. The contract accepts it without validation
5. Their next round position is now determined by their chosen signature value via `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
6. If they are order 1 in the current round, they also control who becomes the extra block producer

The test would verify that two different signature values for the same previousInValue both get accepted, and result in different next-round mining orders, proving that signature validation is missing.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L112-122)
```csharp
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```
