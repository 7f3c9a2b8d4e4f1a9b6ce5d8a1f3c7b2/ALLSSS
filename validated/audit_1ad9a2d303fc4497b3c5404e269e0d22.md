# Audit Report

## Title
Consensus DoS via Unchecked FinalOrderOfNextRound Values in TuneOrderInformation

## Summary
A malicious miner can permanently halt consensus by submitting extreme integer values through the `TuneOrderInformation` parameter in `UpdateValue`. The values are applied without bounds validation, causing integer overflow exceptions during next round generation that prevent block production.

## Finding Description

The AEDPoS consensus system allows miners to adjust mining orders for the next round via the `TuneOrderInformation` field in `UpdateValueInput`. However, the system fails to validate that these order values are within acceptable bounds (1 to minersCount), enabling a DoS attack.

**Attack Execution Path:**

1. **Malicious Input Construction**: A miner crafts an `UpdateValueInput` with `TuneOrderInformation` containing extreme values like `{"targetMinerPubkey": 2147483647}` (int.MaxValue). The protobuf definition allows any int32 value. [1](#0-0) 

2. **Direct Application Without Validation**: In `ProcessUpdateValue`, these values are directly applied to the round state without any bounds checking: [2](#0-1) 

3. **Insufficient Validation**: The validation system fails to catch this because for `UpdateValue` behavior, only `UpdateValueValidationProvider` and `LibInformationValidationProvider` are used: [3](#0-2) 

4. **Missing Order Validation**: `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, but not `TuneOrderInformation`: [4](#0-3) 

5. **Wrong Validator Scope**: `NextRoundMiningOrderValidationProvider`, which validates order-related constraints, is only applied for `NextRound` behavior, not `UpdateValue`: [5](#0-4) 

6. **Overflow During Next Round Generation**: When the next round needs to be generated, `GenerateNextRoundInformation` processes miners ordered by their `FinalOrderOfNextRound` values and calculates `ExpectedMiningTime`: [6](#0-5) 

7. **Checked Arithmetic Exception**: The multiplication `miningInterval.Mul(order)` where `order = int.MaxValue` triggers an overflow. Since `SafeMath.Mul` uses checked arithmetic, it throws an `OverflowException`: [7](#0-6) 

8. **Consensus Halt**: This exception occurs in `GetConsensusExtraDataForNextRound` when generating next round information: [8](#0-7) 
   This prevents the extra block producer from generating valid consensus extra data, permanently halting consensus progression.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability causes complete blockchain denial-of-service:

- **Permanent Consensus Halt**: All block production stops. Once malicious `FinalOrderOfNextRound` values are committed to state, no miner can generate valid next round consensus data because the overflow exception occurs during round generation.

- **No Automatic Recovery**: The blockchain requires manual intervention (likely a coordinated hard fork) to recover, as the malicious state persists on-chain and cannot be overridden through normal consensus operations.

- **Total Network Paralysis**: All blockchain operations cease:
  - No transaction processing
  - Cross-chain operations frozen
  - Governance proposals cannot execute
  - Token operations impossible
  - Validators lose rewards
  - dApps become non-functional

The impact extends to every participant in the ecosystem without any automatic recovery mechanism.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially executable:

- **Low Barrier to Entry**: Any active miner in the current round can execute the attack via the public `UpdateValue` method: [9](#0-8) 

- **Single Transaction**: Only one transaction with crafted `TuneOrderInformation` is required. No complex coordination, timing, or cryptographic operations needed.

- **Immediate Effect**: Once the transaction executes and state is updated, the next round generation attempt immediately triggers the overflow and halts consensus.

- **Economic Motivation**: While the attacker loses future mining rewards, the attack may be worthwhile for:
  - Competitors attacking rival blockchains
  - Ransom/extortion scenarios
  - Exploiting economic positions benefiting from network downtime
  - Malicious disruption

## Recommendation

Add bounds validation for `TuneOrderInformation` values in `ProcessUpdateValue`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate TuneOrderInformation bounds
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount, 
            $"Invalid order value {tuneOrder.Value}. Must be between 1 and {minersCount}.");
        Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
            "Cannot tune order for non-existent miner.");
    }
    
    // ... rest of existing code
}
```

Alternatively, apply `NextRoundMiningOrderValidationProvider` to `UpdateValue` behavior, or create a dedicated validator for `TuneOrderInformation`.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousTuneOrderInformation_CausesConsensusHalt()
{
    // Setup: Initialize consensus with 3 miners
    var miners = GenerateMiners(3);
    await InitializeConsensus(miners);
    
    // Attacker (miner 1) crafts malicious UpdateValueInput
    var maliciousInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = Hash.FromString("sig"),
        PreviousInValue = Hash.Empty,
        ActualMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
        SupposedOrderOfNextRound = 1,
        // ATTACK: Set extreme value
        TuneOrderInformation = 
        {
            { miners[1].PublicKey.ToHex(), int.MaxValue }
        }
    };
    
    // Execute malicious UpdateValue - this should succeed
    await miners[0].ExecuteUpdateValue(maliciousInput);
    
    // Attempt next round generation - this should throw OverflowException
    var exception = await Assert.ThrowsAsync<OverflowException>(async () =>
    {
        await miners[2].GenerateNextRound(); // Extra block producer
    });
    
    // Verify consensus is halted - no new blocks can be produced
    Assert.NotNull(exception);
    Assert.Contains("Arithmetic operation resulted in an overflow", exception.Message);
}
```

**Notes**

The vulnerability exists because the consensus system trusts miners not to provide malicious `TuneOrderInformation` values, but any miner can call the public `UpdateValue` method with arbitrary input. The separation of validation providers (order validation only for `NextRound`, not `UpdateValue`) creates a gap where malicious values bypass checks during input but cause failures during later computation. The use of checked arithmetic in `SafeMath.Mul` correctly prevents silent integer overflow but results in an exception that permanently halts consensus when malicious state has already been persisted.

### Citations

**File:** protobuf/aedpos_contract.proto (L208-208)
```text
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L13-19)
```csharp
    public static int Mul(this int a, int b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
