# Audit Report

## Title
Unauthorized Candidate Registration via AnnounceElectionFor() Enables Authorization Violation, Subsidy Theft, and DataCentersRankingList DoS

## Summary
The `AnnounceElectionFor()` function accepts arbitrary public keys from user input without verifying ownership or authorization, allowing attackers to register victims' keys as election candidates without consent. This authorization bypass enables attackers to capture subsidy benefits, lock victims out of admin control, and potentially DoS the DataCentersRankingList for legitimate candidates.

## Finding Description

The Election contract provides two methods for announcing candidacy: `AnnounceElection()` which validates ownership through `Context.RecoverPublicKey()`, and `AnnounceElectionFor()` which accepts any public key without validation. [1](#0-0) 

The vulnerable `AnnounceElectionFor()` function directly accepts a public key string from user input and passes it to the private `AnnounceElection(byte[])` method without any ownership verification: [2](#0-1) 

The private validation method only checks that the key is not an initial miner, not already a candidate, and not banned - but performs no ownership check: [3](#0-2) 

**Attack Execution:**

1. Attacker calls `AnnounceElectionFor()` with victim's public key
2. Admin defaults to `Context.Sender` (the attacker) if not explicitly provided
3. Attacker locks 100,000 ELF tokens (fully recoverable later) [4](#0-3) 

4. If DataCentersRankingList has capacity (minersCount × 5), the victim is automatically enrolled in the BackupSubsidy profit scheme [5](#0-4) 

**Victim Lockout:**

The victim cannot quit the election because only the admin (the attacker) has permission: [6](#0-5) 

The victim cannot change the admin because an admin is already set, and only the current admin (or Parliament) can modify it: [7](#0-6) 

**Subsidy Theft:**

When candidates are registered and the DataCentersRankingList has available slots, they are automatically enrolled as beneficiaries in the BackupSubsidy profit scheme: [8](#0-7) 

While legitimate candidates with votes can eventually replace fake 0-vote candidates through the replacement mechanism, attackers receive subsidy distributions during the interim period: [9](#0-8) 

## Impact Explanation

**Primary Impact - Authorization Violation (HIGH):**
- Fundamental violation of user autonomy - attackers can register arbitrary public keys as candidates without owner consent
- Victims' identities are permanently associated with election candidacy in immutable blockchain state
- Only recourse is slow Parliament governance intervention
- Reputational and privacy damage from unauthorized public listing

**Secondary Impact - Subsidy Theft (MEDIUM-HIGH):**
- Attackers receive BackupSubsidy profit distributions for controlled fake candidates
- With 17 miners (standard), DataCentersRankingList capacity is 85 slots (17 × 5)
- Cost to fill all slots: 8,500,000 ELF (85 × 100,000 ELF)
- Legitimate candidates miss initial subsidy benefits until replacement occurs
- Since tokens are fully recoverable via `QuitElection()`, attack cost is transaction fees only [10](#0-9) 

**Tertiary Impact - Griefing/DoS (MEDIUM):**
- Continuous cycle of registration and quitting disrupts election system
- Legitimate candidates face delays in accessing subsidy benefits
- System instability from repeated DataCentersRankingList manipulation

## Likelihood Explanation

**High Likelihood:**
- `AnnounceElectionFor()` is a public function with no access control
- Only requires 100,000 ELF per candidate (fully recoverable)
- No complex preconditions or timing requirements
- Attack is straightforward and deterministic
- Existing test suite confirms the functionality works as designed: [11](#0-10) 

## Recommendation

Add ownership verification to `AnnounceElectionFor()` to ensure the caller has authorization from the public key owner. Two possible approaches:

**Option 1: Require signature from both sponsor and candidate**
- Modify input to include a signature from the candidate's private key
- Verify the signature matches the provided public key before registration

**Option 2: Require candidate to pre-approve sponsor**
- Add a whitelist mechanism where public key owners pre-approve specific addresses
- Check whitelist before allowing registration

**Recommended Fix (Option 2):**
```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    
    // NEW: Verify caller is approved by the candidate
    var candidateAddress = Address.FromPublicKey(pubkeyBytes);
    var approvedSponsors = State.ApprovedSponsorsMap[candidateAddress];
    Assert(approvedSponsors != null && approvedSponsors.Addresses.Contains(Context.Sender),
        "Caller is not approved to sponsor this candidate.");
    
    // Continue with existing logic...
    AnnounceElection(pubkeyBytes);
    var admin = input.Admin ?? Context.Sender;
    // ... rest of function
}
```

Additionally, add a new method for candidates to manage their approved sponsors:
```csharp
public override Empty ApproveElectionSponsor(Address sponsor)
{
    var candidatePubkey = Context.RecoverPublicKey();
    var approvedList = State.ApprovedSponsorsMap[Context.Sender] ?? new AddressList();
    if (!approvedList.Addresses.Contains(sponsor))
        approvedList.Addresses.Add(sponsor);
    State.ApprovedSponsorsMap[Context.Sender] = approvedList;
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task UnauthorizedCandidateRegistration_Attack()
{
    // Setup: Attacker and victim keypairs
    var attackerKeyPair = SampleAccount.Accounts.First().KeyPair;
    var victimKeyPair = SampleAccount.Accounts.Last().KeyPair;
    
    // Attacker prepares their tokens
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    var attackerBalanceBefore = await GetNativeTokenBalance(attackerKeyPair.PublicKey);
    
    // ATTACK: Attacker registers victim's public key without authorization
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Admin = Address.FromPublicKey(attackerKeyPair.PublicKey), // Attacker controls admin
        Pubkey = victimKeyPair.PublicKey.ToHex() // Victim's key
    });
    
    // VERIFY: Victim's key is now registered as candidate
    var candidateInfo = await attackerStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    candidateInfo.IsCurrentCandidate.ShouldBeTrue();
    
    // VERIFY: Attacker is the admin (has control)
    var admin = await attackerStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    admin.ShouldBe(Address.FromPublicKey(attackerKeyPair.PublicKey));
    
    // VERIFY: Victim is enrolled in DataCentersRankingList and subsidy scheme
    var dataCenterList = await attackerStub.GetDataCenterRankingList.CallAsync(new Empty());
    dataCenterList.DataCenters.ContainsKey(victimKeyPair.PublicKey.ToHex()).ShouldBeTrue();
    
    var subsidySchemeId = ProfitItemsIds[ProfitType.BackupSubsidy];
    var profitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput
        {
            SchemeId = subsidySchemeId,
            Beneficiary = Address.FromPublicKey(victimKeyPair.PublicKey)
        });
    profitDetail.Details.Count.ShouldBeGreaterThan(0); // Enrolled in subsidy
    
    // VERIFY: Attacker can recover tokens by quitting
    await attackerStub.QuitElection.SendAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    
    var attackerBalanceAfter = await GetNativeTokenBalance(attackerKeyPair.PublicKey);
    attackerBalanceAfter.ShouldBe(attackerBalanceBefore - TransactionFees); // Only lost fees
}
```

## Notes

This vulnerability exists because `AnnounceElectionFor()` was designed to enable "sponsorship" where one party pays the deposit for another, but lacks the fundamental security requirement that candidates must consent to registration. The function should either require proof of candidate authorization or be restricted to candidates who have explicitly whitelisted sponsors.

The issue is particularly severe because:
1. It violates the core principle that users control their own identity
2. The victim has no practical recourse except Parliament intervention
3. Attackers can profit from subsidy distributions at minimal cost
4. The attack is repeatable and can scale to DoS the entire DataCentersRankingList

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-42)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-236)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L732-746)
```csharp
    private void CandidateReplaceMemberInDataCenter(DataCenterRankingList rankingList, string candidate,
        long voteAmount)
    {
        var dateCenter = rankingList.DataCenters;
        if (dateCenter.Count < GetValidationDataCenterCount())
            return;
        if (dateCenter.ContainsKey(candidate))
            return;
        var list = dateCenter.ToList();
        var minimumVoteCandidateInDataCenter = list.OrderBy(x => x.Value).First();
        if (voteAmount <= minimumVoteCandidateInDataCenter.Value) return;
        dateCenter.Remove(minimumVoteCandidateInDataCenter.Key);
        dateCenter[candidate] = voteAmount;
        NotifyProfitReplaceCandidateInDataCenter(minimumVoteCandidateInDataCenter.Key, candidate);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-795)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/SponsorTests.cs (L16-49)
```csharp
    public async Task ElectionContract_AnnounceElectionFor_State_Test()
    {
        var candidatesKeyPair = ValidationDataCenterKeyPairs.First();
        var sponsorKeyPair = ValidationDataCenterKeyPairs.Last();
        var balanceBeforeAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);

        // Execute AnnounceElectionFor.
        var electionStub = GetElectionContractTester(sponsorKeyPair);
        var candidateAdmin = Address.FromPublicKey(candidatesKeyPair.PublicKey);
        await electionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
        {
            Admin = candidateAdmin,
            Pubkey = candidatesKeyPair.PublicKey.ToHex()
        });

        var balanceAfterAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);
        balanceAfterAnnouncing.ShouldBe(balanceBeforeAnnouncing - ElectionContractConstants.LockTokenForElection);

        var votingItem = await VoteContractStub.GetVotingItem.CallAsync(new GetVotingItemInput
        {
            VotingItemId = MinerElectionVotingItemId
        });
        votingItem.Options.Count.ShouldBe(1);
        votingItem.Options.ShouldContain(candidatesKeyPair.PublicKey.ToHex());
        var dataCenterList = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
        dataCenterList.DataCenters.ContainsKey(candidatesKeyPair.PublicKey.ToHex()).ShouldBeTrue();
        var subsidy = ProfitItemsIds[ProfitType.BackupSubsidy];
        var profitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            SchemeId = subsidy,
            Beneficiary = Address.FromPublicKey(candidatesKeyPair.PublicKey)
        });
        profitDetail.Details.Count.ShouldBe(1);
    }
```
