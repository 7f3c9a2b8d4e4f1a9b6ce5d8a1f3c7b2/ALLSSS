# Audit Report

## Title
LIB Height Manipulation via Ineffective Validation of ImpliedIrreversibleBlockHeight in UpdateValue

## Summary
The `LibInformationValidationProvider` validation executes after `RecoverFromUpdateValue` has already overwritten the base round's `ImpliedIrreversibleBlockHeight` with the provided value, making the validation check ineffective. This allows malicious miners to submit arbitrary implied irreversible block heights, enabling ≥1/3 colluding miners to manipulate the LIB calculation and halt finality progression.

## Finding Description

**Root Cause - Validation Order Flaw:**

In `ValidateBeforeExecution`, the method retrieves the current round from state, then calls `RecoverFromUpdateValue` to merge provided consensus data into the base round **before** running validation providers. [1](#0-0) 

The critical flaw occurs where `RecoverFromUpdateValue` is invoked before the validation context is created and before validation providers execute: [2](#0-1) [3](#0-2) [4](#0-3) 

The `RecoverFromUpdateValue` method unconditionally overwrites the base round's `ImpliedIrreversibleBlockHeight`: [5](#0-4) 

After this modification, the validation context uses the already-modified `baseRound`. The `ProvidedRound` property accesses the original data from `ExtraData.Round`: [6](#0-5) 

When `LibInformationValidationProvider` executes, it compares the miner's `ImpliedIrreversibleBlockHeight` from `baseRound` against `providedRound`: [7](#0-6) 

The check is now ineffective because both `baseRound[pubkey].ImpliedIrreversibleBlockHeight` and `providedRound[pubkey].ImpliedIrreversibleBlockHeight` contain the **same** value after the overwrite. The intended validation `baseRound > providedRound` becomes `newValue > newValue`, which always evaluates to false and passes validation.

**Exploitation Path:**

1. The honest implementation sets `ImpliedIrreversibleBlockHeight = Context.CurrentHeight`: [8](#0-7) 

2. A malicious miner can craft their own consensus extra data with artificially low `ImpliedIrreversibleBlockHeight` (e.g., 0 or any value below current height).

3. The validation fails to detect this due to the order bug.

4. `ProcessUpdateValue` stores the fake value in state: [9](#0-8) 

5. In the next round, `LastIrreversibleBlockHeightCalculator` retrieves these values from the previous round and selects the LIB: [10](#0-9) 

6. The sorting mechanism retrieves values from miners who participated in the current round: [11](#0-10) 

7. If ≥ `⌊(count-1)/3⌋ + 1` miners collude to provide artificially low values, they can control the selected LIB height, as their low values will occupy the lower indices of the sorted array.

## Impact Explanation

**Consensus Integrity Violation:**

The LIB (Last Irreversible Block) height can be manipulated to freeze or slow its advancement. While the forward-only check prevents LIB from moving backward: [12](#0-11) 

This does not prevent the LIB from being artificially frozen at a low value while block production continues normally.

**Byzantine Fault Tolerance Compromise:**

For a network with n miners:
- With n=7: `⌊(7-1)/3⌋ = 2`, requiring 3+ colluding miners (43%) to control the LIB
- With n=21: `⌊(21-1)/3⌋ = 6`, requiring 7+ colluding miners (33%) to control the LIB

This is at the edge of or exceeds standard BFT 1/3 Byzantine tolerance.

**Operational Impact:**

1. **Finality DoS**: Blocks cannot become irreversible, preventing transaction finality guarantees
2. **Cross-chain operations blocked**: Cross-chain indexing and verification depend on LIB heights for security, so frozen LIB advancement blocks cross-chain transfers and message passing
3. **System-wide degradation**: Applications and smart contracts relying on finality guarantees cannot confirm critical transactions (e.g., high-value transfers, governance actions)

## Likelihood Explanation

**Attacker Requirements:**
- Control of ≥1/3 of active miners
- Coordination among colluding miners
- Modification of mining software to bypass honest consensus transaction generation

**Feasibility Assessment:**

While miners are elected and economically incentivized through staking, creating barriers to collusion, the 1/3 threshold is achievable in scenarios such as:
- Compromised mining pools controlling multiple validator nodes
- Nation-state level attacks targeting blockchain infrastructure
- Economic incentives from competitors to disrupt cross-chain operations
- Coordinated attacks during periods of low miner participation

**Detection:**
The attack is observable - LIB height stops advancing while block production continues. Monitoring systems can detect the discrepancy between current block height and LIB height, and forensic analysis can identify which miners submitted abnormally low implied heights.

**Economic Rationality:**
While direct financial gain may be limited (no immediate fund theft), motivations include:
- Disrupting competitor chains in cross-chain ecosystems
- Market manipulation (shorting tokens dependent on chain operations)
- Censorship (preventing finality of specific transactions)
- Extortion (demanding payment to restore normal operations)

The attack requires medium execution complexity - miner collusion but no sophisticated cryptographic exploits.

## Recommendation

Fix the order of operations by preserving the original `baseRound` state for validation. The validation should compare the original state against the provided values, not the already-modified state.

**Option 1**: Clone `baseRound` before calling `RecoverFromUpdateValue`:
```csharp
var originalBaseRound = baseRound.Clone(); // Preserve original for validation
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

var validationContext = new ConsensusValidationContext
{
    BaseRound = originalBaseRound, // Use original for validation
    // ... rest of context
};
```

**Option 2**: Perform validation before calling `RecoverFromUpdateValue`:
```csharp
// Create validation context first with unmodified baseRound
var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound,
    // ... rest of context
};

// Validate first
var validationResult = service.ValidateInformation(validationContext);
if (!validationResult.Success)
    return validationResult;

// Only then modify state
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**Option 3**: Modify `LibInformationValidationProvider` to fetch the original value from state directly instead of using the modified `baseRound`.

## Proof of Concept

```csharp
[Fact]
public async Task LibHeightManipulation_ViaIneffectiveValidation()
{
    // Setup: Initialize consensus with 7 miners
    var miners = GenerateMiners(7);
    await InitializeConsensusAsync(miners);
    
    // Advance to round 2
    await ProduceNormalBlocksUntilNextRound();
    
    var currentHeight = await GetCurrentBlockHeightAsync();
    var currentLib = await GetLibHeightAsync();
    
    // Attack: 3 colluding miners (≥1/3) submit artificially low ImpliedIrreversibleBlockHeight
    var maliciousHeight = currentLib - 100; // Artificially low value
    
    for (int i = 0; i < 3; i++)
    {
        var maliciousMiner = miners[i];
        var updateInput = CreateUpdateValueInput(maliciousMiner);
        updateInput.ImpliedIrreversibleBlockHeight = maliciousHeight; // Malicious value
        
        // This should fail validation but doesn't due to the bug
        var result = await ExecuteUpdateValueAsync(maliciousMiner, updateInput);
        result.Status.ShouldBe(TransactionResultStatus.Mined); // Incorrectly succeeds
    }
    
    // Honest miners submit correct values
    for (int i = 3; i < 7; i++)
    {
        var honestMiner = miners[i];
        var updateInput = CreateUpdateValueInput(honestMiner);
        updateInput.ImpliedIrreversibleBlockHeight = currentHeight; // Honest value
        await ExecuteUpdateValueAsync(honestMiner, updateInput);
    }
    
    // Advance to next round to trigger LIB calculation
    await ProduceNormalBlocksUntilNextRound();
    
    var newLib = await GetLibHeightAsync();
    
    // Verify: LIB is controlled by malicious miners at index (7-1)/3 = 2
    // The sorted array will be: [maliciousHeight, maliciousHeight, maliciousHeight, currentHeight, ...]
    // Index 2 selects the 3rd element, which is maliciousHeight
    newLib.ShouldBe(maliciousHeight); // LIB is artificially low
    
    // Verify: Block production continues normally
    var newHeight = await GetCurrentBlockHeightAsync();
    newHeight.ShouldBeGreaterThan(currentHeight + 10); // Blocks continue to be produced
    
    // Impact demonstrated: LIB frozen while blocks continue
    (newHeight - newLib).ShouldBeGreaterThan(100); // Large gap = finality DoS
}
```

## Notes

This vulnerability represents a critical flaw in the consensus finality mechanism. The root cause is an incorrect order of operations where state modification happens before validation, causing the validation to become a no-op. The system's Byzantine fault tolerance is compromised at exactly the 1/3 threshold, which should be the maximum tolerable Byzantine actor percentage in a BFT system. The fix requires careful refactoring to ensure validation sees the original state values before any modifications occur.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-19)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-60)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L82-82)
```csharp
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L98-98)
```csharp
        var validationResult = service.ValidateInformation(validationContext);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-21)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-249)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-18)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
```
