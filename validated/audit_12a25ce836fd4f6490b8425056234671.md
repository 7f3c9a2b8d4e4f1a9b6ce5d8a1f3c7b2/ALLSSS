# Audit Report

## Title
Predictable Miner Ordering in First Round of New Term Due to Empty InValue Chain

## Summary
The AEDPoS consensus contract fails to generate unique InValues for miners during the first round of a new term. When `IsMinerListJustChanged = true`, the `SecretSharingInformation` event is not fired, preventing InValue generation. All miners default to using `Hash.Empty` as their InValue, producing identical OutValues and Signatures. This breaks the consensus randomness mechanism, making round 2 miner ordering completely predictable and manipulable.

## Finding Description

The vulnerability exists in the consensus round initialization and secret sharing logic.

**Root Cause - Empty InValue Initialization:**

When generating the first round of a new term, all miners receive `PreviousInValue = Hash.Empty` [1](#0-0) , and the round is marked with `IsMinerListJustChanged = true` [2](#0-1) .

**Broken InValue Generation:**

The `SecretSharingInformation` event is only fired when `round.RoundNumber > 1 && !round.IsMinerListJustChanged` [3](#0-2) . When this condition fails, no event is emitted, and InValue generation never occurs. The InValue cache returns `Hash.Empty` for uncached values [4](#0-3) .

**Identical Signature Computation:**

During block production, OutValue and Signature are computed from the InValue [5](#0-4) . For the first round of a new term, the conditional check `!IsFirstRoundOfCurrentTerm(out _)` evaluates to false [6](#0-5) , preventing the signature from being recalculated with previous round data. All miners compute the same signature from `Hash.Empty`.

**Predictable Order Calculation:**

The signature determines `SupposedOrderOfNextRound` via modulo operation [7](#0-6) . Identical signatures produce identical supposed orders, triggering conflict resolution [8](#0-7) . The next round generation orders miners by their `FinalOrderOfNextRound` [9](#0-8) , making round 2 ordering deterministic based on round 1 block production sequence.

The validation logic explicitly permits `Hash.Empty` as `PreviousInValue` [10](#0-9) , providing no protection against this scenario.

## Impact Explanation

**Consensus Security Degradation:**
This vulnerability breaks the fundamental consensus property of unpredictable and unmanipulable miner ordering. The VRF-based secret sharing mechanism, designed to ensure randomness in block producer selection, is completely bypassed for the first round of every new term.

**Exploitation Scenarios:**
1. **Predictable Ordering:** All miners can pre-compute the exact round 2 mining sequence before any blocks are produced in round 1
2. **Coordination Attacks:** Colluding miners can selectively skip their round 1 time slots to manipulate which miners receive favorable positions in round 2
3. **Extra Block Producer Targeting:** The extra block producer for round 2 is selected via the same predictable signature calculation [11](#0-10) , enabling targeted attacks on that position
4. **MEV Opportunities:** Miners can optimize their participation strategy based on known future ordering to maximize MEV extraction

**Affected Parties:**
- Network security relies on unpredictable consensus
- Honest miners face information asymmetry
- Applications depending on fair block producer selection
- Users expecting consensus randomness guarantees

While this doesn't directly enable fund theft or chain reorganization, it systematically undermines a core security assumption of the consensus mechanism.

## Likelihood Explanation

**Automatic Occurrence:**
This vulnerability triggers automatically at every term change, which occurs periodically based on election results. The term change process through `NextTerm` invokes the problematic round generation logic as part of normal protocol operation.

**Zero Attack Complexity:**
Any miner can:
1. Observe that `IsMinerListJustChanged = true` for the first round of a new term
2. Calculate that all miners will use `InValue = Hash.Empty`
3. Compute the resulting identical signatures
4. Predict the exact round 2 ordering via the deterministic conflict resolution algorithm

**No Special Privileges Required:**
All information needed is publicly available on-chain. No consensus key compromise, special authorization, or economic cost is required to observe and exploit this behavior.

**Certainty:**
This is not a probabilistic vulnerabilityâ€”it occurs with 100% certainty at every term transition by design due to the `IsMinerListJustChanged` flag in the round generation logic.

## Recommendation

Generate unique InValues for the first round of a new term through an alternative mechanism:

1. **Option 1 - Bootstrap InValues:** Generate deterministic but unique InValues for each miner based on their public key and the term number when `IsMinerListJustChanged = true`:
   ```csharp
   if (round.IsMinerListJustChanged && round.TermNumber > 1)
   {
       // Generate bootstrap InValues
       foreach (var miner in round.RealTimeMinersInformation)
       {
           var bootstrapInValue = HashHelper.ComputeFrom(
               miner.Key.Append(round.TermNumber.ToString()));
           // Cache the bootstrap InValue for use in block production
       }
   }
   ```

2. **Option 2 - Fire Event Unconditionally:** Modify the event firing logic to generate InValues even when `IsMinerListJustChanged = true`:
   ```csharp
   if (round.RoundNumber > 1) // Remove the IsMinerListJustChanged check
   {
       Context.Fire(new SecretSharingInformation { ... });
   }
   ```

3. **Option 3 - Use Previous Term Data:** If a previous term exists, use the last round's signatures from the previous term as the basis for generating initial InValues in the new term.

## Proof of Concept

A test demonstrating the vulnerability would:
1. Simulate a term transition creating a new round with `IsMinerListJustChanged = true`
2. Verify no `SecretSharingInformation` event is fired
3. Show all miners produce identical signatures from `Hash.Empty`
4. Demonstrate round 2 ordering is deterministically calculable from round 1 production sequence
5. Prove miners can manipulate round 2 ordering through selective round 1 participation

The core issue is in the interaction between `GenerateFirstRoundOfNewTerm` setting empty InValues and `AddRoundInformation` not firing the secret sharing event, combined with the signature calculation logic that doesn't compensate for this initialization state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L35-35)
```csharp
            minerInRound.PreviousInValue = Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IInValueCache.cs (L31-32)
```csharp
        _inValues.TryGetValue(roundId, out var inValue);
        return inValue ?? Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L72-72)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-26)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-122)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```
