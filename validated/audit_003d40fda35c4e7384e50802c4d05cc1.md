# Audit Report

## Title
Insufficient Validation of OutValue in NextRound Allows Denial of Service Against Miners

## Summary
The `ValidationForNextRound()` method in `RoundTerminateValidationProvider` only validates that `InValue` is null for all miners in the next round, but critically fails to validate that `OutValue` is also null. This allows a malicious miner to inject arbitrary non-null `OutValue` data for other miners during round transitions, causing victims to be incorrectly identified as having already mined, preventing them from producing blocks and ultimately leading to their removal from the consensus set as "evil nodes."

## Finding Description

The vulnerability exists in the consensus round transition validation logic. When a miner triggers a NextRound transition, the validation only checks that `InValue` fields are null but completely omits validation of `OutValue` fields. [1](#0-0) 

The comment explicitly states "In Values Should Be Null" but makes no mention of OutValue validation. When a legitimate next round is generated, both InValue and OutValue should be null for all miners. [2](#0-1) 

A malicious miner can exploit this by calling the public `NextRound` method with crafted data: [3](#0-2) 

The malicious NextRoundInput data is converted to a Round object via `ToRound()`, which directly copies ALL fields including OutValue: [4](#0-3) 

This corrupted round data is then stored directly without additional OutValue validation: [5](#0-4) 

The attack succeeds because consensus behavior determination relies critically on OutValue being null to identify miners who haven't mined yet: [6](#0-5) 

If OutValue is non-null (due to malicious injection), the miner is incorrectly treated as having already mined, causing them to skip the `UpdateValue` behavior and miss their mining slot entirely. The miner's `MissedTimeSlots` counter then increments for each missed round, and sustained attacks lead to permanent banning. [7](#0-6) [8](#0-7) 

## Impact Explanation

**Severity: HIGH**

**Consensus Integrity Impact:**
- Victim miners are completely prevented from producing their first consensus block (UpdateValue) during affected rounds because the system incorrectly believes they have already mined
- Each victim's `MissedTimeSlots` counter increments with every affected round
- After 4,320 missed time slots (approximately 3 days at 1 slot per minute), victims are permanently marked as "evil nodes" and removed from the consensus validator set
- The Election contract receives this evil node designation and bans the miner

**Network-Wide Impact:**
- Reduces the effective number of active consensus miners, directly weakening network security
- If multiple miners are targeted simultaneously, could severely impact chain liveness and block production rate
- Honest miners lose all mining rewards for missed blocks
- Network experiences degraded service quality and potentially slower transaction finalization

**Who is Affected:**
- Any honest miner can be targeted by any malicious miner during their turn as extra block producer
- The entire network suffers from reduced consensus security
- Users experience degraded blockchain performance

This is a HIGH severity vulnerability because it enables a single malicious consensus miner to permanently remove honest validators from the network through a simple, low-cost attack that corrupts consensus state.

## Likelihood Explanation

**Probability: HIGH**

**Attacker Prerequisites (Easily Met):**
- Attacker must be a current consensus miner (approximately 17 miners in typical configuration)
- Attacker must be selected as the extra block producer to trigger NextRound (occurs naturally in rotation through all miners)
- Attacker modifies their node to inject malicious OutValue data

**Attack Complexity: LOW**
- The attack is straightforward: construct a NextRoundInput with non-null OutValue for target miners
- No complex timing requirements, race conditions, or cryptographic operations needed
- Single transaction executes the complete attack
- No additional economic cost beyond normal mining operations

**Feasibility: HIGH**
- The NextRound method is publicly accessible to all miners
- Miners regularly rotate through the extra block producer role, providing repeated attack opportunities
- The validation gap ensures the malicious transaction will pass all checks

**Detection: DIFFICULT**
- Malicious OutValue data is visible in block data but may not trigger immediate monitoring alerts
- Effects (miners missing slots) could initially be attributed to network connectivity issues
- Requires detailed blockchain analysis to identify the root cause of miner failures

The combination of easy prerequisites, low complexity, high feasibility, and difficult detection makes this a HIGH likelihood vulnerability.

## Recommendation

Add OutValue validation to the `ValidationForNextRound()` method to ensure all miners have null OutValue in next round data:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // Validate InValue is null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information: InValue must be null." };
    
    // ADD THIS: Validate OutValue is also null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.OutValue != null))
        return new ValidationResult { Message = "Incorrect next round information: OutValue must be null." };

    return new ValidationResult { Success = true };
}
```

This ensures the critical invariant that at the start of a new round, all miners must have both null InValue AND null OutValue, preventing malicious data injection.

## Proof of Concept

```csharp
[Fact]
public async Task OutValueInjectionAttack_ShouldPreventVictimFromMining()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeContracts();
    var miners = InitialCoreDataCenterKeyPairs;
    var attacker = miners[0];
    var victim = miners[1];
    
    // Advance to a round where attacker is extra block producer
    await BootMinerProduceBlocks(miners);
    
    // Attacker crafts malicious NextRound data
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var maliciousNextRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = { currentRound.RealTimeMinersInformation }
    };
    
    // Inject non-null OutValue for victim
    var victimPubkey = victim.PublicKey.ToHex();
    maliciousNextRound.RealTimeMinersInformation[victimPubkey].OutValue = HashHelper.ComputeFrom("malicious");
    maliciousNextRound.RealTimeMinersInformation[victimPubkey].InValue = null; // Keep InValue null to pass validation
    
    // Attacker submits malicious NextRound transaction
    var attackerStub = GetAEDPoSContractStub(attacker);
    var result = await attackerStub.NextRound.SendAsync(NextRoundInput.Create(maliciousNextRound, GenerateRandomNumber()));
    
    // Attack succeeds - transaction passes validation
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify victim cannot produce blocks in new round
    var victimStub = GetAEDPoSContractStub(victim);
    var command = await victimStub.GetConsensusCommand.CallAsync(BytesValue.FromHexString(victimPubkey));
    
    // Victim should get UpdateValue behavior but gets Nothing instead
    command.Behaviour.ShouldNotBe(AElfConsensusBehaviour.UpdateValue);
    
    // Verify victim's MissedTimeSlots will increment
    var updatedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    updatedRound.RealTimeMinersInformation[victimPubkey].OutValue.ShouldNotBeNull(); // Still contains malicious value
}
```

## Notes

This vulnerability breaks a fundamental consensus invariant: at the start of each new round, all miners should have clean state (null InValue and OutValue) to properly participate in that round's VRF-based block production. The missing OutValue validation creates a critical gap that allows malicious miners to corrupt this state and effectively DoS other validators. The attack is particularly severe because it can lead to permanent removal of honest miners from the consensus set through the evil node detection mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
