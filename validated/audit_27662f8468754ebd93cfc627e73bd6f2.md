# Audit Report

## Title
Side Chain Rental Payment Bypass via Missing Creator Assertion

## Summary
The `PayRental()` function contains a critical flaw where it silently returns when `SideChainCreator` is null, allowing side chains to evade rental payments indefinitely. Since `InitializeFromParentChain()` requires Parliament governance approval and is not automatically enforced, a side chain can operate without setting a creator, permanently bypassing the rental fee mechanism designed to compensate the parent chain for resource usage.

## Finding Description

The vulnerability exists in the rental payment enforcement mechanism for side chains. The `PayRental()` function performs a null check on the creator and silently returns without processing any rental charges: [1](#0-0) 

This function is invoked automatically every block through the `DonateResourceToken()` method on side chains: [2](#0-1) 

The `DonateResourceToken()` method itself is called by a system transaction generator on every block: [3](#0-2) 

The `SideChainCreator` is only set when `InitializeFromParentChain()` is called, which invokes `SetSideChainCreator()`: [4](#0-3) 

However, `SetSideChainCreator()` requires either the genesis contract or Parliament default organization as the sender: [5](#0-4) 

Additionally, the creator can only be set once due to the assertion check at line 1131.

Test evidence confirms that side chains can operate without initialization, as demonstrated where the rental controller query fails with "side chain creator dose not exist" before initialization: [6](#0-5) 

The initialization is conditionally added during side chain setup, only if parent chain contract addresses are provided: [7](#0-6) 

**Root Cause:** The silent return allows a misconfigured or maliciously deployed side chain to bypass all rental payment logic. When the creator is null, the entire rental calculation loop is never executed, including debt tracking in `OwningRental` and token transfers to the consensus contract. [8](#0-7) 

## Impact Explanation

**Direct Economic Loss:**
- Side chains are designed to pay rental fees for resources (CPU, RAM, DISK, NET) calculated as: `duration × ResourceAmount[symbol] × Rental[symbol]` per minute
- The rental payment loop processes these charges at line 1040-1097, but is completely bypassed when creator is null
- Rental fees are intended to be transferred to the consensus contract to compensate parent chain validators for providing security and infrastructure
- A side chain without a creator receives unlimited free resource usage for its entire operational lifetime

**Affected Parties:**
- Parent chain loses continuous rental revenue that should fund consensus participants
- Properly initialized side chains face unfair economic competition from free-riding chains  
- The protocol's economic incentive structure is fundamentally undermined

**Severity Assessment:** HIGH - This enables permanent, unbounded economic loss. Once a side chain starts without a creator, there is no recovery mechanism to collect retroactive rental fees, and the chain can operate indefinitely without contributing to parent chain economics.

## Likelihood Explanation

**Attack Prerequisites:**
- Ability to deploy a side chain (via CrossChain contract with governance approval)
- Ability to influence or control side chain governance to prevent `InitializeFromParentChain()` approval
- No sophisticated technical capabilities required beyond normal protocol participation

**Attack Complexity:**
- LOW - The exploit is passive; simply never submitting or approving the initialization proposal is sufficient
- The side chain functions normally for all operations (token transfers, smart contracts, consensus)
- No active manipulation or complex transaction sequences needed

**Feasibility Conditions:**
1. **Misconfiguration Scenario:** Side chain deployed with incomplete initialization data or misconfigured genesis
2. **Governance Failure:** Initialization proposal submitted but never approved due to apathy or coordination failure
3. **Malicious Deployment:** Side chain operators deliberately skip initialization to evade rental obligations

**Detection Difficulty:**
- The side chain appears fully functional from a user perspective
- `DonateResourceToken()` executes successfully every block without errors or events
- No on-chain signals indicate rental payment failure (no failed transactions or error logs)
- Detection requires off-chain monitoring of rental payment flows and creator state

**Probability Assessment:** MEDIUM - Requires either deliberate exploitation or governance dysfunction during setup. However, once established, the bypass is automatic, permanent, and irreversible. The protocol lacks enforcement mechanisms to ensure initialization occurs before a side chain can begin operations.

## Recommendation

Add an assertion in `PayRental()` to fail the transaction if the creator is not set, forcing proper initialization:

```csharp
private void PayRental()
{
    var creator = State.SideChainCreator.Value;
    Assert(creator != null, "Side chain creator must be initialized before rental payment.");
    
    // Rest of the rental payment logic...
}
```

Alternatively, add validation in `DonateResourceToken()` to prevent side chain operation without a creator:

```csharp
if (!isMainChain)
{
    Assert(State.SideChainCreator.Value != null, 
        "Side chain must call InitializeFromParentChain before operations.");
    PayRental();
}
```

## Proof of Concept

The test at lines 38-47 demonstrates that a side chain can query for rental controller before initialization and receive the error "side chain creator dose not exist", proving the chain is operational without a creator: [9](#0-8) 

The test then shows `InitializeFromParentChain()` being called via Parliament proposal after the chain is already operational: [10](#0-9) 

This confirms that:
1. A side chain can operate without calling `InitializeFromParentChain()`
2. The creator remains null during this period
3. `PayRental()` silently returns every block without charging fees
4. The initialization must happen through governance, which may never occur

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L947-950)
```csharp
        if (!isMainChain)
        {
            PayRental();
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1019-1022)
```csharp
    private void PayRental()
    {
        var creator = State.SideChainCreator.Value;
        if (creator == null) return;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1040-1097)
```csharp
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);

            // Try to update owning rental.
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }

            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
            {
                donates = donates.Add(rental);
                ModifyBalance(creator, symbol, -donates);
            }
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }

            // Side Chain donates.
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);

            Context.Fire(new RentalCharged()
            {
                Symbol = symbol,
                Amount = donates,
                Payer = creator,
                Receiver = consensusContractAddress
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1129-1142)
```csharp
    private void SetSideChainCreator(Address input)
    {
        Assert(State.SideChainCreator.Value == null, "Creator already set.");
        if (State.ParliamentContract.Value == null)
        {
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
        }

        Assert(Context.Sender == Context.GetZeroSmartContractAddress() ||
               Context.Sender == State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            "No permission.");
        State.SideChainCreator.Value = input;
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/DonateResourceTransactionGenerator.cs (L28-75)
```csharp
    public async Task<List<Transaction>> GenerateTransactionsAsync(Address from, long preBlockHeight,
        Hash preBlockHash)
    {
        var generatedTransactions = new List<Transaction>();

        var chainContext = new ChainContext
        {
            BlockHash = preBlockHash,
            BlockHeight = preBlockHeight
        };

        var tokenContractAddress =
            await _smartContractAddressService.GetAddressByContractNameAsync(chainContext,
                TokenSmartContractAddressNameProvider.StringName);

        if (tokenContractAddress == null) return generatedTransactions;

        var totalResourceTokensMaps = await _totalResourceTokensMapsProvider.GetTotalResourceTokensMapsAsync(
            chainContext);

        ByteString input;
        if (totalResourceTokensMaps != null && totalResourceTokensMaps.BlockHeight == preBlockHeight &&
            totalResourceTokensMaps.BlockHash == preBlockHash)
            // If totalResourceTokensMaps match current block.
            input = totalResourceTokensMaps.ToByteString();
        else
            input = new TotalResourceTokensMaps
            {
                BlockHash = preBlockHash,
                BlockHeight = preBlockHeight
            }.ToByteString();

        generatedTransactions.AddRange(new List<Transaction>
        {
            new()
            {
                From = from,
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.DonateResourceToken),
                To = tokenContractAddress,
                RefBlockNumber = preBlockHeight,
                RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
                Params = input
            }
        });

        Logger.LogTrace("Tx DonateResourceToken generated.");
        return generatedTransactions;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L207-213)
```csharp
    public override AuthorityInfo GetSideChainRentalControllerCreateInfo(Empty input)
    {
        Assert(State.SideChainCreator.Value != null, "side chain creator dose not exist");
        Assert(State.SideChainRentalController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        return State.SideChainRentalController.Value;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/SideChainUnitTestTokenContractInitializationProvider.cs (L97-110)
```csharp
        if (initializationData.RegisteredOtherTokenContractAddresses.Values.All(v => v != null))
            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.InitializeFromParentChain),
                Params = new InitializeFromParentChainInput
                {
                    ResourceAmount = { initializationData.ResourceAmount },
                    RegisteredOtherTokenContractAddresses =
                    {
                        initializationData.RegisteredOtherTokenContractAddresses
                    },
                    Creator = initializationData.Creator
                }.ToByteString()
            });
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L37-47)
```csharp
    [Fact]
    public async Task SideChainRentalController_Test()
    {
        var rentalControllerRet =
            await TokenContractStub.GetSideChainRentalControllerCreateInfo.SendWithExceptionAsync(new Empty());
        rentalControllerRet.TransactionResult.Error.ShouldContain("side chain creator dose not exist");
        await InitialTokenContractAsync();
        var rentalController =
            await TokenContractStub.GetSideChainRentalControllerCreateInfo.CallAsync(new Empty());
        rentalController.ShouldNotBeNull();
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L303-316)
```csharp
        var setSideChainCreatorProposalInput = new InitializeFromParentChainInput
        {
            ResourceAmount =
            {
                { "CPU", CpuAmount },
                { "RAM", RamAmount },
                { "DISK", DiskAmount },
                { "NET", NetAmount }
            },
            Creator = Creator
        };
        await ParliamentReachAnAgreementAsync(TokenContractAddress, defaultParliamentOrganization,
            nameof(TokenContractImplContainer.TokenContractImplStub.InitializeFromParentChain),
            setSideChainCreatorProposalInput);
```
