# Audit Report

## Title
Consensus Halt via Null ExpectedMiningTime Validation Bypass in AEDPoS Round Transitions

## Summary
A malicious miner can bypass the `CheckRoundTimeSlots()` validation by manipulating `RoundIdForValidation` to match the current round's `RoundId`, allowing storage of a Round object with null `ExpectedMiningTime` fields. This causes `NullReferenceException` crashes in critical consensus paths, halting all block production network-wide.

## Finding Description

The vulnerability exists in the AEDPoS consensus round transition validation logic. The `GetExtraBlockMiningTime()` method directly dereferences `ExpectedMiningTime` without null checking [1](#0-0) , and `IsTimeSlotPassed()` similarly lacks null safety [2](#0-1) .

While `CheckRoundTimeSlots()` correctly validates for null `ExpectedMiningTime` [3](#0-2) , this validation is only invoked conditionally in `TimeSlotValidationProvider` based on `RoundId` comparison [4](#0-3) .

The critical flaw is that the `RoundId` property has fallback logic that returns `RoundIdForValidation` when `ExpectedMiningTime` fields are null [5](#0-4) .

**Attack Execution:**

1. Malicious miner creates `NextRoundInput` with:
   - `RoundNumber = currentRound.RoundNumber + 1` (passes `RoundTerminateValidationProvider`)
   - All `ExpectedMiningTime = null` (protobuf3 allows null message fields [6](#0-5) )
   - `RoundIdForValidation = currentRound.RoundId` (manipulated value to bypass validation)

2. Calls the public `NextRound` RPC method [7](#0-6) 

3. During `ValidateBeforeExecution()` [8](#0-7) , the `TimeSlotValidationProvider` compares `ProvidedRound.RoundId` vs `BaseRound.RoundId`. Since `ProvidedRound.RoundId` returns `RoundIdForValidation` (due to null fields) and equals `BaseRound.RoundId`, the condition is FALSE, bypassing `CheckRoundTimeSlots()`.

4. The malicious Round is stored via `ProcessNextRound()` [9](#0-8) 

5. When miners call `GetConsensusCommand()` [10](#0-9) , the `ConsensusBehaviourProviderBase` constructor calls `IsTimeSlotPassed()` [11](#0-10) , which dereferences null `ExpectedMiningTime`, causing a `NullReferenceException`.

Additionally, `IsCurrentMiner()` calls `GetExtraBlockMiningTime()` [12](#0-11) , causing the same crash.

## Impact Explanation

**High Severity - Complete Consensus Halt:**

- `GetConsensusCommand()` is the entry point for ALL block production in AEDPoS. When this method throws `NullReferenceException`, no miner can obtain consensus commands.
- The crash occurs in the `ConsensusBehaviourProviderBase` constructor, affecting all consensus behaviors (UpdateValue, TinyBlock, NextRound, NextTerm).
- The malicious Round persists in state until manual intervention [13](#0-12) .
- All network participants are affected simultaneously when the malicious round becomes current.
- Extra block producers cannot be determined, preventing round termination.
- Network requires hard fork or emergency contract upgrade to recover.

## Likelihood Explanation

**Medium-High Likelihood:**

**Attacker Requirements:**
- Must be an active miner in `currentRound.RealTimeMinersInformation` (granted by election/genesis)
- Can generate consensus extra data (standard capability for all miners)
- Can manipulate protobuf serialization to set `ExpectedMiningTime` fields to null (protobuf3 message fields are nullable)

**Attack Feasibility:**
- The bypass is technically straightforward: set `RoundIdForValidation` to current `RoundId` value
- No cryptographic requirements beyond standard block signing
- The validation logic explicitly allows the bypass through the RoundId comparison mechanism
- Public `NextRound` RPC method is directly accessible [14](#0-13) 

**Detection:**
- Immediate: `NullReferenceException` appears in node logs when next miner calls `GetConsensusCommand()`
- However, damage is already done as malicious Round is in state

**Mitigating Factors:**
- Requires miner status (limited attacker pool)
- Single-use attack (network learns to blacklist attacker)
- Traceable on-chain (attacker's public key in block)

## Recommendation

Add explicit null validation for `ExpectedMiningTime` before the RoundId comparison in `TimeSlotValidationProvider`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // Always validate time slots for new rounds, regardless of RoundId
    if (validationContext.ProvidedRound.RoundNumber != validationContext.BaseRound.RoundNumber)
    {
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    else
    {
        // Existing time slot check logic...
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

Alternatively, add direct null checks in `IsTimeSlotPassed()` and `GetExtraBlockMiningTime()` to fail gracefully instead of crashing.

## Proof of Concept

```csharp
[Fact]
public async Task Test_ConsensusHalt_Via_NullExpectedMiningTime()
{
    // Setup: Initialize consensus with valid round
    await InitializeConsensusAsync();
    var currentRound = await GetCurrentRoundInformationAsync();
    
    // Attack: Create malicious NextRoundInput with null ExpectedMiningTime
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RoundIdForValidation = currentRound.RoundId, // KEY BYPASS
        RandomNumber = GenerateRandomNumber()
    };
    
    // Add miners with null ExpectedMiningTime
    foreach (var miner in currentRound.RealTimeMinersInformation)
    {
        maliciousInput.RealTimeMinersInformation[miner.Key] = new MinerInRound
        {
            Pubkey = miner.Key,
            Order = miner.Value.Order,
            ExpectedMiningTime = null, // NULL VALUE
            InValue = null
        };
    }
    
    // Execute attack - this should be rejected but validation is bypassed
    await ExecuteNextRoundAsync(maliciousInput);
    
    // Verify: All subsequent GetConsensusCommand calls crash with NullReferenceException
    await Assert.ThrowsAsync<NullReferenceException>(async () =>
    {
        await GetConsensusCommandAsync(minerPublicKey);
    });
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L40-41)
```csharp
        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-98)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** protobuf/aedpos_contract.proto (L34-35)
```text
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L278-278)
```text
    google.protobuf.Timestamp expected_mining_time = 6;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L35-35)
```csharp
            _isTimeSlotPassed = CurrentRound.IsTimeSlotPassed(_pubkey, _currentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L173-174)
```csharp
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L105-105)
```csharp
        State.Rounds.Set(round.RoundNumber, round);
```
