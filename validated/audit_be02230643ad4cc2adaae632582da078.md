# Audit Report

## Title
Evil Nodes Bypass Punishment During Term Transitions Due to Missing Banned Pubkey Check in GetVictories Fallback Logic

## Summary
The Election contract's `GetVictories` method contains a critical flaw in its fallback logic that allows banned miners to be reselected during term transitions. When insufficient valid candidates exist, the method selects backup miners from current miners and initial miners without checking the `BannedPubkeyMap`, enabling evil nodes that should be permanently excluded to continue participating in consensus and earning rewards.

## Finding Description

**Vulnerability Root Cause**

The `GetVictories` method in the Election contract determines which miners will participate in the next consensus term. When there are insufficient valid candidates (those with votes > 0), it enters fallback logic to fill remaining slots with backup miners. [1](#0-0) 

The critical flaw occurs when valid candidates are insufficient. The fallback logic selects backups from:
1. Current miners (excluding valid candidates) 
2. Initial miners (if still more backups needed)

This selection happens WITHOUT checking `State.BannedPubkeyMap`, which tracks evil nodes that should be permanently excluded from mining.

**Evil Node Marking Process**

When a node is marked as evil via `UpdateCandidateInformation`, the following actions occur: [2](#0-1) 

The process sets `State.BannedPubkeyMap[pubkey] = true` and removes the node from `State.Candidates`. However, critically, the banned node is NOT removed from `State.InitialMiners`, making it eligible for reselection in the fallback logic.

**Correct Implementation Exists**

The same file demonstrates the correct approach in `GetMinerReplacementInformation`, which properly filters banned pubkeys when selecting from initial miners: [3](#0-2) 

This shows the developers were aware of the need to check banned status, but failed to apply this check in `GetVictories`.

**Term Transition Flow**

During term transitions, the consensus contract calls `TryToGetVictories` to obtain the new miner list: [4](#0-3) 

The returned miner list is then used directly to set the consensus miner list without additional banned checks: [5](#0-4) 

**Miner Replacement Limitation**

The miner replacement mechanism, which DOES check banned status, only activates during same-term round transitions, NOT during term changes: [6](#0-5) 

The condition `previousRound.TermNumber == currentRound.TermNumber` ensures replacement only occurs within the same term, leaving term transitions vulnerable to reselecting banned miners.

## Impact Explanation

**Consensus Integrity Violation**: This vulnerability completely bypasses the evil node punishment system, which is fundamental to AElf's consensus security model. Miners that were deliberately excluded for malicious behavior (missed blocks, attempted double-signing, etc.) can automatically rejoin consensus at the next term transition.

**Reward Misallocation**: Banned miners continue earning block production rewards and participating in profit distributions despite being marked as malicious actors. This creates perverse incentives where the punishment mechanism becomes meaningless.

**Severity - CRITICAL**: 
- Undermines the core security assumption that evil nodes can be permanently excluded
- No privileged access required - occurs automatically during normal term transitions
- Affects network integrity across multiple terms once triggered
- Silent failure with no error or event emission makes detection difficult
- Realistic trigger conditions (low candidate participation is common in early network stages)

**Affected Parties**: 
- Network security and trustworthiness
- Legitimate miners facing unfair competition from unpunished evil actors
- Token holders whose mining rewards fund banned nodes
- Governance effectiveness (punishment decisions become meaningless)

## Likelihood Explanation

**Reachable Entry Point**: The vulnerability triggers through the normal term transition mechanism, which is a public, time-based process that occurs automatically approximately every 7 days.

**Feasible Preconditions**:
1. At least one miner has been marked as evil (realistic - happens through consensus contract's automated detection or governance decisions)
2. Valid candidates with votes < required miners count at term transition (realistic during low voter participation periods, network bootstrap phases, or when many candidates are banned)
3. Term transition occurs (guaranteed by protocol design)

**Execution Practicality**:
- No attacker capabilities required beyond being previously marked as evil
- Triggered deterministically during automated term transitions
- Low candidate participation is a realistic scenario, especially:
  - During network launch phases
  - During periods of low voter engagement
  - When multiple candidates are simultaneously banned
  - In smaller side chains with limited validators

**Detection Difficulty**: The vulnerability executes silently without emitting error events or failing transactions, making it difficult to detect without explicit monitoring of the miner list composition across term transitions.

**Probability - HIGH**: Will occur deterministically whenever:
- At least one banned node exists in current miners or initial miners
- Valid candidates < MinersCount at term transition time
- Both conditions can easily occur simultaneously in production environments

## Recommendation

Add banned pubkey filtering to the `GetVictories` fallback logic. The fix should mirror the approach used in `GetMinerReplacementInformation`:

```csharp
private List<ByteString> GetVictories(List<string> currentMiners)
{
    var validCandidates = GetValidCandidates();
    List<ByteString> victories;
    
    var diff = State.MinersCount.Value - validCandidates.Count;
    // Valid candidates not enough.
    if (diff > 0)
    {
        victories = new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
        
        // Filter out banned pubkeys from current miners
        var backups = currentMiners
            .Where(k => !validCandidates.Contains(k))
            .Where(k => !State.BannedPubkeyMap[k])  // ADD THIS CHECK
            .ToList();
            
        if (State.InitialMiners.Value != null)
            backups.AddRange(
                State.InitialMiners.Value.Value.Select(k => k.ToHex())
                    .Where(k => !backups.Contains(k))
                    .Where(k => !State.BannedPubkeyMap[k]));  // ADD THIS CHECK

        victories.AddRange(backups.OrderBy(p => p)
            .Take(Math.Min(diff, currentMiners.Count))
            .Select(v => ByteStringHelper.FromHexString(v)));
        
        return victories;
    }
    
    victories = validCandidates.Select(k => State.CandidateVotes[k])
        .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount)
        .Select(v => v.Pubkey)
        .Take(State.MinersCount.Value).ToList();
    
    return victories;
}
```

Additionally, consider implementing defensive checks in the consensus contract's `SetMinerList` method to validate that no banned pubkeys are included in the miner list being set.

## Proof of Concept

```csharp
[Fact]
public async Task GetVictories_SelectsBannedInitialMiner_WhenInsufficientCandidates()
{
    // Setup: Start a new term to enable term transitions
    await NextRound(BootMinerKeyPair);
    
    // Get an initial miner pubkey to mark as evil
    var evilMinerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var evilMinerPubkey = evilMinerKeyPair.PublicKey.ToHex();
    
    // Mark the initial miner as evil node
    await ElectionContractStub.UpdateCandidateInformation.SendAsync(
        new UpdateCandidateInformationInput
        {
            Pubkey = evilMinerPubkey,
            IsEvilNode = true
        });
    
    // Verify the node is banned
    var isBanned = await ElectionContractStub.IsPubkeyBanned.CallAsync(
        new StringValue { Value = evilMinerPubkey });
    isBanned.Value.ShouldBeTrue();
    
    // Verify the node is removed from candidates
    var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    candidates.Value.Select(p => p.ToHex()).ShouldNotContain(evilMinerPubkey);
    
    // Create insufficient valid candidates scenario
    // Announce only (MinersCount - 2) candidates with votes
    var validCandidatesCount = EconomicContractsTestConstants.InitialCoreDataCenterCount - 2;
    var validCandidates = ValidationDataCenterKeyPairs.Take(validCandidatesCount).ToList();
    
    foreach (var candidate in validCandidates)
    {
        await AnnounceElectionAsync(candidate);
        await VoteToCandidateAsync(VoterKeyPairs[0], candidate.PublicKey.ToHex(), 100 * 86400, 100);
    }
    
    // Call GetVictories - should trigger fallback logic
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    var victoryPubkeys = victories.Value.Select(p => p.ToHex()).ToList();
    
    // VULNERABILITY: The banned initial miner should NOT be in victories
    // but it WILL be selected due to missing banned check in fallback
    victoryPubkeys.ShouldContain(evilMinerPubkey, 
        "BUG: Banned initial miner was reselected in GetVictories fallback logic");
    
    // The miner list should be full size
    victoryPubkeys.Count.ShouldBe(EconomicContractsTestConstants.InitialCoreDataCenterCount);
}
```

This test demonstrates that when insufficient valid candidates exist during term transition, the `GetVictories` method will select banned miners from the initial miner pool, completely bypassing the punishment mechanism.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L386-392)
```csharp
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-343)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```
