# Audit Report

## Title
Unhandled Exception in CrossChainCreate Due to Missing External Info Validation

## Summary
The `CrossChainCreate` method in the NFT contract accesses token external info dictionary keys without validation, causing unhandled exceptions (`KeyNotFoundException` or `FormatException`) when required NFT metadata is missing or malformed. This creates a denial-of-service vector preventing cross-chain NFT protocol synchronization for improperly created tokens.

## Finding Description

The vulnerability exists in the `CrossChainCreate` method where external info dictionary values are accessed without checking key existence or validating content format. [1](#0-0) 

**Root Cause:**

The code directly accesses `tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey]` and `tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]` without using defensive dictionary access patterns like `TryGetValue` or `ContainsKey`. The constant keys are defined as `"aelf_nft_base_uri"` and `"aelf_nft_token_id_reuse"`. [2](#0-1) 

**Why Protections Fail:**

1. **No ExternalInfo Validation in Token Creation**: The MultiToken contract's `Create` method accepts arbitrary `ExternalInfo` without validating NFT-specific metadata keys. [3](#0-2) 

2. **ExternalInfo Preserved During Cross-Chain Sync**: When tokens are synced cross-chain, the external info is copied verbatim without validation. [4](#0-3) 

3. **No Authorization Check**: The `CrossChainCreate` method has no authorization check, allowing any user to call it. [5](#0-4) 

4. **No Defensive Dictionary Access**: No validation exists before dictionary access or boolean parsing.

**Execution Path:**

1. Attacker creates token on main chain via `MultiToken.Create` with missing or invalid external info (bypassing NFT contract's proper `Create` method which sets metadata correctly) [6](#0-5) 

2. Token is synced to side chain via `CrossChainCreateToken`, preserving the malformed external info

3. User or automated system calls `CrossChainCreate` on side chain for that token symbol

4. Dictionary access at line 87 or 88 throws `KeyNotFoundException` (if key missing) or `FormatException` (if boolean value invalid)

5. Transaction reverts with unhandled exception, consuming gas up to failure point

## Impact Explanation

**Primary Harm:**
- **Denial of Service**: Prevents cross-chain synchronization of NFT protocols for tokens lacking proper metadata
- **Transaction Reversion**: All attempts to sync the NFT protocol fail with unhandled exceptions
- **Gas Consumption**: Users/systems waste gas on failed transactions
- **Symbol Squatting**: Malicious actors can create tokens with specific symbols on main chain to prevent legitimate NFT protocols from being synced to side chains

**Scope:**
- Only affects tokens NOT created via NFT contract's proper `Create` method
- Legitimate NFT protocols with correct metadata (created via `NFT.Create`) remain functional
- No state corruption, fund loss, or authorization bypass occurs
- Transaction fails safely without corrupting contract state

**Severity Assessment:**
This represents a **Medium severity** defensive programming issue. While it creates operational disruption and a griefing vector, the impact is limited to availability (DoS) rather than fund loss or privilege escalation. The transaction fails safely without state corruption.

## Likelihood Explanation

**Attacker Capabilities:**
- Any user can create tokens via `MultiToken.Create` without restrictions on external info content [7](#0-6) 
- No special permissions required to trigger the vulnerability
- Anyone can call `CrossChainCreate` due to lack of authorization check

**Attack Complexity:**
- **Low**: Straightforward three-step process (create token, sync cross-chain via normal mechanisms, trigger exception)
- No cryptographic or timing requirements
- Direct method calls with predictable behavior

**Feasibility Conditions:**
- Attacker must create token on main chain first (consumes minimal resources)
- Token must be synced cross-chain via legitimate MultiToken cross-chain mechanisms
- Limited practical benefit: only blocks NFT protocol sync for that specific symbol

**Probability:**
- **Moderate to High**: More likely to occur accidentally (users not following proper NFT creation procedures) than maliciously
- Automated cross-chain sync systems could encounter this with improperly created tokens
- Low barrier to entry (no special permissions needed)

## Recommendation

Implement defensive dictionary access and validation in `CrossChainCreate`:

1. **Use TryGetValue for safe dictionary access:**
   - Check key existence before accessing dictionary values
   - Provide meaningful error messages when required keys are missing

2. **Validate boolean string format:**
   - Use `bool.TryParse()` instead of `bool.Parse()` to handle invalid formats gracefully
   - Check parse result before using the value

3. **Add explicit validation:**
   - Verify that required NFT metadata keys exist in ExternalInfo
   - Validate value formats match expected types

Example fix pattern:
```csharp
if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftBaseUriMetadataKey, out var baseUri))
    throw new AssertionException($"Token {input.Symbol} missing required NFT metadata: base URI");

if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var tokenIdReuseStr) ||
    !bool.TryParse(tokenIdReuseStr, out var isTokenIdReuse))
    throw new AssertionException($"Token {input.Symbol} missing or invalid NFT metadata: token ID reuse flag");
```

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_WithMissingMetadata_ShouldThrowKeyNotFoundException()
{
    // Step 1: Create token via MultiToken.Create with empty ExternalInfo (bypassing NFT.Create)
    var symbol = "TE-TEST-0";
    var createResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = symbol,
        TokenName = "Test Token",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF"),
        ExternalInfo = new ExternalInfo() // Empty - missing NFT metadata keys
    });
    createResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Step 2: Simulate token exists on side chain (would happen via CrossChainCreateToken)
    // For test: token already exists in MultiToken contract from step 1

    // Step 3: Attempt CrossChainCreate - should throw KeyNotFoundException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = symbol
        });
    });
    
    // Verify it's a KeyNotFoundException for missing "aelf_nft_base_uri" key
    exception.Message.ShouldContain("aelf_nft_base_uri");
}
```

**Notes:**
- The vulnerability is triggered when tokens are created via `MultiToken.Create` directly instead of through `NFT.Create`
- `NFT.Create` properly sets all required metadata keys in the ExternalInfo dictionary [8](#0-7) 
- The proper NFT creation flow ensures metadata keys exist, but the cross-chain creation path assumes they exist without validation
- This is a defensive programming issue where input validation was not applied at the consumption point (`CrossChainCreate`) due to assumptions about the creation flow

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-79)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L184-200)
```csharp
    private ExternalInfo GetTokenExternalInfo(CreateInput input)
    {
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var tokenExternalInfo = input.Metadata == null
            ? new ExternalInfo()
            : new ExternalInfo
            {
                Value = { input.Metadata.Value }
            };

        // Add NFT Type to external info.
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
        return tokenExternalInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L8-9)
```csharp
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L501-501)
```csharp
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```
