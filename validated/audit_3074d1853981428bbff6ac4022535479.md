# Audit Report

## Title
RemoveNFTType Causes Permanent DoS of Cross-Chain NFT Protocol Creation

## Summary
The `RemoveNFTType` function removes NFT type mappings without validating whether existing protocols depend on those types. When Parliament removes a type on a sidechain, all subsequent `CrossChainCreate` attempts for protocols using that type's short name will permanently fail with an `AssertionException`, completely breaking cross-chain NFT functionality for those protocols.

## Finding Description

The vulnerability arises from a missing validation check in the `RemoveNFTType` function and a hard dependency in `CrossChainCreate`.

**The RemoveNFTType function** only removes type mappings from state variables without checking protocol usage. [1](#0-0)  It removes entries from `NFTTypeFullNameMap`, `NFTTypeShortNameMap`, and `NFTTypes` but performs no validation that protocols in `NftProtocolMap` are using this type.

**The CrossChainCreate function** has a critical dependency on these type mappings. [2](#0-1)  It extracts the 2-character short name from the protocol symbol, looks up the full type name using `State.NFTTypeFullNameMap[nftTypeShortName]`, and throws an `AssertionException` if this returns `null`.

**Attack Scenario:**
1. An NFT protocol is created on mainchain with symbol "AR123456-1" using NFT type "Art" (short name "AR")
2. Parliament removes the "AR" type on a sidechain via `RemoveNFTType("AR")` (legitimate governance action)
3. Cross-chain indexing triggers `CrossChainCreate` for "AR123456-1" on the sidechain
4. The function extracts "AR", looks it up in `NFTTypeFullNameMap`, gets `null`
5. Throws `AssertionException` â†’ protocol cannot be created
6. All future attempts fail permanently until type is re-added

The protocols store the full NFT type name in their `nft_type` field [3](#0-2) , creating state inconsistency where protocols reference non-existent types.

## Impact Explanation

**Impact: HIGH**

This vulnerability completely breaks the cross-chain NFT protocol synchronization mechanism for affected types:

1. **Permanent DoS of Cross-Chain Functionality**: Once a type is removed on a sidechain, all protocols with symbols starting with that type's short name cannot be created via `CrossChainCreate`. This is the fundamental mechanism for synchronizing NFT protocols from mainchain to sidechains.

2. **No Automatic Recovery**: The failure is permanent. There is no fallback mechanism or alternative path to create these protocols. Recovery requires governance action to re-add the type through `AddNFTType`.

3. **Widespread Impact**: Affects all future cross-chain protocol creation attempts for that type, not just a single protocol. If "Art" type is removed, all art-related NFT protocols fail permanently.

4. **Core Functionality Break**: Cross-chain support is a fundamental feature of the AElf NFT system. This vulnerability undermines the entire multi-chain NFT architecture.

The NFT protocol information structure explicitly includes the `nft_type` field [4](#0-3) , demonstrating this is core protocol metadata that should remain consistent across chains.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability has realistic trigger conditions:

1. **Legitimate Authority**: Parliament's default organization has explicit authority to call `RemoveNFTType` [5](#0-4) . This is not a privilege escalation - it's an intended governance function.

2. **Realistic Scenario**: Parliament might legitimately decide to deprecate an NFT type category (e.g., removing support for a specific type of collectibles). The function exists precisely for this purpose.

3. **No Validation Safeguards**: The contract provides no warnings or checks to inform Parliament that removing a type will break cross-chain creation for existing protocols. The default NFT types are initialized on first use [6](#0-5) , showing these mappings are critical infrastructure.

4. **Automatic Trigger**: Cross-chain indexing happens automatically. Once a type is removed, the next cross-chain synchronization attempt will fail without any manual intervention needed.

5. **Irreversible Impact**: Once triggered, every future cross-chain create for affected protocols fails until governance re-adds the type.

## Recommendation

Add validation to `RemoveNFTType` to prevent removal of types that are currently in use by protocols. The fix should:

1. Before removing a type, check if any protocols in `NftProtocolMap` have `nft_type` matching the full name being removed
2. If any protocols are found using this type, revert with an appropriate error message
3. Alternatively, add a force flag that requires explicit acknowledgment of the impact

Additionally, consider adding a soft-fail mechanism in `CrossChainCreate` that uses a default/fallback type when the mapping is missing, with appropriate logging for monitoring.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveNFTType_CausesDoS_CrossChainCreate()
{
    // Setup: Create Parliament proposal to remove NFT type
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Step 1: Remove "AR" NFT type on sidechain (assume this is a sidechain context)
    var proposalId = await CreateProposalAsync(
        NFTContractAddress,
        defaultParliament,
        nameof(NFTContractStub.RemoveNFTType),
        new StringValue { Value = "AR" }
    );
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // Step 2: Verify type was removed
    var nftTypes = await NFTContractStub.GetNFTTypes.CallAsync(new Empty());
    nftTypes.Value.ShouldNotContainKey("AR");
    
    // Step 3: Attempt CrossChainCreate for a protocol with "AR" prefix
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = "AR123456-1" // Symbol starts with removed type "AR"
        });
    });
    
    // Step 4: Verify it fails with AssertionException about missing type
    exception.Message.ShouldContain("Full name of AR not found");
    
    // This proves permanent DoS: protocol cannot be created cross-chain until type is re-added
}
```

**Notes:**

1. The vulnerability is confirmed in production code: `RemoveNFTType` removes critical type mappings without dependency checks [1](#0-0) 

2. `CrossChainCreate` has a hard assertion that throws when the type mapping is missing [2](#0-1) , with no fallback mechanism

3. This breaks cross-chain NFT protocol synchronization, which is a core feature of the AElf multi-chain architecture

4. The only recovery path is governance action to re-add the type via `AddNFTType`, which is not automatic and requires coordination across chains

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L40-52)
```csharp
        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```

**File:** protobuf/nft_contract.proto (L261-285)
```text
message NFTProtocolInfo {
    // The symbol of the token.
    string symbol = 1;
    // The minted number of the token.
    int64 supply = 2;
    // The total number of the token.
    int64 total_supply = 3;
    // The address that creat the token.
    aelf.Address creator = 4;
    // Base Uri.
    string base_uri = 5;
    // A flag indicating if this token is burnable.
    bool is_burnable = 6;
    // The chain to mint this token.
    int32 issue_chain_id = 7;
    // The metadata of the token.
    Metadata metadata = 8;
    // NFT Type.
    string nft_type = 9;
    // Protocol name, aka token name in MultiToken Contract.
    string protocol_name = 10;
    // Is token id can be reused.
    bool is_token_id_reuse = 11;
    int64 issued = 12;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```
