# Audit Report

## Title
Snapshot Carryforward Allows Vote Double-Counting Through Withdraw-Revote Cycle

## Summary
The `TakeSnapshot()` function carries forward `VotesAmount` from the previous snapshot to create the next snapshot's initial state, but `Withdraw()` operations only update the original snapshot's `VotingResult`, not future snapshots that already inherited those votes. This allows attackers to vote in snapshot N, wait for snapshot creation, withdraw to unlock tokens, then vote again in snapshot N+1, having their voting power counted twice using a single set of tokens.

## Finding Description

The Vote contract maintains separate `VotingResult` state for each snapshot of a voting item. When a user votes, the system records which snapshot the vote belongs to. [1](#0-0) 

When the sponsor takes a snapshot to move to the next period, the system creates a new `VotingResult` for the next snapshot and explicitly carries forward the cumulative `VotersCount` and `VotesAmount` from the previous snapshot. [2](#0-1) 

However, when a voter withdraws their vote, the system only updates the `VotingResult` for the specific snapshot in which the vote was originally cast, retrieved using the `VotingRecord`'s stored `SnapshotNumber`. [3](#0-2) 

This creates an exploitable race condition:

1. **Attacker votes in snapshot 1** with 1,000 tokens → `VotingResult[1].VotesAmount = 1,000`, tokens locked
2. **Sponsor calls TakeSnapshot()** → `VotingResult[2]` created with `VotesAmount = 1,000` (carried forward)
3. **Attacker withdraws** → `VotingResult[1].VotesAmount = 0`, tokens unlocked, but `VotingResult[2].VotesAmount = 1,000` remains unchanged
4. **Attacker votes again in snapshot 2** → `VotingResult[2].VotesAmount = 2,000` (1,000 from carryforward + 1,000 new)

The same 1,000 tokens are now counted twice in snapshot 2. This can be repeated across all snapshots, multiplying voting power by the number of snapshots without requiring additional tokens.

The vulnerability exists because each snapshot's `VotingResult` is independent and identified by a hash computed from `VotingItemId` and `SnapshotNumber`. [4](#0-3)  There is no mechanism to propagate withdrawal updates to future snapshots that have already inherited the vote through carryforward.

## Impact Explanation

**Direct Harm:**
- Attackers can achieve N×X voting power where N is the number of snapshots and X is their token holdings
- This allows manipulation of voting outcomes in governance decisions, parameter changes, elections, or resource allocation votes
- For example, with 5 snapshots and 1,000 tokens, an attacker can achieve 5,000 effective voting power in the final snapshot

**Protocol Integrity:**
- Breaks the fundamental voting invariant that one token equals one vote per decision
- Undermines trust in any governance mechanism using multi-snapshot voting
- Cannot be detected through normal monitoring as each transaction appears legitimate

**Affected Parties:**
- All participants in multi-snapshot voting items are disadvantaged
- Governance systems relying on Vote contract results for decision-making
- Any contract or protocol depending on accurate vote counts

This represents a HIGH severity vulnerability as it enables direct manipulation of governance outcomes with minimal cost (only gas fees), compromising the integrity of the entire voting system.

## Likelihood Explanation

**Attacker Capabilities:**
- Requires only basic voter permissions that any token holder possesses
- No privileged access or special roles needed
- Can be executed from any standard account

**Attack Complexity:**
- Very low complexity: 4 simple transactions (vote → wait → withdraw → vote)
- All operations use standard public functions with no special parameters
- Timing is predictable as `TakeSnapshot()` is called by the sponsor at known intervals
- Can be automated and repeated across multiple snapshot boundaries

**Preconditions:**
- Voting item must have `TotalSnapshotNumber > 1` (common for governance votes)
- Attacker must hold tokens accepted by the voting item (normal requirement)
- No special state or permission requirements beyond standard voting

**Detection Difficulty:**
- Each vote receives a unique `VoteId`, appearing as separate legitimate votes
- Withdraw and re-vote patterns are not inherently suspicious in multi-snapshot voting
- VotingResult state appears internally consistent within each snapshot
- No on-chain indicators distinguish exploited votes from normal ones

This represents a HIGH likelihood vulnerability that can be exploited by any motivated attacker with tokens in any multi-snapshot voting scenario.

## Recommendation

Modify the `Withdraw()` function to update all future snapshots that have already been created and inherited the withdrawn vote through carryforward. This requires:

1. Track the current snapshot number when withdrawing
2. Iterate through all snapshots from `votingRecord.SnapshotNumber + 1` up to `votingItem.CurrentSnapshotNumber`
3. For each future snapshot, subtract the withdrawn amount from its `VotesAmount` and decrement `VotersCount` if applicable

Alternative approach: Do not carry forward `VotesAmount` and `VotersCount` in `TakeSnapshot()`. Instead, calculate these values on-demand by aggregating all active (non-withdrawn) votes from the current and previous snapshots when querying results. This eliminates the carryforward mechanism entirely but requires more complex query logic.

The recommended fix maintains the current architecture while ensuring withdrawal updates propagate correctly:

```csharp
// In Withdraw() method, after updating the original snapshot
for (var snapshotNum = votingRecord.SnapshotNumber + 1; snapshotNum <= votingItem.CurrentSnapshotNumber; snapshotNum++)
{
    var futureSnapshotHash = GetVotingResultHash(votingRecord.VotingItemId, snapshotNum);
    var futureResult = State.VotingResults[futureSnapshotHash];
    if (futureResult != null)
    {
        futureResult.VotesAmount = futureResult.VotesAmount.Sub(votingRecord.Amount);
        futureResult.Results[votingRecord.Option] = futureResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            futureResult.VotersCount = futureResult.VotersCount.Sub(1);
        State.VotingResults[futureSnapshotHash] = futureResult;
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteDoubleCountingThroughSnapshotCarryforward()
{
    // Setup: Create voting item with 3 snapshots
    var votingItem = await RegisterVotingItemAsync(100, 2, true, DefaultSender, 3);
    var attacker = Accounts[1];
    var voteAmount = 1000L;
    
    // Step 1: Attacker votes 1000 tokens in snapshot 1
    await Vote(attacker.KeyPair, votingItem.VotingItemId, votingItem.Options[0], voteAmount);
    var snapshot1Result = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    snapshot1Result.VotesAmount.ShouldBe(1000L); // 1000 from attacker
    
    // Step 2: Sponsor takes snapshot (creates snapshot 2 with carryforward)
    await TakeSnapshot(votingItem.VotingItemId, 1);
    var snapshot2ResultBeforeWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 2
    });
    snapshot2ResultBeforeWithdraw.VotesAmount.ShouldBe(1000L); // Carried forward
    
    // Step 3: Attacker withdraws (unlocks tokens, updates only snapshot 1)
    var voteIds = await GetVoteIds(attacker.KeyPair, votingItem.VotingItemId);
    await Withdraw(attacker.KeyPair, voteIds.ActiveVotes.First());
    
    var snapshot1AfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    snapshot1AfterWithdraw.VotesAmount.ShouldBe(0L); // Correctly updated
    
    var snapshot2AfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 2
    });
    snapshot2AfterWithdraw.VotesAmount.ShouldBe(1000L); // BUG: Still has carryforward amount!
    
    // Step 4: Attacker votes again in snapshot 2 with same tokens
    await Vote(attacker.KeyPair, votingItem.VotingItemId, votingItem.Options[0], voteAmount);
    
    var snapshot2Final = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 2
    });
    
    // VULNERABILITY: VotesAmount is now 2000 (1000 carried forward + 1000 new vote)
    // but attacker only has 1000 tokens total!
    snapshot2Final.VotesAmount.ShouldBe(2000L); // Double-counted!
}
```

## Notes

The vulnerability is particularly severe because:

1. **Multiplicative Effect**: Can be repeated across all snapshots in a voting item, exponentially increasing voting power with each snapshot boundary
2. **Economic Rationality**: Costs only gas fees while potentially capturing significant governance influence or resource allocation
3. **Detection Resistance**: Individual transactions appear legitimate and follow normal voting patterns
4. **Wide Applicability**: Affects any multi-snapshot voting item, which are commonly used for extended governance votes or elections

The root cause is the architectural decision to carry forward cumulative vote counts to new snapshots without maintaining backward links to propagate state changes (withdrawals) to dependent snapshots. This creates an inconsistency where past votes can be "erased" from old snapshots while their contribution persists in future snapshots.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L207-222)
```csharp
        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L262-271)
```csharp
        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** contract/AElf.Contracts.Vote/VoteExtensions.cs (L14-21)
```csharp
    public static Hash GetHash(this VotingResult votingResult)
    {
        return HashHelper.ComputeFrom(new VotingResult
        {
            VotingItemId = votingResult.VotingItemId,
            SnapshotNumber = votingResult.SnapshotNumber
        });
    }
```
