# Audit Report

## Title
Dictionary Access Without Key Validation in IsCurrentMiner During Miner List Changes Causes KeyNotFoundException

## Summary
The `IsCurrentMiner` private method in the AEDPoS consensus contract bypasses critical dictionary key validation when `IsMinerListJustChanged = true`, leading to `KeyNotFoundException` when removed miners attempt to call authorization-protected functions like `ClaimTransactionFees` during term transitions or miner replacements. This creates a deterministic DoS affecting legitimate protocol operations.

## Finding Description

The vulnerability exists in the `IsCurrentMiner(string pubkey)` private method where a conditional safety check only validates dictionary key existence when the miner list has NOT changed: [1](#0-0) 

When `IsMinerListJustChanged` is true, this check is completely bypassed, yet the code proceeds to directly access the `RealTimeMinersInformation` dictionary without any validation: [2](#0-1) 

The `IsMinerListJustChanged` flag is set to true in two scenarios:

1. When generating the first round of a new term: [3](#0-2) 

2. When replacing evil miners within a term: [4](#0-3) [5](#0-4) 

The vulnerability is triggered when `ConvertAddressToPubkey` returns a pubkey that exists in the previous round but not in the current round, because it searches BOTH rounds: [6](#0-5) 

Additional vulnerable dictionary accesses exist that will also throw exceptions when the pubkey doesn't exist: [7](#0-6) [8](#0-7) [9](#0-8) 

The public entry points that internally invoke `IsCurrentMiner` and are affected include:

**ClaimTransactionFees:** [10](#0-9) [11](#0-10) 

**DonateResourceToken:** [12](#0-11) 

**ProposeCrossChainIndexing:** [13](#0-12) [14](#0-13) [15](#0-14) 

**ReleaseCrossChainIndexingProposal:** [16](#0-15) 

## Impact Explanation

**Operational Impact - Critical DoS:**
- Guaranteed transaction failures via `KeyNotFoundException` during every term transition and miner replacement event
- Affects critical system operations: `ClaimTransactionFees`, `DonateResourceToken`, `ProposeCrossChainIndexing`, and `ReleaseCrossChainIndexingProposal`
- Removed miners cannot complete legitimate operations, particularly claiming accumulated transaction fees they earned from blocks produced before removal
- System instability during consensus transitions, which are regularly scheduled events in AEDPoS (every `PeriodSeconds`)
- Cross-chain indexing operations become unavailable if executed by recently removed miners

**Affected Parties:**
- Removed/replaced miners lose access to legitimately earned transaction fees
- The broader network experiences degraded service during term transitions when multiple miners may be replaced simultaneously
- Cross-chain communication infrastructure becomes unreliable during miner list changes

**Severity Justification:**
This is a Critical severity issue because it causes guaranteed, deterministic transaction failures during normal protocol operations. The vulnerability affects multiple core system functions including fee collection and cross-chain indexing, creates operational disruption without requiring any malicious intent, and results in economic loss for honest miners who cannot claim earned fees.

## Likelihood Explanation

**Reachable Entry Point:**
Public methods `ClaimTransactionFees`, `DonateResourceToken`, `ProposeCrossChainIndexing`, and `ReleaseCrossChainIndexingProposal` are all callable by miner addresses and internally invoke the vulnerable `IsCurrentMiner` method.

**Feasible Preconditions:**
- Term changes occur regularly in AEDPoS (configured by `PeriodSeconds` in the protocol)
- Miner replacements occur automatically when miners miss too many time slots (evil node detection mechanism)
- No special attacker capabilities required - this happens during normal protocol operation
- The condition `IsMinerListJustChanged = true` is set automatically by the protocol

**Execution Practicality:**
1. Wait for a term change or miner replacement (natural protocol behavior that occurs regularly)
2. As a removed miner, call `ClaimTransactionFees()` to claim legitimately earned transaction fees from blocks produced before removal
3. `IsCurrentMiner` receives the removed miner's pubkey from the previous round via `ConvertAddressToPubkey`
4. Safety check at lines 142-144 is bypassed because `IsMinerListJustChanged = true`
5. Dictionary access at line 158, 182, 170, or 205 throws `KeyNotFoundException`
6. Transaction fails, and the miner cannot claim their fees

**Economic Rationality:**
Zero attack cost - this occurs during legitimate protocol operations without any malicious activity. Removed miners have strong economic incentive to claim transaction fees they earned before removal, making this scenario not only probable but expected during every miner list change.

**Probability:**
High probability during every term transition or miner replacement event. Any removed miner who attempts to perform any of the affected operations will trigger this vulnerability. Given that term transitions are regular scheduled events in AEDPoS and miners have legitimate reasons to claim earned fees, this vulnerability will be triggered frequently in production.

## Recommendation

Add a dictionary key existence check before all dictionary accesses, regardless of the `IsMinerListJustChanged` flag value:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;
    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;
    
    // Always validate key existence in current round
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        // For removed miners during transition, check if they were the previous extra block producer
        if (currentRound.IsMinerListJustChanged && 
            Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            return true;
        }
        return false;
    }
    
    // ... rest of the method continues with safe dictionary access
}
```

Alternatively, modify `ConvertAddressToPubkey` to only return pubkeys that exist in the current round when `IsMinerListJustChanged = true`, ensuring that removed miners receive proper authorization failures rather than exceptions.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedMiner_CannotClaimFees_DuringMinerListChange()
{
    // Setup: Initialize consensus with initial miner set
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(initialMiners);
    
    // Miner2 produces blocks and earns transaction fees
    await ProduceBlocksAndEarnFees("miner2", feeAmount: 1000);
    
    // Term change occurs - miner2 is removed from the new term
    var newMiners = new[] { "miner1", "miner3", "miner4" };
    await ChangeTermWithNewMinerList(newMiners); // This sets IsMinerListJustChanged = true
    
    // Removed miner2 attempts to claim legitimately earned fees
    var miner2Address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray("miner2"));
    var claimInput = new TotalTransactionFeesMap();
    
    // This should throw KeyNotFoundException
    var exception = await Assert.ThrowsAsync<KeyNotFoundException>(async () =>
    {
        await TokenContractStub.ClaimTransactionFees.SendAsync(claimInput);
    });
    
    Assert.Contains("The given key was not present in the dictionary", exception.Message);
}
```

## Notes

This vulnerability demonstrates a critical oversight in the transition logic where the safety check was intentionally bypassed for `IsMinerListJustChanged = true` scenarios, but subsequent dictionary accesses were not protected. The economic impact is significant as removed miners lose access to legitimately earned transaction fees, and the operational impact affects critical cross-chain and consensus functions during every miner list change event.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L128-130)
```csharp
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L158-158)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L170-170)
```csharp
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L205-205)
```csharp
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L341-341)
```csharp
                isMinerListChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L14-14)
```csharp
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L24-24)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-869)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-915)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-286)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-297)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-294)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```
