# Audit Report

## Title
Scheme Manager Can Permanently Destroy All Accumulated Profits by Removing Beneficiaries Before Distribution

## Summary
A malicious TokenHolder scheme manager can exploit the profit distribution system to permanently destroy all accumulated profits by removing all beneficiaries before calling `DistributeProfits`. When distribution occurs with zero total shares, the system automatically burns the funds instead of distributing them, resulting in complete and irreversible loss of assets that legitimate beneficiaries were entitled to claim.

## Finding Description

TokenHolder schemes are created with `CanRemoveBeneficiaryDirectly = true` by default, granting the scheme manager unrestricted ability to remove beneficiaries at any time. [1](#0-0) 

The scheme manager (validated as the scheme creator) can call `RemoveBeneficiary` to remove any beneficiary from the scheme. The authorization check validates that `Context.Sender` matches the scheme manager address. [2](#0-1) 

Each removal is forwarded to the underlying Profit contract, which subtracts the removed beneficiary's shares from the scheme's `TotalShares`. [3](#0-2) 

When `CanRemoveBeneficiaryDirectly` is true, the `RemoveProfitDetails` function removes all beneficiary details without restrictions—unlike the false case which only removes expired beneficiaries. [4](#0-3) 

The critical flaw occurs in `DistributeProfits`: when `totalShares <= 0`, the contract calls `BurnProfits` instead of distributing to beneficiaries. [5](#0-4) 

The `BurnProfits` function permanently destroys the tokens by transferring them to the contract and calling the Token contract's `Burn` method, with no recovery mechanism. [6](#0-5) 

The scheme manager has authorized access to both `RemoveBeneficiary` and `DistributeProfits` functions. The latter explicitly allows calls from the scheme manager. [7](#0-6) 

## Impact Explanation

This vulnerability enables **complete and permanent destruction of accumulated profits** with the following consequences:

1. **Total Fund Loss**: All tokens accumulated in the scheme are burned, permanently reducing the token supply. The burn operation directly decrements the token's total supply. [8](#0-7) 

2. **Beneficiary Impact**: Legitimate beneficiaries who staked tokens or registered for profit sharing lose their entire entitled distribution without any claim mechanism.

3. **No Recovery**: The burning operation is irreversible—there is no mechanism to restore burned tokens or compensate affected users.

4. **Protocol-Wide Impact**: The broader ecosystem suffers permanent token supply deflation, affecting all token holders and ecosystem participants.

This qualifies as **HIGH severity** because it results in direct, complete, and irreversible loss of user funds through a simple two-step attack requiring only manager privileges.

## Likelihood Explanation

The likelihood is assessed as **MEDIUM-to-HIGH** based on:

**Attacker Profile**: The attacker must be or compromise a TokenHolder scheme manager. In typical use cases, these are DApp operators managing staking rewards or dividend distributions, making insider threats realistic.

**Attack Complexity**: The attack is trivially simple:
- Step 1: Call `RemoveBeneficiary` for each beneficiary (can be batched)
- Step 2: Call `DistributeProfits`

**No Barriers**:
- No timelock between operations
- No governance approval required
- No minimum shares validation before burning
- Can be executed in a single block
- Both functions are directly accessible to the manager

**Realistic Scenarios**:
- Compromised DApp operator credentials
- Malicious exit scam by scheme operators
- Insider attack from disgruntled administrators
- Financial incentive to harm competitors or users

**Detection Challenges**: The removal transactions appear legitimate and authorized. Without real-time monitoring of beneficiary counts before distribution, the attack is only detected after funds are destroyed.

## Recommendation

Implement multiple safeguards:

1. **Prevent Distribution with Zero Shares**: Add a check in `DistributeProfits` to revert when `totalShares == 0` instead of burning:
```csharp
Assert(totalShares > 0, "Cannot distribute profits with zero total shares.");
```

2. **Add Timelock for Critical Operations**: Implement a delay between beneficiary removal and profit distribution to allow detection and response.

3. **Restrict CanRemoveBeneficiaryDirectly**: Consider making this false by default or requiring governance approval to enable it.

4. **Add Minimum Share Threshold**: Require schemes to maintain a minimum number of beneficiaries or shares before distribution is allowed.

5. **Emit Warning Events**: Fire events when beneficiary count approaches zero to enable monitoring systems to detect suspicious activity.

## Proof of Concept

```csharp
[Fact]
public async Task Exploit_ManagerCanBurnAllProfitsByRemovingBeneficiaries()
{
    // Setup: Create scheme and add profits
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF"
    });
    
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 100_000 // Accumulated profits
    });
    
    // Add beneficiary who should receive the profits
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(),
        Shares = 100
    });
    
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var schemeId = schemeIds.SchemeIds[0];
    
    // Get initial token supply
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "ELF" });
    var initialSupply = tokenInfo.Supply;
    
    // ATTACK: Manager removes all beneficiaries
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(),
        Amount = 0 // Remove completely
    });
    
    // Verify TotalShares is now 0
    var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    scheme.TotalShares.ShouldBe(0);
    
    // ATTACK: Manager distributes profits, triggering burn
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = Starter
    });
    
    // IMPACT VERIFICATION: Token supply decreased (profits burned)
    var finalTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "ELF" });
    var finalSupply = finalTokenInfo.Supply;
    finalSupply.ShouldBe(initialSupply - 100_000); // 100k tokens permanently destroyed
    
    // Beneficiary received nothing
    var beneficiaryBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddresses.First(),
        Symbol = "ELF"
    });
    beneficiaryBalance.Balance.ShouldBe(0); // Lost entitled profits
}
```

## Notes

This vulnerability exploits the combination of unrestricted beneficiary removal (`CanRemoveBeneficiaryDirectly = true`) and the burn-on-zero-shares logic in profit distribution. While the burn mechanism may have been intended for edge cases or invalid schemes, it creates a griefing vector when combined with manager control over beneficiary membership. The TokenHolder contract establishes a trust model where the scheme manager has unilateral control, which becomes problematic when managing user funds.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-24)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-72)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L546-550)
```csharp
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L328-328)
```csharp
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);
```
