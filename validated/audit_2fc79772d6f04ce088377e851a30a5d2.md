# Audit Report

## Title
Early Loop Termination in GetAvailableSymbolToPayTxFee Prevents Primary Token Fallback for Delegations

## Summary
The `GetAvailableSymbolToPayTxFee()` method in the MultiToken contract contains a critical logic error where it uses `break` instead of `continue` when checking delegation sufficiency across multiple fee payment tokens. This causes the loop to terminate prematurely when an early token lacks sufficient delegation allowance, preventing evaluation of remaining tokens including the mandatory primary token (ELF). Users with valid delegations and sufficient balances in unevaluated tokens cannot pay transaction fees, resulting in denial of service for transaction execution.

## Finding Description

The vulnerability exists in the token selection logic for transaction size fee payment when delegation is configured. The `GetAvailableSymbolToPayTxFee()` method iterates through all configured tokens in `SymbolsToPayTxSizeFee` to find a suitable token for fee payment. [1](#0-0) 

When delegation is present, the code checks if each token has sufficient delegation allowance using `IsDelegationEnoughBaseOnPrimaryToken()`. The critical flaw is at line 480: when this check returns false (delegation insufficient), the code executes `break`, which exits the entire loop immediately rather than continuing to check remaining tokens. [2](#0-1) 

All four tracking variables (`availableSymbol`, `availableSymbolWithAnything`, `availableSymbolWithEnoughBalance`, `availableSymbolWithEnoughBalancePlusAllowance`) remain null when the loop breaks early. The function then returns null to the caller. [3](#0-2) 

When called from `ChargeSizeFee()`, a null return in delegation scenarios triggers immediate failure: [4](#0-3) 

The vulnerability is compounded by the protocol invariant that the primary token MUST be included in the `SymbolsToPayTxSizeFee` list: [5](#0-4) 

However, there is no ordering constraint on where the primary token appears in the list. If the list is configured as `[TOKEN_A, TOKEN_B, ELF]` and TOKEN_A lacks sufficient delegation allowance, the loop breaks before ever evaluating TOKEN_B or ELF, even if they have adequate delegation and balance.

The entry point for this vulnerability is the publicly accessible `ChargeTransactionFees()` method, which is automatically invoked by the ACS1 pre-execution plugin for every transaction: [6](#0-5) 

## Impact Explanation

**Severity: HIGH**

This vulnerability causes denial of service for transaction fee payment, which is a fundamental blockchain operation. The impact manifests in several ways:

1. **Operational DoS**: Users with valid delegation allowances and sufficient token balances cannot execute transactions because the fee charging mechanism fails prematurely. The failure occurs silently without evaluating all available tokens.

2. **Invariant Violation**: The protocol enforces that the primary token must always be available for fee payment (as evidenced by the mandatory inclusion requirement). This vulnerability breaks that invariant by potentially preventing the primary token from ever being evaluated.

3. **No Workaround**: Affected users cannot bypass this issue. The token list ordering is controlled by governance through `SetSymbolsToPayTxSizeFee()`, and individual users cannot modify it. Users with delegations set up for the primary token but not for earlier tokens in the list will be completely unable to transact.

4. **User Fund Lockup**: While user funds are not permanently lost, they become effectively unusable for transaction execution. Users cannot transfer tokens, execute contracts, or perform any blockchain operations that require transaction fees.

The severity is HIGH because it affects core protocol functionality (transaction execution), has no user-level workaround, and can impact any user utilizing the delegation feature with multi-token fee payment configurations.

## Likelihood Explanation

**Likelihood: HIGH**

All preconditions for this vulnerability are realistic and likely to occur in production environments:

1. **Multi-Token Configuration**: The protocol explicitly supports multiple tokens for size fee payment through `SetSymbolsToPayTxSizeFee()`. This is a documented feature, not an edge case.

2. **Delegation Usage**: Transaction fee delegation (ACS12) is a standard protocol feature that allows delegatees to pay fees on behalf of delegators. This is commonly used for sponsored transactions and improved user experience.

3. **Per-Token Delegation Limits**: The delegation system allows different allowance amounts per token. [7](#0-6) 
   It is entirely realistic for a delegatee to have sufficient allowance for some tokens but not others.

4. **Arbitrary Token Ordering**: There is no enforced ordering of tokens in `SymbolsToPayTxSizeFee`. Governance can configure tokens in any order, and there's no requirement that the primary token appears first.

5. **No Special Privileges Required**: This vulnerability affects normal users performing standard transactions. No special permissions or attack setup is needed.

The combination of these realistic conditions makes this vulnerability highly likely to manifest in production, particularly in scenarios where:
- Multiple tokens are configured for fee payment to provide flexibility
- Delegation is used with varying per-token limits
- Token list ordering happens to place tokens with lower delegation before the primary token

## Recommendation

Change line 480 from `break` to `continue` to allow the loop to evaluate all configured tokens:

```csharp
if (delegations != null)
{
    var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
        symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
        txSizeFeeAmount, delegations);
    if (!delegationEnough) continue;  // Changed from 'break' to 'continue'
}
```

This ensures that when one token lacks sufficient delegation, the algorithm skips to the next token rather than abandoning the search entirely. The primary token and other tokens with adequate delegation will be properly evaluated.

Additionally, consider adding explicit ordering requirements or priority logic to ensure the primary token is always evaluated first or has priority in the selection algorithm, providing a more robust fallback mechanism.

## Proof of Concept

```csharp
[Fact]
public async Task DelegationWithMultipleTokens_BreaksOnFirstInsufficientToken_Test()
{
    // Setup: Initialize contract with primary token (ELF) and additional tokens (TOKEN_A, TOKEN_B)
    await Initialize();
    
    // Configure multi-token fee payment: [TOKEN_A, TOKEN_B, ELF]
    // This ordering places primary token AFTER other tokens
    await TokenContractStub.SetSymbolsToPayTxSizeFee.SendAsync(new SymbolListToPayTxSizeFee
    {
        SymbolsToPayTxSizeFee = 
        {
            new SymbolToPayTxSizeFee { TokenSymbol = "TOKEN_A", BaseTokenWeight = 1, AddedTokenWeight = 1 },
            new SymbolToPayTxSizeFee { TokenSymbol = "TOKEN_B", BaseTokenWeight = 1, AddedTokenWeight = 1 },
            new SymbolToPayTxSizeFee { TokenSymbol = "ELF", BaseTokenWeight = 1, AddedTokenWeight = 1 }
        }
    });
    
    // Setup delegation with insufficient allowance for TOKEN_A but sufficient for ELF
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(new SetTransactionFeeDelegationsInput
    {
        DelegatorAddress = User1Address,
        Delegations = 
        {
            ["TOKEN_A"] = 10,  // Insufficient for transaction fee
            ["ELF"] = 1000000  // More than sufficient for transaction fee
        }
    });
    
    // Give delegatee sufficient balance of all tokens
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = DefaultAddress,
        Symbol = "ELF",
        Amount = 10000000
    });
    
    // Attempt to charge transaction fee via delegation
    var result = await TokenContractStub.ChargeTransactionFees.CallAsync(new ChargeTransactionFeesInput
    {
        ContractAddress = TokenContractAddress,
        MethodName = "Transfer",
        TransactionSizeFee = 100000,  // Size fee that TOKEN_A cannot cover but ELF can
        SymbolsToPayTxSizeFee = 
        {
            new SymbolToPayTxSizeFee { TokenSymbol = "TOKEN_A", BaseTokenWeight = 1, AddedTokenWeight = 1 },
            new SymbolToPayTxSizeFee { TokenSymbol = "TOKEN_B", BaseTokenWeight = 1, AddedTokenWeight = 1 },
            new SymbolToPayTxSizeFee { TokenSymbol = "ELF", BaseTokenWeight = 1, AddedTokenWeight = 1 }
        }
    });
    
    // Expected: Fee payment succeeds using ELF (sufficient delegation + balance)
    // Actual: Fee payment fails because loop breaks at TOKEN_A before reaching ELF
    result.Success.ShouldBeTrue("Fee payment should succeed with ELF delegation");
    // This assertion will FAIL, proving the vulnerability
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Silent Failure**: The error message "Transaction fee not enough" misleads users into thinking they lack funds, when in reality they have sufficient funds in tokens that were never evaluated.

2. **Governance Impact**: The issue can only be mitigated by governance reordering the token list to place the primary token first, but this workaround may not be obvious and requires governance action for each affected configuration.

3. **Delegation-Specific**: The bug only affects delegation scenarios. Non-delegation fee payment works correctly because it uses different tracking variables (`availableSymbolWithAnything`) that get populated even when tokens are insufficient, providing graceful degradation.

The root cause is a simple but critical error in control flow logic that violates the intended fallback behavior of the multi-token fee payment system.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-28)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L410-414)
```csharp
            //For delegation,if there is no available token,return false,no need to generate bill
            if (delegations != null && availableSymbol == null)
            {
                return false;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L467-471)
```csharp
        SymbolToPayTxSizeFee availableSymbol = null;
        SymbolToPayTxSizeFee availableSymbolWithAnything = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalance = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalancePlusAllowance = null;

```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L473-481)
```csharp
        foreach (var symbolToPlayTxSizeFee in allSymbolToTxFee)
        {
            if (delegations != null)
            {
                var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                    symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
                    txSizeFeeAmount, delegations);
                if (!delegationEnough) break;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L513-516)
```csharp
        availableSymbol ??= availableSymbolWithEnoughBalancePlusAllowance ??
                            availableSymbolWithEnoughBalance ?? availableSymbolWithAnything;

        return availableSymbol;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L621-642)
```csharp
        var isPrimaryTokenExist = false;
        var symbolList = new List<string>();
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty());
        Assert(!string.IsNullOrEmpty(primaryTokenSymbol.Value), "primary token does not exist");
        foreach (var tokenWeightInfo in input.SymbolsToPayTxSizeFee)
        {
            if (tokenWeightInfo.TokenSymbol == primaryTokenSymbol.Value)
            {
                isPrimaryTokenExist = true;
                Assert(tokenWeightInfo.AddedTokenWeight == 1 && tokenWeightInfo.BaseTokenWeight == 1,
                    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be 1");
            }

            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
            Assert(!symbolList.Contains(tokenWeightInfo.TokenSymbol),
                $"symbol:{tokenWeightInfo.TokenSymbol} repeat");
            AssertSymbolToPayTxFeeIsValid(tokenWeightInfo.TokenSymbol, out var addedTokenTotalSupply);
            symbolList.Add(tokenWeightInfo.TokenSymbol);
        }

        Assert(isPrimaryTokenExist, $"primary token:{primaryTokenSymbol.Value} not included");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1399-1410)
```csharp
    private bool IsDelegationEnough(string txSymbol, string baseSymbol, long cost,
        long txSizeFeeAmount, TransactionFeeDelegations delegations)
    {
        if (!delegations.IsUnlimitedDelegate)
        {
            return delegations.Delegations.ContainsKey(txSymbol) && (baseSymbol == txSymbol
                ? delegations.Delegations[txSymbol].Sub(cost)
                : delegations.Delegations[txSymbol]) >= txSizeFeeAmount;
        }

        return true;
    }
```
