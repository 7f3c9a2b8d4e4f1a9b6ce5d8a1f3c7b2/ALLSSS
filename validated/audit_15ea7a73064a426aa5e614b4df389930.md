# Audit Report

## Title
Missing Input Validation Allows Zero or Negative Lock Periods, Enabling Immediate Token Withdrawal

## Summary
The `CreateScheme()` function in TokenHolderContract accepts `MinimumLockMinutes` parameter without validation, allowing zero or negative values. This completely bypasses the token lock mechanism, enabling users to withdraw tokens immediately after registration, defeating the core purpose of time-locked profit distribution schemes.

## Finding Description

The vulnerability exists in the `CreateScheme()` function where `input.MinimumLockMinutes` is stored directly into the scheme state without any bounds checking or validation. [1](#0-0) 

The `MinimumLockMinutes` parameter is defined as `int64` in the protobuf schema, which permits negative values and zero by design. [2](#0-1) 

The lock period is enforced in the `Withdraw()` function through a timestamp comparison. The assertion checks if the unlock time (lock timestamp + MinimumLockMinutes) has passed before allowing withdrawal. [3](#0-2) 

The `AddMinutes()` extension method performs simple arithmetic without input validation, multiplying the input by 60 and adding it to the timestamp. [4](#0-3) 

**Attack Mechanism:**
1. Attacker calls `CreateScheme()` with `MinimumLockMinutes = 0` (or negative)
2. Calls `RegisterForProfits()` to lock tokens and record timestamp
3. Immediately calls `Withdraw()` in the next block
4. The assertion `State.LockTimestamp[lockId].AddMinutes(0) < Context.CurrentBlockTime` passes because any subsequent block time is greater than the lock timestamp
5. Tokens are unlocked without any waiting period

**Why Protections Fail:**
- No validation exists in `CreateScheme()` to enforce minimum positive values
- The `Withdraw()` check only validates against the computed unlock time, which can be manipulated at scheme creation
- No system-wide minimum lock period is enforced

## Impact Explanation

**Direct Security Impact:**
- Complete bypass of the token lock mechanism, a critical security feature
- Users can game profit distribution systems by locking/unlocking instantly without actual commitment
- Economic incentive alignment is broken - schemes designed to reward long-term holders become exploitable
- Side chain consensus systems using TokenHolder for validator incentives could be compromised if misconfigured

**Affected Components:**
- Any profit distribution scheme relying on TokenHolder's time-lock guarantees
- Production code in AEDPoS that computes `MinimumLockMinutes` dynamically as `periodSeconds / 60` - if `periodSeconds < 60`, the result is zero [5](#0-4) 

**Severity Justification (High):**
This represents a complete failure of a critical access control mechanism (time-based token locking). While it doesn't directly steal funds from other users, it undermines the economic security model and enables gaming of profit distribution systems that assume token commitment.

## Likelihood Explanation

**Attacker Requirements:**
- Ability to call public contract methods (any account)
- No special privileges needed
- Zero transaction cost beyond gas fees

**Attack Complexity:**
- Trivial: Single function call with zero parameter value
- No timing requirements or complex state manipulation
- Immediately exploitable upon scheme creation

**Real-World Evidence:**
The existing test suite inadvertently demonstrates this vulnerability - it creates a scheme without specifying `MinimumLockMinutes` (defaulting to 0) and successfully withdraws immediately without any waiting period. [6](#0-5) 

**Probability Assessment:**
- High likelihood through either malicious intent or misconfiguration
- Production code already computes this value dynamically, risking zero values
- No detection or prevention mechanisms exist
- Economic rationality favors exploitation (zero-cost parameter manipulation for immediate access)

## Recommendation

Add input validation to the `CreateScheme()` function to enforce a minimum positive value for `MinimumLockMinutes`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(input.MinimumLockMinutes > 0, "Minimum lock minutes must be positive.");
    
    // ... rest of the implementation
}
```

Alternatively, enforce a system-wide minimum lock period (e.g., 60 minutes) to ensure meaningful token commitment.

## Proof of Concept

```csharp
[Fact]
public async Task Exploit_ZeroLockPeriod_ImmediateWithdrawal()
{
    var amount = 1000L;
    var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
    
    // Create scheme with zero lock period
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = nativeTokenSymbol,
        MinimumLockMinutes = 0  // Exploitable: no validation
    });
    
    // Register and lock tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = amount,
        SchemeManager = Starter
    });
    
    // Immediately withdraw in the next block (no waiting period enforced)
    var result = await TokenHolderContractStub.Withdraw.SendAsync(Starter);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Tokens unlocked immediately, bypassing lock mechanism
    var balance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = nativeTokenSymbol,
        Owner = Starter
    })).Balance;
    
    balance.ShouldBeGreaterThanOrEqualTo(amount);  // Exploit successful
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L39-42)
```csharp
    public static Timestamp AddMinutes(this Timestamp timestamp, long minutes)
    {
        return timestamp + new Duration { Seconds = minutes.Mul(60) };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L28-32)
```csharp
        State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = AEDPoSContractConstants.SideChainShareProfitsTokenSymbol,
            MinimumLockMinutes = periodSeconds.Div(60)
        });
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L438-452)
```csharp
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
        var beforeUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        await TokenHolderContractStub.Withdraw.SendAsync(Starter);
```
