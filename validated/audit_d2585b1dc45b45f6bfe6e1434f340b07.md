# Audit Report

## Title
Incorrect Accounting Assertion in Recharge() Causes Denial of Service for Valid Side Chain Recharges

## Summary
The `Recharge()` function contains a critical logic error in its validation assertion that incorrectly counts `input.Amount` twice when checking if sufficient funds have been provided. This causes legitimate recharge transactions to be rejected, preventing side chains in debt status from being recovered.

## Finding Description

The vulnerability is located in the `Recharge()` function which handles recharging indexing fees for side chains. [1](#0-0) 

**Execution Flow:**

1. The function first transfers `input.Amount` from the sender to the side chain's virtual address. [2](#0-1) 

2. If the side chain is in debt status, it loops through accumulated arrears and transfers them to proposers FROM the side chain's virtual address. [3](#0-2) 

3. After arrears transfers complete, it retrieves the current balance of the side chain using `GetSideChainIndexingFeeDeposit()`. [4](#0-3) 

4. It validates using: `Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice)` [5](#0-4) 

**The Logic Error:**

The `GetSideChainIndexingFeeDeposit()` function queries the token balance of the side chain's virtual address. [6](#0-5) 

At line 206, `originBalance` is retrieved AFTER the arrears have been transferred out, so it equals:
```
originBalance = old_balance + input.Amount - arrearsAmount
```

The assertion at line 207 becomes:
```
input.Amount + (old_balance + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice
```

Simplifying:
```
2*input.Amount + old_balance >= 2*arrearsAmount + IndexingPrice
```

**Correct Logic:**

After recharge and paying arrears, the remaining balance must be at least `IndexingPrice`:
```
old_balance + input.Amount >= arrearsAmount + IndexingPrice
```

Since `originBalance` already has arrears deducted, the correct check should be:
```
originBalance >= IndexingPrice
```

The bug causes the assertion to require approximately double the necessary funds because `input.Amount` is counted twice in the validation.

## Impact Explanation

**Denial of Service - HIGH Severity:**

Legitimate users attempting to recharge side chains in debt status will be incorrectly rejected when they provide exactly the mathematically required amount. This completely blocks the recovery mechanism for debt-ridden side chains.

**Concrete Example:**
- Side chain balance: 75 tokens
- Arrears owed: 100 tokens  
- Indexing price: 50 tokens
- User provides: 75 tokens (correct amount)

**Expected:** Should succeed (75+75=150 total, minus 100 arrears = 50 remaining ≥ 50 required)

**Actual:** Transaction fails (assertion checks 75+50 ≥ 100+50 → 125 ≥ 150 ✗)

**Who is affected:**
- Side chain creators attempting to clear debt
- Side chain operators maintaining service continuity
- All users depending on debt-affected side chains

The only workaround is to overpay by approximately double, which creates significant capital inefficiency and may not be understood by users, leaving side chains permanently stuck in debt status.

## Likelihood Explanation

**HIGH Likelihood:**

The `Recharge()` function is a public entry point callable by any user without special privileges. [7](#0-6) 

**Feasible Preconditions:**
1. Side chain exists and is in `IndexingFeeDebt` status (occurs naturally during normal operations when indexing fees deplete)
2. Arrears have accumulated in the side chain's `ArrearsInfo`
3. User has token allowance for the recharge amount

**Execution Practicality:**

This bug triggers automatically in normal operation whenever a side chain falls into debt and someone tries to recharge with the mathematically correct amount. No attack is needed - it's a logic error affecting legitimate usage. Given the economic incentive to minimize capital lockup, users will naturally attempt to recharge with the minimum required amount, triggering this bug frequently.

## Recommendation

Change the assertion at line 207 to only check that the remaining balance (after arrears payment) is sufficient for the indexing price:

```csharp
// Current (buggy):
Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");

// Should be:
Assert(originBalance >= sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

This correctly validates that after paying all arrears, the side chain has at least `IndexingPrice` remaining for future indexing operations.

## Proof of Concept

```csharp
[Fact]
public async Task RechargeForSideChain_MinimumAmount_ShouldSucceed()
{
    // Setup: Create side chain with initial balance 75, indexing price 50
    var sideChainId = await InitAndCreateSideChainAsync(10, 123, 75, 50);
    
    // Index blocks to create debt: 3 blocks at price 50 each = 150 needed
    // Balance 75 - 150 = -75, so debt of 75 accumulates and 75 remaining debt
    var crossChainBlockData = new CrossChainBlockData
    {
        SideChainBlockDataList = {
            CreateSideChainBlockData(HashHelper.ComputeFrom("hash"), 1, sideChainId, HashHelper.ComputeFrom("root")),
            CreateSideChainBlockData(HashHelper.ComputeFrom("hash"), 2, sideChainId, HashHelper.ComputeFrom("root")),
            CreateSideChainBlockData(HashHelper.ComputeFrom("hash"), 3, sideChainId, HashHelper.ComputeFrom("root"))
        }
    };
    await DoIndexAsync(crossChainBlockData, new[] { sideChainId });
    
    // Verify side chain is in debt
    var chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(
        new Int32Value { Value = sideChainId });
    debt.Value.ShouldBe(100); // arrears amount
    
    var balanceBeforeRecharge = await GetSideChainBalanceAsync(sideChainId);
    balanceBeforeRecharge.ShouldBe(0); // old_balance
    
    // Recharge with EXACTLY the minimum required: 
    // old_balance (0) + input.Amount (100 + 50) = arrears (100) + IndexingPrice (50)
    await ApproveBalanceAsync(150);
    var rechargeInput = new RechargeInput
    {
        ChainId = sideChainId,
        Amount = 150  // Mathematically correct minimum
    };
    
    // BUG: This should succeed but will fail with "Indexing fee recharging not enough"
    // Buggy assertion checks: 150 + 50 >= 100 + 50 → 200 >= 150 ✓ (would pass)
    // But with debt example (75 balance, 100 arrears, 50 price):
    // User provides 75: assertion checks 75 + 50 >= 100 + 50 → 125 >= 150 ✗ (fails)
    var result = await CrossChainContractStub.Recharge.SendAsync(rechargeInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-98)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
    }
```
