# Audit Report

## Title
Fixed Candidate Registration Cost Enables Predictable Candidate Pool Monopolization Attack

## Summary
The Election contract's fixed 100,000 ELF registration cost combined with the Vote contract's hard 64-candidate limit allows an attacker with 6.4M ELF to monopolize all candidate slots, creating a denial-of-service condition that blocks all new candidate registrations until the attacker voluntarily quits.

## Finding Description

The vulnerability arises from the interaction of three immutable design decisions:

**1. Fixed Registration Cost**

The Election contract hardcodes the candidate registration lock amount at 100,000 ELF with no mechanism for governance adjustment. [1](#0-0) 

**2. Hard Candidate Limit**

The Vote contract enforces a maximum of 64 voting options (candidates) per voting item. [2](#0-1) 

**3. Strict Limit Enforcement**

The `AddOption` method rejects any attempt to exceed the 64-option limit with an assertion. [3](#0-2) 

**Attack Execution Path:**

When a user announces their candidacy via `AnnounceElection` or `AnnounceElectionFor`, the system first locks 100,000 ELF from the sender. [4](#0-3) 

Then it adds the candidate as a voting option via cross-contract call. [5](#0-4) 

The Election contract developers explicitly acknowledged this limitation in comments. [6](#0-5) 

**Why Existing Protections Are Insufficient:**

The only economic barrier is the token lock requirement, but this provides inadequate defense because:

- The attacker's tokens are fully recoverable via `QuitElection`, making this a reversible investment rather than a sunk cost. [7](#0-6) 

- The `RemoveEvilNode` governance mechanism exists but requires Emergency Response Organization permission and is designed for consensus misbehavior, not economic slot-filling attacks. [8](#0-7) 

- No rate limiting, progressive pricing, or dynamic cost adjustment mechanisms exist to deter bulk registrations.

## Impact Explanation

**Operational Denial of Service:**
Once an attacker fills all 64 candidate slots, the `AddOption` assertion will fail for any subsequent candidate registration attempts. This creates complete unavailability of the candidate registration system for all legitimate node operators, regardless of their stake or community support.

**Consensus Centralization Risk:**
While existing candidates can continue receiving votes and becoming miners, no new competition can emerge. The attacker maintains indefinite control over which 64 public keys occupy the entire candidate pool, undermining the permissionless and open nature of the AElf consensus mechanism.

**Quantified Damage:**
- Total attack capital: 6,400,000 ELF (64 × 100,000 ELF)
- Effective cost: Only opportunity cost of locked liquidity (principal is fully recoverable)
- Impact scope: All prospective validators attempting to register as candidates
- Duration: Until attacker voluntarily releases slots via `QuitElection`

**Severity: Medium** — Requires significant capital (6.4M ELF) but enables concrete operational disruption of a critical system component without permanent fund loss.

## Likelihood Explanation

**Attacker Capability Requirements:**
- Control of 6,400,000 ELF tokens plus transaction fees
- Ability to execute 64 transactions calling `AnnounceElection` or `AnnounceElectionFor`
- No special privileges, insider access, or compromised keys required

**Attack Complexity:**
Low complexity with deterministic outcome. The attack is a straightforward sequence of identical public method calls. A single address can sponsor multiple candidates using `AnnounceElectionFor` with different public keys. [9](#0-8) 

**Economic Feasibility:**
For wealthy actors or entities with existing consensus/governance interests, the strategic value of controlling candidate pool composition may justify the opportunity cost of locking 6.4M ELF, especially since the principal is fully recoverable and the attack can be maintained indefinitely.

**Detection vs. Mitigation:**
The attack is easily detectable (sudden spike in candidate registrations), but detection provides no mitigation path. Once the 64 slots are filled, the damage is complete. The `RemoveEvilNode` governance mechanism accepts only a single pubkey per call, requiring 64 separate Emergency Response Organization actions (each requiring 90% approval from current miners) to clear the monopolized slots while the DoS persists.

## Recommendation

**Immediate Mitigations:**

1. **Convert constants to governance-adjustable state variables**:
   - Replace `ElectionContractConstants.LockTokenForElection` with a state variable that can be updated through Parliament proposals
   - Replace `VoteContractConstants.MaximumOptionsCount` with a state variable that can be updated through governance

2. **Implement progressive pricing**:
   ```csharp
   // Example: Exponential cost scaling based on current candidate count
   long baseCost = State.LockTokenForElection.Value;
   int currentCandidates = State.Candidates.Value.Value.Count;
   long actualCost = currentCandidates < 40 
       ? baseCost 
       : baseCost * (1 + (currentCandidates - 40) / 10);
   ```

3. **Add rate limiting**:
   - Enforce minimum time interval between announcements from the same sponsor address
   - Track announcement timestamps per address

4. **Enhance RemoveEvilNode**:
   - Add batch removal capability to handle multiple malicious candidates efficiently
   - Create specialized governance response for economic attacks vs. consensus misbehavior

## Proof of Concept

```csharp
[Fact]
public async Task CandidatePoolMonopolizationAttack()
{
    // Setup: Initialize election contract and vote contract
    await InitializeElectionContract();
    
    // Attacker prepares 64 different public keys
    var attackerKeyPairs = new List<ECKeyPair>();
    for (int i = 0; i < 64; i++)
    {
        attackerKeyPairs.Add(CryptoHelper.GenerateKeyPair());
    }
    
    // Check initial candidate count
    var initialCandidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    Assert.True(initialCandidates.Value.Count < 64);
    
    // Attacker monopolizes all 64 candidate slots
    var attackerStub = GetElectionContractStub(AttackerKeyPair);
    for (int i = 0; i < 64; i++)
    {
        await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
        {
            Pubkey = attackerKeyPairs[i].PublicKey.ToHex(),
            Admin = Address.FromPublicKey(AttackerKeyPair.PublicKey)
        });
    }
    
    // Verify all 64 slots are filled
    var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    Assert.Equal(64, candidates.Value.Count);
    
    // Legitimate candidate attempts to register - should FAIL
    var legitimateCandidate = CryptoHelper.GenerateKeyPair();
    var legitimateStub = GetElectionContractStub(legitimateCandidate);
    
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await legitimateStub.AnnounceElection.SendAsync(
            Address.FromPublicKey(legitimateCandidate.PublicKey));
    });
    
    // Verify the DoS: assertion failure due to exceeding 64-option limit
    Assert.Contains("can't greater than", exception.Message);
    
    // Verify attacker can recover all funds by quitting
    long initialBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = Address.FromPublicKey(AttackerKeyPair.PublicKey),
        Symbol = "ELF"
    })).Balance;
    
    for (int i = 0; i < 64; i++)
    {
        await attackerStub.QuitElection.SendAsync(new StringValue 
        { 
            Value = attackerKeyPairs[i].PublicKey.ToHex() 
        });
    }
    
    long finalBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = Address.FromPublicKey(AttackerKeyPair.PublicKey),
        Symbol = "ELF"
    })).Balance;
    
    // Verify full fund recovery (minus transaction fees)
    Assert.True(finalBalance >= initialBalance - 100000); // Account for tx fees
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L86-89)
```csharp
    /// <summary>
    ///     Actually this method is for adding an option of the Voting Item.
    ///     Thus the limitation of candidates will be limited by the capacity of voting options.
    ///     The input is candidate admin, better be an organization address of Association Contract.
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L197-209)
```csharp
    private void AddCandidateAsOption(string publicKey)
    {
        if (State.VoteContract.Value == null)
            State.VoteContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName);

        // Add this candidate as an option for the the Voting Item.
        State.VoteContract.AddOption.Send(new AddOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = publicKey
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-280)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```
