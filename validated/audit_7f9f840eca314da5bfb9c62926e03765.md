# Audit Report

## Title
InitialNFTTypeNameMap Fails to Re-initialize After All NFT Types Are Removed, Causing Permanent DoS of NFT Creation

## Summary
The `InitialNFTTypeNameMap()` function contains a flawed guard condition that only checks if the `NFTTypes` object is null, but does not verify whether its internal map is empty. When Parliament removes all default NFT types via `RemoveNFTType()`, the object remains non-null with an empty map, causing the initialization function to return early without repopulating the required type mappings. This permanently breaks both `Create()` and `CrossChainCreate()` functions until Parliament manually restores the types.

## Finding Description
The vulnerability exists in the guard condition that determines whether NFT type mappings need initialization. [1](#0-0) 

The `NFTTypes` protobuf message is defined as a wrapper containing a map field. [2](#0-1)  In C# protobuf implementations, the message object itself is never null once instantiated, even when the internal map is empty.

**Exploitation Sequence:**

1. **Initial State:** On first use, `InitialNFTTypeNameMap()` creates 10 default NFT type mappings and populates both the `State.NFTTypes.Value` object and the bidirectional mapping states. [3](#0-2) 

2. **Parliament Removes Types:** Parliament legitimately calls `RemoveNFTType()` to remove types (e.g., for deprecation or reorganization). [4](#0-3)  Each removal deletes entries from all three state variables: `State.NFTTypeFullNameMap`, `State.NFTTypeShortNameMap`, and `State.NFTTypes.Value.Value` (the internal map). After removing all 10 default types, `State.NFTTypes.Value` is a non-null object with an empty map.

3. **Create() Failure:** When a user calls `Create()`, it invokes `GetSymbol()`. [5](#0-4)  The `GetSymbol()` function attempts to lookup the NFT type in the empty `State.NFTTypeShortNameMap`, gets null, and calls `InitialNFTTypeNameMap()` to reinitialize. [6](#0-5)  However, the guard condition detects that `State.NFTTypes.Value != null` and returns early without executing the initialization logic. Back in `GetSymbol()`, the lookup still returns null, causing an AssertionException to be thrown.

4. **CrossChainCreate() Failure:** Similarly, `CrossChainCreate()` calls `InitialNFTTypeNameMap()` which returns early without repopulating the maps. [7](#0-6)  The subsequent lookup in `State.NFTTypeFullNameMap` returns null, triggering an AssertionException. [8](#0-7) 

## Impact Explanation
**Severity: HIGH** - Complete operational DoS of core NFT contract functionality.

**Operational Impact:**
- All calls to `Create()` fail with "Short name of NFT Type {nftType} not found"
- All calls to `CrossChainCreate()` fail with "Full name of {nftTypeShortName} not found"  
- No new NFT protocols can be created across the entire chain
- Cross-chain NFT protocol synchronization becomes impossible
- Existing NFT protocols remain functional, but no new protocols can be established

**Affected Parties:**
- All users attempting to create new NFT protocols
- All developers and applications building on NFT functionality
- Cross-chain operations requiring NFT protocol synchronization

**Recovery Process:**
Recovery requires Parliament to manually call `AddNFTType()` multiple times to restore each type mapping. [9](#0-8)  Given the governance approval process required for Parliament actions, the contract may remain in a DoS state for an extended period.

## Likelihood Explanation
**Likelihood: MEDIUM** - Requires Parliament action but realistic through legitimate governance operations.

**Feasible Preconditions:**
- Requires Parliament default address authorization (legitimate trusted role confirmed by authority check) [10](#0-9) 
- Parliament could legitimately remove all types for valid governance reasons:
  - Deprecation of certain NFT categories
  - Reorganization of type taxonomy
  - Policy changes or system upgrades
- No malicious intent required - can occur through governance mistakes or incomplete migration procedures

**Execution Practicality:**
- Simple execution: Parliament calls `RemoveNFTType()` 10 times (once per default type)
- Each call is properly authorized for Parliament
- Once triggered, immediately affects all users attempting NFT creation
- Consequences are severe, unexpected, and non-obvious to governance operators

## Recommendation
Modify the guard condition in `InitialNFTTypeNameMap()` to check if the internal map is empty, not just if the object is null:

```csharp
private NFTTypes InitialNFTTypeNameMap()
{
    // Check if NFTTypes is null OR if the map is empty
    if (State.NFTTypes.Value != null && State.NFTTypes.Value.Value.Count > 0) 
        return State.NFTTypes.Value;

    var nftTypes = new NFTTypes();
    // ... rest of initialization code
}
```

Alternatively, to be more defensive, also check the mapping states:

```csharp
private NFTTypes InitialNFTTypeNameMap()
{
    // Only skip initialization if we have a properly populated state
    if (State.NFTTypes.Value != null && 
        State.NFTTypes.Value.Value.Count > 0 &&
        State.NFTTypeShortNameMap["Art"] != null)
        return State.NFTTypes.Value;

    // Reinitialize
    var nftTypes = new NFTTypes();
    // ... initialization code
}
```

## Proof of Concept
```csharp
[Fact]
public async Task RemoveAllNFTTypes_CausesCreateToFail()
{
    // Get default Parliament organization
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Initialize NFT types by calling GetNFTTypes (triggers InitialNFTTypeNameMap)
    var initialTypes = await NFTContractStub.GetNFTTypes.CallAsync(new Empty());
    initialTypes.Value.Count.ShouldBe(10); // 10 default types
    
    // Parliament removes all NFT types one by one
    var typeShortNames = new[] { "XX", "AR", "MU", "DN", "VW", "TC", "CO", "SP", "UT", "BA" };
    foreach (var shortName in typeShortNames)
    {
        var proposalId = await CreateProposalAsync(
            NFTContractAddress,
            defaultParliament,
            nameof(NFTContractStub.RemoveNFTType),
            new StringValue { Value = shortName });
        await ApproveWithMinersAsync(proposalId);
        await ParliamentContractStub.Release.SendAsync(proposalId);
    }
    
    // Verify all types removed
    var remainingTypes = await NFTContractStub.GetNFTTypes.CallAsync(new Empty());
    remainingTypes.Value.Count.ShouldBe(0);
    
    // Attempt to create NFT - should fail with DoS
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.Create.SendAsync(new CreateInput
        {
            BaseUri = "ipfs://test/",
            Creator = DefaultAddress,
            IsBurnable = true,
            NftType = "Art",
            ProtocolName = "TEST",
            TotalSupply = 1000000
        });
    });
    
    exception.Message.ShouldContain("Short name of NFT Type Art not found");
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L28-33)
```csharp
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L41-41)
```csharp
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L43-62)
```csharp
        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
```

**File:** protobuf/nft_contract.proto (L104-106)
```text
message NFTTypes {
    map<string, string> value = 1;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L20-20)
```csharp
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L78-78)
```csharp
        InitialNFTTypeNameMap();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L90-93)
```csharp
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-150)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-181)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
```
