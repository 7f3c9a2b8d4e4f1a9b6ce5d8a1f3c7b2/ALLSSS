# Audit Report

## Title
Missing Options Count Validation in Vote Contract Register Method Allows Bypass of MaximumOptionsCount Limit

## Summary
The Vote contract's `Register` method fails to validate the number of options during voting item creation, allowing attackers to bypass the protocol-defined `MaximumOptionsCount` limit of 64. This enables creation of voting items with arbitrarily large option arrays, causing permanent state bloat and potential denial-of-service through excessive storage consumption across all network nodes.

## Finding Description

The Vote contract establishes a security constant `MaximumOptionsCount = 64` to limit voting options [1](#0-0) , but this limit is completely bypassed during the registration flow.

The `Register` method directly assigns input options to the VotingItem without any count or length validation [2](#0-1) . The validation helper `AssertValidNewVotingItem` only checks voting item existence, snapshot number validity, and timestamp constraints - it completely omits options count validation [3](#0-2) .

This represents a critical inconsistency when compared with modification methods that properly enforce the limit:
- `AddOption` enforces the limit with a strict less-than check before adding [4](#0-3) 
- `AddOptions` enforces it with a less-than-or-equal check after adding options [5](#0-4) 

Additionally, while `AssertOption` validates individual option length limits [6](#0-5) , it is never invoked during the registration process, allowing bypass of both the count limit (64 options) and individual option length limit (1024 characters per option) [7](#0-6) .

The VotingItems are stored permanently in the contract state [8](#0-7) , meaning this excessive data persists indefinitely across all network nodes.

## Impact Explanation

**Operational Impact - State Bloat and Resource Exhaustion:**

An attacker can create voting items with far more than 64 options (potentially 1000+ options). Since the protobuf definition allows unlimited repeated strings [9](#0-8)  and there's no enforcement, a single malicious voting item could store approximately 1MB of data (1000 options × 1024 bytes), compared to the intended ~64KB maximum (64 options × 1024 bytes).

The permanent storage in `State.VotingItems` means this bloat affects all network nodes perpetually. With only a 10 ELF transaction fee per registration [10](#0-9) , an attacker spending 1000 ELF could create 100 such items, resulting in ~100MB of permanent state bloat.

This degrades node performance, increases storage costs network-wide, and could lead to denial-of-service through state exhaustion. The protocol's design invariant (MaximumOptionsCount) exists precisely to prevent such scenarios, but the missing validation renders it ineffective.

## Likelihood Explanation

**High Feasibility:**

The `Register` method is publicly accessible [11](#0-10)  with no access control restrictions beyond token whitelisting. An attacker only needs:
1. ELF tokens for the 10 ELF transaction fee
2. A whitelisted token symbol (ELF itself is whitelisted by default) [12](#0-11) 

Both preconditions are trivially obtainable. The exploit is straightforward: construct a `VotingRegisterInput` with an arbitrarily large options array and call `Register`.

**Economic Viability:**

At 10 ELF per registration, creating 100 voting items with 1000 options each (resulting in ~100MB of permanent bloat) costs only 1000 ELF. During periods of low ELF price or for a sufficiently motivated attacker, this becomes economically rational to execute. The permanent nature of blockchain storage makes this particularly damaging.

## Recommendation

Add options count and length validation in the `Register` method before storing the voting item. The validation should match the enforcement used in `AddOption` and `AddOptions`:

```csharp
public override Empty Register(VotingRegisterInput input)
{
    var votingItemId = AssertValidNewVotingItem(input);
    
    // Add validation for options count
    Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount,
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    
    // Validate each option's length
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
    }
    
    // ... rest of the method
}
```

Alternatively, refactor to use the existing `AssertOption` helper for each input option during registration to ensure consistent validation across all entry points.

## Proof of Concept

```csharp
[Fact]
public async Task Register_WithExcessiveOptions_ShouldBypassMaximumCount()
{
    // Arrange: Create input with 1000 options (far exceeding limit of 64)
    var excessiveOptions = new List<string>();
    for (int i = 0; i < 1000; i++)
    {
        excessiveOptions.Add($"Option_{i}");
    }
    
    var input = new VotingRegisterInput
    {
        StartTimestamp = TimestampHelper.GetUtcNow(),
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(7),
        AcceptedCurrency = "ELF",
        IsLockToken = true,
        TotalSnapshotNumber = 1,
        Options = { excessiveOptions }
    };
    
    // Act: Register voting item with excessive options
    var result = await VoteContractStub.Register.SendAsync(input);
    
    // Assert: Should succeed (demonstrating vulnerability)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify the voting item was stored with all 1000 options
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender));
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(
        new GetVotingItemInput { VotingItemId = votingItemId });
    
    // Vulnerability confirmed: 1000 options stored despite 64 limit
    votingItem.Options.Count.ShouldBe(1000);
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L6-6)
```csharp
    public const int OptionLengthLimit = 1024;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-20)
```csharp
    public override Empty Register(VotingRegisterInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L29-34)
```csharp
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L54-54)
```csharp
        State.VotingItems[votingItemId] = votingItem;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L294-294)
```csharp
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L320-321)
```csharp
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** protobuf/vote_contract.proto (L99-99)
```text
    repeated string options = 6;
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L47-47)
```csharp
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
```
