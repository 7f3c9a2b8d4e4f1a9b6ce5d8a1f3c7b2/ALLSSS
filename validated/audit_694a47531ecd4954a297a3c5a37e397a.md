# Audit Report

## Title
Inconsistent Profit Detail Matching Logic Enables Vote Extension Manipulation

## Summary
The Election and Profit contracts use different fallback strategies when matching profit details by shares for legacy votes, causing `ChangeVotingOption` to extend the wrong vote's profit period when multiple votes have identical weights.

## Finding Description

The vulnerability stems from inconsistent LINQ selection logic between two contracts when handling old-system votes where `ProfitDetail.Id` is null.

**Election Contract Validation:**

The `GetProfitDetailByElectionVotingRecord` method uses `LastOrDefault` to find profit details when matching by shares, which returns the **last** element in the collection. [1](#0-0) 

**Profit Contract Modification:**

The `FixProfitDetail` method uses `OrderBy(d => d.StartPeriod).FirstOrDefault` to find profit details when matching by shares, which returns the element with the **earliest StartPeriod**. [2](#0-1) 

**Root Cause:**

When a user has multiple old votes with identical weights (same amount and lock time), the validation check and the actual modification target different profit details:
- Validation: selects the last detail in collection order using `LastOrDefault`
- Modification: selects the detail with earliest StartPeriod using `OrderBy().FirstOrDefault`

**Vote Weight Determinism:**

The weight calculation is purely deterministic based on `votesAmount` and `lockTime`, making identical weights inevitable for votes with identical parameters. [3](#0-2) 

**Execution Path:**

When `ChangeVotingOption` is called with `IsResetVotingTime=true`, it invokes `ExtendVoterWelfareProfits`. [4](#0-3) 

`ExtendVoterWelfareProfits` retrieves the profit detail using `GetProfitDetailByElectionVotingRecord` for validation, then calls `State.ProfitContract.FixProfitDetail.Send` which re-searches using different logic. [5](#0-4) 

**Realistic Scenario Evidence:**

The test suite demonstrates creating three votes with identical parameters (same voter, same candidate, same lock time of 20 days, same amount of 10 tokens), confirming this scenario is expected behavior. [6](#0-5) 

**Technical Mechanism:**

For old votes, profit detail `Id` fields are null (confirmed by backward compatibility comments). When `FixProfitDetail` receives a non-null `ProfitDetailId` parameter, it attempts to match against profit details with `Id = null`, which always fails, forcing the fallback to shares-based matching. Since this fallback uses different logic (`OrderBy().FirstOrDefault`) than the validation (`LastOrDefault`), different profit details are selected when multiple details share the same weight.

## Impact Explanation

**HIGH Severity** due to:

1. **Direct Financial Manipulation**: Users can extend Vote A's profit period by calling `ChangeVotingOption` on Vote B when both have identical weights. Vote A receives extended profit distributions beyond its intended period, while Vote B's period remains unmodified.

2. **Protocol Integrity Breach**: The profit distribution scheme's correctness guarantee is violated - votes receive incorrect profit periods, causing misallocation of welfare rewards.

3. **Diluted Distributions**: Other beneficiaries in the welfare scheme receive reduced distributions due to the incorrect share periods of manipulated votes.

4. **Silent State Corruption**: No error is thrown; the wrong profit detail is modified without any indication, making detection extremely difficult. The method completes successfully while corrupting state.

5. **No Authorization Required**: Exploitation uses the standard public `ChangeVotingOption` method with legitimate parameters.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood** because:

1. **No Special Permissions**: Any user with old-system votes can exploit this through the public `ChangeVotingOption` method.

2. **Realistic Preconditions**: 
   - Old-system votes (Id=null) exist in production systems that were deployed before profit detail IDs were introduced (confirmed by backward compatibility code presence)
   - Users commonly vote with standardized amounts (e.g., 1000 tokens for 365 days), naturally creating duplicate weights
   - The test suite itself demonstrates this scenario as normal behavior

3. **Low Complexity**: The exploit requires only calling `ChangeVotingOption` with `IsResetVotingTime=true` on a vote that has a sibling vote with identical weight.

4. **Detection Difficulty**: Both contracts execute successfully with no errors, and the state change appears as a legitimate vote extension in logs.

## Recommendation

Unify the profit detail selection logic between both contracts. The recommended fix is to standardize on `OrderBy(d => d.StartPeriod).FirstOrDefault` in both locations:

**In `GetProfitDetailByElectionVotingRecord`:**
```csharp
if (profitDetail == null)
{
    // Use consistent ordering logic
    profitDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
        .FirstOrDefault(d => d.Shares == electionVotingRecord.Weight);
}
```

Alternatively, add a verification step in `ExtendVoterWelfareProfits` to ensure the retrieved profit detail matches the intended vote ID before calling `FixProfitDetail`, or pass the exact profit detail reference rather than re-searching by shares.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating multiple old-system votes with identical amounts and lock times for the same voter
2. Observing that all votes have identical weights (deterministic calculation)
3. Calling `ChangeVotingOption` with `IsResetVotingTime=true` on Vote B
4. Verifying that Vote A's `EndPeriod` was extended (earliest StartPeriod)
5. Verifying that Vote B's `EndPeriod` was NOT extended (intended target)

The existing test in `ChangeVotingOptionTests.cs` demonstrates the preconditions (multiple identical votes), and the inconsistent LINQ logic is directly observable in the source code.

## Notes

This vulnerability only affects old-system votes where profit detail IDs are null. New votes that store vote IDs in profit detail `Id` fields are not affected, as they use the primary `SingleOrDefault(d => d.Id == input.ProfitDetailId)` lookup path. However, the presence of backward compatibility code indicates old votes are expected to exist in production environments.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L23-50)
```csharp
    public override Empty ChangeVotingOption(ChangeVotingOptionInput input)
    {
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
        Assert(Context.Sender == votingRecord.Voter, "No permission to change current vote's option.");
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");

        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
        else
        {
            // false, no change for EndPeroid
            State.LockTimeMap[input.VoteId] = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds);
        }

        // Withdraw old votes
        State.VoteContract.Withdraw.Send(new WithdrawInput
        {
            VoteId = input.VoteId
        });

```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L275-294)
```csharp
        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }
```

**File:** test/AElf.Contracts.Election.Tests/Full/ChangeVotingOptionTests.cs (L22-26)
```csharp
        for (var i = 0; i < 3; i++)
        {
            await VoteToCandidateAsync(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(), 20 * 86400,
                10);
        }
```
