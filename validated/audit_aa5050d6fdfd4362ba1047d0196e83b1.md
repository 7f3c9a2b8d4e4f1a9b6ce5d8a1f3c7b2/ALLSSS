# Audit Report

## Title
Extra Block Producer ArrangedMiningTime Violates Time Slot Boundaries in Future Rounds

## Summary

The `ArrangeAbnormalMiningTime` method incorrectly calculates the extra block producer's mining time for future rounds by using the producer's normal Order position instead of the extra block slot position (after all regular miners). This causes the extra block to be scheduled within another miner's time slot, violating the fundamental consensus time slot allocation invariant.

## Finding Description

The vulnerability exists in the time slot calculation logic when arranging extra block mining for future rounds after the designated time has passed.

**Entry Point:**
When a miner's behavior is `NextRound` or `NextTerm`, the `TerminateRoundCommandStrategy` is instantiated [1](#0-0) , which calls `ArrangeExtraBlockMiningTime` [2](#0-1) .

**Root Cause:**
The `ArrangeExtraBlockMiningTime` method delegates to `Round.ArrangeAbnormalMiningTime` [3](#0-2) . When the extra block producer's designated time has passed (the condition at line 30 fails), the code falls through to line 36 which calculates using the miner's normal `Order` position [4](#0-3) , not the extra block slot position.

**Expected Behavior:**
According to the consensus design, the extra block should be produced after all normal miners. The `GetExtraBlockMiningTime` method correctly implements this by taking the last miner's `ExpectedMiningTime` and adding one `MiningInterval` [5](#0-4) . The total round time includes an extra interval for the extra block [6](#0-5) .

**Why Order ≠ minersCount:**
The `BreakContinuousMining` logic swaps the last miner (Order = minersCount) with the second-to-last miner when the last miner is the extra block producer [7](#0-6) . This ensures the extra block producer typically has `Order < minersCount`.

**Missing Validation:**
The `TimeSlotValidationProvider` only validates against `ExpectedMiningTime` (normal slot) or checks that new round time slots are evenly spaced [8](#0-7) , and the `RoundTerminateValidationProvider` only validates round number and InValue fields [9](#0-8) . Neither checks that extra blocks are scheduled at the correct extra block time slot.

## Impact Explanation

This vulnerability violates the fundamental consensus invariant that each miner has a designated time slot and the extra block producer mines after all regular miners.

**Concrete Example:**
- 5 miners, mining interval = 4000ms
- Extra block producer has Order = 2 (typical after BreakContinuousMining)
- If arranging for a future round starting at time T:
  - **Calculated (incorrect)**: T + (2 × 4000) = T + 8000ms (Order 2 slot)
  - **Expected (correct)**: T + (5 × 4000) = T + 20000ms (extra block slot)
  - **Violation**: 12000ms (3 time slots) off target

**Consensus Integrity Impact:**
1. **Time slot collision**: The extra block producer is scheduled during another miner's normal time slot, causing potential simultaneous mining attempts
2. **Round termination failures**: The extra block is not produced at the correct time, potentially delaying round transitions
3. **Consensus disruption**: Blocks produced out-of-sequence can affect consensus finality and chain progression

This constitutes a high-severity consensus integrity violation affecting the core time slot scheduling mechanism that ensures orderly block production in AEDPoS.

## Likelihood Explanation

**High likelihood** - this occurs during normal consensus operations without requiring any malicious actor.

**Preconditions (naturally occurring):**
1. Extra block producer's Order < minersCount (common due to BreakContinuousMining)
2. Extra block mining time has passed when consensus command is requested
3. Behavior is NextRound or NextTerm, as determined by the behavior provider [10](#0-9) 

**Triggering Conditions:**
This occurs whenever a miner queries for their consensus command after their extra block time slot has passed. Given network latency, node synchronization delays, or brief outages, this is a regular occurrence in distributed consensus systems. The behavior provider automatically returns NextRound/NextTerm when appropriate [11](#0-10) .

## Recommendation

Fix the `ArrangeAbnormalMiningTime` method to use the extra block slot position instead of the miner's Order when the caller is the extra block producer:

In `Round_ArrangeAbnormalMiningTime.cs`, replace line 36 with:
```csharp
// For extra block producer, use the extra block slot position (after all miners)
var timeSlotPosition = GetExtraBlockProducerInformation().Pubkey == pubkey 
    ? RealTimeMinersInformation.Count 
    : minerInRound.Order;
return futureRoundStartTime.AddMilliseconds(timeSlotPosition.Mul(miningInterval));
```

This ensures the extra block is always scheduled at the correct position regardless of whether the designated time has passed.

## Proof of Concept

A proof of concept would require setting up a test consensus scenario with:
1. 5 miners in a round
2. Extra block producer positioned at Order = 2 (after BreakContinuousMining swap)
3. Current time past the extra block designated time
4. Extra block producer requesting consensus command

The test would verify that:
- The returned `ArrangedMiningTime` uses Order position (T + 8000ms) instead of extra block position (T + 20000ms)
- This creates a 12000ms (3 time slot) discrepancy
- The extra block is scheduled during another miner's time slot

**Notes**

This vulnerability affects the core time slot allocation mechanism in AEDPoS consensus. The issue is particularly insidious because it only manifests when the extra block time has passed, which is a common scenario in distributed systems experiencing network delays or synchronization issues. The `BreakContinuousMining` logic ensures that the extra block producer frequently has `Order < minersCount`, making this a high-probability occurrence during normal operations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L41-44)
```csharp
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L25-26)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-36)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L60-73)
```csharp
    /// <summary>
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
    /// </summary>
    /// <param name="miningInterval"></param>
    /// <returns></returns>
    public int TotalMilliseconds(int miningInterval = 0)
    {
        if (miningInterval == 0) miningInterval = GetMiningInterval();

        return RealTimeMinersInformation.Count * miningInterval + miningInterval;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L92-107)
```csharp
        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-47)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-83)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```
