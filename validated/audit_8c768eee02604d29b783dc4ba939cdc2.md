# Audit Report

## Title
Banned Candidates Can Rejoin Consensus Through Snapshot Replacement Mechanism

## Summary
The Election contract's `GetMinerReplacementInformation()` function fails to filter banned candidates when selecting alternative miners from election snapshots. This allows previously banned evil nodes to rejoin consensus and produce blocks, directly violating the fundamental security guarantee that banned nodes must never participate in block production.

## Finding Description

The vulnerability exists across three interconnected functions in the Election contract that collectively enable banned candidates to bypass the evil node punishment system:

**Root Cause 1: GetNewestPubkey lacks banned validation**

The `GetNewestPubkey()` helper function simply returns the newest pubkey from replacement mappings without checking if that pubkey is banned. [1](#0-0) 

**Root Cause 2: Snapshot processing fails to remove banned candidates**

In `GetPreviousTermSnapshotWithNewestPubkey()`, when processing banned candidates in election snapshots, the function attempts to replace them with their newest pubkeys. [2](#0-1) 

The critical flaw is at lines 152-154: when `GetNewestPubkey(bannedCandidate)` returns the same banned candidate (because no replacement occurred after the ban), the code executes `continue`, which **skips removal of the banned candidate from the snapshot**. The banned candidate remains in `snapshot.ElectionResult` with their full vote count intact.

**Root Cause 3: Alternative miner selection doesn't validate banned status**

The `GetMinerReplacementInformation()` function selects alternative candidates from the snapshot without checking `State.BannedPubkeyMap`. [3](#0-2) 

Lines 368-377 filter by initial/current miner status but have **no check** that `cs.Key` is not banned. This is inconsistent with lines 387-391 where initial miners as fallback **are** filtered by banned status: [4](#0-3) 

**Exploitation Path:**

The consensus contract trusts the Election contract's response and directly adds the alternative candidate without verification. [5](#0-4) 

Lines 313-338 show the consensus contract adds `alternativeCandidatePubkey` to the current round and transfers mining rights without checking if it's banned.

**Attack Scenario:**
1. Candidate P gains votes and appears in Term N election snapshot
2. During Term N+1, P is detected as evil and banned via `UpdateCandidateInformation(P, IsEvilNode=true)`
3. P is removed from the active candidates list but remains in the Term N snapshot
4. In Term N+2, when another miner M becomes evil, consensus calls `GetMinerReplacementInformation()`
5. `GetPreviousTermSnapshotWithNewestPubkey()` returns Term N+1 snapshot still containing banned P
6. P is selected as alternative with highest votes after filtering current/initial miners
7. Consensus adds P to the current round, allowing it to produce blocks despite being banned

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation**

This vulnerability directly breaks the critical security invariant that "banned nodes must never participate in consensus." The impact includes:

1. **Evil Node Re-entry**: Malicious actors previously identified and banned can regain consensus participation and block production authority
2. **Punishment Mechanism Bypass**: Completely undermines the evil node detection and punishment system that is fundamental to consensus security
3. **Continued Attacks**: Banned nodes could continue attacking the network (double-signing, censorship, liveness attacks) after detection
4. **Economic Impact**: Block production rewards flow to banned entities that should have been permanently excluded
5. **Trust Violation**: Users and honest validators rely on the ban system to protect the network; this vulnerability violates that trust

The banned node gains full mining capabilities including producing blocks, participating in consensus rounds, and earning rewards - identical to a legitimate miner.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood**

The vulnerability has high feasibility because:

1. **Automatic Trigger**: Called automatically by consensus during `GenerateNextRoundInformation()` when evil miners are detected - no special attacker action needed
2. **Realistic Preconditions**: 
   - Evil miners are regularly detected in production blockchain systems
   - Only requires attacker was a candidate with votes in a previous term
   - Attacker getting banned is actually the trigger (ironic)
3. **No Special Permissions**: Attacker needs no privileges beyond having been a candidate
4. **Zero Economic Cost**: No additional transactions or fees required from the attacker
5. **Deterministic**: Will occur with certainty when: (a) banned candidate exists in snapshot, (b) another miner needs replacement
6. **Detection Difficulty**: The banned miner appears legitimate in round information; only cross-checking against `BannedPubkeyMap` would reveal the issue

The only limiting factor is the timing window - requires another miner to be banned while the attacker still exists in a retrievable snapshot. However, given the natural occurrence of evil node detection, this window is sufficiently large in practice.

## Recommendation

Implement banned status validation at multiple checkpoints:

1. **In GetPreviousTermSnapshotWithNewestPubkey**: Remove banned candidates from snapshots regardless of replacement status
```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    // If newest pubkey not exists, same as old, OR is also banned, remove the banned candidate
    if (newestPubkey == null || newestPubkey == bannedCandidate || 
        IsPubkeyBanned(newestPubkey) || snapshot.ElectionResult.ContainsKey(newestPubkey))
    {
        snapshot.ElectionResult.Remove(bannedCandidate);
        continue;
    }
    var electionResult = snapshot.ElectionResult[bannedCandidate];
    snapshot.ElectionResult.Add(newestPubkey, electionResult);
    snapshot.ElectionResult.Remove(bannedCandidate);
}
```

2. **In GetMinerReplacementInformation**: Add banned status check when selecting alternatives
```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    .Where(cs => !State.InitialMiners.Value.Value.Contains(
        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    .Where(cs => !State.BannedPubkeyMap[cs.Key])  // Add this check
    .OrderByDescending(s => s.Value).ToList();
```

3. **Defense in Depth - Consensus Contract**: Add validation before accepting alternatives
```csharp
var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
// Verify alternative is not banned
Assert(!State.ElectionContract.IsPubkeyBanned.Call(new StringValue { Value = alternativeCandidatePubkey }).Value,
    "Alternative candidate is banned");
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

```csharp
[Fact]
public async Task BannedCandidateRejoinsConsensus_Test()
{
    // Setup: Candidate P gains votes in Term 1
    var candidatePubkey = "banned_candidate_pubkey";
    await ElectionContract.Vote(candidatePubkey, 10000);
    await ElectionContract.TakeSnapshot(new TakeElectionSnapshotInput { TermNumber = 1 });
    
    // Step 1: Ban candidate P in Term 2
    await ElectionContract.UpdateCandidateInformation(new UpdateCandidateInformationInput
    {
        Pubkey = candidatePubkey,
        IsEvilNode = true
    });
    
    // Verify P is banned
    var isBanned = await ElectionContract.IsPubkeyBanned.CallAsync(new StringValue { Value = candidatePubkey });
    isBanned.Value.ShouldBeTrue();
    
    // Step 2: In Term 3, another miner becomes evil, trigger replacement
    var currentMiners = new List<string> { "miner1", "evil_miner2", "miner3" };
    await ElectionContract.UpdateCandidateInformation(new UpdateCandidateInformationInput
    {
        Pubkey = "evil_miner2",
        IsEvilNode = true
    });
    
    // Step 3: Request replacement information
    var replacementInfo = await ElectionContract.GetMinerReplacementInformation.CallAsync(
        new GetMinerReplacementInformationInput { CurrentMinerList = { currentMiners } });
    
    // VULNERABILITY: Banned candidate P is returned as alternative
    replacementInfo.AlternativeCandidatePubkeys.ShouldContain(candidatePubkey);
    
    // Step 4: Consensus contract adds banned P to active round
    // P can now produce blocks despite being banned
    // This violates the fundamental security invariant
}
```

This test demonstrates that a banned candidate remains in election snapshots and gets selected as an alternative miner, allowing it to rejoin consensus and produce blocks.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L145-158)
```csharp
        var bannedCandidates = snapshot.ElectionResult.Keys.Where(IsPubkeyBanned).ToList();
        Context.LogDebug(() => $"Banned candidates count: {bannedCandidates.Count}");
        if (!bannedCandidates.Any()) return snapshot;
        Context.LogDebug(() => "Getting snapshot and there's miner replaced during current term.");
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-338)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```
