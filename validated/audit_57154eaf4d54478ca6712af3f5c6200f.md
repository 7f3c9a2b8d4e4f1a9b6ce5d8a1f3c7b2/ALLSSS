# Audit Report

## Title
Unhandled Exception in CrossChainCreate() Due to Unsafe bool.Parse() on Unvalidated ExternalInfo

## Summary
The `CrossChainCreate()` method in the NFT contract performs unsafe `bool.Parse()` and direct dictionary access on `ExternalInfo` values without validation or exception handling. An attacker can create a token on the mainchain with malformed `ExternalInfo` metadata, replicate it cross-chain, and cause permanent DoS of NFT protocol creation for that symbol on the sidechain.

## Finding Description

The vulnerability exists in the `CrossChainCreate()` method where it performs unsafe operations on unvalidated `ExternalInfo` metadata without any try-catch blocks or pre-validation. [1](#0-0) 

These lines perform two unsafe operations:
1. **Direct dictionary access** using the indexer operator - throws `KeyNotFoundException` if the key doesn't exist
2. **Unsafe bool.Parse()** - throws `FormatException` if the value is not a valid boolean string

The metadata key constants are defined as: [2](#0-1) 

**Root Cause**: The MultiToken contract's `Create` method accepts arbitrary `ExternalInfo` content without validating its format or required keys. [3](#0-2) 

The `ExternalInfo` is simply copied from the input without content validation. An attacker can bypass the NFT contract's proper formatting by calling `MultiToken.Create()` directly. The legitimate NFT contract's `Create` method properly formats boolean values as strings: [4](#0-3) 

**Cross-Chain Replication Preserves Malformed Data**: The malformed `ExternalInfo` is replicated cross-chain via `CrossChainCreateToken`. [5](#0-4) 

The `ValidateTokenInfoExists` method only validates that the `ExternalInfo` matches between chains, but doesn't validate the content format. [6](#0-5) 

**Safer Patterns Exist Elsewhere**: Other parts of the MultiToken contract use `TryGetValue()` and `TryParse()` for safe dictionary access and parsing. [7](#0-6) 

**Attack Path**:
1. Attacker obtains a SEED NFT (tradeable on secondary markets). [8](#0-7) 
2. Attacker calls `MultiToken.Create()` on mainchain with NFT collection symbol (e.g., "ART-0") and malformed `ExternalInfo`:
   - Missing required keys (`aelf_nft_base_uri`, `aelf_nft_token_id_reuse`)
   - OR providing non-boolean values like `{"aelf_nft_token_id_reuse": "not_a_boolean"}`
3. Token is created with malformed metadata [9](#0-8) 
4. Attacker calls `ValidateTokenInfoExists()` on mainchain (succeeds - only checks matching)
5. Attacker calls `CrossChainCreateToken()` on sidechain with merkle proof
6. Token is replicated to sidechain with same malformed `ExternalInfo` [10](#0-9) 
7. When anyone attempts `NFTContract.CrossChainCreate()` on sidechain, the method throws unhandled exceptions
8. NFT protocol creation for that symbol is permanently broken on the sidechain

## Impact Explanation

**High Severity** - Complete denial of service with no recovery path:

1. **Permanent DoS**: Once a malicious token is replicated to a sidechain, `CrossChainCreate()` for that symbol will always throw an unhandled exception. The NFT protocol cannot be created on the sidechain without a contract upgrade.

2. **Breaks Cross-Chain NFT Functionality**: NFT protocols created on the mainchain cannot be instantiated on affected sidechains, breaking the core cross-chain NFT use case.

3. **Protocol Lock-Out**: The protocol exists on mainchain but is permanently inaccessible on the sidechain for that symbol.

4. **Resource Waste**: Legitimate users attempting protocol creation will pay transaction fees for transactions that always fail.

**Affected Parties**:
- NFT protocol creators expanding to sidechains
- DApps depending on cross-chain NFT availability  
- End users unable to interact with NFT protocols on affected chains

## Likelihood Explanation

**Medium-High Likelihood**:

**Attacker Requirements** (All Achievable):
1. **Obtain SEED NFT**: Required for token creation. SEEDs are tradeable NFTs that can be purchased on secondary markets.
2. **Call Public Methods**: `MultiToken.Create()`, `ValidateTokenInfoExists()`, and `CrossChainCreateToken()` are all public, permissionless methods.
3. **Execute Cross-Chain Operations**: Standard cross-chain token replication using merkle proofs - no special privileges needed.

**Attack Complexity**: Low
- Simple multi-step process using standard public methods
- No cryptographic manipulation required
- No timing dependencies or race conditions
- Straightforward malicious input creation

**Economic Viability**:
- Cost: One SEED NFT + transaction fees
- Benefit: Can permanently block specific NFT protocol symbols (e.g., competitors' protocols)
- Viable for griefing or competitive advantage

**No Protection Mechanisms**:
- No input validation on `ExternalInfo` content in `MultiToken.Create()`
- No pre-validation in `CrossChainCreate()` before unsafe operations
- No exception handling to catch and recover from malformed data

## Recommendation

**Immediate Fix**: Add defensive validation and error handling in `CrossChainCreate()`:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = input.Symbol
    });
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    // SAFE VALIDATION: Use TryGetValue and TryParse
    if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftBaseUriMetadataKey, out var baseUri) ||
        string.IsNullOrEmpty(baseUri))
        throw new AssertionException($"Missing or invalid {NftBaseUriMetadataKey} in ExternalInfo.");
    
    if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var tokenIdReuseStr) ||
        !bool.TryParse(tokenIdReuseStr, out var isTokenIdReuse))
        throw new AssertionException($"Missing or invalid {NftTokenIdReuseMetadataKey} in ExternalInfo.");

    // Rest of the method continues normally...
}
```

**Additional Recommendations**:
1. Add content validation in `MultiToken.Create()` for NFT collection symbols to reject malformed `ExternalInfo`
2. Enhance `ValidateTokenInfoExists()` to validate metadata format, not just key matching
3. Add similar defensive validation in other methods that access `ExternalInfo`

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_WithMalformedExternalInfo_ShouldThrowException()
{
    // Setup: Create malformed token on mainchain
    var malformedExternalInfo = new ExternalInfo();
    malformedExternalInfo.Value["some_key"] = "some_value";
    // Missing required keys: aelf_nft_base_uri, aelf_nft_token_id_reuse
    
    // Call MultiToken.Create with SEED NFT and malformed ExternalInfo
    var createInput = new CreateInput
    {
        Symbol = "ART-0",
        TokenName = "Art Collection",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        ExternalInfo = malformedExternalInfo
    };
    
    await TokenContractStub.Create.SendAsync(createInput);
    
    // Simulate cross-chain replication to sidechain
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "ART-0" });
    
    // Attempt CrossChainCreate on sidechain - should throw KeyNotFoundException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = "ART-0"
        });
    });
    
    Assert.Contains("KeyNotFoundException", exception.Message);
}

[Fact]
public async Task CrossChainCreate_WithInvalidBooleanValue_ShouldThrowException()
{
    // Setup: Create token with invalid boolean value
    var malformedExternalInfo = new ExternalInfo();
    malformedExternalInfo.Value["aelf_nft_base_uri"] = "https://example.com";
    malformedExternalInfo.Value["aelf_nft_token_id_reuse"] = "not_a_boolean"; // Invalid
    
    var createInput = new CreateInput
    {
        Symbol = "MU-0",
        TokenName = "Music Collection",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        ExternalInfo = malformedExternalInfo
    };
    
    await TokenContractStub.Create.SendAsync(createInput);
    
    // Attempt CrossChainCreate - should throw FormatException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = "MU-0"
        });
    });
    
    Assert.Contains("FormatException", exception.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L198-199)
```csharp
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L8-9)
```csharp
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L59-64)
```csharp
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L124-130)
```csharp
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L449-456)
```csharp
        if (tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.Count > 0 ||
            input.ExternalInfo != null && input.ExternalInfo.Count > 0)
        {
            validationResult = validationResult && tokenInfo.ExternalInfo.Value.Count == input.ExternalInfo.Count;
            if (tokenInfo.ExternalInfo.Value.Any(keyPair =>
                    !input.ExternalInfo.ContainsKey(keyPair.Key) || input.ExternalInfo[keyPair.Key] != keyPair.Value))
                throw new AssertionException("Token validation failed.");
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-503)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```
