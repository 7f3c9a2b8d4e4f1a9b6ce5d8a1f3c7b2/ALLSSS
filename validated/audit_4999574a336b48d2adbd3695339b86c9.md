# Audit Report

## Title
Incorrect Backup Miner Limit Causes Consensus to Operate with Fewer Miners Than Configured

## Summary
The `GetVictories` function in the Election contract uses an incorrect upper bound when selecting backup miners, limiting selection to `currentMiners.Count` instead of the available `backups` list size. This causes the consensus to operate with fewer validators than the governance-configured `MinersCount` when valid candidates are insufficient, undermining network security and governance authority.

## Finding Description

The vulnerability exists in the backup miner selection logic when there are insufficient valid candidates (candidates with votes > 0) to fill the required `MinersCount` positions. [1](#0-0) 

The root cause is in the backup selection logic which uses `Math.Min(diff, currentMiners.Count)` to limit how many backups are selected. The issue is:

1. **Logic Flow**: When `validCandidates.Count < State.MinersCount.Value`, the system calculates `diff = State.MinersCount.Value - validCandidates.Count` to determine how many additional miners are needed
2. **Backup Building**: A `backups` list is constructed containing filtered current miners plus filtered initial miners, which can be larger than `currentMiners.Count`
3. **Incorrect Limit**: The code takes backups using `Math.Min(diff, currentMiners.Count)` instead of `Math.Min(diff, backups.Count)` or just `diff`

**Concrete Example**:
- Governance sets `MinersCount = 7`
- Only 2 candidates have votes: `validCandidates.Count = 2`
- Current miners: `currentMiners.Count = 3`
- After filtering, `backups` contains: 3 current miners + 5 initial miners = 8 potential backups
- System needs: `diff = 7 - 2 = 5` additional miners
- Bug causes: `Math.Min(5, 3) = 3` backups selected (limited by wrong value)
- **Result**: Returns only 5 total miners (2 valid + 3 backups) instead of required 7

**Why Protections Fail**:

The consensus contract accepts whatever miner list is returned without validation: [2](#0-1) 

The `GenerateFirstRoundOfNewTerm` method simply iterates through whatever miners are provided in the list without checking if the count matches `MinersCount`. [3](#0-2) 

The `SetMinerList` method stores the miner list without count validation.

## Impact Explanation

**Consensus Security Degradation**: Operating with 5 miners instead of 7 reduces Byzantine fault tolerance. With 7 miners, the system tolerates up to 2 malicious nodes (BFT threshold = (n-1)/3). With only 5 miners, it can only tolerate 1 malicious node.

**Governance Violation**: The `MinersCount` parameter is set through governance-controlled mechanisms: [4](#0-3) [5](#0-4) 

The bug causes this governance-approved parameter to be silently ignored, undermining protocol governance authority.

**Network Stability Risk**: Fewer validators increases vulnerability to node failures. A validator set of 5 instead of 7 means each validator failure has proportionally greater impact on network availability.

## Likelihood Explanation

**Triggering Conditions**:
1. `MinersCount` has been increased through governance (natural during network growth)
2. Valid candidate count is insufficient: `validCandidates.Count < MinersCount` (occurs during low participation periods)
3. Current miner count is less than needed backups: `currentMiners.Count < diff`
4. Sufficient `InitialMiners` available (always true as they persist)

**Automatic Execution**: [6](#0-5) [7](#0-6) 

The consensus contract automatically calls `GetVictories` during term transitions via `TryToGetVictories`. This occurs naturally during consensus operation without any attacker action required. The bug manifests silently - the system continues operating but with reduced validator count.

## Recommendation

Fix the backup selection limit to use the correct upper bound:

```csharp
victories.AddRange(backups.OrderBy(p => p)
    .Take(Math.Min(diff, backups.Count))  // Use backups.Count instead of currentMiners.Count
    .Select(v => ByteStringHelper.FromHexString(v)));
```

Or simply use `diff` directly since the backups list is already filtered to exclude valid candidates:

```csharp
victories.AddRange(backups.OrderBy(p => p)
    .Take(diff)  // Take exactly what we need
    .Select(v => ByteStringHelper.FromHexString(v)));
```

## Proof of Concept

```csharp
[Fact]
public async Task GetVictories_ReturnsFewerMinersThanConfigured_WhenBackupLimitIncorrect()
{
    // Setup: Increase MinersCount to 7 via governance
    await ConsensusContractStub.SetMaximumMinersCount.SendAsync(new Int32Value { Value = 7 });
    
    // Ensure we have sufficient initial miners (at least 5)
    // and current miners (3)
    
    // Create only 2 valid candidates (with votes)
    var validCandidates = ValidationDataCenterKeyPairs.Take(2).ToList();
    foreach (var keyPair in validCandidates)
    {
        await AnnounceElectionAsync(keyPair);
        await VoteToCandidateAsync(VoterKeyPairs[0], keyPair.PublicKey.ToHex(), 100 * 86400, 100);
    }
    
    // Get victories
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // Expected: 7 miners (2 valid + 5 from backups)
    // Actual: 5 miners (2 valid + 3 limited by currentMiners.Count)
    victories.Value.Count.ShouldBe(7, "Should return MinersCount miners");
    // This assertion will FAIL, demonstrating the bug
}
```

## Notes

The vulnerability is in production scope, requires no attacker privileges, occurs during normal consensus operation, and has measurable impact on network security by reducing the effective validator set below governance-configured levels. The bug silently degrades consensus security guarantees without any visible errors or reverts.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L60-76)
```csharp
        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-240)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```
