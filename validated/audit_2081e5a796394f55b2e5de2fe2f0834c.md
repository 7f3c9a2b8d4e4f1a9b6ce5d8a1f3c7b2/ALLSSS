# Audit Report

## Title
Cumulative Allowance Exploitation via Misleading GetAvailableAllowance Math.Max Logic

## Summary
The MultiToken contract's allowance system allows spenders to consume multiple independent allowances (specific token, wildcard "*", and NFT collection wildcards) sequentially for the same token. The `GetAvailableAllowance` view function uses `Math.Max` to display only the maximum single allowance, misleading users into believing this represents their total exposure. However, the actual transfer enforcement uses a fallback mechanism that enables cumulative consumption, allowing transfers significantly exceeding the displayed amount.

## Finding Description

The vulnerability stems from a critical mismatch between how allowances are displayed to users versus how they are actually consumed during transfers.

**Allowance Storage Architecture**: Each allowance type is stored independently in the state mapping. When a token owner approves both specific tokens (e.g., "ELF") and wildcard allowances (e.g., "*"), these create separate storage entries at different keys. [1](#0-0) 

**Misleading Display Logic**: The `GetAvailableAllowance` view function retrieves allowances from multiple sources and returns only the maximum value using `Math.Max`. This clearly communicates to users that the maximum available from any single source represents their total exposure. [2](#0-1) 

**Cumulative Consumption Logic**: The private `GetAllowance` helper function implements a fallback resolution strategy. It first checks the specific token allowance; if insufficient, it falls back to checking wildcard allowances ("*" for all tokens, "COLLECTION-*" for NFT collections). Each successful transfer decrements only the allowance source that was actually used. [3](#0-2) 

**Exploitation Mechanism**: The `DoTransferFrom` function calls `GetAllowance` to find a sufficient allowance, performs the transfer, then decrements only the specific allowance that was consumed. This allows sequential consumption of multiple independent allowances for the same token. [4](#0-3) 

**Attack Scenario**:
1. Owner approves 1000 ELF specifically to spender
2. Owner approves 500 ELF via wildcard "*" to same spender  
3. User queries `GetAvailableAllowance("ELF")` → returns 1000 (Math.Max result)
4. Spender calls `TransferFrom` for 1000 ELF → consumes specific allowance
5. Spender calls `TransferFrom` for 500 ELF → consumes wildcard allowance
6. **Total transferred: 1500 ELF**, despite view function indicating only 1000

No validation exists to prevent this cumulative consumption pattern across multiple allowance types for the same token.

## Impact Explanation

**Direct Financial Loss**: Token owners lose significantly more funds than intended. A user who approves 1000 tokens specifically and 500 via wildcard believes they've limited their exposure to 1000 tokens (as explicitly shown by `GetAvailableAllowance`), but a spender can actually extract 1500 tokens - a 50% excess loss.

**Affected User Categories**:
- All token holders using wildcard approvals for operational convenience
- DeFi protocol integrations that may leverage wildcards for flexible token management
- NFT collection owners using collection-level approvals ("COLLECTION-*" pattern)
- Users who set different allowance types for different trust levels

**Severity Justification**: This is a **High severity** issue because:
1. It enables unauthorized token extraction beyond user-intended limits
2. The `Math.Max` logic in `GetAvailableAllowance` clearly indicates design intent to show maximum available from any single source, not cumulative total
3. No mechanism exists for users to detect this cumulative behavior from the provided view functions
4. Users making security-critical decisions based on `GetAvailableAllowance` are systematically misled

## Likelihood Explanation

**Attack Complexity**: **Low**. The exploit requires only standard operations:
1. Token owner approving multiple allowance types (natural workflow)
2. Spender executing `TransferFrom` multiple times (standard usage pattern)

**Realistic Preconditions**: Users naturally may:
- Set specific allowances for known trusted contracts with fixed amounts
- Add wildcard allowances separately for convenience with flexible services
- Fail to realize these allowances are cumulative rather than alternative/overlapping
- Rely on `GetAvailableAllowance` to understand their actual exposure

**Detection Gap**: The existing test suite validates individual allowance types in isolation. The comprehensive wildcard test demonstrates that `GetAvailableAllowance` returns the maximum and that transfers correctly decrement the used allowance, but no test validates the security-critical behavior of cumulative consumption across multiple allowance types. [5](#0-4) 

**Attacker Profile**: Any approved spender - no special privileges, compromised keys, or protocol violations required. The approved spender is acting within their technical permissions but exploiting the semantic mismatch between displayed and actual allowances.

**Overall Likelihood**: **High** - Natural user workflows, standard contract interactions, and the misleading view function make this highly likely to occur in production.

## Recommendation

Implement one of the following fixes:

**Option 1 - Cumulative Display (Preferred)**: Modify `GetAvailableAllowance` to return the **sum** of all applicable allowances rather than the maximum:

```csharp
public override GetAllowanceOutput GetAvailableAllowance(GetAllowanceInput input)
{
    var result = new GetAllowanceOutput
    {
        Symbol = input.Symbol,
        Owner = input.Owner,
        Spender = input.Spender,
    };
    var symbol = input.Symbol;
    var allowance = State.Allowances[input.Owner][input.Spender][symbol];
    if (CheckSymbolIdentifier(symbol))
    {
        result.Allowance = allowance;
        return result;
    }
    var symbolType = GetSymbolType(symbol);
    // Sum instead of Math.Max
    allowance += GetAllSymbolAllowance(input.Owner, input.Spender, out _);
    if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
    {
        allowance += GetNftCollectionAllSymbolAllowance(input.Owner, input.Spender, symbol, out _);
    }
    result.Allowance = allowance;
    return result;
}
```

**Option 2 - Non-Cumulative Enforcement**: Modify `GetAllowance` to prevent fallback consumption once a specific allowance exists:

```csharp
private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount, out string allowanceSymbol)
{
    allowanceSymbol = sourceSymbol;
    var allowance = State.Allowances[from][spender][sourceSymbol];
    // If specific allowance exists (even if zero), don't fall back
    if (State.Allowances[from][spender][sourceSymbol] != null) return allowance;
    
    var tokenType = GetSymbolType(sourceSymbol);
    if (tokenType == SymbolType.Token)
    {
        allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
    }
    else
    {
        allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
        if (allowance >= amount) return allowance;
        allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
    }
    return allowance;
}
```

**Option 3 - Explicit Documentation**: If cumulative behavior is intended, document it clearly and rename the function to `GetCumulativeAvailableAllowance`, with prominent warnings in the protocol documentation.

## Proof of Concept

```csharp
[Fact]
public async Task CumulativeAllowanceExploitation_Test()
{
    // Setup: Create and issue tokens to owner
    await CreateAndIssueMultiTokensAsync();
    
    var ownerAddress = DefaultAddress;
    var spenderAddress = User1Address;
    var tokenSymbol = AliceCoinTokenInfo.Symbol; // "ELF" or similar
    
    // Step 1: Owner approves 100 tokens specifically to spender
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Symbol = tokenSymbol,
        Amount = 100,
        Spender = spenderAddress
    });
    
    // Step 2: Owner also approves 50 tokens via wildcard to spender
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Symbol = "*",
        Amount = 50,
        Spender = spenderAddress
    });
    
    // Step 3: Check GetAvailableAllowance - shows only 100 (Math.Max)
    var availableAllowance = await TokenContractStub.GetAvailableAllowance.CallAsync(
        new GetAllowanceInput
        {
            Owner = ownerAddress,
            Spender = spenderAddress,
            Symbol = tokenSymbol
        });
    availableAllowance.Allowance.ShouldBe(100); // User believes max exposure is 100
    
    // Step 4: Spender transfers 100 tokens (consumes specific allowance)
    var spenderStub = GetTester<TokenContractImplContainer.TokenContractImplStub>(
        TokenContractAddress, User1KeyPair);
    await spenderStub.TransferFrom.SendAsync(new TransferFromInput
    {
        From = ownerAddress,
        To = User2Address,
        Symbol = tokenSymbol,
        Amount = 100
    });
    
    // Step 5: Spender transfers another 50 tokens (consumes wildcard allowance)
    await spenderStub.TransferFrom.SendAsync(new TransferFromInput
    {
        From = ownerAddress,
        To = User2Address,
        Symbol = tokenSymbol,
        Amount = 50
    });
    
    // Verify: 150 tokens transferred despite GetAvailableAllowance showing 100
    var recipientBalance = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput
        {
            Owner = User2Address,
            Symbol = tokenSymbol
        });
    recipientBalance.Balance.ShouldBe(150); // VULNERABILITY: 50% more than displayed limit
}
```

This test demonstrates that a spender can extract 150 tokens when `GetAvailableAllowance` indicated only 100 were available, confirming the cumulative consumption vulnerability.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L270-281)
```csharp
    private void Approve(Address spender, string symbol, long amount)
    {
        var actualSymbol = GetActualTokenSymbol(symbol);
        State.Allowances[Context.Sender][spender][actualSymbol] = amount;
        Context.Fire(new Approved
        {
            Owner = Context.Sender,
            Spender = spender,
            Symbol = actualSymbol,
            Amount = amount
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L64-87)
```csharp
    public override GetAllowanceOutput GetAvailableAllowance(GetAllowanceInput input)
    {
        var result = new GetAllowanceOutput
        {
            Symbol = input.Symbol,
            Owner = input.Owner,
            Spender = input.Spender,
        };
        var symbol = input.Symbol;
        var allowance = State.Allowances[input.Owner][input.Spender][symbol];
        if (CheckSymbolIdentifier(symbol))
        {
            result.Allowance = allowance;
            return result;
        }
        var symbolType = GetSymbolType(symbol);
        allowance = Math.Max(allowance, GetAllSymbolAllowance(input.Owner,input.Spender,out _));
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            allowance = Math.Max(allowance, GetNftCollectionAllSymbolAllowance(input.Owner, input.Spender, symbol, out _));
        }
        result.Allowance = allowance;
        return result;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L97-116)
```csharp
    private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
        out string allowanceSymbol)
    {
        allowanceSymbol = sourceSymbol;
        var allowance = State.Allowances[from][spender][sourceSymbol];
        if (allowance >= amount) return allowance;
        var tokenType = GetSymbolType(sourceSymbol);
        if (tokenType == SymbolType.Token)
        {
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }
        else
        {
            allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
            if (allowance >= amount) return allowance;
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }

        return allowance;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L536-649)
```csharp
    public async Task MultiTokenContract_TransferFrom_Nft_Global_Test()
    {
        await CreateNft();
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "ABC-1",
            Amount = 100,
            To = DefaultAddress,
            Memo = "test"
        });
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "ABC-1",
            Amount = 200,
            To = User1Address,
            Memo = "test"
        });
        var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultAddress,
            Symbol = "ABC-1"
        });
        balance.Balance.ShouldBe(100);
        balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = User1Address,
            Symbol = "ABC-1"
        });
        balance.Balance.ShouldBe(200);
        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Amount = 1000,
            Symbol = "*",
            Spender = User1Address
        });
        
        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Amount = 1,
            Symbol = "ABC-*",
            Spender = User1Address
        });
        var allowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "ABC-1"
        });
        allowance.Allowance.ShouldBe(0);
        allowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "ELF"
        });
        allowance.Allowance.ShouldBe(0);
        {
            var realAllowance = await TokenContractStub.GetAvailableAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = DefaultAddress,
                Spender = User1Address,
                Symbol = "ABC-1"
            });
            realAllowance.Allowance.ShouldBe(1000);
        }
        {
            var realAllowance = await TokenContractStub.GetAvailableAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = DefaultAddress,
                Spender = User1Address,
                Symbol = "ELF"
            });
            realAllowance.Allowance.ShouldBe(1000);
        }
        var user1Stub =
            GetTester<TokenContractImplContainer.TokenContractImplStub>(TokenContractAddress, User1KeyPair);
        var result2 = await user1Stub.TransferFrom.SendAsync(new TransferFromInput
        {
            Amount = 50,
            From = DefaultAddress,
            Memo = "test",
            Symbol = "ABC-1",
            To = User1Address
        }); 
        result2.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        {
            var realAllowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = DefaultAddress,
                Spender = User1Address,
                Symbol = "ABC-1"
            });
            realAllowance.Allowance.ShouldBe(0);
        }
        allowance = await TokenContractStub.GetAvailableAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "ABC-1"
        });
        allowance.Allowance.ShouldBe(1000-50);
        balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultAddress,
            Symbol = "ABC-1"
        });
        balance.Balance.ShouldBe(50);
        balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = User1Address,
            Symbol = "ABC-1"
        });
        balance.Balance.ShouldBe(250);
    }
```
