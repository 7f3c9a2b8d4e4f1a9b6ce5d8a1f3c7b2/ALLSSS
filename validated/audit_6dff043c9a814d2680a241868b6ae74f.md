# Audit Report

## Title
Negative MissedTimeSlots Bypass Evil Miner Detection via Unchecked Round Input

## Summary
The AEDPoS consensus contract accepts miner-provided `NextRoundInput` containing signed `MissedTimeSlots` values without validating non-negativity. Since evil miner detection uses `>=` comparison against a positive threshold (4320), negative values permanently bypass punishment, allowing malicious miners to miss unlimited time slots while remaining in the validator set.

## Finding Description

The `NextRound` method is a public entry point that accepts user-provided `NextRoundInput` structures. [1](#0-0)  The `missed_time_slots` field is defined as `int64`, a signed type that permits negative values.

When `ProcessNextRound` executes, it directly converts the input to a `Round` object via `ToRound()` without any bounds validation: [2](#0-1) 

The `ToRound()` conversion method blindly copies all field values including `MissedTimeSlots` without sanitization: [3](#0-2) 

The validation framework for `NextRound` behavior only checks structural properties (round number increment, InValue fields, mining order) but never validates `MissedTimeSlots` values: [4](#0-3) [5](#0-4) 

The `PreCheck` function only verifies the sender is in the miner list, not that input data has integrity: [6](#0-5) 

The malicious round is stored directly in state: [7](#0-6) 

Evil miner detection compares `MissedTimeSlots >= TolerableMissedTimeSlotsCount`: [8](#0-7) 

The threshold is hardcoded to 4320 (positive value): [9](#0-8) 

When `GenerateNextRoundInformation` processes subsequent rounds, it increments `MissedTimeSlots` by 1 for miners who miss: [10](#0-9) 

If an attacker sets `MissedTimeSlots = -10000`, the counter increments to -9999, -9998, etc., requiring 14,320 rounds to reach the threshold instead of the intended 4,320.

## Impact Explanation

This vulnerability breaks the consensus invariant that ensures reliable block production. The evil miner detection mechanism is designed to remove validators who consistently fail to produce blocks, maintaining network quality and liveness.

By injecting negative `MissedTimeSlots` values, malicious miners can:
- Miss unlimited time slots without being flagged as evil nodes
- Occupy validator positions indefinitely while providing no service
- Reduce overall network throughput as their time slots are wasted
- Cause honest miners to lose block rewards (fewer available slots)
- Degrade user experience through slower block times

The comparison `-10000 >= 4320` always evaluates to `false`, completely bypassing the punishment mechanism. This compromises the economic security model that incentivizes reliable validator performance.

## Likelihood Explanation

**Attacker Prerequisites**: The attacker must be an elected miner in the current validator set. This is achievable through:
- Normal governance voting mechanisms
- Compromised validator keys
- Initially honest validators turning malicious

**Attack Execution**: When scheduled to produce a `NextRound` block:
1. Craft `NextRoundInput` with `MissedTimeSlots` set to large negative value (e.g., -10000)
2. Submit the `NextRound` transaction during block production
3. Validation passes (structural checks only, no value validation)
4. Malicious round stored in state
5. Subsequent evil miner detection fails to flag attacker

**Feasibility**: High probability given:
- No technical barriers (simple arithmetic manipulation)
- No economic barriers beyond normal transaction fees
- Low detection probability (negative values not visible in typical monitoring)
- Deterministic outcome (mathematical guarantee of bypass)

## Recommendation

Add input validation to `ProcessNextRound` before storing the round:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Validate MissedTimeSlots are non-negative
    foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
    {
        Assert(minerInRound.MissedTimeSlots >= 0, 
            $"Invalid MissedTimeSlots value: {minerInRound.MissedTimeSlots}");
        Assert(minerInRound.ProducedBlocks >= 0,
            $"Invalid ProducedBlocks value: {minerInRound.ProducedBlocks}");
    }
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of method
}
```

Alternatively, add a dedicated validator in the validation framework that checks all numeric consensus fields are within expected bounds.

## Proof of Concept

```csharp
[Fact]
public async Task NegativeMissedTimeSlotsBypassesEvilMinerDetection()
{
    // Setup: Initialize consensus with test miner
    await InitializeConsensusContract();
    var miner = SampleAccount.Accounts[0].KeyPair;
    
    // Get current round
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Craft malicious NextRoundInput with negative MissedTimeSlots
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        RealTimeMinersInformation = 
        {
            {
                miner.PublicKey.ToHex(),
                new MinerInRound
                {
                    Pubkey = miner.PublicKey.ToHex(),
                    MissedTimeSlots = -10000, // Negative value
                    Order = 1
                }
            }
        }
    };
    
    // Execute NextRound with malicious input
    await ConsensusStub.NextRound.SendAsync(maliciousInput);
    
    // Verify: The round was stored with negative MissedTimeSlots
    var storedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(-10000, storedRound.RealTimeMinersInformation[miner.PublicKey.ToHex()].MissedTimeSlots);
    
    // Verify: Evil miner detection fails to detect the miner
    var detected = storedRound.TryToDetectEvilMiners(out var evilMiners);
    Assert.False(detected); // Should be true but fails due to negative value
    Assert.Empty(evilMiners); // Miner not flagged despite invalid state
}
```

### Citations

**File:** protobuf/aedpos_contract.proto (L282-282)
```text
    int64 missed_time_slots = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L110-110)
```csharp
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-56)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```
