# Audit Report

## Title
DataCentersRankingList Allows Negative Vote Amounts via Quit-Reannounce-Withdraw Sequence

## Summary
The Election Contract contains a critical state desynchronization vulnerability where candidates who quit election and then re-announce can have negative vote amounts in the DataCentersRankingList. This occurs because QuitElection preserves CandidateVotes while removing the ranking list entry, re-announcing resets the ranking value to 0, and subsequent voter withdrawals create negative values that corrupt ranking logic and subsidy distribution.

## Finding Description

The vulnerability exploits an incorrect assumption that DataCentersRankingList and CandidateVotes remain synchronized through the quit-reannounce lifecycle.

**Step 1: QuitElection preserves CandidateVotes**

When a candidate quits election, their entry in DataCentersRankingList is set to 0 and then removed, but `State.CandidateVotes[pubkey]` is never cleared - it retains all vote records and amounts from before quitting. [1](#0-0)  The candidate is marked as `IsCurrentCandidate = false` [2](#0-1)  but their vote data persists in state.

**Step 2: Re-announcing adds back with value 0**

When re-announcing, the candidate is added back to DataCentersRankingList with a hardcoded value of 0, completely ignoring the fact that `State.CandidateVotes[pubkey]` still contains the original vote amounts. [3](#0-2)  The re-announce logic sets `IsCurrentCandidate = true` while preserving historical CandidateInformation. [4](#0-3) 

**Step 3: Withdraw subtracts from ranking list creating negative values**

When voters withdraw after the candidate has re-announced, the withdrawal unconditionally subtracts from the DataCentersRankingList value (currently 0), creating negative values. [5](#0-4)  There is no check that prevents withdrawal from a candidate who previously quit and re-announced, and no validation that the subtraction result must be non-negative.

**Step 4: SafeMath.Sub permits negative results within type bounds**

The `checked` block in SafeMath.Sub only prevents overflow beyond `long`'s range (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807). [6](#0-5)  The operation `0L - 1000L = -1000L` is perfectly valid for signed integers and does NOT throw an exception.

**Step 5: Negative values break ranking logic**

The ranking comparison logic treats negative values as legitimately "less than" positive values. In `UpdateDataCenterAfterMemberVoteAmountChanged`, the comparison checks if any candidate has fewer votes than the target member. [7](#0-6)  In `TryToBecomeAValidationDataCenter`, candidates are ordered by vote amount ascending, so negative values are selected first as the minimum. [8](#0-7)  Similarly in `CandidateReplaceMemberInDataCenter`, negative-valued candidates become prime targets for removal. [9](#0-8) 

**Step 6: DataCenterRankingList type permits negative values**

The protobuf definition uses `int64` (signed), which allows negative values without type-level enforcement of non-negativity. [10](#0-9) 

## Impact Explanation

**Critical Protocol Invariant Violated**: The election system assumes vote amounts are non-negative, as voting inherently represents accumulation of support. Negative vote amounts are mathematically and semantically invalid.

**Concrete Impacts**:

1. **Ranking Corruption**: Candidates with negative values are incorrectly sorted below all legitimate candidates in ranking operations, regardless of their actual voter support in CandidateVotes.

2. **Subsidy Misallocation**: The DataCentersRankingList determines BackupSubsidy profit scheme beneficiaries (5% of mining rewards). [11](#0-10)  Candidates with negative values lose subsidy access unfairly despite having legitimate votes.

3. **Unfair Replacement**: New candidates can incorrectly replace candidates with negative values even when those candidates have legitimate outstanding votes in CandidateVotes, breaking the merit-based selection mechanism.

4. **Election Integrity**: Voters who legitimately voted for a candidate find their voting power nullified or inverted when the candidate undergoes quit-reannounce, fundamentally breaking trust in the election mechanism.

**Severity: HIGH** - This breaks a core invariant of the voting system, enables ranking manipulation, affects economic rewards distribution tied to consensus, and can occur through both accidental operational patterns and deliberate exploitation.

## Likelihood Explanation

**Attack Complexity: LOW** - Requires only standard public operations available to any candidate and voters:
- Announce election (public method)
- Vote (public method)  
- Quit election (requires candidate admin authorization, but normal operation)
- Re-announce (public method)
- Withdraw votes after lock period (standard public operation)

**Feasible Preconditions**:
1. Candidate announces and gets added to ranking list (space available in top N*5 slots)
2. Voters vote for candidate
3. Candidate quits - valid as long as not a current miner [12](#0-11) 
4. Candidate re-announces (space available)
5. Voters withdraw after lock time expires (standard operation with time check only) [13](#0-12) 

**Realistic Scenarios**:

- **Accidental**: Candidate experiences downtime/technical issues, quits temporarily, resolves issues and re-announces. Original voters naturally withdraw when lock periods expire, inadvertently creating negative values.

- **Malicious**: Candidate admin intentionally exploits the quit-reannounce sequence to manipulate their ranking position or grief competitors by forcing themselves into negative territory.

- **Griefing**: Attacker votes for candidates they control, forces quit-reannounce cycles, then withdraws to assign negative votes and corrupt the ranking system.

**No Detection or Prevention**: The negative value persists in contract state and affects all subsequent ranking operations. There is no validation, automatic correction, or monitoring to detect or prevent this state.

**Probability: MEDIUM-HIGH** - Can occur through normal operational flows (candidate lifecycle management) or deliberate manipulation with no special privileges required beyond candidate admin access, which is a standard operational role.

## Recommendation

Implement state synchronization and validation at multiple checkpoints:

1. **In QuitElection**: Clear or mark CandidateVotes as inactive when candidate quits to prevent stale vote data from persisting through re-announce cycles.

2. **In AnnounceElection (re-announce case)**: When re-adding a candidate who previously quit, set DataCentersRankingList value based on current active CandidateVotes instead of hardcoded 0.

3. **In Withdraw**: Add validation to ensure DataCentersRankingList value cannot go negative. Reject withdrawal or cap at 0 if subtraction would result in negative value.

4. **Type-level protection**: Consider using `uint64` instead of `int64` in DataCenterRankingList protobuf definition to enforce non-negativity at the type level, or add explicit assertion checks after all arithmetic operations that modify ranking values.

Example fix for Withdraw method:
```csharp
if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
var currentValue = rankingList.DataCenters[newestPubkey];
var newValue = currentValue >= votingRecord.Amount ? currentValue.Sub(votingRecord.Amount) : 0;
rankingList.DataCenters[newestPubkey] = newValue;
// Add assertion: Assert(rankingList.DataCenters[newestPubkey] >= 0, "Ranking value cannot be negative");
```

## Proof of Concept

```csharp
[Fact]
public async Task NegativeVoteAmount_Via_QuitReannounceWithdraw_Test()
{
    // Step 1: Announce election and get votes
    var candidateKeyPair = ValidationDataCenterKeyPairs.First();
    var voterKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    
    await AnnounceElectionAsync(candidateKeyPair);
    
    // Step 2: Vote for candidate
    const long voteAmount = 10_000;
    var voteId = await VoteToCandidate(voterKeyPair, candidateKeyPair.PublicKey.ToHex(), 
        voteAmount, 100);
    
    // Verify candidate is in DataCentersRankingList with positive value
    var rankingListBefore = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
    rankingListBefore.DataCenters[candidateKeyPair.PublicKey.ToHex()].ShouldBe(voteAmount);
    
    // Step 3: Candidate quits election
    await QuitElectionAsync(candidateKeyPair);
    
    // Step 4: Candidate re-announces
    await AnnounceElectionAsync(candidateKeyPair);
    
    // Verify candidate re-added with value 0
    var rankingListAfterReannounce = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
    rankingListAfterReannounce.DataCenters[candidateKeyPair.PublicKey.ToHex()].ShouldBe(0);
    
    // Step 5: Advance time past lock period and withdraw
    await AdvanceTimePastLockPeriod(100);
    await WithdrawVotes(voterKeyPair, voteId);
    
    // Step 6: Verify negative value created
    var rankingListFinal = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
    var finalValue = rankingListFinal.DataCenters[candidateKeyPair.PublicKey.ToHex()];
    
    // BUG: This should never be negative but is -10000
    finalValue.ShouldBeLessThan(0); // Proves vulnerability
    finalValue.ShouldBe(-voteAmount); // Exact negative value matches withdrawn amount
}
```

## Notes

This vulnerability represents a fundamental state management flaw where the contract fails to maintain consistency between two related state variables (DataCentersRankingList and CandidateVotes) across the candidate lifecycle. The core issue is that QuitElection creates a "zombie" state where CandidateVotes persist while the candidate is removed from rankings, and re-announcing does not reconcile this inconsistency. The use of signed integers (`int64`) without validation further enables the negative value corruption.

The impact extends beyond just incorrect ranking to affect real economic outcomes through BackupSubsidy distribution, making this a high-severity issue affecting both protocol correctness and economic security.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L112-116)
```csharp
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L154-161)
```csharp
        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-279)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L292-296)
```csharp
        if (State.AEDPoSContract.Value != null)
            Assert(
                !State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
                    .Contains(publicKeyByteString),
                "Current miners cannot quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L475-481)
```csharp
        foreach (var pubkeyToVotesAmount in rankingList.DataCenters.OrderBy(x => x.Value))
            if (pubkeyToVotesAmount.Value < minimumVotes)
            {
                replaceWillHappen = true;
                minimumVotesCandidate = pubkeyToVotesAmount.Key;
                break;
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L633-636)
```csharp
        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L671-676)
```csharp
        var rankingList = State.DataCentersRankingList.Value;
        if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
        rankingList.DataCenters[newestPubkey] =
            rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
        UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
        State.DataCentersRankingList.Value = rankingList;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L685-689)
```csharp
        var amountAfterWithdraw = rankingList.DataCenters[targetMember];
        if (isForceReplace)
            Assert(amountAfterWithdraw == 0, "should update vote amount in data center firstly");
        else if (rankingList.DataCenters.Any(x => x.Value < amountAfterWithdraw))
            return;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L740-745)
```csharp
        var list = dateCenter.ToList();
        var minimumVoteCandidateInDataCenter = list.OrderBy(x => x.Value).First();
        if (voteAmount <= minimumVoteCandidateInDataCenter.Value) return;
        dateCenter.Remove(minimumVoteCandidateInDataCenter.Key);
        dateCenter[candidate] = voteAmount;
        NotifyProfitReplaceCandidateInDataCenter(minimumVoteCandidateInDataCenter.Key, candidate);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-794)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** protobuf/election_contract.proto (L460-463)
```text
message DataCenterRankingList {
    // The top n * 5 candidates with vote amount, candidate public key -> vote amount.
    map<string, int64> data_centers = 1;
}
```
