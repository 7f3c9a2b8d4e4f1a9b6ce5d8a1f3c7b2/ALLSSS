# Audit Report

## Title
Pricing Discrepancy in GetNeededDeposit Due to TotalSupply vs Actual Balance Mismatch

## Summary
The `GetNeededDeposit()` function incorrectly uses `tokenInfo.TotalSupply` as the connector balance for Bancor pricing calculations, while actual `Buy`/`Sell` operations use the converter's real token holdings via `GetSelfBalance()`. When tokens are distributed before enabling the connector, this creates a significant pricing mismatch that results in unexpected trading prices and potential financial losses.

## Finding Description

The TokenConverter contract exhibits an inconsistent balance calculation between deposit initialization and trading operations.

In `GetNeededDeposit()`, the `toConnectorBalance` parameter uses `tokenInfo.TotalSupply` for Bancor pricing calculations. [1](#0-0)  The function calculates tokens outside the converter but still uses total supply for the balance parameter in the Bancor formula. [2](#0-1) 

However, in actual trading operations, `GetSelfBalance()` is used to determine connector balances. For resource tokens (non-deposit accounts), this returns only the actual balance held by the converter contract. [3](#0-2) 

The `Buy` operation uses these actual balances for Bancor pricing. [4](#0-3) 

Similarly, the `Sell` operation uses the actual balances. [5](#0-4) 

**Execution Flow:**
1. Token created with TotalSupply = 1,000,000
2. 900,000 tokens distributed to users (staked/locked/held)
3. `EnableConnector` called with AmountToTokenConvert = 100,000
4. `GetNeededDeposit` calculates deposit using TotalSupply = 1,000,000 as the balance parameter
5. Connector is enabled with 100,000 tokens actually deposited
6. `Buy`/`Sell` operations price based on actual balance = 100,000
7. Result: 10x discrepancy in the balance parameter used for pricing

## Impact Explanation

**Medium Severity - Financial Loss Through Pricing Inaccuracy**

The Bancor formula used for pricing is highly sensitive to connector balance values. [6](#0-5) 

When the `toConnectorBalance` used in deposit calculation is significantly different from what's used in actual trading:

1. **Incorrect Prices**: The formula produces drastically different results when the balance parameter varies by 10x
2. **User Financial Loss**: Buyers pay more than expected based on initial deposit calculations because smaller balance values increase the price ratio in the formula
3. **Reserve Miscalculation**: The initial deposit may be insufficient to support the actual price curve that results from the lower balance
4. **Economic Instability**: The converter's economic model breaks down when pricing assumptions don't match reality

For example, with TotalSupply = 1M but only 100K actually in the converter, users expecting prices based on 1M supply face significantly higher costs due to the 100K actual balance being used in trading.

## Likelihood Explanation

**High Likelihood - Standard Operational Pattern**

This vulnerability triggers naturally in common token deployment workflows:

1. **Resource Token Distribution**: Tokens like CPU, RAM, or governance tokens are often issued and distributed before trading begins
2. **Staking/Locking Scenarios**: Users may stake or lock tokens before the converter is enabled, reducing available supply in the converter
3. **Phased Rollout**: Projects commonly distribute tokens first for utility purposes, then enable trading later
4. **No Special Privileges Required**: Any token creator following standard practices encounters this issue

The scenario requires no attacker capabilities - it occurs through normal operations when:
- Tokens have pre-existing utility (staking, governance)
- Distribution happens before trading activation
- Not all issued tokens are deposited into the converter

This is demonstrated in test scenarios where tokens are issued before connector enablement. [7](#0-6) 

## Recommendation

Modify `GetNeededDeposit()` to use the actual balance that will be in the converter after enabling, rather than TotalSupply. The calculation should use `input.AmountToTokenConvert` (plus any existing balance) as the `toConnectorBalance` parameter instead of `tokenInfo.TotalSupply`.

```csharp
// In GetNeededDeposit, replace line 78-80 with:
var tb = toConnector.IsVirtualBalanceEnabled
    ? toConnector.VirtualBalance.Add(balance).Add(input.AmountToTokenConvert)
    : balance.Add(input.AmountToTokenConvert);
```

This ensures the deposit calculation uses the same balance that will be used during actual trading operations, maintaining pricing consistency.

## Proof of Concept

```csharp
[Fact]
public async Task PricingDiscrepancy_TotalSupplyVsActualBalance_Test()
{
    await DefaultStub.Initialize.SendAsync(new InitializeInput
    {
        FeeRate = "0.005"
    });
    
    var tokenSymbol = "DISC";
    var totalSupply = 1_000_000_00000000;
    
    // Create token with large total supply
    await CreateTokenAsync(tokenSymbol, totalSupply);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Issue only 10% to user who will enable connector
    var amountToDeposit = 100_000_00000000;
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = amountToDeposit,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    // GetNeededDeposit calculates using TotalSupply = 1M
    var toBeBuildConnectorInfo = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = amountToDeposit
    };
    var depositInfo = await DefaultStub.GetNeededDeposit.CallAsync(toBeBuildConnectorInfo);
    
    // Enable connector
    await DefaultStub.EnableConnector.SendAsync(toBeBuildConnectorInfo);
    
    // Now check actual price using Buy - it uses actual balance = 100K
    var buyAmount = 1000_00000000;
    
    // Calculate expected price based on TotalSupply (what GetNeededDeposit used)
    var expectedPriceWithTotalSupply = BancorHelper.GetAmountToPayFromReturn(
        depositInfo.NeedAmount, 0.05m, totalSupply, 0.05m, buyAmount);
    
    // Get actual price from Buy operation (uses actual balance)
    var balanceBeforeBuy = await GetBalanceAsync(NativeSymbol, DefaultSender);
    await DefaultStub.Buy.SendAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = buyAmount
    });
    var balanceAfterBuy = await GetBalanceAsync(NativeSymbol, DefaultSender);
    var actualPrice = balanceBeforeBuy - balanceAfterBuy;
    
    // Demonstrate discrepancy: actualPrice != expectedPriceWithTotalSupply
    // With 10x difference in balance, prices diverge significantly
    actualPrice.ShouldNotBe(expectedPriceWithTotalSupply);
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L78-80)
```csharp
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-171)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L383-399)
```csharp
        var tokenSymbol = "NETT";
        await CreateTokenAsync(tokenSymbol);
        await AddPairConnectorAsync(tokenSymbol);
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Amount = 99_9999_0000,
            To = DefaultSender,
            Symbol = tokenSymbol
        });
        var toBeBuildConnectorInfo = new ToBeConnectedTokenInfo
        {
            TokenSymbol = tokenSymbol,
            AmountToTokenConvert = 99_9999_0000
        };
        var deposit = await DefaultStub.GetNeededDeposit.CallAsync(toBeBuildConnectorInfo);
        deposit.NeedAmount.ShouldBe(100);
        await DefaultStub.EnableConnector.SendAsync(toBeBuildConnectorInfo);
```
