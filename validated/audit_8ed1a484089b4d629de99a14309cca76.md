# Audit Report

## Title
Missing Bounds Validation on FinalOrderOfNextRound Allows Mining Schedule Disruption

## Summary
The `ProcessUpdateValue` method in the AEDPoS consensus contract accepts user-supplied `SupposedOrderOfNextRound` and `TuneOrderInformation` values without validating they are within the valid range [1, minersCount]. A malicious miner can submit out-of-bounds order values that propagate to the next round's mining schedule, causing incorrect `ExpectedMiningTime` calculations and disrupting consensus operations.

## Finding Description

The vulnerability exists in the consensus update flow where order values lack bounds validation:

**Root Cause:** In `ProcessUpdateValue`, the method directly assigns user-supplied order values from `UpdateValueInput` without any bounds checking: [1](#0-0) [2](#0-1) 

These unchecked values become the `FinalOrderOfNextRound` for miners, which is later used to set the `Order` field when generating the next round: [3](#0-2) 

The `Order` field directly determines `ExpectedMiningTime` through multiplication with `miningInterval`, without any bounds enforcement.

**Why Existing Protections Fail:**

1. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` fields, not order values: [4](#0-3) 

2. The `NextRoundMiningOrderValidationProvider` validates that the count of miners with `FinalOrderOfNextRound > 0` equals miners who mined, but does NOT validate that values are within [1, minersCount]: [5](#0-4) 

3. While `ApplyNormalConsensusData` correctly calculates bounded order values using modulus arithmetic, this is only called during block generation on the client side: [6](#0-5) 

4. During validation, `RecoverFromUpdateValue` recovers order values from block header without bounds checking: [7](#0-6) 

**Execution Path:**
1. Malicious miner produces block during their time slot
2. Calls `UpdateValue` with crafted `UpdateValueInput` containing out-of-bounds order values (e.g., 1000, 2000)
3. `ProcessConsensusInformation` invokes `ProcessUpdateValue`
4. Invalid order values stored in state without validation
5. Later, when `NextRound` is triggered, `GenerateNextRoundInformation` uses these invalid values to set `Order` and calculate `ExpectedMiningTime`
6. Mining schedule breaks due to invalid time calculations

## Impact Explanation

**Consensus Disruption:**
- Invalid `Order` values (e.g., 1000 when `minersCount` is 7) cause `ExpectedMiningTime` to be calculated as `currentBlockTimestamp + (4000ms × 1000) = 4,000,000ms` (66+ minutes in the future)
- Affected miners cannot mine at their time slots, effectively excluding them from consensus
- Time slot validation fails for subsequent blocks from affected miners

**Critical Logic Failures:**

The `BreakContinuousMining` method attempts to find miners with specific `Order` values (1, 2, minersCount, minersCount-1), which fail when orders are out of bounds: [8](#0-7) [9](#0-8) 

The `First()` method will throw an exception if no miner has the expected order, causing the entire round generation to fail.

**Attack Amplification:**
Through `TuneOrderInformation`, a single malicious miner can set out-of-bounds `FinalOrderOfNextRound` values for *other* miners, multiplying the impact across the entire miner set.

**Severity:** HIGH - Direct disruption of consensus mechanism, denial of service to mining operations, exploitable by single compromised miner with ability to affect entire network.

## Likelihood Explanation

**Attacker Capabilities:** Any miner in the active miner list can exploit this vulnerability. Miners have legitimate access to produce blocks and submit `UpdateValue` transactions during their time slots.

**Attack Complexity:** Low. The attacker simply needs to:
1. Modify their block producer client to submit custom `UpdateValueInput` values
2. Set `SupposedOrderOfNextRound` to an arbitrary int32 value (e.g., 1000, 10000)
3. Optionally populate `TuneOrderInformation` to affect other miners
4. Include matching values in block header extra data

**Feasibility Conditions:**
- Attacker must be an active miner (realistic given election process)
- No special permissions beyond normal mining rights required
- Attack executes during attacker's regular time slot
- No economic cost beyond normal block production

**Detection:** Difficult to detect proactively since validation passes with malformed values and impact only manifests in next round generation.

**Probability:** HIGH - Low barrier to entry, single compromised miner sufficient, immediate impact on next round.

## Recommendation

Add bounds validation in `ProcessUpdateValue` to ensure order values are within the valid range:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate SupposedOrderOfNextRound is within bounds
    Assert(updateValueInput.SupposedOrderOfNextRound > 0 && 
           updateValueInput.SupposedOrderOfNextRound <= minersCount,
           "Invalid SupposedOrderOfNextRound value.");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
    minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
    
    // Validate TuneOrderInformation values are within bounds
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount,
               "Invalid TuneOrderInformation value.");
        currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
    }
    
    // ... rest of the method
}
```

Additionally, add validation in `UpdateValueValidationProvider` to check order values during validation phase.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a consensus round with 7 miners
2. Having a malicious miner submit an `UpdateValue` with `SupposedOrderOfNextRound = 1000`
3. Observing that the value is accepted without validation
4. When `NextRound` is called, the next round generation will use this invalid order
5. The affected miner's `ExpectedMiningTime` will be calculated as currentTime + (4000ms × 1000), placing their slot over an hour in the future
6. The `BreakContinuousMining` logic will fail when trying to find miners with orders 1, 2, 6, or 7 if none exist due to out-of-bounds values

The test would verify that:
- `ProcessUpdateValue` accepts out-of-bounds order values
- `GenerateNextRoundInformation` produces invalid `ExpectedMiningTime` values
- Consensus operations fail due to missing expected order values

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-84)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L13-17)
```csharp
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.gs (L94-101)
```text

```
