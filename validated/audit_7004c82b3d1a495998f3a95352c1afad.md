# Audit Report

## Title
Integer Overflow Denial of Service in Round Generation via Unbounded FinalOrderOfNextRound Values

## Summary
A malicious miner can halt consensus indefinitely by setting arbitrary `FinalOrderOfNextRound` values (up to `Int32.MaxValue`) through the `tune_order_information` field in `UpdateValueInput`. This causes an integer overflow during next round generation, triggering an `OverflowException` that prevents any miner from producing the NextRound block.

## Finding Description

The vulnerability exists due to missing bounds validation on `tune_order_information` values in the consensus update flow, combined with overflow-prone arithmetic in round generation.

**Root Cause 1 - Missing Input Validation:**

In `ProcessUpdateValue`, the `tune_order_information` map from user input is applied directly to set `FinalOrderOfNextRound` values without any bounds checking: [1](#0-0) 

The protobuf definition allows any `int32` value in this map: [2](#0-1) 

**Root Cause 2 - Overflow-Prone Arithmetic:**

During next round generation, the unchecked `FinalOrderOfNextRound` value is used in a multiplication that can overflow: [3](#0-2) 

The `GetMiningInterval()` method returns an `int` (typically 4000 milliseconds for single miner, or time difference between first two miners): [4](#0-3) 

**Why SafeMath Protection Fails:**

The `Mul()` extension method uses checked arithmetic that throws `OverflowException` on overflow: [5](#0-4) 

While this prevents silent overflow, the exception causes consensus disruption rather than graceful handling.

**Insufficient Validation:**

The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are filled, and checks `PreviousInValue` consistency. It does NOT validate `tune_order_information` bounds: [6](#0-5) 

The `NextRoundMiningOrderValidationProvider` only checks count consistency, not value bounds: [7](#0-6) 

**Attack Execution Path:**

Round generation is called during consensus extra data preparation for the next round: [8](#0-7) 

The normal flow ensures `FinalOrderOfNextRound` stays within `[1, minersCount]` through the `ApplyNormalConsensusData` conflict resolution: [9](#0-8) 

However, `ProcessUpdateValue` bypasses this by directly overwriting values from `tune_order_information`, allowing an attacker to set `Int32.MaxValue`.

## Impact Explanation

**Consensus Denial of Service:**

When `FinalOrderOfNextRound` is set to `Int32.MaxValue` (2,147,483,647) and `miningInterval` is 4000, the calculation `4000 * 2,147,483,647 = 8,589,934,588,000` exceeds `Int32.MaxValue` (2,147,483,647). The `OverflowException` causes the `GenerateNextRoundInformation` call to fail during `GetConsensusExtraDataForNextRound`, preventing any miner from producing the NextRound block.

**Protocol-Wide Impact:**
- Consensus completely halts - no blocks can be produced for the next round
- All miners attempting to transition to the next round will fail with the same overflow exception
- Requires manual intervention, coordinated rollback, or chain restart to recover
- Affects the entire blockchain network, not just individual miners
- All transactions pending and future transactions cannot be processed

**Severity Justification:**

This is a **High severity** vulnerability because:
1. Complete consensus halt affects all network operations with no automatic recovery
2. Attack is trivial for any current miner to execute with a single transaction
3. No special permissions beyond being in the current miner set required
4. Persistent DoS - not a temporary revert but ongoing inability to produce blocks
5. Recovery requires manual intervention and coordination among network operators

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a current miner (member of the consensus round)
- Can produce at least one block in the current round
- No additional permissions or special access required beyond miner status

**Attack Complexity:**
- **Very Low**: Single `UpdateValue` transaction with crafted `UpdateValueInput`
- Simply set `tune_order_information[<any_miner_pubkey>] = Int32.MaxValue`
- No timing requirements, race conditions, or complex setup
- Deterministic outcome - overflow will always occur on next round generation

**Feasibility Conditions:**
- Attacker is in the active miner set (realistic - multiple miners exist)
- No economic barriers - attack cost is just one block production
- Can target any miner's order value, not just their own
- Attack persists until manual intervention

**Detection Constraints:**
- Attack is visible on-chain in the `UpdateValue` transaction
- However, damage occurs when next round generation is attempted
- By the time overflow is detected, consensus is already compromised

**Probability Assessment:**
- **High Likelihood**: Any malicious or compromised miner can execute this attack
- Multiple miners means multiple potential attack vectors
- Accidental triggering is unlikely (requires intentional extreme values)
- Could be used for griefing, ransom, or competitive attack

## Recommendation

Add bounds validation for `tune_order_information` values in `ProcessUpdateValue`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // ... existing code ...
    
    // Validate tune_order_information bounds before applying
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
            $"Invalid FinalOrderOfNextRound: {tuneOrder.Value}. Must be between 1 and {minersCount}.");
        currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
    }
    
    // ... rest of existing code ...
}
```

Alternatively, add validation in `UpdateValueValidationProvider`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    // Existing validations...
    
    if (!ValidateTuneOrderInformation(validationContext))
        return new ValidationResult { Message = "Invalid tune_order_information bounds." };
    
    return new ValidationResult { Success = true };
}

private bool ValidateTuneOrderInformation(ConsensusValidationContext validationContext)
{
    var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
    var extraData = validationContext.ExtraData;
    
    // Extract tune_order_information from UpdateValueInput in extraData
    // and verify all values are in range [1, minersCount]
    
    return true; // if all values are valid
}
```

## Proof of Concept

```csharp
[Fact]
public async Task IntegerOverflow_InRoundGeneration_HaltsConsensus()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = GenerateInitialMiners(3);
    await InitializeConsensus(initialMiners);
    
    // Attacker is current miner
    var attackerKeyPair = initialMiners[0];
    
    // Step 1: Attacker produces a normal block first
    await ProduceNormalBlock(attackerKeyPair);
    
    // Step 2: Craft malicious UpdateValueInput with unbounded tune_order_information
    var maliciousInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = HashHelper.ComputeFrom("signature"),
        PreviousInValue = Hash.Empty,
        RoundId = GetCurrentRoundNumber(),
        ActualMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            // Set victim miner's FinalOrderOfNextRound to Int32.MaxValue
            { initialMiners[1].PublicKey.ToHex(), int.MaxValue }
        },
        ImpliedIrreversibleBlockHeight = 1,
        RandomNumber = ByteString.CopyFrom(new byte[32])
    };
    
    // Step 3: Submit malicious UpdateValue - this succeeds
    var updateResult = await ConsensusStub.UpdateValue.SendAsync(maliciousInput);
    updateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Attempt to generate next round - this should fail with OverflowException
    var nextRoundMiner = initialMiners[1];
    
    // When the next round miner tries to get consensus extra data for NextRound behavior
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(nextRoundMiner.PublicKey),
        Behaviour = AElfConsensusBehaviour.NextRound,
        RandomNumber = ByteString.CopyFrom(new byte[32])
    };
    
    // This call should throw OverflowException due to miningInterval.Mul(Int32.MaxValue)
    Should.Throw<OverflowException>(() => 
    {
        var extraData = ConsensusStub.GetConsensusExtraData.Call(triggerInfo.ToBytesValue());
    });
    
    // Verify consensus is halted - no miner can produce NextRound block
    foreach (var miner in initialMiners)
    {
        triggerInfo.Pubkey = ByteString.CopyFrom(miner.PublicKey);
        Should.Throw<OverflowException>(() => 
        {
            ConsensusStub.GetConsensusExtraData.Call(triggerInfo.ToBytesValue());
        });
    }
}
```

## Notes

This vulnerability represents a critical consensus availability issue where the checked arithmetic that was intended as a safety measure (preventing silent overflow) instead becomes an attack vector when combined with missing input validation. The attack is particularly severe because it affects all miners attempting to transition to the next round, creating a persistent denial-of-service condition that requires manual intervention to resolve.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L13-19)
```csharp
    public static int Mul(this int a, int b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-45)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

```
