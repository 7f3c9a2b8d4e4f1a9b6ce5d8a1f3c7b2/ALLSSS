# Audit Report

## Title
Null Reference Exception in ProfitDetails Retrieval Causes DoS of TokenHolder and Election Contract Functions

## Summary
The Profit contract's `GetProfitDetails` view method returns null for non-existent beneficiaries without defensive handling. Multiple calling contracts (TokenHolder and Election) directly access properties on the returned object without null checks, causing NullReferenceException and transaction failures during normal operations when processing new beneficiaries or voters.

## Finding Description

The Profit contract's `GetProfitDetails` method directly returns the mapped state value without any null handling or validation [1](#0-0) , which returns null when querying a beneficiary that has never been registered in a profit scheme.

The TokenHolder contract's `AddBeneficiary` method calls `GetProfitDetails` and immediately accesses the `.Details` property without checking if the returned object is null [2](#0-1) . When adding a NEW beneficiary (the primary use case), the beneficiary doesn't exist in the profit scheme yet, causing `GetProfitDetails` to return null and the subsequent `detail.Details.Any()` call to throw NullReferenceException.

Similarly, the `RemoveBeneficiary` method chains `.Details.Single()` directly on the `GetProfitDetails` call result without null validation [3](#0-2) , which crashes if the beneficiary doesn't exist or has already been removed.

The Election contract also exhibits this vulnerability in its `GetProfitDetailByElectionVotingRecord` private method, where it accesses `profitDetails.Details.FirstOrDefault()` and `profitDetails.Details.LastOrDefault()` without null checking [4](#0-3) . This method is called during vote option changes [5](#0-4) , causing failures when processing voters who don't have existing profit details in the welfare scheme.

Critically, the Profit contract's own internal methods handle this null case correctly. The private `GetAllProfitsMap` method explicitly checks for null and returns an empty result [6](#0-5) , and the `AddBeneficiary` method handles null by creating a new ProfitDetails instance [7](#0-6) . This confirms that null returns are the expected behavior that all calling contracts should properly handle.

## Impact Explanation

**Operational DoS of Critical Functions:**

The `TokenHolder.AddBeneficiary` function becomes completely non-functional for its primary use case. Since new beneficiaries by definition don't have existing profit details, every attempt to add a first-time beneficiary fails with NullReferenceException before reaching the actual add logic. This breaks the core mechanism for registering users in token holder dividend distribution systems.

The `TokenHolder.RemoveBeneficiary` function fails when called with non-existent beneficiary addresses, preventing cleanup operations and causing accidental DoS scenarios.

The Election contract's `ChangeVotingOption` function fails when voters attempt to extend their welfare profits if they haven't been properly registered in the welfare scheme, disrupting legitimate voting operations.

**Affected Parties:**
- DApp operators cannot onboard new users to profit distribution schemes
- Token holders cannot be registered for rewards or dividends through the TokenHolder contract
- Voters may experience transaction failures when changing voting options
- The entire TokenHolder profit distribution subsystem is unusable for new registrations

**Severity:** Medium - While no funds are directly at risk and existing beneficiaries can still claim profits, the availability of core profit distribution functionality is completely broken for new registrations, preventing the protocol from onboarding new participants to reward schemes.

## Likelihood Explanation

**Reachable Entry Points:**
- `TokenHolder.AddBeneficiary` and `RemoveBeneficiary` are public methods callable by scheme managers [8](#0-7) [9](#0-8) 
- `Election.ChangeVotingOption` is a public method callable by voters [10](#0-9) 
- The `GetValidScheme` helper validates that the caller is an authorized scheme manager [11](#0-10) 

**Trigger Conditions:**
This vulnerability triggers during normal legitimate operations with zero attack complexity:
1. A scheme manager adds the first beneficiary to a new profit scheme
2. A scheme manager adds any beneficiary who hasn't been registered before
3. A scheme manager attempts to remove a beneficiary with an incorrect address
4. A voter changes their voting option when they haven't been added to the welfare scheme

**Probability:** High - This occurs immediately upon any attempt to use the TokenHolder contract for its intended purpose of managing profit distribution to new users. The vulnerability activates during standard protocol usage without any malicious intent required.

## Recommendation

Add null checks before accessing properties on the `GetProfitDetails` return value in all calling contracts:

**For TokenHolder.AddBeneficiary** (lines 40-56):
```csharp
var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    SchemeId = scheme.SchemeId,
    Beneficiary = input.Beneficiary
});
var shares = input.Shares;
if (detail != null && detail.Details.Any())  // Add null check here
{
    // Only keep one detail.
    State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = input.Beneficiary
    });
    shares = shares.Add(detail.Details.Single().Shares);
}
```

**For TokenHolder.RemoveBeneficiary** (lines 74-78):
```csharp
var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    Beneficiary = input.Beneficiary,
    SchemeId = scheme.SchemeId
});
Assert(detail != null && detail.Details.Any(), "Beneficiary not found in scheme.");
var lockedAmount = detail.Details.Single().Shares;
```

**For Election.GetProfitDetailByElectionVotingRecord** (lines 170-177):
```csharp
var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    Beneficiary = electionVotingRecord.Voter,
    SchemeId = State.WelfareHash.Value
});

if (profitDetails == null)
{
    return null;
}

ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
```

## Proof of Concept

```csharp
[Fact]
public async Task AddBeneficiary_NewUser_ShouldNotCrash()
{
    // Setup: Create a token holder profit scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "TEST",
        MinimumLockMinutes = 1
    });
    
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 1000
    });

    // Act: Try to add a NEW beneficiary (who has never been in the profit scheme)
    // This will crash with NullReferenceException at line 46 of TokenHolderContract.cs
    // because GetProfitDetails returns null for new beneficiaries
    var result = await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(), // New user, not in scheme yet
        Shares = 100
    });
    
    // Expected: Should succeed
    // Actual: Transaction fails with NullReferenceException on detail.Details.Any()
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

## Notes

This vulnerability demonstrates a defensive programming failure where the Profit contract correctly handles null internally but exposes a public API that returns null, which calling contracts fail to handle. The issue is exacerbated by the fact that the primary use case (adding new beneficiaries) is the exact scenario that triggers the crash. The existing test suite at lines 101-117 of TokenHolderTests.cs only tests adding beneficiaries after the scheme already has contributions, but doesn't catch the null reference issue because it doesn't verify the intermediate state where `GetProfitDetails` returns null for truly new beneficiaries.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L108-110)
```csharp
        var profitDetails = State.ProfitDetailsMap[schemeId][beneficiary];

        if (profitDetails == null) return new GetAllProfitsMapOutput();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-37)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L40-46)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-70)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L23-23)
```csharp
    public override Empty ChangeVotingOption(ChangeVotingOptionInput input)
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L37-37)
```csharp
            ExtendVoterWelfareProfits(input.VoteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L170-181)
```csharp
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```
