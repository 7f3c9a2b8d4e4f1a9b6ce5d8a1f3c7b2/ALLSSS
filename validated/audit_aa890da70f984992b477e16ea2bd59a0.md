# Audit Report

## Title
Missing TermNumber Validation in NextRound Allows Consensus Time Slot Bypass

## Summary
The AEDPoS consensus contract fails to validate the TermNumber field in NextRoundInput during NextRound processing. A malicious miner can inject an incorrect TermNumber that gets stored in the round state but doesn't update the global CurrentTermNumber, creating a mismatch that causes subsequent blocks to incorrectly bypass time slot validation, breaking consensus schedule integrity.

## Finding Description

The vulnerability exists in the NextRound consensus flow where TermNumber validation is completely omitted, unlike the NextTerm flow which properly validates it.

**Root Cause:**

The `ToRound()` method blindly copies all fields including TermNumber from NextRoundInput to Round without any validation. [1](#0-0) 

The pre-execution validation for NextRound behavior only validates RoundNumber increment and InValue nullity in `ValidationForNextRound`, completely omitting TermNumber validation. [2](#0-1) 

In contrast, `ValidationForNextTerm` properly validates TermNumber by checking that it increments by exactly 1. [3](#0-2) 

**Execution Path:**

ProcessNextRound converts the input using the unvalidated `ToRound()` method and stores it via `AddRoundInformation`. [4](#0-3) 

Critically, ProcessNextRound only updates RoundNumber in state via `TryToUpdateRoundNumber`, NOT TermNumber. [5](#0-4) 

State.CurrentTermNumber is ONLY updated in ProcessNextTerm via `TryToUpdateTermNumber`. [6](#0-5) 

The state variable itself is defined here. [7](#0-6) 

In subsequent blocks, the validation context fetches PreviousRound from State.Rounds (containing the malicious TermNumber) and CurrentTermNumber from State.CurrentTermNumber.Value (unchanged). [8](#0-7) 

The time slot validation checks if it's the first round of a new term by comparing these values. [9](#0-8) 

When this check incorrectly returns true due to the TermNumber mismatch, time slot validation is immediately bypassed. [10](#0-9) 

**Attack Scenario:**

1. Current state: State.CurrentTermNumber = N, State.CurrentRoundNumber = R
2. Attacker (valid miner) crafts NextRoundInput with RoundNumber = R+1 (valid), TermNumber = N+1 (invalid but unchecked)
3. ValidationForNextRound only checks RoundNumber increment and InValues - passes
4. ProcessNextRound stores Round with TermNumber = N+1 in State.Rounds[R+1]
5. State.CurrentTermNumber remains N (unchanged - only ProcessNextTerm updates it)
6. Next block validation fetches PreviousRound with TermNumber = N+1, CurrentTermNumber = N
7. IsFirstRoundOfCurrentTerm: N+1 ≠ N → returns true
8. CheckMinerTimeSlot returns true immediately without checking time slots

## Impact Explanation

This vulnerability breaks the fundamental consensus invariant of time slot validation. The AEDPoS consensus mechanism assigns specific time slots to miners to ensure fair block production and prevent centralization.

**Concrete Impact:**

1. **Time Slot Violation**: Malicious miners can produce blocks outside their assigned time slots, violating the consensus schedule
2. **Unfair Block Rewards**: Attackers gain additional block production opportunities, earning more rewards than legitimately allocated
3. **Centralization Risk**: Reduces decentralization by allowing one miner to dominate block production
4. **State Inconsistency**: Creates divergence between stored Round.TermNumber values and global State.CurrentTermNumber
5. **Consensus Schedule Breakdown**: The carefully designed mining time arrangement becomes meaningless

The severity is **Medium** because while it compromises consensus integrity (a critical invariant), the attacker must be an active miner in the current round, limiting the attack surface to elected/staked participants. However, the impact on fairness and schedule integrity is concrete and significant.

## Likelihood Explanation

**High Likelihood** due to:

1. **Low Attack Complexity**: Attacker simply crafts a NextRoundInput with manipulated TermNumber
2. **Realistic Preconditions**: Only requires being a valid miner, achievable through normal election/staking mechanisms
3. **No Additional Privileges**: Beyond being in the miner list (verified by PreCheck), no special authority needed [11](#0-10) 
4. **No Economic Cost**: Only standard transaction fees required
5. **Immediate Exploitation**: Takes effect in the very next round
6. **Difficult Detection**: The manipulated TermNumber is stored but global state appears correct; subsequent behavior mimics legitimate "first round of term" scenario

Any malicious miner seeking unfair advantage can easily exploit this vulnerability.

## Recommendation

Add TermNumber validation to the `ValidationForNextRound` method, similar to how `ValidationForNextTerm` validates it:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number increment
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // Validate InValues are null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // ADD: Validate TermNumber remains unchanged during NextRound
    if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Term number must not change during NextRound." };
    
    return new ValidationResult { Success = true };
}
```

The fix ensures that NextRound transitions cannot modify TermNumber, as only NextTerm should change term numbers in a controlled, validated manner.

## Proof of Concept

```csharp
[Fact]
public async Task TermNumber_Manipulation_Bypasses_TimeSlot_Validation()
{
    // Setup: Initialize consensus with term 1, round 1
    var initialMiners = await BootMiner();
    var currentRound = await GetCurrentRoundInformation();
    var currentTerm = await GetCurrentTermNumber();
    
    // Attack: Craft malicious NextRoundInput with incremented TermNumber
    var maliciousNextRound = currentRound.GenerateNextRoundInformation(
        Context.CurrentBlockTime, 
        Context.CurrentBlockHeight, 
        initialMiners);
    
    // Manipulate TermNumber to be currentTerm + 1 (should be invalid)
    maliciousNextRound.TermNumber = currentTerm.Add(1);
    
    var maliciousInput = new NextRoundInput();
    maliciousInput.MergeFrom(maliciousNextRound);
    maliciousInput.RandomNumber = GetRandomBytes();
    
    // Execute: Call NextRound with malicious input (should fail but doesn't)
    var result = await ConsensusStub.NextRound.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Check state inconsistency
    var storedRound = await GetRoundInformation(currentRound.RoundNumber.Add(1));
    var globalTermNumber = await GetCurrentTermNumber();
    
    // Malicious TermNumber stored in round state
    storedRound.TermNumber.ShouldBe(currentTerm.Add(1));
    
    // But global CurrentTermNumber unchanged
    globalTermNumber.ShouldBe(currentTerm);
    
    // Exploit: Next block will bypass time slot validation
    // IsFirstRoundOfCurrentTerm will incorrectly return true
    // because storedRound.TermNumber != globalTermNumber
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-174)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L22-22)
```csharp
    public Int64State CurrentTermNumber { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L53-58)
```csharp
    private bool IsFirstRoundOfCurrentTerm(out long termNumber, ConsensusValidationContext validationContext)
    {
        termNumber = validationContext.CurrentTermNumber;
        return validationContext.PreviousRound.TermNumber != termNumber ||
               validationContext.CurrentRoundNumber == 1;
    }
```
