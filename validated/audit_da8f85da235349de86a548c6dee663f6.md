# Audit Report

## Title
Unvalidated ActualMiningTime Allows Miners to Manipulate Consensus Behavior and Gain Block Production Advantages

## Summary
Miners can submit arbitrary `ActualMiningTime` values that are stored in consensus state without validation against `Context.CurrentBlockTime`. This allows malicious miners to inflate tiny block production limits, manipulate term change timing, and gain unfair economic advantages through extra block rewards.

## Finding Description

The AEDPoS consensus contract accepts `ActualMiningTime` timestamps from transaction inputs and stores them directly in state without validating them against the actual block time. This breaks the fundamental consensus invariant that mining timestamps must accurately reflect when blocks were produced.

**Root Cause - Unvalidated Storage:**

In `ProcessUpdateValue`, the input timestamp is directly added to state without any validation: [1](#0-0) 

Similarly in `ProcessTinyBlock`: [2](#0-1) 

While the contract correctly sets `ActualMiningTime = Context.CurrentBlockTime` when generating consensus extra data: [3](#0-2) 

A malicious miner can intercept this transaction generation and modify the `ActualMiningTime` field before including the transaction in their block, since miners have full control over block content.

**Why Existing Protections Fail:**

1. **Hash Validation Excludes ActualMiningTimes**: The validation system explicitly clears `ActualMiningTimes` before computing hashes: [4](#0-3) 

2. **TimeSlotValidationProvider Checks Previous State Only**: This validator only examines the latest `ActualMiningTime` from the base round (previous state), not the new timestamp being submitted: [5](#0-4) 

3. **UpdateValueValidationProvider Ignores Timestamps**: This provider only validates `OutValue`, `Signature`, and `PreviousInValue` fields: [6](#0-5) 

4. **After-Execution Validation Cannot Detect**: The post-execution validation compares round hashes which explicitly exclude `ActualMiningTimes`: [7](#0-6) 

**Attack Execution Path:**
1. Miner receives consensus command with correct timestamp from `GenerateConsensusTransactions`
2. Miner modifies the `UpdateValueInput.ActualMiningTime` or `TinyBlockInput.ActualMiningTime` to a false value (e.g., timestamp before round start)
3. Miner includes the modified transaction in their block
4. Block validation passes because all validators check previous state or exclude timestamps from hashing
5. False timestamp is permanently stored in `minerInRound.ActualMiningTimes`
6. Subsequent consensus decisions use the manipulated timestamps

## Impact Explanation

**Direct Consensus Integrity Impacts:**

1. **Extra Tiny Block Production**: The `TinyBlockCommandStrategy` calculates block production limits using: [8](#0-7) 

By reporting `ActualMiningTimes` before the round start time, a miner artificially inflates `blocksBeforeCurrentRound`, allowing production of `_maximumBlocksCount + blocksBeforeCurrentRound` tiny blocks instead of the intended limit. With unlimited historical timestamps, this removes the tiny block production cap entirely.

2. **Term Change Timing Manipulation**: The `NeedToChangeTerm` method uses the latest `ActualMiningTime` from each miner to determine when terms should change: [9](#0-8) 

False timestamps can delay or accelerate term changes, directly affecting miner rotation and election outcomes.

3. **Mining Order Calculation Manipulation**: First round mining order depends on the first miner's `ActualMiningTimes`: [10](#0-9) 

False initial timestamps affect time slot calculations for all miners in round 1, potentially allowing miners to claim mining rights out of turn.

**Quantified Economic Impact:**
- Each extra tiny block produces 1 additional mining reward
- Normal maximum: 8 tiny blocks per time slot  
- With manipulation: unlimited extra blocks via historical timestamp injection
- Direct financial gain proportional to extra blocks produced
- Honest miners disadvantaged through unfair competition
- Consensus integrity compromised through arbitrary timestamp injection

## Likelihood Explanation

**Attacker Capabilities:** Any valid miner in the current miner list can execute this attack. Miners have full control over transaction parameters when producing blocks and can craft `UpdateValueInput` or `TinyBlockInput` with arbitrary `ActualMiningTime` values. The methods `UpdateValue` and `UpdateTinyBlockInformation` are public entry points: [11](#0-10) 

**Attack Complexity:** LOW - This requires only simple parameter modification with no cryptographic challenges, complex constraints to bypass, or coordination with other miners. The miner simply modifies a timestamp field in the transaction before including it in their block.

**Detection Difficulty:** The validation system explicitly excludes `ActualMiningTimes` from hash verification. No events or logs track timestamp discrepancies. Detection would require off-chain monitoring comparing `Context.CurrentBlockTime` to reported values, making forensic analysis difficult as historical timestamps accumulate in state.

**Economic Rationality:** Highly rational for malicious miners - extra block production directly increases mining rewards with minimal cost (no additional computational work beyond normal block production) and no observable on-chain detection mechanism.

## Recommendation

Add validation in `ProcessUpdateValue` and `ProcessTinyBlock` to verify that submitted timestamps match the current block time:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Validate ActualMiningTime matches current block time
    Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime,
        "ActualMiningTime must equal Context.CurrentBlockTime");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of method
}
```

Apply the same validation in `ProcessTinyBlock`. This ensures that only accurate timestamps reflecting actual block production times are stored in consensus state.

## Proof of Concept

A malicious miner can create a test demonstrating the vulnerability:

1. Call `UpdateValue` with `ActualMiningTime` set to a timestamp before the current round start time
2. Observe that the transaction succeeds and the false timestamp is stored in state
3. Verify that subsequent calls to `TinyBlockCommandStrategy.IsLastTinyBlockOfCurrentSlot()` calculate an inflated `blocksBeforeCurrentRound` value
4. Demonstrate that the miner can now produce more tiny blocks than the normal `_maximumBlocksCount` limit

The vulnerability is confirmed by the lack of any validation comparing `updateValueInput.ActualMiningTime` against `Context.CurrentBlockTime` in the processing logic, combined with the explicit exclusion of `ActualMiningTimes` from all hash-based validation checks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L92-98)
```csharp
        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L193-193)
```csharp
            checkableMinerInRound.ActualMiningTimes.Clear();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L218-223)
```csharp
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L40-41)
```csharp
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L28-33)
```csharp
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L61-62)
```csharp
            var blocksBeforeCurrentRound = MinerInRound.ActualMiningTimes.Count(t => t < roundStartTime);
            return producedBlocksOfCurrentRound == blocksBeforeCurrentRound.Add(_maximumBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
