# Audit Report

## Title
Missing Input Size Validation in SetTransactionFeeDelegations Enables Resource Exhaustion Attack

## Summary
The `SetTransactionFeeDelegations()` function in the MultiToken contract lacks validation on the number of token symbols in the input delegations map, allowing attackers to submit transactions with thousands of entries that cause excessive state reads, exceed the 128KB state size limit, and result in transaction failures after fees are already charged and committed.

## Finding Description

The `SetTransactionFeeDelegations()` function accepts unbounded delegation maps without validating the entry count. [1](#0-0) 

The function performs multiple O(n) iterations over all delegation entries. For new delegatees, it iterates through all input delegations calling `AssertValidToken()` for each positive-value entry: [2](#0-1)  For existing delegatees, it again iterates through all input delegations with the same validation: [3](#0-2) 

Each `AssertValidToken()` call triggers a state read via `GetTokenInfo()`: [4](#0-3)  which reads from contract state: [5](#0-4) 

The final state write stores the entire `TransactionFeeDelegatees` object which can exceed the enforced 128KB state size limit: [6](#0-5)  and [7](#0-6) 

The state size limit is enforced at 128KB: [8](#0-7) 

When this limit is exceeded, `ValidateStateSize` throws `StateOverSizeException`: [9](#0-8) 

**Root Cause Pattern Violation**: The codebase establishes a security pattern in `BatchApprove` which validates input collection size: [10](#0-9)  with a configurable maximum limit retrieved from state or default constant: [11](#0-10) 

However, `SetTransactionFeeDelegations()` has no corresponding validation, violating this established pattern. The existing `DELEGATEE_MAX_COUNT` constant: [12](#0-11)  only limits the number of delegatees per delegator (24), not the number of token symbols per delegation: [13](#0-12) 

The protobuf definition confirms the delegations field is an unbounded map: [14](#0-13) 

## Impact Explanation

**Financial Impact - Failed Transactions with Non-Refunded Fees:**

Transaction fees are charged via pre-execution plugin BEFORE the main transaction executes: [15](#0-14) 

The pre-execution plugin commits fee charging state changes even when the main transaction will fail: [16](#0-15) 

When the main transaction fails, only PreTraces and PostTraces state changes are committed to the block state cache, NOT the main transaction's changes: [17](#0-16) 

This behavior is confirmed in test cases where transactions fail but fees are still fully charged: [18](#0-17) 

**Operational Impact - Resource Exhaustion:**
- An attacker can construct transactions with 5,000-10,000+ token symbols
- Each token symbol triggers a `GetTokenInfo()` state read, causing thousands of state reads per transaction
- Multiple O(n) iterations compound the computational cost
- Block processing delays occur as nodes execute these expensive operations

**DoS Impact:**
When the serialized `TransactionFeeDelegatees` object exceeds 128KB (approximately 5,000-5,500 token symbols), the state validation throws `StateOverSizeException`, but fees are already committed. Users lose transaction fees for processing that ultimately fails.

**Severity Justification - Medium:**
- No direct fund theft from balances or unauthorized privilege escalation (not High)
- Clear operational disruption, financial waste through failed fee-charged transactions, and violation of established security patterns (not Low)
- Measurable impact on network performance and user experience

## Likelihood Explanation

**Reachable Entry Point:**
The function is a public RPC method accessible to any address without permission requirements: [19](#0-18) 

**Attacker Capabilities:**
- No special permissions, governance approval, or privileged roles required
- Only needs knowledge of existing token symbols, which are publicly queryable on-chain
- Can be fully automated with scripts

**Attack Complexity:**
- Low complexity: construct a `SetTransactionFeeDelegationsInput` with thousands of token symbols
- Example attack: Query token symbols from blockchain, create map with 6,000 entries, submit transaction
- Transaction is accepted into mempool (under transaction size limit), only fails during execution after fees are charged

**Probability - High:**
Given the ease of execution, lack of access controls, absence of input validation, and clear pattern violation compared to similar functions in the codebase (`BatchApprove`), this attack is highly likely to occur either maliciously or accidentally through legitimate usage with many tokens.

## Recommendation

Add input size validation similar to the `BatchApprove` pattern:

1. Define a constant in `TokenContractConstants.cs`:
```csharp
public const int MaxDelegationSymbolsCount = 100;
```

2. Add validation at the beginning of `SetTransactionFeeDelegations()`:
```csharp
Assert(input.Delegations != null && input.Delegations.Count > 0, "Delegations cannot be null or empty!");
Assert(input.Delegations.Count <= TokenContractConstants.MaxDelegationSymbolsCount, 
    "Exceeds the max delegation symbols count.");
```

3. Optionally, make the limit configurable through governance like `BatchApprove` does with `GetMaxBatchApproveCount()`.

## Proof of Concept

```csharp
[Fact]
public async Task SetTransactionFeeDelegations_ExceedStateSize_Test()
{
    await Initialize();
    
    // Create a large delegation map with 6000+ token symbols
    var delegations = new Dictionary<string, long>();
    for (int i = 0; i < 6000; i++)
    {
        delegations[$"TOKEN{i}"] = 1000;
    }
    
    // This should fail with StateOverSizeException but fees are already charged
    var result = await TokenContractStub.SetTransactionFeeDelegations
        .SendWithExceptionAsync(new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations = { delegations }
        });
    
    // Transaction fails
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("State size");
    
    // But fees were still charged (PreTraces committed)
    var fees = result.TransactionResult.GetChargedTransactionFees();
    fees.ShouldNotBeEmpty(); // Fees were deducted
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L12-16)
```csharp
    public override SetTransactionFeeDelegationsOutput SetTransactionFeeDelegations(
        SetTransactionFeeDelegationsInput input)
    {
        AssertValidInputAddress(input.DelegatorAddress);
        Assert(input.Delegations != null, "Delegations cannot be null!");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L30-37)
```csharp
            // If there has been already DELEGATEE_MAX_COUNT delegatees, and still try to addï¼Œfail.
            if (allDelegateesMap.Count() >= TokenContractConstants.DELEGATEE_MAX_COUNT)
            {
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = false
                };
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L45-52)
```csharp
                foreach (var (key, value) in delegationsToInput)
                {
                    if (value > 0)
                    {
                        AssertValidToken(key, value);
                        allDelegateesMap[delegateeAddress].Delegations.Add(key, value);
                    }
                }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L57-57)
```csharp
                State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L69-80)
```csharp
            foreach (var (key, value) in delegationsToInput)
            {
                if (value <= 0 && delegationsMap.ContainsKey(key))
                {
                    delegationsMap.Remove(key);
                }
                else if (value > 0)
                {
                    AssertValidToken(key, value);
                    delegationsMap[key] = value;
                }
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L83-83)
```csharp
            State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L33-39)
```csharp
    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L148-160)
```csharp
    public object ValidateStateSize(object obj)
    {
        var stateSizeLimit = AsyncHelper.RunSync(() => _smartContractBridgeService.GetStateSizeLimitAsync(
            new ChainContext
            {
                BlockHash = _transactionContext.PreviousBlockHash,
                BlockHeight = _transactionContext.BlockHeight - 1
            }));
        var size = SerializationHelper.Serialize(obj).Length;
        if (size > stateSizeLimit)
            throw new StateOverSizeException($"State size {size} exceeds limit of {stateSizeLimit}.");
        return obj;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L285-286)
```csharp
        Assert(input != null && input.Value != null && input.Value.Count > 0, "Invalid input .");
        Assert(input.Value.Count <= GetMaxBatchApproveCount(), "Exceeds the max batch approve count.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L724-729)
```csharp
    private int GetMaxBatchApproveCount()
    {
        return State.MaxBatchApproveCount.Value == 0
            ? TokenContractConstants.DefaultMaxBatchApproveCount
            : State.MaxBatchApproveCount.Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```

**File:** protobuf/token_contract.proto (L138-139)
```text
    rpc SetTransactionFeeDelegations (SetTransactionFeeDelegationsInput) returns (SetTransactionFeeDelegationsOutput){
    }
```

**File:** protobuf/token_contract.proto (L674-679)
```text
message SetTransactionFeeDelegationsInput {
    // the delegator address
    aelf.Address delegator_address = 1;
    // delegation, symbols and its' amount
    map<string, int64> delegations = 2;
}
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L110-118)
```csharp
        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L167-178)
```csharp
            if (singleTxExecutingDto.Depth == 0)
                if (!await ExecutePluginOnPreTransactionStageAsync(executive, txContext,
                        singleTxExecutingDto.CurrentBlockTime,
                        internalChainContext, internalStateCache, cancellationToken))
                {
                    trace.ExecutionStatus = ExecutionStatus.Prefailed;
                    return trace;
                }

            #endregion

            await executive.ApplyAsync(txContext);
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L283-293)
```csharp
                var stateSets = preTrace.GetStateSets().ToList();
                internalStateCache.Update(stateSets);
                var parentStateCache = txContext.StateCache as TieredStateCache;
                parentStateCache?.Update(stateSets);

                if (!plugin.IsStopExecuting(preTrace.ReturnValue, out var error)) continue;

                // If pre-tx fails, still commit the changes, but return false to notice outside to stop the execution.
                preTrace.Error = error;
                preTrace.ExecutionStatus = ExecutionStatus.Executed;
                return false;
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutionPluginForMethodFeeTest.cs (L306-342)
```csharp
    public async Task ChargeFee_TxFee_FailedTest()
    {
        await DeployTestContractAsync();

        var issueAmount = 99999;
        var tokenContractStub = await GetTokenContractStubAsync();
        await SetPrimaryTokenSymbolAsync(tokenContractStub);

        await tokenContractStub.Transfer.SendAsync(new TransferInput
        {
            Symbol = "ELF",
            Amount = issueAmount,
            To = Accounts[1].Address,
            Memo = "Set for token converter."
        });

        var feeAmount = 100000;
        await SetMethodFee_Successful(feeAmount);

        var userTestContractStub =
            GetTester<ContractContainer.ContractStub>(_testContractAddress,
                Accounts[1].KeyPair);
        var dummy = await userTestContractStub.DummyMethod
            .SendWithExceptionAsync(new Empty()); // This will deduct the fee
        dummy.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        dummy.TransactionResult.Error.ShouldBe("Pre-Error: Transaction fee not enough.");
        var transactionFeeDic = dummy.TransactionResult.GetChargedTransactionFees();
        await CheckTransactionFeesMapAsync(Accounts[1].Address,transactionFeeDic);

        var afterFee = (await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Accounts[1].Address,
            Symbol = "ELF"
        })).Balance;
        afterFee.ShouldBe(0);
        transactionFeeDic[Accounts[1].Address]["ELF"].ShouldBe(issueAmount);
    }
```
