# Audit Report

## Title
Initial Miners Can Bypass Election Announcement Check via ReplaceCandidatePubkey to Gain Double Subsidies

## Summary
The `ReplaceCandidatePubkey` method in the Election contract contains insufficient validation that allows initial miners to bypass the restriction preventing them from announcing election. By replacing a regular candidate's pubkey with an initial miner's pubkey, the initial miner becomes simultaneously present in both the `Candidates` and `InitialMiners` lists, enabling them to receive both mining rewards and backup subsidy - violating the economic model's separation of reward streams.

## Finding Description

The vulnerability exists in `ReplaceCandidatePubkey` due to asymmetric validation logic that checks if the new pubkey is already a candidate but fails to check if it's an initial miner. [1](#0-0) 

While initial miners are explicitly blocked from directly announcing election, this protection is bypassed through pubkey replacement: [2](#0-1) 

The method only validates that the new pubkey isn't already in `Candidates`, but doesn't check `InitialMiners`.

When replacing a regular candidate's pubkey with an initial miner's pubkey: [3](#0-2) 

The old pubkey is removed from `Candidates` and the new pubkey (initial miner) is added. However, the code only modifies `InitialMiners` if the OLD pubkey was in that list: [4](#0-3) 

Since the old pubkey (regular candidate) is not in `InitialMiners`, this block is skipped. Meanwhile, backup subsidy beneficiary registration is transferred: [5](#0-4) 

**Result**: The initial miner's pubkey now exists in both `Candidates` (receiving backup subsidy) and `InitialMiners` (eligible for mining), violating the design invariant.

The Treasury contract clearly separates these reward streams: [6](#0-5) 

Initial miners can mine when used as fallback validators and receive mining rewards (basic, flexible). Additionally, candidates in the `DataCentersRankingList` receive backup subsidy with no exclusion logic for active miners. The backup subsidy beneficiary management: [7](#0-6) 

There is no mechanism to remove backup subsidy beneficiaries when they become active miners, enabling the double subsidy extraction.

## Impact Explanation

**Direct Fund Misallocation**: Initial miners gain access to two reward streams simultaneously:

1. **Mining Rewards**: As members of `InitialMiners`, they serve as fallback validators and receive their proportional share of mining rewards (basic reward based on blocks produced, flexible reward)
2. **Backup Subsidy**: As registered beneficiaries in the backup subsidy scheme, they receive shares of the 5% backup subsidy allocation

The Treasury distributes backup subsidy (1/20 or 5% of total) to all candidates in the `DataCentersRankingList` without excluding active miners. When an initial miner both mines AND is registered for backup subsidy, they receive rewards from both pools.

**Affected Parties**:
- Legitimate candidates lose their fair share of backup subsidy as it's diluted by initial miners who shouldn't be eligible
- The economic model is fundamentally broken as initial miners were designed to only receive mining rewards, not election subsidies
- Treasury resources are continuously misallocated over multiple terms

This represents a HIGH severity issue as it enables persistent extraction of unintended rewards, violating core economic design principles.

## Likelihood Explanation

**Entry Point**: `ReplaceCandidatePubkey` is a public method callable by any candidate admin. [8](#0-7) 

**Feasible Preconditions**:
- Attacker needs an initial miner pubkey (public information from chain state)
- Attacker announces election with a regular pubkey and sets themselves as admin
- Requires locking tokens (ElectionContractConstants.LockTokenForElection) but this is recoverable upon quitting

**Execution Steps**:
1. Call `AnnounceElection` with regular pubkey A, setting attacker's address as admin
2. Optionally call `SetProfitsReceiver` to direct rewards to attacker's address
3. Call `ReplaceCandidatePubkey(oldPubkey=A, newPubkey=B)` where B is an initial miner pubkey
4. Initial miner B is now in both lists and registered for backup subsidy

**Attack Complexity**: LOW - Two straightforward contract calls with no timing dependencies or complex state manipulation. All validation checks incorrectly pass due to the missing `InitialMiners` check.

**Economic Rationality**: The cost is temporary token lock (recoverable), while the gain is continuous dual subsidy extraction over multiple terms, making this highly profitable.

The likelihood is MEDIUM-HIGH as the attack is technically simple, requires no special privileges beyond being a candidate admin, and the preconditions are easily satisfiable.

## Recommendation

Add validation in `ReplaceCandidatePubkey` to check if the new pubkey is already in `InitialMiners`:

```csharp
public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
{
    Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
        "Pubkey is neither a current candidate nor an initial miner.");
    Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
        "Pubkey is in already banned.");

    // Add this validation
    var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));
    Assert(!State.InitialMiners.Value.Value.Contains(newPubkeyBytes),
        "Cannot replace with an initial miner pubkey.");

    // Permission check.
    Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
    
    // ... rest of the method
}
```

This ensures initial miners cannot be added to the `Candidates` list through any path, maintaining the economic model's invariant.

## Proof of Concept

```csharp
[Fact]
public async Task InitialMinerBypassViaReplacePubkey_Test()
{
    // Setup: Get initial miner pubkey from InitialMiners list
    var initialMinerList = await ElectionContractStub.GetInitialMinerList.CallAsync(new Empty());
    var initialMinerPubkey = initialMinerList.Value[0].ToHex();
    
    // Step 1: Announce election with regular candidate
    var regularCandidate = SampleKeyPairs[1];
    var regularPubkey = regularCandidate.PublicKey.ToHex();
    await ElectionContractStub.AnnounceElection.SendAsync(regularCandidate.Address);
    
    // Verify regular candidate in Candidates list
    var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    candidates.Value.Select(p => p.ToHex()).ShouldContain(regularPubkey);
    
    // Step 2: Replace regular candidate pubkey with initial miner pubkey
    await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = regularPubkey,
        NewPubkey = initialMinerPubkey
    });
    
    // Verify vulnerability: Initial miner now in BOTH lists
    var candidatesAfter = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    candidatesAfter.Value.Select(p => p.ToHex()).ShouldContain(initialMinerPubkey);
    
    var initialMinersAfter = await ElectionContractStub.GetInitialMinerList.CallAsync(new Empty());
    initialMinersAfter.Value.Select(p => p.ToHex()).ShouldContain(initialMinerPubkey);
    
    // Initial miner is now in both Candidates and InitialMiners
    // Can receive both mining rewards and backup subsidy
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L192-197)
```csharp
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L216-217)
```csharp
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L27-30)
```csharp
///     3 sub profit schemes:
///     (Mining Reward for Miners) - 3
///     (Subsidy for Candidates / Backups) - 1
///     (Welfare for Electors / Voters / Citizens) - 1
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-795)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
    }
```
