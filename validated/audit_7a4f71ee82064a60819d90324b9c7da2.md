# Audit Report

## Title
Incorrect Backup Miner Limit Causes Consensus to Operate with Fewer Miners Than Configured

## Summary
The `GetVictories` function in the Election contract contains a logic error in its backup miner selection algorithm. When valid candidates are insufficient to meet the governance-configured `MinersCount`, the function incorrectly limits backup selection to `currentMiners.Count` instead of the actual `backups` list size, causing the consensus system to operate with fewer validators than required.

## Finding Description

The vulnerability exists in the backup miner selection logic when there are insufficient valid candidates (candidates with votes > 0) to fill the required `MinersCount` positions. [1](#0-0) 

**The Bug:**
The critical flaw is that the code uses `Math.Min(diff, currentMiners.Count)` to limit backup selection, but this is semantically incorrect because:

1. The `backups` list is constructed from both `currentMiners` (filtered) AND `InitialMiners` (filtered), making it potentially larger than `currentMiners.Count`
2. The variable `diff` represents how many additional miners are needed, not how many current miners exist
3. When `currentMiners.Count < diff`, the system takes fewer backups than available and needed

**Example Scenario:**
- `MinersCount` = 7 (set via governance)
- `validCandidates.Count` = 2 (only 2 candidates with votes)
- `diff` = 7 - 2 = 5 (need 5 more miners)
- `currentMiners` = 3 miners from previous term
- `backups` after construction = 3 current miners + 5 initial miners = 8 available
- Bug: `Math.Min(5, 3) = 3` → only takes 3 backups
- Result: Returns 2 + 3 = 5 miners instead of required 7

**Why Protections Fail:**

The consensus contract accepts the miner list without validating the count matches expectations: [2](#0-1) 

The round generation simply uses whatever miners are provided: [3](#0-2) 

The miner list storage has no count validation: [4](#0-3) 

## Impact Explanation

**Consensus Security Degradation:**
Operating with 5 miners instead of the configured 7 reduces Byzantine fault tolerance from ⌊7/3⌋ = 2 malicious nodes to ⌊5/3⌋ = 1 malicious node. This fundamentally weakens the network's security guarantees against Byzantine attacks.

**Governance Violation:**
The `MinersCount` parameter is set through governance via the consensus contract's `SetMaximumMinersCount` method, which requires Parliament approval. The system silently ignores this governance decision, undermining the authority of on-chain governance. [5](#0-4) [6](#0-5) 

**Network Stability:**
Fewer validators increases vulnerability to node failures and makes transaction censorship easier, as a smaller number of colluding nodes can disrupt the network.

## Likelihood Explanation

**Triggering Conditions (All Realistic):**

1. `MinersCount` has been increased through governance (normal network growth pattern)
2. Low voter participation results in `validCandidates.Count < MinersCount` (common between election terms)
3. Previous term had fewer active miners than needed backups (happens after network events or miner departures)
4. `InitialMiners` are configured (always true, set at genesis and persists)

**Automatic Execution:**

The consensus contract automatically calls `GetVictories` during term transitions as part of normal consensus operation: [7](#0-6) 

This occurs naturally without any attacker action. The bug manifests silently - the system continues operating but with a reduced validator count that violates governance-established security parameters.

## Recommendation

Change line 72 in `ViewMethods.cs` from:
```csharp
.Take(Math.Min(diff, currentMiners.Count))
```

To:
```csharp
.Take(Math.Min(diff, backups.Count))
```

This ensures the backup selection is limited by the actual number of available backups rather than the unrelated count of current miners.

Additionally, consider adding validation in the consensus contract to assert that the returned miner count matches the expected `MinersCount` value, providing an explicit failure rather than silent degradation.

## Proof of Concept

```csharp
[Fact]
public async Task GetVictories_InsufficientBackups_ReturnsFewerMiners()
{
    // Setup: Increase MinersCount to 7 through governance
    var consensusStub = GetConsensusContractStub(BootMinerKeyPair);
    await consensusStub.SetMaximumMinersCount.SendAsync(new Int32Value { Value = 7 });
    
    // Setup: Only 2 candidates with votes (low participation)
    var candidate1 = ValidationDataCenterKeyPairs[0];
    var candidate2 = ValidationDataCenterKeyPairs[1];
    await AnnounceElectionAsync(candidate1);
    await AnnounceElectionAsync(candidate2);
    await VoteToCandidateAsync(VoterKeyPairs[0], candidate1.PublicKey.ToHex(), 100 * 86400, 100);
    await VoteToCandidateAsync(VoterKeyPairs[0], candidate2.PublicKey.ToHex(), 100 * 86400, 100);
    
    // Execute: GetVictories should return 7 miners but will return fewer
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // Verify: Bug causes fewer than 7 miners to be returned
    victories.Value.Count.ShouldBeLessThan(7); // Demonstrates the bug
    // Expected: victories.Value.Count.ShouldBe(7);
}
```

## Notes

This vulnerability represents a critical deviation between governance-intended configuration and actual consensus behavior. The `MinersCount` parameter is specifically designed to allow the network to scale the number of validators through governance decisions, but this bug silently undermines that capability when candidate participation is low. The issue becomes more severe as the network attempts to grow, creating a situation where governance increases security parameters that are then ignored by the implementation.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L60-76)
```csharp
        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-79)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```
