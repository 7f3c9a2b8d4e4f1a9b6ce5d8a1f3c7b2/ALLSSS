# Audit Report

## Title
Missing Authorization Check for Extra Block Producer in Round Termination

## Summary
The AEDPoS consensus validation does not verify that the sender of a `NextRound` or `NextTerm` block is the designated extra block producer (`IsExtraBlockProducer = true`). Any miner whose time slot has passed can produce a round-terminating block and gain the associated block production credit and `ExtraBlockProducerOfPreviousRound` status, bypassing the intended consensus role assignment and undermining fair reward distribution.

## Finding Description

In AEDPoS consensus, each round concludes with a designated "extra block producer" who should produce the final block to terminate the round. This role is assigned via the `IsExtraBlockProducer` flag and is meant to be fairly distributed across miners.

However, the consensus validation fails to enforce this role assignment:

**1. Automatic Behavior Assignment Without Authorization Check**

When any miner's time slot passes, `GetConsensusBehaviour()` automatically returns `NextRound` or `NextTerm` behavior without checking if that miner is the designated extra block producer: [1](#0-0) 

**2. Missing Validation in ValidateBeforeExecution**

When a `NextRound` or `NextTerm` block is validated, the system applies several validators, but NONE check if the sender is the designated extra block producer: [2](#0-1) 

Specifically:
- `MiningPermissionValidationProvider` only checks miner list membership: [3](#0-2) 

- `TimeSlotValidationProvider` only validates time slot consistency of the new round structure, not who produced it: [4](#0-3) 

- `RoundTerminateValidationProvider` only validates round/term number correctness: [5](#0-4) 

**3. PreCheck Insufficient**

The `PreCheck` method in `ProcessConsensusInformation` only verifies miner list membership, not extra block producer authorization: [6](#0-5) 

**4. IsCurrentMiner Method Exists But Unused**

The codebase contains an `IsCurrentMiner()` method that DOES check if a miner is the extra block producer at the appropriate time: [7](#0-6) 

However, this method is never called during consensus validation, rendering the check ineffective.

**5. Exploitable Consequences**

When a non-designated miner successfully produces a `NextTerm` block, they gain:

- Incremented `ProducedBlocks` count used for reward calculation: [8](#0-7) 

- Status as `ExtraBlockProducerOfPreviousRound` for the next round: [9](#0-8) 

This status grants extended mining privileges in the subsequent round: [10](#0-9) 

## Impact Explanation

**Consensus Invariant Violation**: The protocol design intends that only the designated extra block producer (identified by `IsExtraBlockProducer = true`) should terminate each round. The validation failure breaks this invariant, allowing any miner to usurp this role.

**Reward Misallocation**: Miners who produce round-terminating blocks receive an additional `ProducedBlocks` increment, which directly affects mining reward distribution through the `DonateMiningReward` mechanism. An unauthorized miner gains rewards meant for the designated producer. [11](#0-10) 

**Fairness Breach**: The extra block producer role is pseudo-randomly assigned to distribute opportunities fairly across all miners. Allowing miners to bypass this assignment undermines the fairness mechanism and creates opportunities for strategic manipulation.

**Quantified Impact**: Each improperly produced extra block represents one additional block credit for the exploiting miner and the loss of that credit for the designated producer. Mining rewards are calculated as `GetMinedBlocks() * GetMiningRewardPerBlock()`, meaning this directly impacts financial distribution.

## Likelihood Explanation

**Attacker Capability**: Any active miner in the current round can execute this attack with no special privileges required.

**Technical Feasibility**: HIGH
1. Attacker waits for their normal time slot to pass (verified by `IsTimeSlotPassed`)
2. Requests consensus command from their node
3. Receives `NextRound`/`NextTerm` behavior automatically from `GetConsensusBehaviour()`
4. Produces and broadcasts the block
5. Block passes all validation checks despite attacker not being the designated extra block producer

**Preconditions**: 
- Attacker must be an active miner in the current round (standard consensus participant)
- Attacker's normal time slot must have elapsed
- No additional authorization or privilege required

**Detection Difficulty**: The blockchain validation logic accepts these blocks as valid, making detection difficult without off-chain monitoring of intended vs. actual extra block producers.

**Probability**: HIGH - Every miner can potentially exploit this after their time slot passes in every round.

## Recommendation

Add a new validation provider `ExtraBlockProducerValidationProvider` that checks whether the sender is authorized to terminate the round:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        
        if (extraData.Behaviour != AElfConsensusBehaviour.NextRound && 
            extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        var supposedExtraBlockProducer = validationContext.BaseRound.RealTimeMinersInformation
            .SingleOrDefault(m => m.Value.IsExtraBlockProducer).Key;
            
        if (validationContext.SenderPubkey != supposedExtraBlockProducer)
        {
            validationResult.Message = $"Only the designated extra block producer {supposedExtraBlockProducer} can terminate the round.";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Then add this provider to the validation pipeline in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new ExtraBlockProducerValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new ExtraBlockProducerValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

## Proof of Concept

```csharp
[Fact]
public async Task UnauthorizedMinerCanTerminateRound()
{
    // Setup: Initialize consensus with multiple miners
    var miners = GenerateMiners(5);
    await InitializeConsensus(miners);
    
    // Get current round and identify the designated extra block producer
    var currentRound = await GetCurrentRound();
    var extraBlockProducer = currentRound.RealTimeMinersInformation
        .Single(m => m.Value.IsExtraBlockProducer).Key;
    
    // Select a different miner (NOT the extra block producer)
    var unauthorizedMiner = miners.First(m => m != extraBlockProducer);
    
    // Wait for unauthorized miner's time slot to pass
    await AdvanceTime(currentRound, unauthorizedMiner);
    
    // Unauthorized miner produces NextRound block
    var nextRoundInput = GenerateNextRoundInput(unauthorizedMiner);
    await ExecuteConsensusTransaction(unauthorizedMiner, nextRoundInput);
    
    // Verify: Block was accepted despite unauthorized miner
    var newRound = await GetCurrentRound();
    Assert.Equal(currentRound.RoundNumber + 1, newRound.RoundNumber);
    
    // Verify: Unauthorized miner gained ProducedBlocks credit
    Assert.Equal(1, newRound.RealTimeMinersInformation[unauthorizedMiner].ProducedBlocks);
    
    // Verify: Unauthorized miner became ExtraBlockProducerOfPreviousRound
    Assert.Equal(unauthorizedMiner, newRound.ExtraBlockProducerOfPreviousRound);
    
    // This demonstrates the vulnerability: any miner can terminate the round
    // and gain rewards meant for the designated extra block producer
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L20-35)
```csharp
    private void UpdateProducedBlocksNumberOfSender(Round input)
    {
        var senderPubkey = Context.RecoverPublicKey().ToHex();

        // Update produced block number of transaction sender.
        if (input.RealTimeMinersInformation.ContainsKey(senderPubkey))
            input.RealTimeMinersInformation[senderPubkey].ProducedBlocks =
                input.RealTimeMinersInformation[senderPubkey].ProducedBlocks.Add(1);
        else
            // If the sender isn't in miner list of next term.
            State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
            {
                Pubkey = senderPubkey,
                RecentlyProducedBlocks = 1
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
