# Audit Report

## Title
Consensus Term Change Can Be Indefinitely Delayed Through Miner Availability Manipulation

## Summary
The AEDPoS consensus mechanism's term change logic relies solely on achieving 2/3+1 consensus among miners' `ActualMiningTimes` without any absolute time validation. When 1/3+ miners are offline or controlled by attackers, term changes can be delayed beyond the intended period for up to 3 days, blocking treasury releases and governance operations.

## Finding Description

The vulnerability exists in the term change decision flow. The `NeedToChangeTerm()` method determines whether to transition to a new term by counting how many miners have `ActualMiningTimes` indicating the term period has elapsed. [1](#0-0) 

The critical issue is that this check requires at least `MinersCountOfConsent` miners (calculated as `Count * 2 / 3 + 1`) to agree. [2](#0-1) 

However, `ActualMiningTimes` is only populated when miners produce blocks and is reset to empty in each new round. [3](#0-2)  When a new round is generated, miners start with fresh `MinerInRound` objects that don't include `ActualMiningTimes` from previous rounds. [4](#0-3) 

The term change decision flows through `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()`, which returns `NextRound` instead of `NextTerm` when `NeedToChangeTerm()` returns false. [5](#0-4) 

The consensus behaviour determines which hint is embedded in the block through `TerminateRoundCommandStrategy`. [6](#0-5) 

Critically, the `RoundTerminateValidationProvider` validates blocks based only on whether round and term numbers increment correctly, not whether sufficient absolute time has elapsed to justify the behaviour. [7](#0-6) 

Offline miners are only removed after exceeding `TolerableMissedTimeSlotsCount` (4320 slots = 3 days). [8](#0-7)  During each round, offline miners' `MissedTimeSlots` counter is incremented. [9](#0-8) 

**Attack Scenario:**
With 17 miners requiring 12 for consensus (2/3+1):
1. After the term period elapses, 6 miners (1/3+) stop producing blocks
2. In the current round, only 11 online miners have non-empty `ActualMiningTimes` indicating term change
3. Since 11 < 12, `NeedToChangeTerm()` returns false
4. Honest miners follow protocol and produce `NextRound` blocks
5. Validation accepts these blocks (only checks incremental correctness)
6. Term change is blocked despite the period having elapsed
7. Can persist for 3 days until evil miner detection removes offline miners

## Impact Explanation

This vulnerability enables critical governance and economic operations to be delayed:

**Treasury Release Delays:** Term changes trigger treasury profit releases during the `ProcessNextTerm` operation. [10](#0-9) 

**Election Snapshot Delays:** Election snapshots recording miner performance are taken at term changes. [11](#0-10) 

**Miner List Update Delays:** New term elections that update the active miner set cannot occur, allowing potentially malicious miners to extend their control period.

The severity is HIGH because it breaks the fundamental consensus invariant that terms transition at defined intervals, enabling governance manipulation and economic disruption for up to 3 days.

## Likelihood Explanation

**Attacker Capabilities:** An attacker needs to control or coordinate 1/3+ of the miner set (approximately 6 out of 17 miners). Alternatively, natural network partitions affecting 1/3+ miners trigger this vulnerability without malicious intent.

**Execution Complexity:** The attack is triggered through the standard consensus flow. No special privileges are required - miners simply stop producing blocks. Honest miners following the protocol inadvertently perpetuate the issue by producing `NextRound` blocks when the threshold isn't met.

**Feasibility:** This represents a liveness failure in the BFT consensus design. While BFT systems tolerate 1/3 byzantine participants for safety, this vulnerability shows inadequate liveness guarantees when that threshold is reached. The likelihood is MEDIUM-HIGH given that network partitions or coordinated attacks affecting 1/3+ miners are plausible scenarios.

## Recommendation

Implement an absolute time-based fallback mechanism for term transitions:

1. **Add time-based validation:** Modify `RoundTerminateValidationProvider` to verify that when a `NextRound` behaviour is used, the absolute term period hasn't been exceeded beyond a tolerance threshold (e.g., 2x the normal term period).

2. **Force term change after timeout:** Introduce a fail-safe that allows term changes to proceed when the term period has been exceeded by a significant margin, even without 2/3+1 consensus. This could require only 1/2+ miners or use the Last Irreversible Block (LIB) mechanism.

3. **Reduce evil miner detection window:** Consider reducing `TolerableMissedTimeSlotsCount` from 3 days to a shorter period (e.g., 1 day) to more quickly remove unresponsive miners.

4. **Alternative consensus threshold:** Calculate `MinersCountOfConsent` based on active miners (those with `ActualMiningTimes.Any()`) rather than total miners in `RealTimeMinersInformation`.

## Proof of Concept

The vulnerability can be demonstrated by simulating a scenario where 6 out of 17 miners go offline after a term period elapses:

1. Initialize consensus with 17 miners
2. Advance blockchain time past the term period
3. Have 6 miners stop producing blocks (don't call UpdateValue/TinyBlock)
4. Have 11 remaining miners attempt to transition terms
5. Observe that `NeedToChangeTerm()` returns false (11 < 12)
6. Verify that `GetConsensusBehaviourToTerminateCurrentRound()` returns `NextRound`
7. Confirm that validation accepts the `NextRound` block
8. Verify that treasury release and election snapshot are not triggered
9. Confirm this persists until the 3-day timeout expires

**Notes**

This vulnerability represents a fundamental design issue in how AEDPoS handles liveness during miner availability problems. The protocol correctly ensures safety (no conflicting term changes) but fails to guarantee liveness (timely term transitions). The lack of absolute time validation in the block validation layer allows this condition to persist indefinitely until the evil miner detection mechanism removes offline participants. This creates a window where critical governance and economic operations can be delayed by either malicious coordination or natural network issues affecting 1/3+ of the miner set.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L20-20)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L54-54)
```csharp
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L29-33)
```csharp
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L205-208)
```csharp
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```
