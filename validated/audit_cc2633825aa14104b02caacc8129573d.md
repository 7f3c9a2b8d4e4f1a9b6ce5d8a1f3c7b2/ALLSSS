# Audit Report

## Title
Insufficient Taylor Series Iterations in Ln Function Causes Material Pricing Error at Domain Boundary

## Summary
The `Ln` function in BancorHelper uses only 20 iterations of the Taylor series approximation, causing significant error when calculating ln(2) at the domain boundary. This error propagates through the Bancor pricing formula in `GetAmountToPayFromReturn`, underestimating the required payment by approximately 4-5% when users buy amounts approaching half of the connector balance, leading to protocol fund loss. [1](#0-0) 

## Finding Description
The vulnerability exists in the natural logarithm implementation that uses a Taylor series approximation with a fixed iteration count. The `Ln` function computes ln(1-x) = -x - x²/2 - x³/3 - ... where x = 1 - a, which is convergent for |x| < 1. [2](#0-1) 

The boundary check permits values where |x| < 1, allowing input parameter 'a' to approach 2.0: [3](#0-2) 

When a user calls the `Buy` function to purchase an amount approaching half of the `toConnectorBalance`, the calculation in `GetAmountToPayFromReturn` produces x = bt / (bt - a) ≈ 2.0: [4](#0-3) 

This value is then passed to the Ln function, where the internal variable becomes x = 1 - 2 = -1 (approaching). The alternating harmonic series (1 - 1/2 + 1/3 - 1/4 + ... ± 1/20) converges to ln(2) ≈ 0.693147, but with only 20 terms, the approximation has an error bounded by the first omitted term (1/21 ≈ 0.0476), representing approximately 6.87% relative error.

This error propagates through the exponential calculation in the pricing formula: [5](#0-4) 

If Ln(2) returns approximately 0.668 instead of the true 0.693, and the weight ratio y = 1, then:
- Exp(1 × 0.668) ≈ 1.95 vs Exp(1 × 0.693) ≈ 2.00
- Payment calculation: fromConnectorBalance × (1.95 - 1) vs fromConnectorBalance × (2.00 - 1)
- Underestimation: approximately 5%

The `Buy` function in TokenConverterContract calls this function without adequate validation: [6](#0-5) 

The only protection is a user-supplied `PayLimit` check, which an attacker can set arbitrarily high: [7](#0-6) 

## Impact Explanation
**Direct Financial Loss**: For a pool with 2,000,000 resource tokens where a user buys 999,998 tokens (just under half):
- x = 2,000,000 / (2,000,000 - 999,998) ≈ 1.999998
- Ln error: ~6.87% maximum bound
- With weight ratio y = 1: Payment underestimated by ~4-5%
- If the economically correct cost should be 1,000,000 base tokens:
  - Actual payment charged: ~950,000 base tokens
  - Loss to protocol: ~50,000 base tokens per trade

**Affected Parties**:
- TokenConverter protocol loses base tokens on boundary trades
- Liquidity providers receive insufficient deposits relative to tokens withdrawn
- Protocol treasury receives reduced fees based on underpriced trades

The 0.5% transaction fee is insufficient to offset the 4-5% pricing error. This violates the Bancor formula invariants that should maintain accurate price discovery based on the reserve ratio. The security guarantee that "users pay the correct Bancor-formula price for tokens" is broken.

## Likelihood Explanation
**Attacker Capabilities**: Any user with sufficient capital can exploit this vulnerability. No special permissions are required as the `Buy` function is public: [8](#0-7) 

**Attack Complexity**: Medium - requires:
1. Mathematical knowledge to identify that buying ~50% of pool triggers x ≈ 2
2. Capital to purchase close to half the connector balance
3. Simple transaction execution with calculated `PayLimit`

**Feasibility**: The exploit is deterministic and reproducible. For pools with millions of tokens, the absolute profit (tens of thousands of tokens) makes the attack economically viable. The transaction appears as a legitimate large buy order, making detection difficult.

**Realistic Preconditions**: 
- Pool must have adequate liquidity (achievable for live token converter pools)
- No additional validation prevents large purchases relative to pool size
- The boundary condition is mathematically reachable within normal protocol operations

## Recommendation
Increase the number of Taylor series iterations to ensure accuracy at the domain boundary. Consider:

1. **Increase `_LOOPS` constant**: Change from 20 to at least 50-100 iterations to reduce error at x ≈ 2 to acceptable levels (< 0.1%)

2. **Add purchase size validation**: Implement a check in the `Buy` function to prevent purchases that would bring x too close to 2:
   ```csharp
   // Prevent buying more than 40% of pool in single transaction
   Assert(input.Amount < toConnectorBalance * 4 / 10, "Purchase amount too large");
   ```

3. **Alternative logarithm implementation**: Use range reduction techniques (ln(ab) = ln(a) + ln(b)) to keep inputs away from domain boundaries, or use pre-computed lookup tables with interpolation for better accuracy.

## Proof of Concept
```csharp
[Fact]
public async Task Test_Ln_Boundary_Error_Causes_Underpayment()
{
    // Setup: Pool with 2,000,000 resource tokens
    long toConnectorBalance = 2_000_000;
    long fromConnectorBalance = 2_000_000;
    decimal weight = 0.5m;
    
    // Attack: Buy 999,998 tokens (just under half)
    long amountToBuy = 999_998;
    
    // Calculate x value: should be very close to 2
    decimal x = (decimal)toConnectorBalance / (toConnectorBalance - amountToBuy);
    // x ≈ 1.999998
    
    // Call GetAmountToPayFromReturn
    var amountToPay = BancorHelper.GetAmountToPayFromReturn(
        fromConnectorBalance, weight,
        toConnectorBalance, weight,
        amountToBuy);
    
    // Expected payment (if Ln(2) was accurate): close to 1,000,000
    // Actual payment will be approximately 4-5% less due to Ln error
    // This demonstrates protocol loses ~50,000 tokens
    
    // Verify underpricing: actual should be < expected by ~4-5%
    long expectedPayment = 1_000_000; // Approximate fair value
    var underestimationPercent = ((decimal)(expectedPayment - amountToPay) / expectedPayment) * 100;
    
    // Assert significant underpricing occurs
    Assert.True(underestimationPercent > 3, 
        $"Payment underestimated by {underestimationPercent}% due to Ln approximation error");
}
```

## Notes
The vulnerability is mathematically provable and does not require any assumptions about implementation details. The 20-iteration limit for the Taylor series is hardcoded and cannot handle inputs near the domain boundary with sufficient accuracy. While the claim's exact error percentages may vary slightly based on weight ratios and pool configurations, the fundamental issue remains: insufficient iterations cause material pricing errors that can be exploited for financial gain at the protocol's expense.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-91)
```csharp
        var x = bt / (bt - a);
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L93-93)
```csharp
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L124-143)
```csharp
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-112)
```csharp
    public override Empty Buy(BuyInput input)
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L127-127)
```csharp
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");
```
