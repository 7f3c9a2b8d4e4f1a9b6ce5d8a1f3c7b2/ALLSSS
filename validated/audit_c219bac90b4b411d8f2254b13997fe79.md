# Audit Report

## Title
Missing Validation of Decrypted Secret Pieces Allows Consensus Randomness Manipulation

## Summary
The AEDPoS consensus contract's secret sharing mechanism accepts decrypted pieces from miners without cryptographic validation, allowing malicious miners to submit fake decrypted values that manipulate other miners' reconstructed `PreviousInValue`, directly affecting signature calculations and miner ordering in subsequent rounds.

## Finding Description

The vulnerability exists in the secret sharing flow where miners decrypt and reveal secret pieces to recover other miners' InValues when they fail to produce blocks.

**Vulnerable Entry Points:**

The `UpdateLatestSecretPieces` function blindly accepts decrypted pieces from trigger information and stores them without validation: [1](#0-0) 

Similarly, `PerformSecretSharing` accepts decrypted pieces from `UpdateValueInput` during transaction processing: [2](#0-1) 

The `UpdateValue` method is publicly callable by any miner in the current or previous round: [3](#0-2) 

**Missing Critical Validation:**

When `RevealSharedInValues` reconstructs a miner's InValue from collected decrypted pieces using Shamir's Secret Sharing, it computes the hash but never validates it against the originally committed OutValue: [4](#0-3) 

The reconstructed value should satisfy `Hash(revealedInValue) == anotherMinerInPreviousRound.OutValue`, but this check is absent.

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates the block producer's own PreviousInValue against their previous OutValue, not the revealed values for other miners: [5](#0-4) 

The validation explicitly uses `validationContext.SenderPubkey`, meaning it only validates the current block producer's own data.

**Cryptographic Authentication Gap:**

The encryption scheme uses ECDH key agreement with AES-CBC, which provides confidentiality but not authenticity: [6](#0-5) 

There is no MAC or authenticated encryption mode, so anyone can generate arbitrary bytes claiming to be "decrypted" pieces.

**Consensus Impact Chain:**

The fake PreviousInValue is propagated to `SupplyCurrentRoundInformation`, which uses it to calculate signatures for miners who didn't produce blocks: [7](#0-6) 

This signature directly determines miner ordering through modulo calculation in `ApplyNormalConsensusData`: [8](#0-7) [9](#0-8) 

## Impact Explanation

**Consensus Integrity Breach:**
- Malicious miners can manipulate which miners are assigned to specific time slots in future rounds
- Breaks the unpredictability guarantee of VRF-based consensus randomness
- Enables strategic manipulation of consensus order for economic advantages
- Violates the fundamental invariant: "Miner schedule must be determined by verifiable random functions"

**Attack Execution:**
1. Round N: Honest Miner A commits `OutValue_A = Hash(InValue_A)` and distributes encrypted pieces
2. Round N+1: Malicious Miner B calls `UpdateValue` with fake decrypted pieces for Miner A
3. The fake pieces are stored without validation via `PerformSecretSharing`
4. When transitioning to NextRound, `RevealSharedInValues` reconstructs a fake `InValue_A'` from the tampered pieces
5. Round N+2: If Miner A didn't mine, `SupplyCurrentRoundInformation` calculates signature using fake `InValue_A'`
6. Result: Miner A receives incorrect `FinalOrderOfNextRound`, breaking consensus randomness

**Protocol-Level Damage:**
- Consensus fairness compromised as attackers can favor allies or punish competitors
- Mining reward distribution becomes manipulatable
- Undermines trust in the deterministic miner selection process

## Likelihood Explanation

**Attacker Requirements:**
- Must be an elected miner (realistic - these positions rotate based on voting)
- Secret sharing must be enabled via configuration (typically enabled in production)
- No special privileges beyond normal miner status required

**Attack Complexity:**
- Low - attacker calls `UpdateValue` with arbitrary bytes as "decrypted" pieces instead of real decryptions
- No sophisticated cryptographic attacks needed
- The `PreCheck` only verifies miner is in current or previous round: [10](#0-9) 

**Feasibility:**
- `UpdateValueInput` accepts `decrypted_pieces` as a map field: [11](#0-10) 
- Target miners must have submitted encrypted pieces in previous rounds (standard behavior)
- Attack is executable during normal mining operations

**Detection Difficulty:**
- Extremely hard to detect on-chain - fake pieces are indistinguishable from legitimate ones without the original secret
- No cryptographic proof system to verify decryption correctness
- Would require off-chain statistical analysis to detect anomalous miner ordering patterns

## Recommendation

Add cryptographic validation in `RevealSharedInValues` to verify that reconstructed InValues match the originally committed OutValues:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// CRITICAL FIX: Validate reconstructed InValue against committed OutValue
if (HashHelper.ComputeFrom(revealedInValue) != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => $"Invalid revealed InValue for {publicKeyOfAnotherMiner} - does not match OutValue commitment");
    continue; // Skip invalid reconstruction
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

Additionally, consider implementing authenticated encryption (e.g., AES-GCM) instead of plain AES-CBC to ensure decrypted pieces cannot be forged.

## Proof of Concept

A malicious miner can execute this attack by:

1. Calling the public `UpdateValue` method with a crafted `UpdateValueInput` containing fake `decrypted_pieces`
2. The fake pieces will be accepted and stored via `PerformSecretSharing` without validation
3. During the next round transition, `RevealSharedInValues` will reconstruct an incorrect `PreviousInValue` using the fake pieces
4. This corrupted value propagates through `SupplyCurrentRoundInformation` to calculate an incorrect signature
5. The signature determines `FinalOrderOfNextRound` in `ApplyNormalConsensusData`, allowing the attacker to manipulate miner ordering

The vulnerability is confirmed by the absence of any validation that compares `Hash(revealedInValue)` against the stored `OutValue` commitment in the secret sharing reconstruction logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Cryptography/CryptoHelper.cs (L142-154)
```csharp
        public static byte[] EncryptMessage(byte[] senderPrivateKey, byte[] receiverPublicKey, byte[] plainText)
        {
            var keyBytes = GetSharedSecret(senderPrivateKey, receiverPublicKey);

            var cipher = new PaddedBufferedBlockCipher(new CbcBlockCipher(new AesEngine()));
            cipher.Init(true, new ParametersWithIV(new KeyParameter(keyBytes), new byte[16]));

            var cipherText = new byte[cipher.GetOutputSize(plainText.Length)];
            var len = cipher.ProcessBytes(plainText, 0, plainText.Length, cipherText, 0);
            cipher.DoFinal(cipherText, len);

            return cipherText;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** protobuf/aedpos_contract.proto (L211-212)
```text
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
```
