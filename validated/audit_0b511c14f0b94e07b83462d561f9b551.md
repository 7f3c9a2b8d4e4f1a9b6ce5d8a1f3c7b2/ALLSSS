# Audit Report

## Title
ExpectedMiningTime Manipulation in Next Round Allows Network DoS

## Summary
The AEDPoS consensus validation fails to verify that `ExpectedMiningTime` values in next round data are anchored to the current block timestamp. A malicious extra block producer can set arbitrary future timestamps while maintaining equal intervals between miners, passing all validation checks but rendering the network unable to produce blocks when the manipulated round activates.

## Finding Description

When a miner produces an extra block to terminate the current round, they include next round information in the consensus extra data. This data is validated by `ValidateBeforeExecution` which orchestrates multiple validation providers. [1](#0-0) 

For NextRound behavior, the validation chain includes `TimeSlotValidationProvider` which delegates to `CheckRoundTimeSlots()` when a new round is provided: [2](#0-1) 

The `CheckRoundTimeSlots()` method only validates relative properties: (1) `ExpectedMiningTime` is not null, (2) mining interval > 0, and (3) intervals between consecutive miners are roughly equal with 100% tolerance. Critically, it does NOT validate that the absolute `ExpectedMiningTime` values are anchored to the current block time: [3](#0-2) 

The intended generation logic properly calculates `ExpectedMiningTime` as `currentBlockTimestamp.AddMilliseconds(miningInterval * order)`: [4](#0-3) 

However, since miners control the consensus data they include in blocks (it's deserialized from block header bytes during validation), an attacker can construct manipulated round data: [5](#0-4) 

The `ProvidedRound` used in validation comes directly from the block producer's serialized extra data: [6](#0-5) 

An attacker can set all `ExpectedMiningTime` values to `currentBlockTime + 1000 years` with proper intervals between them, which would pass all validation checks.

When this manipulated round becomes active, `IsCurrentMiner()` checks fail for all miners. This method verifies that `Context.CurrentBlockTime` falls within the time slot `[ExpectedMiningTime, ExpectedMiningTime + miningInterval]`: [7](#0-6) 

With `ExpectedMiningTime` set far in the future, the check at lines 162-167 will always fail because current block time will never reach the artificially advanced timestamps, preventing all block production.

The manipulated round is stored in state and becomes the active round: [8](#0-7) 

## Impact Explanation

This vulnerability enables a complete consensus-level denial of service attack:

**Network Halt**: Once the manipulated round activates, all `IsCurrentMiner()` checks return false because the current block time never reaches the artificially advanced `ExpectedMiningTime` values. Block production stops entirely.

**Transaction Freeze**: No transactions can be processed, no state updates occur, and the blockchain becomes completely non-functional.

**Recovery Difficulty**: The network remains halted until manual intervention (governance action or hard fork) since the consensus mechanism itself is compromised.

**Broad Impact**: All network participants are affected - users cannot transact, applications cannot function, and validators cannot earn rewards.

The severity is HIGH because this causes complete, deterministic network unavailability with no automatic recovery mechanism.

## Likelihood Explanation

**Attacker Profile**: Any miner in the active validator set can execute this attack when selected as the extra block producer. Extra block producer selection rotates deterministically based on consensus signatures, meaning every miner periodically has this opportunity.

**Attack Prerequisites**: 
- Attacker must be a miner (normal participant role, not privileged)
- Attacker must wait until selected as extra block producer (happens regularly through rotation)
- Attacker runs modified node software that manipulates round data before block production

**Technical Simplicity**: The attack requires only modifying the `Round` protobuf structure before serialization - no cryptographic breaks, no race conditions, no complex state manipulation. The validation gap makes exploitation straightforward.

**Detection Window**: The attack is invisible during validation (all checks pass) and only becomes apparent when the manipulated round activates and blocks stop being produced. By then, the malicious round data is already committed to the chain.

The likelihood is HIGH because every miner regularly becomes extra block producer, and the validation logic has no defense against this manipulation.

## Recommendation

Add validation in `CheckRoundTimeSlots()` or a new validation provider to verify that `ExpectedMiningTime` values are properly anchored to the current block timestamp. The validation should:

1. Check that the first miner's `ExpectedMiningTime` is close to (within acceptable bounds of) `Context.CurrentBlockTime`
2. Verify subsequent miners' `ExpectedMiningTime` values follow the pattern: `firstMinerTime + (miningInterval * (order - 1))`
3. Reject rounds where timestamps are unreasonably far in the past or future

Example validation logic to add to `TimeSlotValidationProvider`:

```csharp
// For NextRound behavior, validate absolute timestamps
if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
{
    var firstMiner = validationContext.ProvidedRound.RealTimeMinersInformation.Values
        .FirstOrDefault(m => m.Order == 1);
    
    if (firstMiner != null)
    {
        var timeDiff = (firstMiner.ExpectedMiningTime - Context.CurrentBlockTime).Seconds;
        var maxAllowedDiff = validationContext.ProvidedRound.GetMiningInterval() / 1000 * 2; // 2x mining interval tolerance
        
        if (Math.Abs(timeDiff) > maxAllowedDiff)
        {
            return new ValidationResult 
            { 
                Message = "ExpectedMiningTime not properly anchored to current block time" 
            };
        }
    }
}
```

## Proof of Concept

```csharp
// Test demonstrating the validation bypass
[Fact]
public async Task MaliciousExtraBlockProducer_CanManipulateExpectedMiningTime()
{
    // Setup: Initialize consensus with multiple miners
    var miners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusAsync(miners);
    
    // Miner1 selected as extra block producer for round transition
    var currentRound = await GetCurrentRoundAsync();
    var maliciousMiner = "miner1";
    
    // Generate proper next round (as contract would do)
    var properNextRound = GenerateNextRound(currentRound, Context.CurrentBlockTime);
    
    // Attacker manipulates ExpectedMiningTime to 1000 years in future
    var manipulatedRound = properNextRound.Clone();
    var futureTime = Context.CurrentBlockTime.AddSeconds(365 * 24 * 3600 * 1000); // +1000 years
    var miningInterval = manipulatedRound.GetMiningInterval();
    
    foreach (var miner in manipulatedRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order))
    {
        miner.ExpectedMiningTime = futureTime.AddMilliseconds(miningInterval * (miner.Order - 1));
    }
    
    // Validation should pass (but doesn't check absolute timestamps)
    var validationResult = await ValidateNextRoundAsync(manipulatedRound);
    Assert.True(validationResult.Success); // VULNERABILITY: Passes validation!
    
    // Execute NextRound with manipulated data
    await ExecuteNextRoundAsync(manipulatedRound, maliciousMiner);
    
    // Verify network is now halted
    foreach (var miner in miners)
    {
        var canMine = await IsCurrentMinerAsync(miner);
        Assert.False(canMine); // All miners fail IsCurrentMiner check
    }
    
    // Confirm no blocks can be produced
    var blockProductionFailed = true;
    try
    {
        await ProduceBlockAsync("miner2");
        blockProductionFailed = false;
    }
    catch
    {
        // Expected: Block production fails
    }
    Assert.True(blockProductionFailed); // Network is halted
}
```

## Notes

This vulnerability exploits a critical gap in the consensus validation logic where relative time properties are verified but absolute timestamp anchoring is not. The attack is particularly severe because:

1. It bypasses all existing validation providers
2. The manipulated data is indistinguishable from valid data during validation
3. The impact is catastrophic and immediate when the round activates
4. Recovery requires governance intervention or hard fork

The fix must balance security with tolerance for network time synchronization issues, but the current implementation has no bounds checking whatsoever on absolute timestamp values.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-221)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;

        Context.LogDebug(() =>
            $"Extra block producer of previous round: {currentRound.ExtraBlockProducerOfPreviousRound}");

        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }

        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }

        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }

        // Check saving extra block time slot.
        var nextArrangeMiningTime =
            currentRound.ArrangeAbnormalMiningTime(pubkey, Context.CurrentBlockTime, true);
        var actualArrangedMiningTime = nextArrangeMiningTime.AddMilliseconds(-currentRound.TotalMilliseconds());
        if (actualArrangedMiningTime <= Context.CurrentBlockTime &&
            Context.CurrentBlockTime <= actualArrangedMiningTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]SAVING");
            return true;
        }

        // If current round is the first round of current term.
        if (currentRound.RoundNumber == 1)
        {
            Context.LogDebug(() => "First round");

            var latestMinedInfo =
                currentRound.RealTimeMinersInformation.Values.OrderByDescending(i => i.Order)
                    .FirstOrDefault(i => i.ActualMiningTimes.Any() && i.Pubkey != pubkey);
            if (latestMinedInfo != null)
            {
                var minersCount = currentRound.RealTimeMinersInformation.Count;
                var latestMinedSlotLastActualMiningTime = latestMinedInfo.ActualMiningTimes.Last();
                var latestMinedOrder = latestMinedInfo.Order;
                var currentMinerOrder =
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
                var passedSlotsCount =
                    (Context.CurrentBlockTime - latestMinedSlotLastActualMiningTime).Milliseconds()
                    .Div(miningInterval);
                if (passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(1).Add(minersCount) ||
                    passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(minersCount))
                {
                    Context.LogDebug(() => "[CURRENT MINER]FIRST ROUND");
                    return true;
                }
            }
        }

        Context.LogDebug(() => "[CURRENT MINER]NOT MINER");

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-124)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }

    /// <summary>
    ///     Will force to generate a `Change` to tx executing result.
    /// </summary>
    /// <param name="round"></param>
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```
