# Audit Report

## Title
Incomplete Token Distribution Due to Outdated SymbolList in TakeSnapshot Causing Permanent Reward Loss

## Summary
The `TakeSnapshot()` function in the Election contract retrieves Treasury's manually-configured `SymbolList` and passes it to `DistributeProfits()` for SubsidyHash and WelfareHash schemes. When `AmountsMap` contains any entries, `DistributeProfits()` processes ONLY those symbols and completely ignores `ReceivedTokenSymbols` (which tracks all contributed tokens). This causes permanent loss of rewards when `SymbolList` is incomplete, as the distribution period increments regardless, preventing future redistribution of missed tokens for that specific period.

## Finding Description

The vulnerability exists in a multi-component interaction where profit distribution logic fails to distribute all contributed tokens:

**Component 1 - Entry Point:** The Election contract's `TakeSnapshot()` retrieves Treasury's `SymbolList` and creates an amounts map containing only those symbols. [1](#0-0) 

**Component 2 - Root Cause:** The `DistributeProfits()` method has a critical if-else conditional. When `AmountsMap` has ANY entries, it processes ONLY those symbols (lines 433-446). The else block (lines 447-460) that would iterate through ALL `ReceivedTokenSymbols` NEVER executes when `AmountsMap` is non-empty. [2](#0-1) 

This means the `IsReleaseAllBalanceEveryTimeByDefault` flag is completely bypassed when `AmountsMap` contains entries. [3](#0-2) 

**Component 3 - Irreversible Period Increment:** After distribution completes (regardless of which tokens were distributed), the `CurrentPeriod` is always incremented. [4](#0-3) 

**Component 4 - Prevention of Retry:** Period validation enforces that only the current period can be processed. Once the period advances, it's impossible to retry distribution for a past period. [5](#0-4) 

**Why Protections Fail:**

Treasury's `SymbolList` is initialized with only the native token and requires manual governance updates via `SetSymbolList`. [6](#0-5) [7](#0-6) 

When tokens are contributed to schemes, they are automatically tracked in `ReceivedTokenSymbols`, but there is no validation that Treasury's `SymbolList` includes all these tokens. [8](#0-7) 

When distributing to sub-schemes, tokens are transferred and added to the sub-scheme's `ReceivedTokenSymbols`. [9](#0-8) 

## Impact Explanation

**Direct Financial Harm:**

When Treasury supports multiple tokens (e.g., ELF, USDT) that have been donated and propagated to SubsidyHash and WelfareHash schemes, but Treasury's `SymbolList` only contains `["ELF"]`:

1. Only ELF rewards are distributed to backup candidates and voters for period N
2. USDT remains in the schemes' virtual addresses
3. USDT cannot be distributed for period N due to period validation
4. When USDT is finally distributed in period N+1 (after SymbolList update), it goes to period N+1 beneficiaries
5. Period N beneficiaries permanently lose their USDT rewards

**Affected Parties:**
- Backup node operators expecting subsidy rewards from SubsidyHash
- Token holders/voters expecting welfare dividends from WelfareHash
- All beneficiaries of profit schemes using this distribution mechanism

**Severity Justification:**
- **High Impact**: Permanent loss of rewards for entire periods; tokens distributed to wrong beneficiaries
- **No Recovery Mechanism**: Period-based distribution with strict validation prevents retroactive fixes
- **Cumulative Effect**: Each term with incomplete SymbolList causes additional loss
- **Trust Damage**: Beneficiaries lose confidence when entitled rewards aren't received

## Likelihood Explanation

**Realistic Scenario:**
1. Treasury initialized with `SymbolList = ["ELF"]`
2. Governance adds new tokens to ecosystem (e.g., USDT as method fee token)
3. Tokens flow through Treasury `Donate()` to SubsidyHash/WelfareHash schemes
4. Governance fails to update Treasury's `SymbolList` (operational oversight)
5. `TakeSnapshot()` is automatically called by consensus contract at term end
6. Incomplete distribution occurs, locking non-ELF tokens for that period

**Feasibility:**
- **No Attacker Required**: Operational failure triggered by normal operations
- **Automatic Trigger**: `TakeSnapshot()` called automatically every term by consensus
- **No Safeguards**: No validation that SymbolList includes all ReceivedTokenSymbols
- **Governance Dependency**: Requires perfect coordination between token additions and SymbolList updates

**Probability:** Medium to High - As the ecosystem grows with new tokens, coordination overhead increases. A single oversight in the multi-step process causes immediate, permanent loss for that term.

## Recommendation

**Solution 1 (Preferred):** Modify `DistributeProfits()` to always check both `AmountsMap` and `ReceivedTokenSymbols`, distributing any symbols in `ReceivedTokenSymbols` that aren't in `AmountsMap`:

```csharp
var profitsMap = new Dictionary<string, long>();
if (input.AmountsMap.Any())
{
    foreach (var amount in input.AmountsMap)
    {
        // Process AmountsMap as before
    }
    // Add missing symbols from ReceivedTokenSymbols
    if (scheme.IsReleaseAllBalanceEveryTimeByDefault)
    {
        foreach (var symbol in scheme.ReceivedTokenSymbols)
        {
            if (!profitsMap.ContainsKey(symbol))
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                }).Balance;
                profitsMap.Add(symbol, balance);
            }
        }
    }
}
```

**Solution 2:** Add validation in `TakeSnapshot()` to verify Treasury's SymbolList includes all symbols in the schemes' ReceivedTokenSymbols, reverting if incomplete.

**Solution 3:** Add a governance-callable function to retroactively distribute missed tokens for past periods (requires removing period validation for this special case).

## Proof of Concept

```csharp
[Fact]
public async Task IncompleteTokenDistribution_PermanentLoss()
{
    // Setup: Treasury initialized with SymbolList = ["ELF"]
    // SubsidyHash scheme has ReceivedTokenSymbols = ["ELF", "USDT"]
    
    // USDT contributed to SubsidyHash scheme
    await TreasuryContractStub.Donate.SendAsync(new DonateInput
    {
        Symbol = "USDT",
        Amount = 10000
    });
    
    // Verify USDT is in SubsidyHash ReceivedTokenSymbols
    var subsidyScheme = await ProfitContractStub.GetScheme.CallAsync(subsidyHash);
    Assert.Contains("USDT", subsidyScheme.ReceivedTokenSymbols);
    
    // TakeSnapshot called (Treasury SymbolList only has "ELF")
    await ConsensusContractStub.NextTerm.SendAsync(new NextTermInput { ... });
    
    // Verify only ELF was distributed for period N
    var distributedInfo = await ProfitContractStub.GetDistributedProfitsInfo.CallAsync(
        new SchemePeriod { SchemeId = subsidyHash, Period = N });
    Assert.True(distributedInfo.AmountsMap.ContainsKey("ELF"));
    Assert.False(distributedInfo.AmountsMap.ContainsKey("USDT")); // USDT missing!
    
    // Verify period incremented
    var scheme = await ProfitContractStub.GetScheme.CallAsync(subsidyHash);
    Assert.Equal(N + 1, scheme.CurrentPeriod);
    
    // Attempt to redistribute for period N fails
    await Assert.ThrowsAsync<AssertionException>(async () =>
    {
        await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = subsidyHash,
            Period = N,
            AmountsMap = { { "USDT", 0 } }
        });
    }); // Error: "Invalid period"
    
    // Period N beneficiaries permanently lost USDT rewards
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L440-447)
```csharp
        var symbolList = State.DividendPoolContract.GetSymbolList.Call(new Empty());
        var amountsMap = symbolList.Value.ToDictionary(s => s, s => 0L);
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-460)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-645)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L948-948)
```csharp
            IsReleaseAllBalanceEveryTimeByDefault = input.IsReleaseAllBalanceEveryTimeByDefault,
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L72-75)
```csharp
        State.SymbolList.Value = new SymbolList
        {
            Value = { Context.Variables.NativeSymbol }
        };
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L282-309)
```csharp
    public override Empty SetSymbolList(SymbolList input)
    {
        AssertPerformedByTreasuryController();
        Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        foreach (var symbol in input.Value.Where(s => s != Context.Variables.NativeSymbol))
        {
            var isTreasuryInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
            {
                Symbol = symbol,
                Address = Context.Self
            }).Value;
            Assert(
                State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value ||
                isTreasuryInWhiteList, "Symbol need to be profitable.");
            Assert(!State.TokenConverterContract.IsSymbolAbleToSell.Call(new StringValue { Value = symbol }).Value,
                $"Token {symbol} doesn't need to set to symbol list because it would become native token after donation.");
        }

        State.SymbolList.Value = input;
        return new Empty();
```
