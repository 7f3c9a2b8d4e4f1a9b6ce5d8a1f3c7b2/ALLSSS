# Audit Report

## Title
Missing Validation of SupposedOrderOfNextRound Allows Consensus Order Manipulation

## Summary
The AEDPoS consensus contract fails to validate that miner-provided `SupposedOrderOfNextRound` values match their cryptographically expected values. During validation and state persistence, the system blindly accepts arbitrary order values from miners, enabling consensus schedule manipulation, order theft, and disruption through zero or collision attacks.

## Finding Description

The vulnerability exists in the consensus validation and state update flow where `SupposedOrderOfNextRound` is accepted without cryptographic verification.

When a miner produces a block with `UpdateValue` behavior, the `SupposedOrderOfNextRound` field should deterministically equal `GetAbsModulus(signature, minersCount) + 1` as calculated during block production. [1](#0-0) [2](#0-1) 

However, during block validation, the `RecoverFromUpdateValue` function blindly copies all provided `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` values from the block header without any validation against the expected cryptographic calculation. [3](#0-2) 

The `UpdateValueValidationProvider` only validates that OutValue and Signature fields are filled, and that the hash of PreviousInValue matches the previous OutValue. It completely omits validation of the order fields. [4](#0-3) 

The validation flow in `ValidateBeforeExecution` calls `RecoverFromUpdateValue` for UpdateValue behavior, but no validation provider checks the order values. [5](#0-4) [6](#0-5) 

Finally, during state persistence, `ProcessUpdateValue` directly accepts the unchecked value from the input and persists it to state. [7](#0-6) 

The malicious value propagates through the system because the signature field is calculated from `previousInValue` BEFORE the order calculation occurs. [8](#0-7) [9](#0-8)  This means modifying the order value does not invalidate the signature check.

## Impact Explanation

The corrupted order values directly break next round generation logic, enabling three critical attack vectors:

**1. Order Stealing Attack**: A malicious miner can set `SupposedOrderOfNextRound = 1` to always claim the first mining position in the next round. The next round generation directly uses this unchecked value to determine mining order and timing. [10](#0-9)  This allows repeated first-position claims, maximizing MEV extraction opportunities and block rewards.

**2. Consensus Disruption via Zero**: Setting `SupposedOrderOfNextRound = 0` exploits the miner classification logic where miners are categorized as "mined" or "not mined" based on whether their order is zero. [11](#0-10) [12](#0-11)  Miners with order 0 are incorrectly classified as "not mined" despite producing blocks, corrupting penalty assignment and order allocation logic.

**3. Order Collision**: Multiple miners claiming the same order violate the consensus invariant requiring unique orders in [1, minersCount]. The available order calculation assumes no duplicates exist. [13](#0-12)  Collisions corrupt this logic, potentially causing incorrect order assignments.

**Severity: HIGH** - This breaks the fundamental "Correct round transitions and miner schedule integrity" consensus invariant. Every block from a malicious miner corrupts future round state.

## Likelihood Explanation

**Attack Requirements**: Any active miner can execute this when producing their assigned block. The miner has full control over the consensus extra data structure in their block header.

**Attack Complexity**: Low - the attacker modifies a single integer field in the round data structure. The cryptographic signature is calculated from `previousInValue` before the order calculation occurs, so modifying the order doesn't invalidate the signature check.

**Feasibility**: 
- Works for any active miner (normal precondition)
- No special timing or state setup required
- Exploitable every round after initialization
- Block signature remains valid after modification

**Detection Difficulty**: The malicious value is included in the block header and passes all validation checks, making it appear legitimate without recalculating and comparing against the expected cryptographic value.

**Probability: HIGH** - Any rational miner seeking competitive advantage (first block rights, MEV opportunities) would exploit this. No technical barriers prevent exploitation.

## Recommendation

Add validation of `SupposedOrderOfNextRound` in the `UpdateValueValidationProvider`. The validator should:

1. Recalculate the expected value: `expectedOrder = GetAbsModulus(minerInRound.Signature.ToInt64(), minersCount) + 1`
2. Compare against the provided value: `if (minerInRound.SupposedOrderOfNextRound != expectedOrder) return ValidationResult with error`

Example fix for `UpdateValueValidationProvider.cs`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    if (!NewConsensusInformationFilled(validationContext))
        return new ValidationResult { Message = "Incorrect new Out Value." };

    if (!ValidatePreviousInValue(validationContext))
        return new ValidationResult { Message = "Incorrect previous in value." };

    // Add validation for SupposedOrderOfNextRound
    if (!ValidateSupposedOrderOfNextRound(validationContext))
        return new ValidationResult { Message = "Incorrect supposed order of next round." };

    return new ValidationResult { Success = true };
}

private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
    var sigNum = minerInRound.Signature.ToInt64();
    var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}

private static int GetAbsModulus(long longValue, int intValue)
{
    return (int)Math.Abs(longValue % intValue);
}
```

## Proof of Concept

A proof of concept would require:
1. Setting up an AElf test node with multiple miners
2. Modifying a miner's block production logic to set `SupposedOrderOfNextRound = 1` (or 0 for disruption) in the `UpdateValueInput` before sending the block
3. Observing that the block passes validation
4. Verifying that the next round uses the malicious order value, giving the attacker first position (or causing disruption with order 0)
5. Confirming no validation errors occur during the process

The test would demonstrate that arbitrary order values are accepted and persisted, breaking consensus schedule integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-27)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L131-135)
```csharp
    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```
