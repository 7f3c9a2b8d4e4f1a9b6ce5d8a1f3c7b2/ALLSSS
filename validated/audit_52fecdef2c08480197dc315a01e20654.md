# Audit Report

## Title
Unbounded Token Symbol Accumulation Causes DOS in Profit Claiming

## Summary
The Profit contract's `ReceivedTokenSymbols` list lacks size limits, allowing unlimited token types to accumulate. When beneficiaries claim profits via `ClaimProfits`, nested iteration through all symbols and periods causes transaction complexity to exceed execution limits, resulting in denial of service for legitimate profit claims.

## Finding Description

The vulnerability exists in the profit claiming mechanism where token symbols accumulate without bounds in the `Scheme` structure's `received_token_symbols` field. [1](#0-0) 

Symbols are added without size validation in two critical locations:

1. **In `DistributeProfitsForSubSchemes`**: When distributing to sub-schemes, the method adds new token symbols to `ReceivedTokenSymbols` without checking list size. [2](#0-1) 

2. **In `ContributeProfits`**: Any user can contribute profits with any valid token symbol. The method has no access control restrictions (unlike `AddBeneficiary` which verifies manager permissions) and adds new symbols without size limits. [3](#0-2) 

The specific symbol addition occurs at: [4](#0-3) 

When `ClaimProfits` is called, it processes up to 10 profit details by calling `ProfitAllPeriods` for each detail: [5](#0-4) 

The `ProfitAllPeriods` method creates a nested loop structure that iterates through ALL symbols in the unbounded `ReceivedTokenSymbols` list: [6](#0-5) 

And for each symbol, loops through periods up to `maxProfitReceivingPeriodCount`: [7](#0-6) 

Each iteration performs state reads to retrieve `DistributedProfitsInfo` and may generate inline token transfers: [8](#0-7) 

The constant `TokenAmountLimit = 5` only applies to method fee configuration in `SetMethodFee`, not to `ReceivedTokenSymbols`: [9](#0-8) [10](#0-9) 

The maximum period count defaults to 100: [11](#0-10) 

## Impact Explanation

**Direct Impact:**
- Beneficiaries cannot claim their legitimate profits when many token symbols accumulate
- Transaction complexity calculation: 10 profit details × N symbols × (100/10) periods = 100N iterations
- With 100+ token types, a single claim requires 10,000+ loop iterations with state reads
- With 1,000 token types, this becomes 100,000+ iterations
- Transaction will timeout or exceed AElf resource limits

**Who is Affected:**
- All beneficiaries of schemes with many accumulated token types
- Particularly severe for long-running treasury schemes accepting diverse tokens
- Multi-token reward programs that naturally accumulate various token symbols

**Operational Damage:**
- Legitimate profit claims fail due to transaction resource exhaustion
- Users experience poor UX, unable to withdraw earned profits
- No workaround available as the nested loop always processes ALL symbols
- In extreme cases, profits may become permanently unclaimable if symbol count is sufficiently high

**Severity Justification (Low):**
- No direct fund theft or permanent loss of funds
- Funds remain securely in the contract, not stolen or misdirected
- DOS is operational rather than complete system failure
- Can be mitigated through careful initial scheme design (limiting token types accepted)
- Attack requires non-trivial economic cost (owning/creating many different tokens and paying gas for each contribution)
- Natural occurrence more likely than malicious attack due to cost barriers

## Likelihood Explanation

**Attacker Capabilities:**
Any user can call `ContributeProfits` to add new token symbols to a scheme without requiring manager permissions or special privileges. This is verified by the absence of access control checks in the method.

**Attack Complexity:**
1. Attacker identifies target profit scheme ID
2. Creates or obtains many different token types (incurs real economic cost)
3. Approves minimal token amounts for the Profit contract
4. Calls `ContributeProfits` repeatedly with minimal amounts (e.g., 1 unit) of each different token symbol
5. Each call adds a new symbol to `ReceivedTokenSymbols` if not already present
6. Accumulates hundreds of different token symbols over time
7. Beneficiaries calling `ClaimProfits` hit complexity limits and experience transaction failures

**Feasibility:**
- **Natural Occurrence**: Multi-token treasury or reward schemes can legitimately accumulate dozens to hundreds of tokens through normal operations over time (Medium-High probability for long-running schemes)
- **Accelerated Attack**: Malicious actor can deliberately speed up accumulation (Low-Medium probability due to economic costs of obtaining/creating many token types and paying gas fees)
- **Economic Barrier**: Attacker must own various tokens and pay transaction fees for each contribution, but minimal token amounts suffice for the attack

**Detection/Constraints:**
- No on-chain detection mechanism for excessive symbol accumulation
- AElf transaction gas limits will eventually cause `ClaimProfits` to fail when symbol count is high enough
- No circuit breaker or warning system for symbol count thresholds
- No cleanup mechanism to remove old or unused token symbols from the list

## Recommendation

Implement a maximum limit on `ReceivedTokenSymbols` list size in the `Scheme` structure. Consider:

1. **Add constant for maximum token symbols:**
```csharp
public const int MaximumTokenSymbolsPerScheme = 20; // Reasonable limit
```

2. **Enforce limit in `ContributeProfits`:**
```csharp
if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol))
{
    Assert(scheme.ReceivedTokenSymbols.Count < ProfitContractConstants.MaximumTokenSymbolsPerScheme,
        "Scheme has reached maximum token symbol limit.");
    scheme.ReceivedTokenSymbols.Add(input.Symbol);
}
```

3. **Enforce limit in `DistributeProfitsForSubSchemes`:**
```csharp
if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
{
    Assert(subScheme.ReceivedTokenSymbols.Count < ProfitContractConstants.MaximumTokenSymbolsPerScheme,
        "Sub-scheme has reached maximum token symbol limit.");
    subScheme.ReceivedTokenSymbols.Add(symbol);
    State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
}
```

4. **Optional: Add cleanup mechanism** to remove token symbols with zero balance or no recent activity after a certain period.

## Proof of Concept

```csharp
[Fact]
public async Task UnboundedTokenSymbolAccumulationCausesDOS()
{
    // Setup: Create a profit scheme
    var schemeId = await CreateTestScheme();
    var beneficiary = Accounts[1].Address;
    
    // Add beneficiary with shares
    await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = beneficiary,
            Shares = 100
        },
        EndPeriod = long.MaxValue
    });
    
    // Attack: Contribute many different token symbols (simulating 100+ tokens)
    for (int i = 0; i < 150; i++)
    {
        var tokenSymbol = $"TOKEN{i}";
        
        // Create and approve token
        await CreateAndApproveToken(tokenSymbol, 1000);
        
        // Contribute minimal amount to add symbol to ReceivedTokenSymbols
        await ProfitContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeId = schemeId,
            Amount = 1,
            Symbol = tokenSymbol,
            Period = 0
        });
    }
    
    // Verify: ReceivedTokenSymbols now contains 150 entries
    var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    Assert.Equal(150, scheme.ReceivedTokenSymbols.Count);
    
    // Distribute profits for period 1
    await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { }  // Release all
    });
    
    // Impact: Beneficiary attempts to claim profits
    // This will fail or timeout due to 10 details × 150 symbols × 10 periods = 15,000 iterations
    var claimResult = await ProfitContractStub.ClaimProfits.SendWithExceptionAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    
    // Transaction exceeds resource limits or times out
    Assert.True(claimResult.TransactionResult.Status == TransactionResultStatus.Failed ||
                claimResult.TransactionResult.Error.Contains("resource") ||
                claimResult.TransactionResult.Error.Contains("timeout"));
}
```

**Notes:**
- This vulnerability is confirmed through systematic code analysis of the Profit contract
- The nested loop complexity (symbols × periods) creates O(N×M) computational cost where N (symbols) is unbounded
- While the economic barrier provides some protection against pure griefing attacks, natural accumulation in multi-token scenarios poses a legitimate risk
- The LOW severity rating is appropriate as funds are not lost or stolen, only temporarily inaccessible
- Implementing a reasonable maximum symbol count (e.g., 20-50) would prevent both malicious and accidental DOS while maintaining scheme flexibility

### Citations

**File:** protobuf/profit_contract.proto (L159-159)
```text
    repeated string received_token_symbols = 12;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-645)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-785)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L851-851)
```csharp
        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L853-915)
```csharp
        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L8-8)
```csharp
    public const int TokenAmountLimit = 5;
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L9-9)
```csharp
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L14-14)
```csharp
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
```
