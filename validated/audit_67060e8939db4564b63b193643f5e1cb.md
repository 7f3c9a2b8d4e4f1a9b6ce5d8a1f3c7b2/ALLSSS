# Audit Report

## Title
Missing Option Length Validation in Vote Contract Registration Allows Permanent Storage Bloat

## Summary
The `Register()` function in the Vote contract accepts voting items with arbitrarily long option strings without validating them against the 1024-character limit that all other contract functions enforce. This creates a permanent inconsistent state where oversized options cannot be voted on or removed, causing irreversible blockchain storage bloat.

## Finding Description

The vulnerability exists due to inconsistent validation across the Vote contract methods:

The `Register()` function directly copies options from input without any length validation. [1](#0-0) 

The validation helper `AssertValidNewVotingItem()` only validates timestamps and voting item uniqueness, with no option length checks. [2](#0-1) 

In contrast, the `AssertOption()` validation function enforces the 1024-character limit defined in constants. [3](#0-2) [4](#0-3) 

The `AddOption()` function enforces this limit by calling `AssertOption()`. [5](#0-4) 

Critically, `RemoveOption()` validates the length **before** checking if the option exists, preventing removal of oversized options. [6](#0-5) 

The `Vote()` function also validates option length, preventing votes on oversized options. [7](#0-6) 

Once an oversized option is registered, it creates a permanent inconsistent state: the option exists in storage but cannot be voted on (Vote validates length) and cannot be removed (RemoveOption validates length before checking existence).

## Impact Explanation

**Storage Bloat**: An attacker can register voting items with option strings containing millions of characters, consuming excessive blockchain storage that all nodes must maintain permanently.

**Permanent Pollution**: The oversized options become permanently stuck in the blockchain state. To remove an option, the sponsor must provide the exact string to `RemoveOption()`, but if the string exceeds 1024 characters, the transaction fails at the length validation check before even checking if the option exists.

**Useless Voting Items**: The voting items become non-functional because users cannot vote for the oversized options, and the sponsor cannot clean up the options. The voting item persists in storage but serves no purpose.

**Cost to Network**: This is a griefing attack vector where malicious actors can bloat the blockchain state at relatively low cost (only transaction fees), affecting all node operators who must store this data permanently.

## Likelihood Explanation

**Reachable Entry Point**: The `Register()` function is a public method callable by any user. [8](#0-7) 

**Low Preconditions**: The only requirement is that the accepted currency token must be in the whitelist, checked at the contract initialization. [9](#0-8)  For common tokens like the native token, this requirement is trivially satisfied.

**Simple Execution**: An attacker simply needs to prepare a `VotingRegisterInput` with valid timestamps and accepted currency, include option strings exceeding 1024 characters, and call `Register()`.

**No Detection**: The `AssertValidNewVotingItem()` helper only validates voting item uniqueness and timestamps - there is no check that would prevent oversized options before they are permanently stored.

## Recommendation

Add option length validation in the `Register()` function before storing the voting item. The fix should validate each option string against the `OptionLengthLimit` constant:

```csharp
public override Empty Register(VotingRegisterInput input)
{
    var votingItemId = AssertValidNewVotingItem(input);
    
    // Validate option lengths
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
    }
    
    // ... rest of the function
}
```

Alternatively, call `AssertOption()` for each option during registration to ensure consistency across all contract methods.

## Proof of Concept

```csharp
[Fact]
public async Task Register_WithOversizedOption_ShouldFail()
{
    // Create an option exceeding the 1024-character limit
    var oversizedOption = new string('A', 2000);
    
    var input = new VotingRegisterInput
    {
        StartTimestamp = Timestamp.FromDateTime(DateTime.UtcNow.AddDays(1)),
        EndTimestamp = Timestamp.FromDateTime(DateTime.UtcNow.AddDays(7)),
        AcceptedCurrency = "ELF",
        TotalSnapshotNumber = 1,
        Options = { oversizedOption }
    };
    
    // This should fail but currently succeeds
    var result = await VoteContractStub.Register.SendAsync(input);
    
    // Verify the oversized option was stored
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(new GetVotingItemInput 
    { 
        VotingItemId = result.Output 
    });
    
    Assert.Contains(oversizedOption, votingItem.Options);
    
    // Verify it cannot be voted on
    var voteInput = new VoteInput
    {
        VotingItemId = result.Output,
        Option = oversizedOption,
        Amount = 100
    };
    
    // This will fail due to length validation in Vote()
    var exception = await Assert.ThrowsAsync<Exception>(
        () => VoteContractStub.Vote.SendAsync(voteInput)
    );
    
    // Verify it cannot be removed
    var removeInput = new RemoveOptionInput
    {
        VotingItemId = result.Output,
        Option = oversizedOption
    };
    
    // This will fail due to length validation in RemoveOption()
    exception = await Assert.ThrowsAsync<Exception>(
        () => VoteContractStub.RemoveOption.SendAsync(removeInput)
    );
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-20)
```csharp
    public override Empty Register(VotingRegisterInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L29-34)
```csharp
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L307-308)
```csharp
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L380-380)
```csharp
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L6-6)
```csharp
    public const int OptionLengthLimit = 1024;
```
