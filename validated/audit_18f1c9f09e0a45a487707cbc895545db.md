# Audit Report

## Title
Permanent Authority Lockout via MethodFeeController Change to Inaccessible Organization

## Summary
The `ChangeMethodFeeController()` function across all ACS1-implementing system contracts allows changing the method fee controller to a Parliament organization with mathematically impossible voting thresholds (e.g., 100% approval). Once set, the controller becomes permanently inaccessible since changing it again requires executing a proposal through the same organization, creating an unbreakable circular dependency with no recovery mechanism.

## Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` implementation pattern used across all ACS1 system contracts. The function enforces that only the current controller can authorize a controller change by checking `Context.Sender` equals the controller's `OwnerAddress`. [1](#0-0) 

The function validates only that the new organization exists, not whether its voting thresholds are achievable. [2](#0-1) 

The Parliament contract's organization validation explicitly allows creating organizations with `MinimalApprovalThreshold = 10000` (representing 100%). [3](#0-2)  The constant `AbstractVoteTotal = 10000` represents 100%. [4](#0-3) 

Test cases explicitly confirm that organizations with 100% approval thresholds are permitted and successfully created. [5](#0-4) 

The approval threshold calculation requires `approvedMemberCount * AbstractVoteTotal >= MinimalApprovalThreshold * parliamentMembers.Count`. With a 100% threshold, this becomes `approvedMemberCount >= parliamentMembers.Count`, requiring unanimous approval from ALL current miners. [6](#0-5) 

When a proposal is released, it executes using the organization's virtual address as `Context.Sender` via `SendVirtualInlineBySystemContract`. [7](#0-6) 

The default initialization only sets the controller if it's null, providing no recovery mechanism once a controller is set. [8](#0-7) 

**Attack Scenario:**
1. Attacker (miner or whitelisted proposer) creates a Parliament organization with `MinimalApprovalThreshold = 10000`
2. Creates proposal to call `ChangeMethodFeeController` with this organization's address
3. Obtains 2/3+ governance approval (the default Parliament threshold)
4. Releases proposal, permanently changing the controller
5. Future controller changes require 100% miner approval - impossible if any single miner is offline, compromised, or refuses

## Impact Explanation

**Critical Governance Failure:** This vulnerability enables permanent denial of service on method fee governance across all affected system contracts (Token, Treasury, Consensus, Election, Parliament, Profit, etc.).

Once the controller is set to an organization with 100% threshold:
- Method fees can never be adjusted to adapt to network conditions
- The blockchain loses economic flexibility permanently
- No emergency override or recovery mechanism exists
- All contracts implementing ACS1 that use this organization as controller are affected system-wide

This violates the fundamental governance invariant that administrative authorities must remain accessible for protocol adaptation. The impact is permanent and irreversible - there is no code path to reset or recover the controller once locked.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Prerequisites:**
- Must be a current miner or whitelisted proposer (standard governance participant)
- Must obtain 2/3+ approval from Parliament (the default governance threshold)

**Attack Complexity: Low**
- Creating an organization with 100% threshold: 1 transaction
- Creating the controller change proposal: 1 transaction  
- Obtaining governance approval: social engineering or appearing legitimate
- Releasing the proposal: 1 transaction

**Realistic Scenarios:**
1. **Accidental:** Well-intentioned governance participants misconfigure thresholds without understanding irreversibility
2. **Malicious:** Compromised miner or social engineering attack disguised as routine governance upgrade
3. **Griefing:** Low-cost attack (only transaction fees) motivated by sabotage

**No Technical Barriers:** The system has no validation, circuit breakers, or warning mechanisms to detect or prevent dangerous threshold configurations.

## Recommendation

Add threshold achievability validation to `ChangeMethodFeeController()`:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Validate threshold achievability
    if (input.ContractAddress == State.ParliamentContract.Value)
    {
        var org = State.ParliamentContract.GetOrganization.Call(input.OwnerAddress);
        Assert(org.ProposalReleaseThreshold.MinimalApprovalThreshold < AbstractVoteTotal,
            "Organization threshold must be achievable (less than 100%).");
    }
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

Additionally, implement an emergency recovery mechanism controlled by a supermajority organization that can reset controllers in deadlock scenarios.

## Proof of Concept

```csharp
[Fact]
public async Task PermanentControllerLockout_Attack()
{
    // Step 1: Create organization with 100% threshold (impossible to achieve)
    var impossibleOrg = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 10000, // 100% - requires ALL miners
            MinimalVoteThreshold = 10000,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        }
    };
    
    var minerStub = GetParliamentContractTester(InitialMinersKeyPairs[0]);
    var orgAddress = await minerStub.CreateOrganization.SendAsync(impossibleOrg);
    orgAddress.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var impossibleOrgAddress = orgAddress.Output;
    
    // Step 2: Create proposal to change Token contract's MethodFeeController
    var proposal = await minerStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        OrganizationAddress = await minerStub.GetDefaultOrganizationAddress.CallAsync(new Empty()),
        ToAddress = TokenContractAddress,
        ContractMethodName = nameof(TokenContractContainer.TokenContractStub.ChangeMethodFeeController),
        Params = new AuthorityInfo
        {
            OwnerAddress = impossibleOrgAddress,
            ContractAddress = ParliamentContractAddress
        }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
    });
    
    // Step 3: Get 2/3+ approval (simulating governance process)
    foreach (var keyPair in InitialMinersKeyPairs.Take(5)) // 5 out of 7 miners approve
    {
        var stub = GetParliamentContractTester(keyPair);
        await stub.Approve.SendAsync(proposal.Output);
    }
    
    // Step 4: Release proposal - controller is now permanently changed
    await minerStub.Release.SendAsync(proposal.Output);
    
    // Step 5: Verify controller is now the impossible organization
    var tokenStub = GetTester<TokenContractImplContainer.TokenContractImplStub>(
        TokenContractAddress, InitialMinersKeyPairs[0]);
    var controller = await tokenStub.GetMethodFeeController.CallAsync(new Empty());
    controller.OwnerAddress.ShouldBe(impossibleOrgAddress);
    
    // Step 6: Prove it's now impossible to change controller again
    // Even if we create a new proposal with 100% approval, if ANY miner is offline,
    // the threshold cannot be reached and the controller is permanently locked
    var recoveryProposal = await minerStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        OrganizationAddress = impossibleOrgAddress,
        ToAddress = TokenContractAddress,
        ContractMethodName = nameof(TokenContractContainer.TokenContractStub.ChangeMethodFeeController),
        Params = new AuthorityInfo
        {
            OwnerAddress = await minerStub.GetDefaultOrganizationAddress.CallAsync(new Empty()),
            ContractAddress = ParliamentContractAddress
        }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
    });
    
    // Only 6 out of 7 miners approve (one is "offline")
    foreach (var keyPair in InitialMinersKeyPairs.Take(6))
    {
        var stub = GetParliamentContractTester(keyPair);
        await stub.Approve.SendAsync(recoveryProposal.Output);
    }
    
    // Release will fail because 6/7 = 85.7% < 100% required
    var releaseResult = await minerStub.Release.SendWithExceptionAsync(recoveryProposal.Output);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Controller remains permanently locked - no recovery possible
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L1-10)
```csharp
namespace AElf.Contracts.Parliament;

public partial class ParliamentContract
{
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
    private const int DefaultOrganizationMaximalAbstentionThreshold = 2000;
    private const int DefaultOrganizationMaximalRejectionThreshold = 2000;
    private const int DefaultOrganizationMinimalVoteThresholdThreshold = 7500;
    private const int AbstractVoteTotal = 10000;
}
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L187-196)
```csharp
        {
            createOrganizationInput.ProposalReleaseThreshold = proposalReleaseThreshold;
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }
```
