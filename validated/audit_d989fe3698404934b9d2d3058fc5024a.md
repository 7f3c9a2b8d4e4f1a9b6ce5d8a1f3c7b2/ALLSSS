# Audit Report

## Title
Missing LIB Height Validation in NextRound/NextTerm Transitions Allows Consensus Integrity Violation

## Summary
The AEDPoS consensus contract fails to validate the `ConfirmedIrreversibleBlockHeight` field during `NextRound` and `NextTerm` transitions, allowing any authorized miner to decrease the Last Irreversible Block (LIB) height. This violates the critical consensus invariant that LIB must be monotonically increasing, potentially compromising cross-chain security and consensus finality guarantees.

## Finding Description

The vulnerability exists due to three interconnected design flaws in the consensus validation logic:

**1. Direct Conversion Without Validation**

The `ToRound()` method in both `NextRoundInput` and `NextTermInput` performs direct field-by-field conversion including `ConfirmedIrreversibleBlockHeight` without any validation checks: [1](#0-0) [2](#0-1) 

**2. Missing Validation Provider for NextRound/NextTerm**

The `LibInformationValidationProvider`, which explicitly checks that LIB height doesn't decrease, is only added to the validation pipeline for `UpdateValue` behavior. It is completely omitted for `NextRound` and `NextTerm` behaviors: [3](#0-2) 

The `LibInformationValidationProvider` contains the logic to prevent LIB regression: [4](#0-3) 

**3. Hash Validation Excludes LIB Height**

The post-execution validation compares round hashes, but the `GetCheckableRound()` method deliberately excludes `ConfirmedIrreversibleBlockHeight` from the hash calculation, only including `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge`: [5](#0-4) [6](#0-5) 

**Attack Execution Path:**

1. Malicious miner calls `GetConsensusCommand` during round/term transition and receives `NextRound`/`NextTerm` behavior
2. Miner calls `GetConsensusExtraData` which generates legitimate Round data via `GenerateNextRoundInformation`: [7](#0-6) 

3. Miner modifies the `ConfirmedIrreversibleBlockHeight` field in the Round to a lower value
4. Miner produces block with manipulated consensus data
5. During validation, `ValidateBeforeExecution` executes but does NOT apply `LibInformationValidationProvider`
6. Transaction executes, calling `ProcessNextRound` which converts via `ToRound()` without validation: [8](#0-7) 

7. Manipulated Round is stored to state: [9](#0-8) 

8. Post-execution validation passes because hash comparison excludes LIB height

## Impact Explanation

**HIGH Severity** - This vulnerability directly compromises fundamental blockchain security properties:

**Consensus Finality Violation:**
The Last Irreversible Block (LIB) represents the consensus finality boundary - blocks below this height are guaranteed to never be reverted. Allowing LIB to decrease violates this core guarantee, undermining the entire security model of the blockchain.

**Cross-Chain Security Compromise:**
Cross-chain operations explicitly rely on LIB for safety. The codebase shows cross-chain indexing uses LIB to determine which blocks are safe to index. A manipulated LIB could enable:
- Cross-chain transactions based on non-finalized blocks
- Double-spend attacks across chains if non-final blocks are treated as final
- Merkle proof validation against incorrect finality assumptions

**Consensus State Corruption:**
All nodes would accept the manipulated LIB value since validation passes, leading to:
- Network-wide agreement on incorrect finality state
- Subsequent consensus decisions based on false finality assumptions
- Potential for cascading failures if other components depend on LIB accuracy

The vulnerability affects a **critical consensus invariant** with direct security implications for both single-chain and cross-chain operations.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood** - The attack is highly feasible:

**Attacker Capabilities:**
- Any authorized miner in the current miner list can exploit this
- No special privileges beyond normal mining rights required
- Authorized miners are regular operational entities, not trusted roles

**Attack Simplicity:**
- Straightforward data manipulation (modify one integer field)
- No cryptographic barriers (field not protected by signatures)
- Legitimate consensus data generation can be obtained via contract calls
- Manipulation happens client-side before block production

**Frequency of Opportunity:**
- Round transitions occur regularly in normal operations (every round completion)
- Term transitions occur periodically
- Each transition presents an exploitation opportunity

**Detection Difficulty:**
- No validation error raised during execution
- Round hash validation passes (LIB not in hash)
- Subsequent `UpdateValue` operations would recalculate LIB, but the vulnerability window allows exploitation
- Silent acceptance by all network nodes

## Recommendation

Add `LibInformationValidationProvider` to the validation pipeline for `NextRound` and `NextTerm` behaviors in the `ValidateBeforeExecution` method:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        // ADD THIS LINE:
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        // ADD THIS LINE:
        validationProviders.Add(new LibInformationValidationProvider());
        break;
}
```

Alternatively, include `ConfirmedIrreversibleBlockHeight` in the `GetCheckableRound()` method to ensure hash validation catches manipulation, though validation at the pre-execution stage is more robust.

## Proof of Concept

```csharp
// Test demonstrating LIB regression during NextRound
[Fact]
public async Task NextRound_Should_Reject_Decreased_LIB()
{
    // Setup: Initialize consensus with current LIB at height 100
    var currentRound = await GenerateRoundWithLIB(100);
    
    // Attacker: Miner generates NextRound with decreased LIB
    var maliciousNextRound = GenerateNextRoundInput(currentRound);
    maliciousNextRound.ConfirmedIrreversibleBlockHeight = 50; // Decreased from 100
    
    // Execute: Process the malicious NextRound
    var result = await ConsensusContract.NextRound.SendAsync(maliciousNextRound);
    
    // Verify: Transaction succeeds (vulnerability)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Malicious LIB is now in state
    var newRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.ConfirmedIrreversibleBlockHeight.ShouldBe(50); // LIB decreased - vulnerability confirmed
}
```

**Notes:**

The vulnerability is confirmed by tracing the complete execution path through the consensus contract. The absence of `LibInformationValidationProvider` for `NextRound` and `NextTerm` behaviors, combined with the exclusion of LIB height from hash validation, creates a complete bypass of finality protection. This represents a critical gap in the consensus validation logic that violates the monotonicity requirement of the Last Irreversible Block height.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L99-124)
```csharp
    /// <summary>
    ///     Will force to generate a `Change` to tx executing result.
    /// </summary>
    /// <param name="round"></param>
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```
