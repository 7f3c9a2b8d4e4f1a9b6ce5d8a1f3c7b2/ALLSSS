# Audit Report

## Title
Consensus Order Manipulation via Hash.Empty PreviousInValue Selection

## Summary
Miners can manipulate their block production order in subsequent rounds by strategically choosing whether to reveal their `previousInValue` or withhold it. The signature used for order calculation is computed once and never recalculated after secret sharing recovery, allowing miners to pre-compute both scenarios and select the more favorable mining position.

## Finding Description

The vulnerability exists in the consensus block production flow where miners can influence their position in future rounds through selective disclosure of their `previousInValue`.

**Vulnerable Flow:**

When a miner produces a block via `UpdateValue` behavior, the `GetConsensusExtraDataToPublishOutValue` function initializes `previousInValue` to `Hash.Empty`: [1](#0-0) 

If the miner does not provide a valid `previousInValue` (or provides null/Hash.Empty), the code generates a fallback value: [2](#0-1) 

The signature is calculated using either the provided or fallback value, which XORs it with all previous round signatures: [3](#0-2) 

This signature directly determines the miner's order in the next round through modulo arithmetic: [4](#0-3) 

**Critical Failure Points:**

1. **Validation explicitly permits Hash.Empty** - The validation layer treats `Hash.Empty` as valid: [5](#0-4) 

2. **Protocol acknowledges miners can withhold values** - The consensus processing explicitly allows non-disclosure: [6](#0-5) 

3. **Signature never recalculated after recovery** - While secret sharing can recover `previousInValue` later: [7](#0-6) [8](#0-7) 

The signature used for order calculation is already set and stored in the round state, never being recalculated.

4. **Miners control trigger information** - Node-side code generates the trigger information, which miners can modify: [9](#0-8) 

**Attack Execution:**

A miner in Round N+1 can:
1. Know their secret `previousInValue` X from Round N
2. Read all public signatures from previous rounds (on-chain data)
3. Pre-compute: `SignatureA = CalculateSignature(X)` → Order A
4. Pre-compute: `SignatureB = CalculateSignature(fakePreviousInValue)` → Order B  
5. Choose to provide X or withhold it based on which order is more favorable
6. Execute the chosen path through their node's trigger information provider

## Impact Explanation

**Consensus Integrity Compromise:**
This vulnerability fundamentally breaks the unpredictability guarantee of the AEDPoS consensus mechanism. The order calculation is designed to be cryptographically random based on secret values that are revealed sequentially, preventing miners from gaming their positions. By allowing miners to choose between revealing or withholding their `previousInValue`, the protocol enables position manipulation.

**Economic Advantage:**
Block production order directly correlates with mining rewards and influence:
- Earlier positions have more frequent opportunities to produce blocks
- First producers have transaction selection advantages  
- Consistent manipulation compounds over time
- In a system with N miners, consistently securing positions 1-3 instead of random positions provides approximately (N-2)/N more opportunities

**Cumulative & Undetectable:**
The attack can be executed every round without detection since both code paths are explicitly permitted by validation. No on-chain evidence distinguishes intentional manipulation from legitimate edge cases (first-round miners, newly joined validators).

**Affected Parties:**
- Honest miners face unfair competition and reduced rewards
- Network decentralization degrades as manipulating miners gain disproportionate control
- Users risk censorship if manipulators dominate transaction ordering

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active consensus miner (requires staking and election, but this is the target role)
- Access to previous round state data (publicly available on-chain)
- Basic computational capability (XOR operations and modulo arithmetic)

**Attack Complexity: LOW**
The attack requires minimal sophistication:
1. Query on-chain round state for previous signatures
2. Locally compute two signatures with different inputs
3. Compare resulting order positions  
4. Modify node trigger information to select preferred path

**Feasibility: HIGHLY FEASIBLE**
All preconditions are satisfied:
- Entry point is the standard `UpdateValue` public method
- No special permissions beyond being a miner (expected role)
- No economic cost or penalty mechanism exists
- Both code paths are explicitly valid per contract logic
- Miners control their own node implementations

**Detection: IMPOSSIBLE**
The attack is indistinguishable from legitimate behavior:
- `Hash.Empty` is explicitly permitted by validation
- No on-chain metric can differentiate intentional manipulation from edge cases
- Transaction structure remains identical
- Protocol explicitly acknowledges miners may withhold values

**Economic Rationality:**
Exploitation provides guaranteed positive expected value with zero cost or detection risk, making it economically irrational NOT to exploit if discovered.

## Recommendation

**Primary Fix: Signature Recalculation After Recovery**

The signature should be recalculated after `previousInValue` recovery during round transitions. Modify the round generation logic to recompute signatures when transitioning to the next round:

In `GenerateNextRoundInformation`, after miners' information is set, add signature recalculation for miners whose `previousInValue` was recovered via secret sharing.

**Alternative Fix: Require Valid PreviousInValue**

Modify validation to reject `Hash.Empty` as a valid `previousInValue` except for the first round of each term:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;
    
    // REMOVE: if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;
    
    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    // MODIFY: Reject Hash.Empty unless first round of term
    if (previousInValue == Hash.Empty || previousInValue == null) 
    {
        // Only allow for first round of term
        return validationContext.CurrentRound.RoundNumber == 1;
    }
    
    return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
}
```

**Additional Hardening:**

Implement penalties for miners who consistently fail to provide valid `previousInValue`, tracking this metric over multiple rounds.

## Proof of Concept

Due to the complexity of the AEDPoS consensus system requiring full node simulation with multiple miners, secret sharing, and round transitions, a complete PoC would require:

1. Setting up a test network with multiple consensus nodes
2. Modifying one node's `AEDPoSTriggerInformationProvider` to implement the attack strategy
3. Observing that the attacking node consistently achieves better order positions over multiple rounds
4. Verifying that validation passes and no penalties occur

The vulnerability is evident from code analysis showing:
- No recalculation of signature after secret sharing recovery
- Explicit permission for `Hash.Empty` in validation  
- Miner control over trigger information generation
- Order calculation directly depending on signature without post-recovery adjustment

The theoretical attack path is fully validated by the implementation, making exploitation straightforward for any miner with access to their node's codebase.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L70-70)
```csharp
        var previousInValue = Hash.Empty; // Just initial previous in value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L94-108)
```csharp
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L149-152)
```csharp
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-53)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L56-67)
```csharp
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
            Logger.LogDebug($"New in value {newInValue} for round of id {hint.RoundId}");
            Logger.LogDebug($"Previous in value {previousInValue} for round of id {hint.PreviousRoundId}");
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = newInValue,
                PreviousInValue = previousInValue,
                Behaviour = hint.Behaviour
            };

            return trigger.ToBytesValue();
```
