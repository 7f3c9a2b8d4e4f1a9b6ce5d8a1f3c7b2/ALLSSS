# Audit Report

## Title
Missing Miner Order Validation in NextTerm Allows Mining Schedule Manipulation

## Summary
The NextTerm consensus transition lacks validation of miner Order values in the provided Round object. A malicious miner producing a NextTerm block can arbitrarily modify Order assignments for the next term, bypassing the protocol's deterministic order assignment mechanism and manipulating the mining schedule for an entire term duration.

## Finding Description

The AEDPoS consensus protocol expects miner Order values to be deterministically assigned by sorting miners by their public key's first byte in descending order and assigning sequential positions. [1](#0-0) 

However, the NextTerm validation flow contains a critical gap. `NextTermInput.Create()` simply copies the `RealTimeMinersInformation` dictionary from the provided Round object without any validation of Order correctness: [2](#0-1) 

When validating NextTerm behavior in `ValidateBeforeExecution`, the validation provider list for NextTerm only includes `RoundTerminateValidationProvider` beyond the basic providers, notably omitting the `NextRoundMiningOrderValidationProvider` that is used for NextRound transitions: [3](#0-2) 

The `RoundTerminateValidationProvider` only validates that the round number and term number increment correctly, and that InValues are null - it does NOT validate Order consistency: [4](#0-3) 

The `TimeSlotValidationProvider` calls `CheckRoundTimeSlots()` to validate time slot spacing, but this method orders miners by the PROVIDED Order values without verifying they match the expected deterministic assignment: [5](#0-4) 

Finally, in `ProcessNextTerm`, the provided Round is directly converted and added to state without any additional Order validation: [6](#0-5) 

**Attack Scenario:**
1. Malicious miner's turn to produce NextTerm block arrives
2. Miner calls `GetConsensusExtraDataForNextTerm` which generates a Round with correct deterministic Orders
3. Before including in block header, attacker modifies Order values (e.g., assigns themselves Order 1, swaps with other miners)
4. Attacker ensures ExpectedMiningTimes remain evenly spaced to pass `CheckRoundTimeSlots`
5. Block is broadcast with malicious consensus extra data
6. Validation passes because no validator checks Order correctness
7. `ProcessNextTerm` executes, storing corrupted Order assignments for entire next term
8. Mining schedule is now manipulated according to attacker's modifications

## Impact Explanation

This vulnerability has **HIGH** severity impact due to direct consensus integrity violation:

**Consensus Mechanism Compromise**: The fundamental guarantee of deterministic, fair miner ordering based on cryptographic public key sorting is completely bypassed. The protocol assumes Order values follow the deterministic assignment defined in `MinerList.GenerateFirstRoundOfNewTerm`, and all mining schedule logic depends on this invariant.

**Mining Schedule Manipulation**: An attacker can:
- Assign themselves the earliest Order positions (Order 1, 2) to mine first blocks of each round
- Swap Orders with colluding miners to create favorable mining sequences
- Manipulate which miners get extra block producer privileges
- Potentially cause timing conflicts where honest miners miss their slots due to incorrect Order expectations

**Protocol-Wide Impact**: Once corrupted Orders are stored in state, they affect:
- All round progression for the entire term (typically 7 days based on `PeriodSeconds`)
- Time slot calculations for every miner
- Extra block producer selection
- Mining reward distribution expectations

**No Self-Correcting Mechanism**: The corrupted Orders persist for the full term duration. There is no automatic recovery - the protocol will use the manipulated values until the next term transition, which could be exploited again.

## Likelihood Explanation

This vulnerability has **MODERATE-HIGH** likelihood of exploitation:

**Attacker Requirements Met**: The attacker must be an authorized miner eligible to produce the NextTerm block. This is not a high barrier since:
- Term transitions occur regularly (every 7 days by default)
- Any miner in the current term rotation can produce the NextTerm block when conditions are met
- The protocol explicitly allows any qualified miner to trigger term transitions

**Low Technical Complexity**: Exploitation requires:
1. Standard miner capabilities (already authorized to produce blocks)
2. Parsing and modifying a protobuf Round object (straightforward)
3. Ensuring ExpectedMiningTimes maintain valid spacing (simple arithmetic)
4. No cryptographic bypasses or complex state manipulation needed

**No Detection During Validation**: The malicious Orders pass all validation checks because:
- No validator compares Orders against expected deterministic assignment from `GetVictories()`
- No validator regenerates the Round to verify correctness
- `TimeSlotValidationProvider` accepts any Orders as long as time spacing is valid
- The VRF random number check protects randomness but not the Round structure itself

**Economic Incentive**: Attackers gain:
- Earlier mining positions → more blocks produced → higher rewards
- Ability to frontrun transactions (MEV extraction)
- Increased influence over block production
- Potential to disadvantage competing miners

## Recommendation

Add an Order validation provider for NextTerm similar to `NextRoundMiningOrderValidationProvider` used for NextRound transitions. The validator should:

1. Retrieve the expected miner list via `GetVictories()` from the Election contract
2. Generate the expected Order assignments by sorting miners deterministically (by public key first byte descending)
3. Compare the provided Round's Order values against the expected values
4. Reject the block if any Order value doesn't match the expected deterministic assignment

Specifically, modify `ValidateBeforeExecution` to include a new `NextTermMiningOrderValidationProvider`: [7](#0-6) 

Create a new validation provider that:
- Calls `TryToGetVictories()` to get the official miner list
- Generates expected Round using `MinerList.GenerateFirstRoundOfNewTerm`
- Compares each miner's Order in the provided Round against the expected Order
- Returns validation failure if any Order mismatch is detected

## Proof of Concept

A proof of concept would demonstrate:
1. Setting up a test chain with multiple miners
2. Advancing to a term transition point
3. Having a malicious miner generate NextTerm consensus data with modified Order values
4. Showing that the block is accepted and the corrupted Orders are stored in state
5. Verifying that subsequent rounds in the new term use the manipulated Order values

The test would call `NextTerm` with a `NextTermInput` containing a Round object where Order values have been swapped from their expected deterministic assignment, and verify that no validation failure occurs and the malicious Orders persist in contract state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L9-12)
```csharp
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-35)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```
