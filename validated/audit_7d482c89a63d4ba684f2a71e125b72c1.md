# Audit Report

## Title
Missing Extra Block Producer Validation Causes Denial of Service in Consensus and Cross-Chain Operations

## Summary
The AEDPoS consensus contract fails to validate that exactly one extra block producer exists in round information during `NextRound` transactions. A malicious miner can exploit this validation gap to submit malformed round data with no extra block producer, causing permanent denial of service for critical operations including cross-chain indexing and transaction fee claiming due to unhandled exceptions in subsequent method calls.

## Finding Description

The vulnerability exists in the consensus round validation and processing logic. The `GetNextMinerPubkey()` method assumes an extra block producer always exists and uses `.First(m => m.IsExtraBlockProducer)` without prior validation [1](#0-0) . Similarly, `IsCurrentMiner()` uses `.Single(m => m.Value.IsExtraBlockProducer)` which throws if zero or multiple extra block producers exist [2](#0-1) .

The `RoundTerminateValidationProvider` only validates round number increment and that InValues are null, but never checks the extra block producer invariant [3](#0-2) . This validation provider is used when processing `NextRound` behavior [4](#0-3) .

**Attack Propagation:**
1. A malicious miner crafts a `NextRoundInput` where all miners have `IsExtraBlockProducer = false` [5](#0-4) 
2. During their mining slot, they submit this via the public `NextRound()` method [6](#0-5) 
3. `PreCheck()` validates only that the sender is a miner, not the round data content [7](#0-6) 
4. The malformed round passes validation and gets stored via `ProcessNextRound()` [8](#0-7) 
5. All subsequent operations that call `IsCurrentMiner()` or `GetNextMinerPubkey()` throw `InvalidOperationException`

While normal round generation always sets exactly one extra block producer [9](#0-8) , this is client-side code that can be bypassed by crafting custom `NextRoundInput` messages [10](#0-9) .

## Impact Explanation

**Critical Operations Permanently Disabled:**

1. **Cross-Chain Indexing DoS**: Both `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal` call `AssertAddressIsCurrentMiner()` [11](#0-10) , which invokes `CheckCrossChainIndexingPermission` [12](#0-11) . This calls `IsCurrentMiner()` [13](#0-12) , which throws on the malformed round. All cross-chain synchronization between parent and side chains halts permanently.

2. **Transaction Fee Claiming DoS**: The `ClaimTransactionFees` method calls `AssertSenderIsCurrentMiner()` [14](#0-13) , which checks `IsCurrentMiner()` [15](#0-14) . Miners cannot claim accumulated transaction fees, causing severe economic disruption and potential miner exodus.

3. **View Method Failures**: External monitoring systems and block production coordination tools that call `GetNextMinerPubkey()` receive unhandled exceptions, breaking consensus monitoring infrastructure.

**Severity Justification:** This is HIGH severity because it causes permanent denial of service for critical protocol operations (cross-chain communication and fee distribution) with a single malicious transaction, requiring only standard miner privileges.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in current/previous round (achievable through election process)
- Transaction must be submitted during their assigned time slot
- Requires normal consensus privileges, not special authorization

**Attack Complexity:**
- LOW: Attacker modifies client-side round generation to set all `IsExtraBlockProducer = false` or multiple to `true`
- Submits via standard `NextRound` transaction
- Single transaction execution sufficient

**Feasibility:**
- Probability of being scheduled miner: ≈1/N per round (typically N=17-21)
- No cryptographic or mathematical barriers
- No runtime validation prevents submission
- Cost: standard transaction fee only (negligible compared to impact)

**Detection:**
- Attack succeeds silently during validation
- Impact manifests only when subsequent operations execute
- No immediate detection mechanism or rollback capability

Likelihood is HIGH given guaranteed periodic miner access, minimal cost, absence of preventive validation, and clear economic/competitive incentives for disruption.

## Recommendation

Add validation in `RoundTerminateValidationProvider` to ensure exactly one extra block producer exists:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // Add validation for extra block producer
    var extraBlockProducerCount = extraData.Round.RealTimeMinersInformation.Values.Count(m => m.IsExtraBlockProducer);
    if (extraBlockProducerCount != 1)
        return new ValidationResult { Message = "Exactly one extra block producer must be designated." };
    
    return new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousNextRound_WithNoExtraBlockProducer_CausesDoS()
{
    // Setup: Initialize consensus with miners
    var initialMiners = GetInitialMiners();
    await InitializeConsensus(initialMiners);
    
    // Attacker: Active miner crafts malicious NextRoundInput
    var maliciousRound = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = 
        {
            // All miners have IsExtraBlockProducer = false
            { "miner1", new MinerInRound { Pubkey = "miner1", Order = 1, IsExtraBlockProducer = false } },
            { "miner2", new MinerInRound { Pubkey = "miner2", Order = 2, IsExtraBlockProducer = false } }
        },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Execute malicious NextRound during attacker's time slot
    var result = await ConsensusContract.NextRound.SendAsync(maliciousRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Cross-chain indexing now throws exception
    var crossChainResult = await CrossChainContract.ProposeCrossChainIndexing.SendAsync(crossChainData);
    crossChainResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    crossChainResult.TransactionResult.Error.ShouldContain("InvalidOperationException");
    
    // Verify: Fee claiming now throws exception
    var feeClaimResult = await TokenContract.ClaimTransactionFees.SendAsync(feeMap);
    feeClaimResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    feeClaimResult.TransactionResult.Error.ShouldContain("InvalidOperationException");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L91-102)
```csharp
    public override StringValue GetNextMinerPubkey(Empty input)
    {
        if (TryToGetCurrentRoundInformation(out var round))
            return new StringValue
            {
                Value = round.RealTimeMinersInformation.Values
                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??
                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey
            };

        return new StringValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** protobuf/aedpos_contract.proto (L458-481)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-302)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }

    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-895)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
        Context.LogDebug(() => $"Claim transaction fee. {input}");
        State.LatestTotalTransactionFeesMapHash.Value = HashHelper.ComputeFrom(input);
        foreach (var bill in input.Value)
        {
            var symbol = bill.Key;
            var amount = bill.Value;
            ModifyBalance(Context.Self, symbol, amount);
            Context.Fire(new TransactionFeeClaimed
            {
                Symbol = symbol,
                Amount = amount,
                Receiver = Context.Self
            });
            
            TransferTransactionFeesToFeeReceiver(symbol, amount);
        }

        Context.LogDebug(() => "Finish claim transaction fee.");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```
