# Audit Report

## Title
Unvalidated Secret Reconstruction in RevealSharedInValues Allows Consensus State Corruption

## Summary
The `RevealSharedInValues` function reconstructs miners' InValues from DecryptedPieces using Shamir's Secret Sharing without validating that the reconstructed secret matches the original OutValue hash. A malicious miner can submit corrupted DecryptedPieces via UpdateValue transactions, causing incorrect PreviousInValue storage that propagates to signature calculations and corrupts consensus randomness.

## Finding Description

The vulnerability exists in the AEDPoS consensus secret sharing mechanism where reconstructed InValues are not validated against their original commitments.

**Missing Validation in Secret Reconstruction**: The `RevealSharedInValues` function collects DecryptedPieces from miners in the previous round and reconstructs InValues using Lagrange interpolation. [1](#0-0)  The reconstructed value is directly stored as `PreviousInValue` without verifying that `Hash(revealedInValue)` equals the original `OutValue` stored in the previous round. [2](#0-1) 

**Unvalidated DecryptedPieces Acceptance**: When miners submit UpdateValue transactions, `PerformSecretSharing` accepts and stores their DecryptedPieces without correctness validation. [3](#0-2) 

**Validation Gap**: The existing `UpdateValueValidationProvider` only validates the sender's own PreviousInValue against their previous OutValue, not the revealed PreviousInValues reconstructed for other miners through secret sharing. [4](#0-3) 

**Corrupted Value Usage**: When miners fail to produce blocks, `SupplyCurrentRoundInformation` retrieves the potentially corrupted `PreviousInValue` and uses it to calculate signatures. [5](#0-4) 

**Impact on Consensus**: The signature calculation XORs the inValue with all miners' signatures, so one corrupted signature affects the collective result used for mining order determination. [6](#0-5)  Mining order is calculated from signatures using modulo arithmetic. [7](#0-6) 

**Attack Vector**: A malicious miner submits UpdateValue with corrupted DecryptedPieces. Since Shamir's Secret Sharing has no error correction, even one corrupted share among the 2/3 threshold produces a completely incorrect reconstruction. [8](#0-7)  The reconstruction always succeeds via Lagrange interpolation regardless of input validity.

**Execution Flow**: RevealSharedInValues is called during round transitions when the extra block producer creates consensus data for the next round. [9](#0-8) 

## Impact Explanation

**Critical Consensus Integrity Violation**: This vulnerability breaks the core security guarantee of the AEDPoS consensus mechanism - correct round transitions and verifiable randomness. When corrupted DecryptedPieces cause incorrect PreviousInValue reconstruction, subsequent signature calculations become wrong, directly affecting:

1. **Consensus Randomness**: Signatures are combined via XOR to generate randomness for mining order selection. One corrupted signature pollutes the entire result through the XOR operation.

2. **Mining Schedule Integrity**: The corrupted signature produces incorrect mining order calculations through the modulo arithmetic, potentially allowing attackers to manipulate block production scheduling and gain unfair advantages.

3. **Cryptographic Chain Break**: The InValue→OutValue→Signature chain that ensures consensus unpredictability is broken for affected miners, compromising the Byzantine fault tolerance properties that AEDPoS relies upon.

All miners and the consensus mechanism are affected because miners who fail to produce blocks have their signatures filled using the corrupted PreviousInValue, propagating the corruption through subsequent rounds.

## Likelihood Explanation

**High Likelihood - Low Complexity Attack**:

**Attacker Requirements**: Any miner in the consensus set can execute this attack, requiring only:
- Miner status (achievable through normal staking/election process)
- Ability to submit UpdateValue transactions (standard consensus participation)

**Attack Execution**: The attacker simply provides corrupted byte arrays as DecryptedPieces values when submitting UpdateValue. The attack succeeds because:
- No validation checks DecryptedPieces correctness before storage
- Shamir's Secret Sharing inherently fails completely with any corrupted share
- If the attacker's piece is among the first 2/3 threshold used for reconstruction, the result is guaranteed wrong
- The corruption is silent - no errors are thrown, wrong values are stored normally

**Detection Difficulty**: The attack is difficult to detect because the incorrect PreviousInValue is stored without errors, and corruption only manifests when signatures don't match expected values in subsequent consensus rounds, which could be attributed to network issues or other factors.

## Recommendation

Add validation in `RevealSharedInValues` to verify that the reconstructed InValue matches the original OutValue commitment:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Validate reconstruction against original commitment
if (HashHelper.ComputeFrom(revealedInValue) != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => $"Failed to reveal in value for {publicKeyOfAnotherMiner}: hash mismatch");
    continue; // Skip this miner, don't store corrupted value
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

This ensures that only correctly reconstructed InValues that match the original OutValue hash commitments are stored as PreviousInValue, preventing consensus state corruption from malicious or corrupted DecryptedPieces.

## Proof of Concept

Based on the existing test structure in the codebase, a test demonstrating this vulnerability would:

1. Set up a consensus round with multiple miners using the `AEDPoSContractTestBase`
2. Have one miner submit `UpdateValue` with intentionally corrupted `DecryptedPieces` (random byte arrays instead of proper decrypted shares)
3. Trigger round transition to invoke `RevealSharedInValues`
4. Verify that the reconstructed `PreviousInValue` for the victim miner is incorrect (doesn't hash to their `OutValue`)
5. Show that this corrupted value is used in subsequent `SupplyCurrentRoundInformation` calls
6. Demonstrate that the corrupted signature affects the consensus randomness calculation

The test would follow the pattern established in `InValueRecoveryTest.cs` [10](#0-9)  but with malicious corrupted pieces instead of properly encrypted/decrypted shares.

## Notes

This vulnerability is particularly severe because:
1. It affects the core consensus mechanism's security properties
2. The attack is silent and difficult to detect
3. It can be executed by any miner without special privileges
4. The corruption propagates across multiple rounds through the signature chain
5. It breaks the cryptographic commit-reveal scheme that AEDPoS depends on for unpredictability

The validation provider infrastructure exists in the codebase [11](#0-10)  but only validates the sender's own values, not the reconstructed values for other miners, creating this critical gap.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-50)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L44-48)
```csharp
        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-64)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/InValueRecoveryTest.cs (L21-62)
```csharp
    public void OffChain_DecryptMessage_Test()
    {
        var message = HashHelper.ComputeFrom("message").ToByteArray();
        var secrets =
            SecretSharingHelper.EncodeSecret(message, MinimumCount,
                EconomicContractsTestConstants.InitialCoreDataCenterCount);
        var encryptedValues = new Dictionary<string, byte[]>();
        var decryptedValues = new Dictionary<string, byte[]>();
        var ownerKeyPair = InitialCoreDataCenterKeyPairs[0];
        var othersKeyPairs = InitialCoreDataCenterKeyPairs.Skip(1).ToList();
        var decryptResult = new byte[0];

        var initial = 0;
        foreach (var keyPair in othersKeyPairs)
        {
            var encryptedMessage = CryptoHelper.EncryptMessage(ownerKeyPair.PrivateKey, keyPair.PublicKey,
                secrets[initial++]);
            encryptedValues.Add(keyPair.PublicKey.ToHex(), encryptedMessage);
        }

        // Check encrypted values.
        encryptedValues.Count.ShouldBe(EconomicContractsTestConstants.InitialCoreDataCenterCount - 1);

        // Others try to recover.
        foreach (var keyPair in othersKeyPairs)
        {
            var cipherMessage = encryptedValues[keyPair.PublicKey.ToHex()];
            var decryptMessage =
                CryptoHelper.DecryptMessage(ownerKeyPair.PublicKey, keyPair.PrivateKey, cipherMessage);
            decryptedValues.Add(keyPair.PublicKey.ToHex(), decryptMessage);

            if (decryptedValues.Count >= MinimumCount)
            {
                decryptResult = SecretSharingHelper.DecodeSecret(
                    decryptedValues.Values.ToList(),
                    Enumerable.Range(1, MinimumCount).ToList(), MinimumCount);
                break;
            }
        }

        decryptResult.ShouldBe(message);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-80)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
```
