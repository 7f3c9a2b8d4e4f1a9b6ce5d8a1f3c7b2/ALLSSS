# Audit Report

## Title
Terminated Side Chains Allow Cross-Chain Token Claims via Unvalidated Transaction Verification

## Summary
The `VerifyTransaction()` function in the CrossChain contract fails to validate whether a side chain has been terminated before verifying cross-chain transactions. When `DisposeSideChain()` is called, it sets the status to `Terminated` but leaves previously indexed block data accessible, allowing attackers to mint tokens using old merkle proofs from terminated chains.

## Finding Description

The vulnerability exists in the cross-chain verification flow. When `CrossChainReceiveToken()` is called, it invokes `CrossChainVerify()` which calls the CrossChain contract's `VerifyTransaction()` method. [1](#0-0) 

The `VerifyTransaction()` method retrieves the merkle tree root via `GetMerkleTreeRoot()`: [2](#0-1) 

**The critical flaw** is in `GetMerkleTreeRoot()` which only checks if `SideChainInfo` exists (`!= null`), but does NOT validate whether the chain's status is `Terminated`: [3](#0-2) 

The method then retrieves indexed data from `State.IndexedSideChainBlockData[parentChainHeight]` which is never cleared upon termination: [4](#0-3) 

When `DisposeSideChain()` is called, it only sets the status to `Terminated` but does not remove the `SideChainInfo` entry or clear the indexed block data: [5](#0-4) 

**In contrast**, NEW indexing operations properly validate the chain status and reject terminated chains: [6](#0-5) 

Similarly, `Recharge()` properly checks for terminated status: [7](#0-6) 

And `AdjustIndexingFeePrice()` also checks for terminated status: [8](#0-7) 

However, these status checks are NOT applied during verification of existing proofs in `GetMerkleTreeRoot()`, creating an inconsistent security boundary.

## Impact Explanation

**Token Supply Inflation:** Attackers can mint tokens on the receiving chain by presenting valid merkle proofs from transactions that occurred before the chain was terminated. Since the indexed data persists indefinitely, there is no time limit on exploitation.

**Cross-Chain Integrity Violation:** The termination status is designed to completely isolate a side chain from the ecosystem. Methods like `Recharge()`, `AdjustIndexingFeePrice()`, and new indexing operations properly enforce this isolation by checking the terminated status. However, the verification path in `GetMerkleTreeRoot()` bypasses this critical check entirely, violating the fundamental security invariant that terminated chains should not participate in ANY cross-chain operations.

**Persistent Exploitation Window:** If a side chain was compromised before being terminated (the likely reason for emergency termination), attackers can continue exploiting old transactions indefinitely. Any unclaimed cross-chain transfer from before termination can be claimed at any point in the future—months or years later—to mint tokens on the receiving chain without corresponding burns on the terminated chain.

## Likelihood Explanation

**Attack Prerequisites:**
- A side chain must be indexed and then terminated (governance-controlled, but realistic for security incidents)
- Attacker needs valid cross-chain transfer transaction bytes from before termination (publicly available from indexed blocks)
- Merkle proofs are derivable from publicly indexed block data

**Execution Complexity:** Very low—the attacker simply calls `CrossChainReceiveToken()` with old transaction bytes and the merkle path. The transaction appears as a legitimate cross-chain token claim and passes all verification checks.

**Detection Difficulty:** The attack is indistinguishable from normal cross-chain token claims. No on-chain mechanism exists to prevent or detect it.

**Probability Assessment:** MEDIUM-HIGH—While chain termination is uncommon, when it occurs (especially for security reasons), this vulnerability guarantees that exploitation is possible and economically rational. The presence of unclaimed cross-chain transfers from before termination makes exploitation inevitable.

## Recommendation

Add a terminated status check in the `GetMerkleTreeRoot()` method to ensure consistency with other cross-chain operations:

```csharp
private Hash GetMerkleTreeRoot(int chainId, long parentChainHeight)
{
    if (chainId == State.ParentChainId.Value)
        return GetParentChainMerkleTreeRoot(parentChainHeight);

    if (State.SideChainInfo[chainId] != null)
    {
        // Add terminated status check
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo.SideChainStatus != SideChainStatus.Terminated, 
            "Cannot verify transactions from terminated side chain.");
        return GetSideChainMerkleTreeRoot(parentChainHeight);
    }

    return GetCousinChainMerkleTreeRoot(parentChainHeight);
}
```

Alternatively, add the check in `GetSideChainMerkleTreeRoot()` or at the `VerifyTransaction()` entry point before retrieving the merkle root.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainReceiveToken_From_Terminated_SideChain_Should_Fail()
{
    // 1. Setup: Create and index a side chain with cross-chain transfers
    var sideChainId = await InitAndCreateSideChainAsync();
    var transferTx = await CreateCrossChainTransferTx(sideChainId, amount: 1000);
    await IndexSideChainBlocks(sideChainId, includeBlock: transferTx.BlockHeight);
    
    // 2. Terminate the side chain via governance
    var disposalProposalId = await DisposeSideChainProposalAsync(new Int32Value { Value = sideChainId });
    await ApproveWithMinersAsync(disposalProposalId);
    await ReleaseProposalAsync(disposalProposalId);
    
    // 3. Verify chain is terminated
    var chainStatus = await CrossChainContractStub.GetChainStatus.CallAsync(new Int32Value { Value = sideChainId });
    chainStatus.Status.ShouldBe(SideChainStatus.Terminated);
    
    // 4. Attempt to claim tokens from terminated chain using old transaction
    var merklePathResult = await GetMerklePathForTransaction(transferTx.TransactionId, transferTx.BlockHeight);
    var receiveResult = await TokenContractStub.CrossChainReceiveToken.SendAsync(new CrossChainReceiveTokenInput
    {
        FromChainId = sideChainId,
        ParentChainHeight = transferTx.BlockHeight,
        TransferTransactionBytes = transferTx.ToByteString(),
        MerklePath = merklePathResult.MerklePath
    });
    
    // VULNERABILITY: This should fail but currently succeeds
    // Expected: receiveResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    // Actual: receiveResult.TransactionResult.Status == TransactionResultStatus.Mined (tokens minted!)
    
    // The attacker successfully minted tokens from a terminated chain
}
```

This test demonstrates that after a side chain is terminated, an attacker can still claim tokens using old merkle proofs, violating the security invariant that terminated chains should be completely isolated from cross-chain operations.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L241-246)
```csharp
    private Hash GetSideChainMerkleTreeRoot(long parentChainHeight)
    {
        var indexedSideChainData = State.IndexedSideChainBlockData[parentChainHeight];
        return ComputeRootWithMultiHash(
            indexedSideChainData.SideChainBlockDataList.Select(d => d.TransactionStatusMerkleTreeRoot));
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L253-264)
```csharp
    private Hash GetMerkleTreeRoot(int chainId, long parentChainHeight)
    {
        if (chainId == State.ParentChainId.Value)
            // it is parent chain
            return GetParentChainMerkleTreeRoot(parentChainHeight);

        if (State.SideChainInfo[chainId] != null)
            // it is child chain
            return GetSideChainMerkleTreeRoot(parentChainHeight);

        return GetCousinChainMerkleTreeRoot(parentChainHeight);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L690-718)
```csharp
    private bool ValidateSideChainBlockData(IEnumerable<SideChainBlockData> sideChainBlockData,
        out Dictionary<int, List<SideChainBlockData>> validatedSideChainBlockData)
    {
        var groupResult = sideChainBlockData.GroupBy(data => data.ChainId, data => data);

        validatedSideChainBlockData = new Dictionary<int, List<SideChainBlockData>>();
        foreach (var group in groupResult)
        {
            var chainId = group.Key;
            validatedSideChainBlockData[chainId] = group.ToList();
            var info = State.SideChainInfo[chainId];
            if (info == null || info.SideChainStatus == SideChainStatus.Terminated)
                return false;
            var currentSideChainHeight = State.CurrentSideChainHeight[chainId];
            var target = currentSideChainHeight != 0
                ? currentSideChainHeight + 1
                : AElfConstants.GenesisBlockHeight;

            foreach (var blockData in group)
            {
                var sideChainHeight = blockData.Height;
                if (target != sideChainHeight)
                    return false;
                target++;
            }
        }

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-179)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L222-242)
```csharp
    public override Int32Value DisposeSideChain(Int32Value input)
    {
        AssertSideChainLifetimeControllerAuthority(Context.Sender);

        var chainId = input.Value;
        var info = State.SideChainInfo[chainId];
        Assert(info != null, "Side chain not found.");
        Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");

        if (TryGetIndexingProposal(chainId, out _))
            ResetChainIndexingProposal(chainId);

        UnlockTokenAndResource(info);
        info.SideChainStatus = SideChainStatus.Terminated;
        State.SideChainInfo[chainId] = info;
        Context.Fire(new Disposed
        {
            ChainId = chainId
        });
        return new Int32Value { Value = chainId };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L244-248)
```csharp
    public override Empty AdjustIndexingFeePrice(AdjustIndexingFeeInput input)
    {
        var info = State.SideChainInfo[input.SideChainId];
        Assert(info != null && info.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");
```
