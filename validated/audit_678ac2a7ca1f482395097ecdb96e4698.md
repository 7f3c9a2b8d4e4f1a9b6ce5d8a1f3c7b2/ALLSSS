# Audit Report

## Title
Uninitialized Rental State Enables Free Resource Usage on Side Chains

## Summary
The side chain rental fee mechanism can be completely bypassed due to missing initialization validation. The `State.Rental` mapping defaults to zero and lacks validation before rental calculations, allowing side chains to consume resources indefinitely without paying rental fees if the rental controller fails to call `UpdateRental` after `InitializeFromParentChain`.

## Finding Description
The vulnerability exists in the rental charging mechanism for side chains within the MultiToken contract. The state variable `State.Rental` is defined as a `MappedState<string, long>` [1](#0-0) , which defaults to 0 for uninitialized keys in C#.

During side chain initialization via `InitializeFromParentChain`, only the `State.ResourceAmount` values are set, but `State.Rental` is not initialized [2](#0-1) . The rental unit values must be set separately through the `UpdateRental` method [3](#0-2) , which requires authorization from the side chain rental controller [4](#0-3) .

The rental calculation in `PayRental()` multiplies the duration, resource amount, and rental unit value [5](#0-4) . If `State.Rental[symbol]` is 0 (uninitialized), the entire rental calculation results in 0, and no fees are charged.

The `PayRental()` function is automatically invoked on side chains when miners call `DonateResourceToken` [6](#0-5) . Critically, there is no validation in `PayRental()` that checks whether `State.Rental[symbol]` has been properly initialized or is greater than zero before performing the rental calculation [7](#0-6) .

The `GetOwningRentalUnitValue()` view function simply reads and returns the current `State.Rental` values without any checks [8](#0-7) , making it possible to observe that rental values are zero but providing no enforcement mechanism.

Test evidence confirms this behavior - the initialization test explicitly calls `UpdateRental` as a separate step after `InitializeFromParentChain` to set rental values [9](#0-8) .

## Impact Explanation
**Economic Impact**: A side chain can exploit this vulnerability to consume computational resources (CPU, RAM, DISK, NET) indefinitely without paying rental fees to the parent chain's consensus contract. This directly violates the economic model where side chains must pay ongoing rental costs proportional to their resource consumption.

**Affected Parties**: 
- Parent chain validators who should receive rental fee distributions lose expected revenue
- The economic security model is undermined as side chains can operate without the intended cost barrier
- Other properly-paying side chains are disadvantaged

**Severity Justification**: HIGH - This represents a complete bypass of the rental fee mechanism, allowing unlimited resource consumption at zero cost. The vulnerability breaks a critical economic invariant (rental fees must be charged for resource usage) and can result in substantial economic loss over time as rental fees accumulate every minute the side chain operates.

## Likelihood Explanation
**Attack Requirements**:
1. Side chain must be initialized via `InitializeFromParentChain` (sets `State.ResourceAmount`)
2. Side chain rental controller must NOT call `UpdateRental` to set rental unit values
3. `DonateResourceToken` is called by miners (happens automatically each block)

**Feasibility**: MEDIUM-HIGH
- The side chain rental controller is typically governed by an association or parliament organization
- Either through malicious intent or operational negligence, the controller could delay or refuse to call `UpdateRental`
- No code-level enforcement requires `UpdateRental` to be called before `DonateResourceToken` executes
- The vulnerability is passively exploited - the attacker simply needs to NOT perform the initialization step

**Detection Constraints**: The issue may go unnoticed initially since:
- `GetOwningRentalUnitValue()` would return zero values, but this might be assumed to be a temporary pre-configuration state
- Rental charges appear to execute successfully (events fire), but with zero amounts
- No transaction reverts or obvious errors occur

**Attack Complexity**: LOW - The "attack" is simply omitting a required initialization step rather than executing complex exploits.

## Recommendation
Add validation to ensure rental values have been properly initialized before allowing rental calculations. Implement one or more of the following fixes:

1. **Add validation in `PayRental()`**: Check that `State.Rental[symbol] > 0` before calculating rental fees, and revert or skip the rental charge if not initialized.

2. **Add validation in `UpdateRental()`**: Modify the assertion to prevent zero rental values: `Assert(pair.Value > 0, "Rental value must be greater than zero.");`

3. **Add initialization requirement**: Modify `InitializeFromParentChain` to require rental values in the input, or add a flag that prevents `DonateResourceToken` from succeeding until `UpdateRental` has been called.

4. **Add view function check**: Create a view function that returns whether rental has been properly initialized, and document that operators must verify this before side chain operation.

The most robust solution is option 3 - requiring rental initialization as part of the side chain setup process, ensuring the economic model is enforced from the start.

## Proof of Concept
The following test demonstrates the vulnerability by showing that when `UpdateRental` is not called after `InitializeFromParentChain`, the rental calculation results in zero fees:

```csharp
[Fact]
public async Task Vulnerability_UninitializedRental_ZeroFeeCharged()
{
    // Setup: Initialize side chain WITHOUT calling UpdateRental
    var defaultParliamentOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Create tokens
    await CreateTokenAsync("ELF", ResourceSupply, true, defaultParliamentOrganization);
    await CreateTokenAsync("CPU", ResourceSupply, true, defaultParliamentOrganization);
    
    // Initialize from parent chain - sets ResourceAmount but NOT Rental
    await ParliamentReachAnAgreementAsync(TokenContractAddress, defaultParliamentOrganization,
        nameof(TokenContractImplContainer.TokenContractImplStub.InitializeFromParentChain),
        new InitializeFromParentChainInput
        {
            ResourceAmount = { { "CPU", 4 } },
            Creator = Creator
        });
    
    await TokenContractStub.SetPrimaryTokenSymbol.SendAsync(new SetPrimaryTokenSymbolInput { Symbol = NativeTokenSymbol });
    await TokenContractStub.InitializeAuthorizedController.SendAsync(new Empty());
    
    // Verify rental is NOT initialized (returns 0)
    var rentalUnitValue = await TokenContractStub.GetOwningRentalUnitValue.CallAsync(new Empty());
    rentalUnitValue.ResourceUnitValue["CPU"].ShouldBe(0); // VULNERABLE STATE
    
    // Check balance before
    var balanceBefore = await GetCreatorBalanceOfAsync("CPU");
    
    // Trigger PayRental by advancing time and calling DonateResourceToken
    await DelayOneMinuteAsync();
    
    // Check balance after - NO fees charged!
    var balanceAfter = await GetCreatorBalanceOfAsync("CPU");
    balanceAfter.ShouldBe(balanceBefore); // VULNERABILITY: Balance unchanged, zero rental charged
}
```

This test proves that without calling `UpdateRental`, the rental mechanism charges zero fees despite resource consumption occurring over time.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L31-31)
```csharp
    public MappedState<string, long> Rental { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-952)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }

        Assert(donateResourceTokenExecuteHeight == Context.CurrentHeight,
            $"This method already executed in height {State.DonateResourceTokenExecuteHeight.Value}");
        State.DonateResourceTokenExecuteHeight.Value = donateResourceTokenExecuteHeight.Add(1);
        Context.LogDebug(() => $"Start donate resource token. {input}");
        State.LatestTotalResourceTokensMapsHash.Value = HashHelper.ComputeFrom(input);
        Context.LogDebug(() =>
            $"Now LatestTotalResourceTokensMapsHash is {State.LatestTotalResourceTokensMapsHash.Value}");

        var isMainChain = true;
        if (State.DividendPoolContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            if (treasuryContractAddress == null)
            {
                isMainChain = false;
            }
            else
            {
                State.DividendPoolContract.Value = treasuryContractAddress;
            }
        }

        PayResourceTokens(input, isMainChain);

        if (!isMainChain)
        {
            PayRental();
        }

        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1019-1097)
```csharp
    private void PayRental()
    {
        var creator = State.SideChainCreator.Value;
        if (creator == null) return;
        if (State.LastPayRentTime.Value == null)
        {
            // Initial LastPayRentTime first calling DonateResourceToken.
            State.LastPayRentTime.Value = Context.CurrentBlockTime;
            return;
        }

        // We need minutes.
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
        if (duration == 0)
        {
            return;
        }

        // Update LastPayRentTime if it is ready to charge rental.
        State.LastPayRentTime.Value += new Duration { Seconds = duration.Mul(60) };

        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);

            // Try to update owning rental.
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }

            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
            {
                donates = donates.Add(rental);
                ModifyBalance(creator, symbol, -donates);
            }
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }

            // Side Chain donates.
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);

            Context.Fire(new RentalCharged()
            {
                Symbol = symbol,
                Amount = donates,
                Payer = creator,
                Receiver = consensusContractAddress
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1099-1112)
```csharp
    public override Empty UpdateRental(UpdateRentalInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.Rental)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.Rental[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L407-413)
```csharp
    private void AssertControllerForSideChainRental()
    {
        Assert(State.SideChainRentalController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(State.SideChainRentalController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L170-177)
```csharp
    public override OwningRentalUnitValue GetOwningRentalUnitValue(Empty input)
    {
        var rentalResourceUnitValue = new OwningRentalUnitValue();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
            rentalResourceUnitValue.ResourceUnitValue[symbol] = State.Rental[symbol];

        return rentalResourceUnitValue;
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L294-333)
```csharp
    private async Task InitialTokenContractAsync(bool issueToken = true)
    {
        var defaultParliamentOrganization =
            await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        await CreateTokenAsync("ELF", ResourceSupply, issueToken, defaultParliamentOrganization);
        await CreateTokenAsync("CPU", ResourceSupply, issueToken, defaultParliamentOrganization);
        await CreateTokenAsync("RAM", ResourceSupply, issueToken, defaultParliamentOrganization);
        await CreateTokenAsync("DISK", ResourceSupply, issueToken, defaultParliamentOrganization);
        await CreateTokenAsync("NET", ResourceSupply, issueToken, defaultParliamentOrganization);
        var setSideChainCreatorProposalInput = new InitializeFromParentChainInput
        {
            ResourceAmount =
            {
                { "CPU", CpuAmount },
                { "RAM", RamAmount },
                { "DISK", DiskAmount },
                { "NET", NetAmount }
            },
            Creator = Creator
        };
        await ParliamentReachAnAgreementAsync(TokenContractAddress, defaultParliamentOrganization,
            nameof(TokenContractImplContainer.TokenContractImplStub.InitializeFromParentChain),
            setSideChainCreatorProposalInput);

        var updateRentalInput = new UpdateRentalInput
        {
            Rental =
            {
                { "CPU", Rental },
                { "RAM", Rental },
                { "DISK", Rental },
                { "NET", Rental }
            }
        };
        await TokenContractStub.SetPrimaryTokenSymbol.SendAsync(new SetPrimaryTokenSymbolInput
            { Symbol = NativeTokenSymbol });
        await TokenContractStub.InitializeAuthorizedController.SendAsync(new Empty());
        await UpdateSideChainRentalDefaultProposalAsync(
            nameof(TokenContractImplContainer.TokenContractImplStub.UpdateRental), updateRentalInput);
    }
```
