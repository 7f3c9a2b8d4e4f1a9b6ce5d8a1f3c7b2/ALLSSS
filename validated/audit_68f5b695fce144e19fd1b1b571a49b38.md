# Audit Report

## Title
Signature Reuse Vulnerability Allows Miners to Manipulate Mining Order

## Summary
The AEDPoS consensus contract does not validate that the signature submitted by miners is correctly calculated for the current round. Miners can reuse signatures from previous rounds to manipulate their mining order in subsequent rounds, breaking the randomness mechanism that ensures fair miner rotation.

## Finding Description

The vulnerability exists in the signature validation flow of the AEDPoS consensus mechanism. The signature is expected to be calculated as `previousRound.CalculateSignature(previousInValue)`, where `CalculateSignature` XORs the previousInValue with all miners' signatures from the previous round to create collective randomness. [1](#0-0) 

When generating consensus extra data, the signature is correctly calculated using this method: [2](#0-1) 

This signature should determine the miner's order in the next round through the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1`: [3](#0-2) 

However, when processing the UpdateValue transaction, the signature is directly assigned from user input without any validation: [4](#0-3) 

The only validation performed by `UpdateValueValidationProvider` checks that the signature field is non-empty and that previousInValue correctly hashes to previousOutValue, but does NOT verify the signature calculation: [5](#0-4) 

The FinalOrderOfNextRound value set from user input directly determines the miner's position in the subsequent round: [6](#0-5) 

## Impact Explanation

This vulnerability undermines the core randomness mechanism of the AEDPoS consensus protocol:

1. **Order Manipulation**: Miners can choose from their historical signatures to influence their position in the next round's mining order, potentially securing first position, avoiding specific time slots, or positioning themselves strategically relative to other miners.

2. **Consensus Integrity Breach**: The AEDPoS protocol's security relies on unpredictable miner ordering to prevent censorship and ensure fair block production. By selecting favorable signatures, malicious miners can front-run specific transactions by securing earlier time slots, avoid producing blocks during periods of network instability, or coordinate with other miners to manipulate the overall mining schedule.

3. **Fairness Violation**: The consensus mechanism is designed so that mining order depends on collective input from all miners (through signature XOR aggregation). Signature reuse allows individual miners to bypass this collective randomness and gain unfair advantages.

4. **Cascading Effects**: Since each round's signatures influence the next round's order calculation, a malicious miner's manipulation in one round can have ripple effects across multiple subsequent rounds.

## Likelihood Explanation

The attack is highly practical and executable by any miner:

**Attacker Capabilities**: Any authorized miner can exploit this vulnerability. The attacker only needs to:
- Maintain a history of their own previous signatures (publicly available on-chain)
- Calculate the resulting mining order for each historical signature
- Select and submit the signature that yields the most favorable position

**Attack Complexity**: Low. The attack requires no cryptographic sophistication:
1. Query historical round data to retrieve old signatures
2. For each candidate signature, compute `(signature.ToInt64() % minersCount) + 1` to predict the resulting order
3. Submit the UpdateValue transaction with the chosen signature and corresponding order instead of the correctly calculated values

**Feasibility Conditions**: The attack is always feasible because the UpdateValue method is callable by any current miner, no validation compares the submitted signature against the expected value, and the previousInValue validation is independent of signature correctness.

**Detection Difficulty**: The attack is difficult to detect because signatures are hash values with no inherent structure revealing their origin, and each signature appears legitimate in isolation without comparing to the expected calculation.

## Recommendation

Add validation in `UpdateValueValidationProvider` or `ProcessUpdateValue` to verify that the submitted signature matches the expected calculation:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation or ProcessUpdateValue
if (TryToGetPreviousRoundInformation(out var previousRound))
{
    var expectedSignature = previousRound.CalculateSignature(previousInValue);
    if (minerInRound.Signature != expectedSignature)
    {
        return new ValidationResult { Message = "Invalid signature value." };
    }
    
    var expectedOrder = GetAbsModulus(expectedSignature.ToInt64(), minersCount) + 1;
    if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
    {
        return new ValidationResult { Message = "Invalid supposed order." };
    }
}
```

## Proof of Concept

A malicious miner can exploit this vulnerability by:

1. Querying historical rounds to retrieve their previous signatures from state
2. For each historical signature, calculating the resulting order: `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
3. Selecting the signature that produces the most favorable order (e.g., order 1 for first position)
4. Submitting an UpdateValue transaction with:
   - The chosen historical signature value
   - The corresponding calculated order as SupposedOrderOfNextRound
   - Valid previousInValue and outValue fields to pass other validations
5. The contract will accept these values without validation and set the miner's FinalOrderOfNextRound accordingly
6. In the next round generation, the miner will be assigned their manipulated order position

The contract will process this manipulated input successfully because there is no validation comparing the submitted signature to `previousRound.CalculateSignature(previousInValue)`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
