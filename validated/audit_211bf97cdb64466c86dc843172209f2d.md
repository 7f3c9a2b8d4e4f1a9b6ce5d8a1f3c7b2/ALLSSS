# Audit Report

## Title
Consensus DoS via Missing Extra Block Producer Validation in Round Transition

## Summary
The AEDPoS consensus contract lacks validation to ensure that round transitions always designate exactly one extra block producer. An authorized miner can exploit this by submitting a `NextRoundInput` with no extra block producer, causing all subsequent consensus command generation to throw an `InvalidOperationException` and permanently halt the blockchain.

## Finding Description

The vulnerability exists in a critical validation gap in the consensus round transition mechanism:

**Root Cause:** The `GetExtraBlockProducerInformation()` method unconditionally uses LINQ's `First()` operator to retrieve the extra block producer. When no miner has `IsExtraBlockProducer = true`, this throws an `InvalidOperationException`. [1](#0-0) 

**Entry Point:** Any miner in the current or previous round can call the public `NextRound()` method with arbitrary `NextRoundInput` data. [2](#0-1)  The only permission check is in `PreCheck()`, which verifies the sender is in the miner list but performs no structural validation of the round data. [3](#0-2) 

**Validation Gap 1:** The `NextRoundInput.ToRound()` conversion method performs no validation - it simply copies all fields without checking for the presence of an extra block producer. [4](#0-3) 

**Validation Gap 2:** The `RoundTerminateValidationProvider` only validates round number sequencing and null InValues. It does NOT verify that exactly one miner has `IsExtraBlockProducer = true`. [5](#0-4)  The `NextRoundMiningOrderValidationProvider` also does not check extra block producer presence. [6](#0-5) 

**State Corruption:** After passing validation, the malicious round is permanently stored via `AddRoundInformation()`, which directly writes to `State.Rounds` without additional structural checks. [7](#0-6)  This occurs in `ProcessNextRound()`. [8](#0-7) 

**Failure Point:** When any miner subsequently attempts to generate a consensus command with `NextRound` or `NextTerm` behavior, the system instantiates a `TerminateRoundCommandStrategy`. [9](#0-8)  This strategy calls `ArrangeExtraBlockMiningTime()` [10](#0-9) , which calls `ArrangeAbnormalMiningTime()` [11](#0-10) , which calls `GetExtraBlockProducerInformation()` [12](#0-11) , triggering the exception.

An additional trigger path exists through `TinyBlockCommandStrategy` when mining time exceeds the time slot. [13](#0-12) 

Consensus command generation is invoked through the ACS4 interface. [14](#0-13) 

## Impact Explanation

**Severity: Critical - Complete Consensus Denial of Service**

This vulnerability breaks the fundamental consensus invariant that every round must have exactly one designated extra block producer. Once exploited:

1. **Immediate Consensus Failure:** All miners attempting to generate consensus commands with NextRound/NextTerm behavior encounter an unhandled `InvalidOperationException`, preventing block production.

2. **Blockchain Halt:** No new blocks can be produced as consensus command generation is a prerequisite for mining. The chain stops processing transactions entirely.

3. **Irreversible State Corruption:** The malicious round data is permanently stored in consensus contract state. Normal consensus mechanisms cannot recover - the chain requires manual intervention through contract upgrade or state migration.

4. **Cascading Failures:** All pending transactions remain unprocessed, cross-chain operations with dependent sidechains fail, economic activities (staking rewards, vote withdrawals, token operations) freeze, and smart contract executions halt.

5. **Network-Wide Impact:** This vulnerability impacts every participant in the blockchain ecosystem simultaneously, not just specific users.

The legitimate round generation logic always sets an extra block producer. [15](#0-14)  However, a malicious miner bypasses this by crafting their own input.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Prerequisites:**
- Must be an authorized miner (member of current or previous round's miner list)
- Achievable through: insider threat from elected miners, compromise of a miner's private key, or malicious behavior by a legitimate miner

**Attack Complexity: Low**
- Requires only constructing a `NextRoundInput` message with all miners' `IsExtraBlockProducer` fields set to `false`
- No complex timing requirements, race conditions, or multi-step transactions needed
- Single transaction execution is sufficient to corrupt state

**Detection & Prevention:**
- No pre-execution detection mechanism exists in the validation pipeline
- The validation providers check round number sequencing and null InValues but not extra block producer presence
- By the time the attack is detected (via consensus command generation failures), the malicious round is already committed to state

While requiring miner-level access creates a barrier, blockchain systems must maintain Byzantine fault tolerance. The AEDPoS consensus should be resilient to individual malicious actors. A single compromised miner should not be able to halt the entire chain.

## Recommendation

Add validation to ensure exactly one extra block producer exists in the next round. Implement this in `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // Add extra block producer validation
    var extraBlockProducerCount = extraData.Round.RealTimeMinersInformation.Values
        .Count(m => m.IsExtraBlockProducer);
    
    if (extraBlockProducerCount != 1)
        return new ValidationResult { 
            Message = $"Next round must have exactly one extra block producer, found {extraBlockProducerCount}." 
        };
    
    return new ValidationResult { Success = true };
}
```

Alternatively, use `FirstOrDefault()` with null-checking in `GetExtraBlockProducerInformation()` and handle the case gracefully, though this is a defensive measure that doesn't address the root cause of missing validation.

## Proof of Concept

```csharp
[Fact]
public async Task ExploitConsensusDoS_MissingExtraBlockProducer()
{
    // Setup: Initialize consensus with valid first round
    await InitializeConsensus();
    
    // Attacker: Craft malicious NextRoundInput with no extra block producer
    var currentRound = await GetCurrentRound();
    var maliciousRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = { }
    };
    
    // Copy all miners but set IsExtraBlockProducer = false for all
    foreach (var miner in currentRound.RealTimeMinersInformation)
    {
        maliciousRound.RealTimeMinersInformation[miner.Key] = new MinerInRound
        {
            Pubkey = miner.Value.Pubkey,
            Order = miner.Value.Order,
            IsExtraBlockProducer = false, // Malicious: no extra block producer
            // ... other fields
        };
    }
    
    // Execute attack: Submit malicious round (will pass validation)
    var result = await ConsensusStub.NextRound.SendAsync(maliciousRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify state corruption
    var corruptedRound = await GetCurrentRound();
    corruptedRound.RealTimeMinersInformation.Values
        .Count(m => m.IsExtraBlockProducer).ShouldBe(0);
    
    // Trigger DoS: Attempt to get consensus command with NextRound behavior
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(async () => 
    {
        await ConsensusStub.GetConsensusCommand.CallAsync(new BytesValue
        {
            Value = ByteString.CopyFrom(MinerKeyPair.PublicKey)
        });
    });
    
    // Chain is now halted - consensus command generation fails permanently
    exception.Message.ShouldContain("Sequence contains no matching element");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-27)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-27)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L40-42)
```csharp
            return arrangedMiningTime > currentTimeSlotEndTime
                ? new TerminateRoundCommandStrategy(CurrentRound, Pubkey, CurrentBlockTime, false)
                    .GetAEDPoSConsensusCommand() // The arranged mining time already beyond the time slot.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```
