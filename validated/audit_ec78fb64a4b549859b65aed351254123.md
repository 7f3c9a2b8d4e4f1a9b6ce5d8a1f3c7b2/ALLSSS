# Audit Report

## Title
Race Condition in Consensus Order Assignment Leads to Duplicate Mining Orders and Broken Round Schedule

## Summary
A race condition in the AEDPoS consensus mechanism allows multiple miners to be assigned identical `FinalOrderOfNextRound` values when they concurrently produce blocks based on the same on-chain state. The off-chain conflict resolution logic runs independently for each miner, and on-chain `UpdateValue` processing lacks uniqueness validation, resulting in duplicate `Order` assignments in the next round that break the fundamental AEDPoS invariant requiring unique mining time slots.

## Finding Description

The vulnerability exists in the interaction between off-chain order calculation and on-chain state updates:

**Off-chain Conflict Resolution:**
Each miner independently calculates their `supposedOrderOfNextRound` based on their signature modulo the miner count. When conflicts are detected with existing `FinalOrderOfNextRound` values, the conflicting miner is reassigned to the next available order slot through local state manipulation. [1](#0-0) 

**On-chain State Update:**
When processing `UpdateValue` transactions, the contract directly applies the miner's `SupposedOrderOfNextRound` to `FinalOrderOfNextRound` and then applies the `TuneOrderInformation` dictionary to update other miners' orders. [2](#0-1) 

**Missing Validation:**
The `UpdateValueValidationProvider` used for `UpdateValue` behavior only validates that consensus information is filled and previous in values are correct, with no uniqueness validation for `FinalOrderOfNextRound` values. [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` uses `.Distinct()` on entire `MinerInRound` objects (not just `FinalOrderOfNextRound` values), and is only applied to `NextRound` behavior, not `UpdateValue`. [4](#0-3) [5](#0-4) 

**Race Condition Scenario:**
1. Miner A mines first and sets `FinalOrderOfNextRound = 2`
2. Miners B and C both calculate `supposedOrderOfNextRound = 2` based on their signatures
3. B produces a block reading state where only A has order 2: detects conflict with A, reassigns A→3, sets B=2, includes `TuneOrderInformation = {A: 3}`
4. C produces a block before seeing B's update, reading the same state: detects same conflict with A, reassigns A→3, sets C=2, includes `TuneOrderInformation = {A: 3}`
5. On-chain: B's block executes (A→3, B=2), then C's block executes (A→3 [already], C=2)
6. **Result: Both B and C have `FinalOrderOfNextRound = 2`**

**Impact on Next Round:**
When generating the next round, miners are assigned `Order` values directly from their `FinalOrderOfNextRound`. With duplicate values, multiple miners receive identical `Order` and `ExpectedMiningTime`, causing them to compete for the same time slot. [6](#0-5) 

## Impact Explanation

**Consensus Integrity Breakdown:**
- Two or more miners receive identical `Order` and `ExpectedMiningTime` values in the next round
- Multiple miners attempt to produce blocks at the same time slot, creating conflicts and potential forks
- Valid order positions remain unassigned, creating gaps in the mining schedule
- The deterministic time-slot allocation critical to AEDPoS consensus is broken
- Round transitions become unpredictable as duplicate-order miners race to produce blocks simultaneously
- Extra block producer calculation and continuous mining prevention logic may malfunction with unexpected duplicate orders

**Affected Parties:**
- All miners in the affected round experience schedule corruption
- Network consensus becomes unreliable as block production timing is compromised
- Chain progress may stall or fork if duplicate-order miners create conflicting blocks
- The fundamental invariant is violated: not all orders from 1 to N are uniquely assigned

This is a **HIGH severity** issue as it directly compromises the integrity of the consensus mechanism, which is fundamental to blockchain security and availability.

## Likelihood Explanation

**Trigger Conditions:**
- No special privileges required - any miner producing blocks can trigger this naturally
- Occurs when multiple miners' signatures modulo N result in the same value (probability ≈1/N for any two miners)
- These miners must produce blocks based on the same on-chain state (before seeing each other's blocks)
- Network latency between geographically distributed nodes increases the probability of this race condition

**Attack Complexity: LOW**
- Can occur without malicious intent through natural network conditions
- Requires only normal block production operations
- No special timing or coordination needed beyond typical network latency
- Can occur repeatedly across multiple rounds

**Probability:**
- With N miners, the probability of two miners getting the same signature modulo value is approximately 1/N per round
- For a 3-miner network, approximately 33% probability when two miners produce blocks concurrently
- For larger networks, while individual collision probability decreases, the number of potential collision pairs increases
- Expected occurrence: potentially multiple times per day on active chains with typical network latency

**Real-World Feasibility:**
- Network latency is inherent in distributed systems
- Miners in different geographic locations naturally have propagation delays of 100-500ms
- The vulnerability manifests during normal operations without any attack
- No detection or prevention mechanisms exist to identify duplicate orders before commitment

## Recommendation

Implement on-chain uniqueness validation for `FinalOrderOfNextRound` values during `UpdateValue` processing:

1. **Add validation in `ProcessUpdateValue`:** Before applying tune orders, verify that the new `FinalOrderOfNextRound` doesn't conflict with any existing miner's order (excluding the miner being updated).

2. **Enhance `UpdateValueValidationProvider`:** Add a check that validates `FinalOrderOfNextRound` uniqueness across all miners in the round, similar to validation logic but checking the actual order values rather than object references.

3. **Transaction-level conflict resolution:** If a conflict is detected on-chain, reject the transaction with a clear error message, forcing the miner to recalculate based on updated state.

Example fix in `ProcessUpdateValue`:
```csharp
// After line 247, before applying tune orders:
var proposedOrder = updateValueInput.SupposedOrderOfNextRound;
foreach (var miner in currentRound.RealTimeMinersInformation.Values)
{
    if (miner.Pubkey != _processingBlockMinerPubkey && 
        miner.FinalOrderOfNextRound == proposedOrder)
    {
        Assert(false, $"Order {proposedOrder} already assigned to {miner.Pubkey}");
    }
}
```

## Proof of Concept

The vulnerability can be demonstrated by simulating concurrent block production where two miners calculate the same `supposedOrderOfNextRound` value based on identical on-chain state:

```csharp
[Fact]
public void DuplicateOrderRaceCondition_Test()
{
    // Initialize 3 miners
    var miners = new[] { "A", "B", "C" };
    
    // Miner A mines first, gets order 2
    var roundAfterA = currentRound.ApplyNormalConsensusData("A", prevIn, outVal, sigA);
    Assert.Equal(2, roundAfterA.RealTimeMinersInformation["A"].FinalOrderOfNextRound);
    
    // Miners B and C both read this state and calculate same order (2)
    // Both detect conflict with A and move A to 3
    var roundForB = roundAfterA.Clone();
    var roundForC = roundAfterA.Clone();
    
    roundForB.ApplyNormalConsensusData("B", prevInB, outValB, sigB); // sigB % 3 == 1
    roundForC.ApplyNormalConsensusData("C", prevInC, outValC, sigC); // sigC % 3 == 1
    
    // Simulate on-chain processing
    var finalRound = currentRound.Clone();
    finalRound.ProcessUpdateValueInput(extractFromB);
    finalRound.ProcessUpdateValueInput(extractFromC);
    
    // Both B and C have order 2!
    Assert.Equal(2, finalRound.RealTimeMinersInformation["B"].FinalOrderOfNextRound);
    Assert.Equal(2, finalRound.RealTimeMinersInformation["C"].FinalOrderOfNextRound);
    
    // Next round generation assigns same Order and ExpectedMiningTime
    finalRound.GenerateNextRoundInformation(timestamp, startTime, out var nextRound);
    Assert.Equal(2, nextRound.RealTimeMinersInformation["B"].Order);
    Assert.Equal(2, nextRound.RealTimeMinersInformation["C"].Order);
    Assert.Equal(
        nextRound.RealTimeMinersInformation["B"].ExpectedMiningTime,
        nextRound.RealTimeMinersInformation["C"].ExpectedMiningTime
    );
}
```

## Notes

This vulnerability is a subtle race condition that arises from the combination of:
1. Off-chain state reading and conflict resolution
2. Independent execution of conflict resolution by different miners
3. Lack of on-chain validation for order uniqueness during `UpdateValue`
4. Natural network propagation delays in distributed systems

The issue is particularly insidious because it can occur without any malicious behavior, simply through normal network latency and coincidental signature values. The `EnsureTransactionOnlyExecutedOnceInOneBlock` protection does not prevent this because the race condition occurs across different blocks, not within the same block. [7](#0-6)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-260)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-88)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-41)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```
