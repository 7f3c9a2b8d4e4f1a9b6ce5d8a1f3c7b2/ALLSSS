# Audit Report

## Title
Integer Overflow in Method Fee Aggregation Completely Bypasses Transaction Fee Collection

## Summary
The fee setting and collection system lacks validation of the aggregate sum of multiple `MethodFee` entries for the same token symbol. When LINQ's unchecked `Sum()` operation causes integer overflow during fee aggregation, the resulting negative values bypass all fee charging logic, allowing transactions to execute without paying any fees. This affects all contracts implementing the ACS1 standard.

## Finding Description

The vulnerability exists across three critical stages of the fee lifecycle:

**Stage 1: Insufficient Validation at Fee Setting**

When governance sets method fees, individual fee entries are validated but the aggregate sum per symbol is not. In Association contract, each fee is validated with `amount >= 0`: [1](#0-0) 

The `MethodFees` protobuf structure explicitly allows multiple fees through its `repeated` field: [2](#0-1) 

This design is intentional and supported by tests that verify multiple fees for the same symbol sum correctly in normal cases: [3](#0-2) 

However, no validation prevents the sum from exceeding `long.MaxValue`.

**Stage 2: Unchecked Overflow in Fee Aggregation**

During fee collection, `GetBaseFeeDictionary()` groups fees by symbol and uses LINQ's `Sum()` method: [4](#0-3) 

Unlike the SafeMath extension methods that explicitly use `checked` blocks: [5](#0-4) 

LINQ's `Sum()` is a precompiled BCL (Base Class Library) method that uses unchecked arithmetic. While AElf has a SafeMath patcher that converts unchecked arithmetic opcodes to checked versions: [6](#0-5) 

This patcher only processes contract code IL, not precompiled BCL methods. The entire `System.Linq` namespace is fully trusted and whitelisted, allowing `Sum()` to execute with its native unchecked behavior. When the sum exceeds `long.MaxValue` (9,223,372,036,854,775,807), it wraps around to a large negative value.

**Stage 3: Negative Values Bypass Fee Charging**

When `ChargeBaseFee()` processes the overflowed negative amount, the comparison at line 359 evaluates `existingAllowance (typically 0) > amountToChargeBaseFee (negative)` as true, causing the method to add the negative amount to the allowance bill and zero to the balance bill: [7](#0-6) 

Finally, `ModifyBalance()` skips both amounts: the zero balance charge is skipped at line 247, and the negative allowance amount is skipped at line 260: [8](#0-7) 

The transaction executes successfully without charging any fees.

## Impact Explanation

**Direct Economic Impact:**
- Complete bypass of transaction fee collection for affected methods
- All transactions using overflowed method fees execute at zero cost
- Loss of all fee revenue that should flow to miners, Treasury, and other fee recipients configured in the system
- Economic security model completely compromised as fees provide no cost barrier

**Operational Impact:**
- Enables spam/DoS attacks using free transactions with no economic cost to the attacker
- Resource exhaustion without the normal economic deterrent
- Affects any contract implementing ACS1 standard across the ecosystem

**Severity Justification:**
This is a HIGH severity issue because it represents a complete failure of a critical economic security mechanism. While the fee collection system is designed to protect the network from spam and fairly compensate participants, this vulnerability allows that protection to be completely bypassed through a governance action that may appear reasonable on the surface (setting fees) but has catastrophic unintended consequences due to overflow.

## Likelihood Explanation

**Attack Prerequisites:**
The vulnerability requires the method fee controller (typically Parliament governance) to set fees that sum to more than `long.MaxValue` for the same symbol. The controller is set via governance: [9](#0-8) 

**Exploitation Scenarios:**

1. **Accidental Trigger:** Legitimate governance proposals that incrementally add or modify fees over time could accidentally exceed `long.MaxValue` without detection. For example, if fees are denominated in smallest token units and economic conditions lead to repeated fee increases, the cumulative total could overflow.

2. **Malicious Governance Participant:** A compromised or malicious participant who gains influence in governance could intentionally propose fees designed to overflow.

3. **Governance Capture:** An attacker who successfully captures sufficient voting power could directly set exploitative fees.

**Feasibility Assessment:**
The attack path is straightforward with no complex state manipulation required. The protocol explicitly supports and tests the pattern of setting multiple fees for the same symbol, making this a legitimate-looking governance action. Once overflow occurs, all users automatically benefit from the fee bypass without individual action. Detection would be challenging as fees simply fail to collect without obvious error signals.

**Likelihood Rating: MEDIUM-HIGH**
While requiring governance action creates a barrier, the combination of potential for accidental trigger, straightforward exploitation path, and protocol-supported fee patterns makes this a realistic threat.

## Recommendation

Implement aggregate sum validation in the `SetMethodFee` method to prevent overflow:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    // Group fees by symbol and validate sum won't overflow
    var symbolToSum = new Dictionary<string, long>();
    foreach (var fee in input.Fees)
    {
        AssertValidToken(fee.Symbol, fee.BasicFee);
        
        if (!symbolToSum.ContainsKey(fee.Symbol))
            symbolToSum[fee.Symbol] = 0;
        
        // Use SafeMath.Add which checks overflow
        symbolToSum[fee.Symbol] = symbolToSum[fee.Symbol].Add(fee.BasicFee);
    }
    
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
        "Unauthorized to set method fee.");
    
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

Additionally, replace LINQ `Sum()` with SafeMath aggregation in `GetBaseFeeDictionary`:

```csharp
private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
{
    var result = new Dictionary<string, long>();
    var groups = methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
        .GroupBy(f => f.Symbol);
    
    foreach (var group in groups)
    {
        long sum = 0;
        foreach (var fee in group)
        {
            sum = sum.Add(fee.BasicFee); // Uses checked SafeMath.Add
        }
        result[group.Key] = sum;
    }
    
    return result;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MethodFee_IntegerOverflow_Bypasses_Fee_Collection()
{
    // Setup: Issue tokens to test account
    await IssueTokenToDefaultSenderAsync(NativeTokenSymbol, 100_000_00000000);
    await SetPrimaryTokenSymbolAsync();
    
    var methodName = nameof(TokenContractContainer.TokenContractStub.Transfer);
    
    // Create two fees that sum to more than long.MaxValue
    // long.MaxValue = 9,223,372,036,854,775,807
    var largeFee = 5_000_000_000_000_000_000L; // 5 quintillion
    
    var overflowingMethodFee = new MethodFees
    {
        MethodName = methodName,
        Fees =
        {
            new MethodFee { Symbol = NativeTokenSymbol, BasicFee = largeFee },
            new MethodFee { Symbol = NativeTokenSymbol, BasicFee = largeFee }
            // Sum = 10,000,000,000,000,000,000 > long.MaxValue
            // Overflows to negative: approximately -8,446,744,073,709,551,616
        }
    };
    
    // Set the overflowing fees via governance
    await TokenContractImplStub.SetMethodFee.SendAsync(overflowingMethodFee);
    
    // Record balance before transaction
    var balanceBefore = await GetBalanceAsync(DefaultSender, NativeTokenSymbol);
    
    // Execute transaction that should charge fee
    var result = await TokenContractStub.ChargeTransactionFees.SendAsync(
        new ChargeTransactionFeesInput
        {
            MethodName = methodName,
            ContractAddress = TokenContractAddress,
            TransactionSizeFee = 0
        });
    
    // Verify transaction succeeded
    result.Output.Success.ShouldBeTrue();
    
    // Verify NO fees were charged (balance unchanged)
    var balanceAfter = await GetBalanceAsync(DefaultSender, NativeTokenSymbol);
    balanceAfter.ShouldBe(balanceBefore); // Balance should be unchanged - BUG!
    
    // Expected: Balance should decrease by fee amount
    // Actual: Balance unchanged due to overflow bypass
}
```

This test demonstrates that when fees overflow to negative values, the transaction completes successfully without charging any fees, proving the complete bypass of the fee collection mechanism.

### Citations

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L76-85)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** protobuf/acs1.proto (L40-46)
```text
message MethodFees {
    // The name of the method to be charged.
    string method_name = 1;
    // List of fees to be charged.
    repeated MethodFee fees = 2;
    bool is_size_fee_free = 3;// Optional based on the implementation of SetMethodFee method.
}
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest.cs (L66-104)
```csharp
    public async Task Set_Repeat_Token_Test()
    {
        await IssueTokenToDefaultSenderAsync(NativeTokenSymbol, 100000_00000000);
        await SetPrimaryTokenSymbolAsync();
        var address = DefaultSender;
        var methodName = nameof(TokenContractContainer.TokenContractStub.Transfer);
        var basicMethodFee = 1000;
        var methodFee = new MethodFees
        {
            MethodName = methodName,
            Fees =
            {
                new MethodFee
                {
                    Symbol = NativeTokenSymbol,
                    BasicFee = basicMethodFee
                },
                new MethodFee
                {
                    Symbol = NativeTokenSymbol,
                    BasicFee = basicMethodFee
                }
            }
        };
        var sizeFee = 0;
        await TokenContractImplStub.SetMethodFee.SendAsync(methodFee);
        var beforeChargeBalance = await GetBalanceAsync(address, NativeTokenSymbol);
        var chargeTransactionFeesInput = new ChargeTransactionFeesInput
        {
            MethodName = methodName,
            ContractAddress = TokenContractAddress,
            TransactionSizeFee = sizeFee,
        };

        var chargeFeeRet = await TokenContractStub.ChargeTransactionFees.SendAsync(chargeTransactionFeesInput);
        chargeFeeRet.Output.Success.ShouldBeTrue();
        var afterChargeBalance = await GetBalanceAsync(address, NativeTokenSymbol);
        beforeChargeBalance.Sub(afterChargeBalance).ShouldBe(basicMethodFee.Add(basicMethodFee));
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L237-266)
```csharp
    private void ModifyBalance(Address fromAddress, TransactionFeeBill bill,
        TransactionFreeFeeAllowanceBill allowanceBill)
    {
        Assert(!IsInTransferBlackListInternal(fromAddress), "Charge fee address is in transfer blacklist.");
        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        // Update balances and allowances
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }

        if (freeAllowancesMap.Map == null || freeAllowancesMap.Map.Count == 0) return;

        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount > 0)
            {
                ModifyFreeFeeAllowanceAmount(fromAddress, freeAllowancesMap, symbol, -amount);
            }
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L336-373)
```csharp
    private bool ChargeBaseFee(Dictionary<string, long> methodFeeMap, Address fromAddress, ref TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        ref TransactionFreeFeeAllowanceBill allowanceBill,
        TransactionFeeDelegations delegations = null)
    {
        Context.LogDebug(() => "ChargeBaseFee Start");
        // Fail to charge
        if (!ChargeFirstSufficientToken(methodFeeMap, fromAddress, out var symbolToChargeBaseFee,
                out var amountToChargeBaseFee, out var existingBalance, out var existingAllowance,
                transactionFeeFreeAllowancesMap,
                delegations))
        {
            Context.LogDebug(() => "Failed to charge first sufficient token.");
            if (symbolToChargeBaseFee != null)
            {
                bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            } // If symbol == 

            return false;
        }

        // Succeed to charge, freeAllowance first.
        if (existingAllowance > amountToChargeBaseFee)
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee);
            // free fee allowance has covered fee, add 0 for size fee
            bill.FeesMap.Add(symbolToChargeBaseFee, 0);
        }
        else
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            bill.FeesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee.Sub(existingAllowance));
        }

        Context.LogDebug(() => "ChargeBaseFee End");
        return true;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/SafeMath/Patcher.cs (L12-30)
```csharp
public class Patcher : IPatcher<ModuleDefinition>
{
    // Replace unchecked math OpCodes with checked OpCodes (overflow throws exception)
    private static readonly Dictionary<OpCode, OpCode> PlainToCheckedOpCodes = new()
    {
        {OpCodes.Add, OpCodes.Add_Ovf},
        {OpCodes.Sub, OpCodes.Sub_Ovf},
        {OpCodes.Mul, OpCodes.Mul_Ovf}
    };

    public bool SystemContactIgnored => false;

    public void Patch(ModuleDefinition module)
    {
        foreach (var method in module.GetAllTypes().SelectMany(t => t.Methods))
        {
            PatchMethod(method);
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```
