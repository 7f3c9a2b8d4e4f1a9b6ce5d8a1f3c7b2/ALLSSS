# Audit Report

## Title
Missing LIB Upper Bound Validation in NextRound/NextTerm Enables Consensus DOS via Integer Overflow

## Summary
The AEDPoS consensus contract contains a critical validation gap where Last Irreversible Block (LIB) upper bounds are not validated for `NextRound` and `NextTerm` behaviors, allowing a malicious miner to inject extreme `ConfirmedIrreversibleBlockHeight` values that bypass all validation layers but eventually trigger arithmetic overflow in `GetMaximumBlocksCount()`, permanently halting blockchain consensus.

## Finding Description

The AEDPoS consensus validation architecture employs behavior-specific validation providers. A critical gap exists where `LibInformationValidationProvider` is exclusively registered for `UpdateValue` behavior: [1](#0-0) 

However, `NextRound` and `NextTerm` behaviors only use `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`: [2](#0-1) 

The `LibInformationValidationProvider` only validates that LIB values do not move backward, with no upper bound checks: [3](#0-2) 

Neither `NextRoundMiningOrderValidationProvider` nor `RoundTerminateValidationProvider` validate LIB bounds: [4](#0-3) [5](#0-4) 

Both `NextRoundInput` and `NextTermInput` contain `ConfirmedIrreversibleBlockHeight` fields that are copied directly without validation: [6](#0-5) [7](#0-6) 

The malicious round is stored directly to state without validation: [8](#0-7) 

Post-execution hash validation also fails to detect this because `GetCheckableRound()` explicitly excludes LIB fields from hash computation: [9](#0-8) [10](#0-9) 

Once stored, the malicious LIB value causes arithmetic overflow when the blockchain enters Severe mining status. The `GetMaximumBlocksCount()` method attempts to compute the distance from current height to the malicious LIB height: [11](#0-10) 

The `Sub()` method uses C#'s `checked` keyword, throwing `OverflowException` on underflow: [12](#0-11) 

**Attack Execution:**
1. Malicious miner waits for NextRound/NextTerm slot
2. Crafts consensus data with `ConfirmedIrreversibleBlockHeight = long.MaxValue`
3. Sets `ConfirmedIrreversibleBlockRoundNumber = currentRound - 1` to delay Severe status
4. Block passes all validation layers (no LIB upper bound checks)
5. Malicious round stored to state
6. After sufficient rounds (~8-16), blockchain enters Severe status
7. `GetMaximumBlocksCount()` attempts `currentHeight.Sub(long.MaxValue)` â†’ `OverflowException`
8. All subsequent consensus transactions fail permanently

## Impact Explanation

**Severity: Critical** - Complete and permanent consensus halt with no automatic recovery mechanism.

The `GetMaximumBlocksCount()` method is invoked during every consensus transaction: [13](#0-12) 

Once the overflow triggers, this creates a permanent DOS condition where:
- No blocks can be produced by any miner
- The blockchain state is frozen at the point of attack
- Recovery requires hard fork or state rollback to before the malicious round
- The attack affects the entire blockchain network (protocol-level availability failure)

## Likelihood Explanation

**Likelihood: Medium-High** given miner access.

**Prerequisites:**
- Attacker must be an active miner in the current miner list
- For mainchain: requires being elected through the election contract (high barrier but achievable)
- For sidechains: requires being in the configured miner set (potentially lower barrier)

**Attack Feasibility:**
- Once miner status is achieved, attack complexity is LOW
- No special transaction crafting required - simply modify Round object fields before block production
- Single malicious block sufficient to poison consensus state
- No runtime detection until overflow triggers

**Economic Factors:**
- Honest miners have incentive to maintain chain health
- However, compromised miners, exiting miners, or Byzantine actors can execute this attack
- Single malicious miner suffices - no coordination required

**Exploitability: High** - The validation gap is architectural and cannot be prevented by individual node operators.

## Recommendation

Add `LibInformationValidationProvider` to the validation chain for both `NextRound` and `NextTerm` behaviors. Additionally, implement upper bound validation in `LibInformationValidationProvider` to ensure LIB values cannot exceed current blockchain height:

```csharp
// In AEDPoSContract_Validation.cs
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
}
```

Additionally, enhance `LibInformationValidationProvider` with upper bound validation:

```csharp
// In LibInformationValidationProvider.cs
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    
    // Add upper bound check
    if (providedRound.ConfirmedIrreversibleBlockHeight > validationContext.CurrentHeight)
    {
        validationResult.Message = "LIB height cannot exceed current block height.";
        return validationResult;
    }
    
    // Existing backward movement checks...
}
```

## Proof of Concept

A complete PoC would require setting up an AElf test environment with multiple miners and demonstrating:

1. Miner A produces a malicious NextRound block with `ConfirmedIrreversibleBlockHeight = long.MaxValue`
2. Block passes validation and is accepted by the network
3. After ~8-16 rounds, the blockchain enters Severe status
4. The next call to `GetMaximumBlocksCount()` throws `OverflowException`
5. All subsequent blocks from all miners fail with the same exception
6. Consensus is permanently halted

The test would verify that the malicious block bypasses validation due to missing `LibInformationValidationProvider` for NextRound behavior, and that the overflow eventually triggers when blockchain enters Severe status.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-20)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-34)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L199-206)
```csharp
        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-66)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```
