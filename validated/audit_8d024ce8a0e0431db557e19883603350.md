# Audit Report

## Title
Rounding Errors in Profit Distribution Cause Inaccessible Dust Accumulation in Period Virtual Addresses

## Summary
The Profit Contract's `SafeCalculateProfits` function uses truncating division that rounds down each beneficiary's profit share, causing remainder tokens (dust) to permanently accumulate in period-specific virtual addresses. Over many distribution periods across all schemes, this results in significant token loss as no recovery mechanism exists for scheme managers to reclaim these locked funds.

## Finding Description

**Root Cause - Truncating Division:**

The profit calculation function performs decimal arithmetic but casts the result to `long`, which truncates fractional token amounts: [1](#0-0) 

When `totalAmount` is not evenly divisible by `totalShares`, each beneficiary receives a rounded-down amount. The mathematical guarantee is that the sum of truncated shares will be strictly less than the distributed amount when remainders exist.

**Distribution Flow - Tokens Transferred to Period Addresses:**

When `DistributeProfits` is called, the contract transfers tokens to a deterministically-generated period-specific virtual address and records the amount in `DistributedProfitsMap`: [2](#0-1) 

The `AmountsMap` stores the original distributed amount but is never decremented as beneficiaries claim their shares.

**Claiming Flow - Truncated Shares Transferred Out:**

When beneficiaries call `ClaimProfits`, their share is calculated using the same truncating function within `ProfitAllPeriods`: [3](#0-2) 

Specifically, line 873-875 calculates the truncated profit amount. After all beneficiaries claim their rounded-down shares, dust remains in the period virtual address.

**Virtual Address Generation - Deterministic and Contract-Controlled:**

Period virtual addresses are generated deterministically from the scheme ID and period number: [4](#0-3) 

Only the Profit Contract can use `SendVirtualInline` with these hashes to transfer tokens. Critically, the contract provides no public method for scheme managers to withdraw remaining balances from period virtual addresses after all beneficiaries have claimed. Managers only control the scheme's main virtual address, not individual period addresses.

**Evidence of Awareness:**

Test infrastructure includes tolerance values for balance verification, indicating developers are aware of rounding behavior: [5](#0-4) 

However, this tolerance appears intended for transaction fees rather than accepting dust accumulation as correct behavior. Unit tests use exact equality checks and carefully avoid dust-producing scenarios.

## Impact Explanation

**Severity: Medium**

This represents a genuine economic loss with cumulative impact:

- **Per-Period Loss:** Each distribution period leaves between 0 and (totalShares - 1) tokens per symbol locked in its period address
- **Concrete Example:** Distributing 100 tokens among 3 equal beneficiaries results in each receiving 33 tokens (total 99), leaving 1 token permanently locked
- **Cumulative Impact:** Over 1,000 distribution periods with average 10 shares per scheme, up to 10,000 tokens could become permanently inaccessible
- **Protocol-Wide Effect:** Affects all profit schemes including consensus rewards, treasury distributions, token holder dividends, and custom schemes

The severity is Medium (not High/Critical) because:
- Funds are locked rather than stolen
- No direct theft or malicious exploitation path exists
- Individual amounts are small per period
- This is a protocol inefficiency rather than an attack vector
- However, it represents real economic loss that degrades protocol efficiency over time

## Likelihood Explanation

**Likelihood: High (Deterministic)**

This occurs automatically during normal operations:

- **Mathematical Certainty:** Happens whenever `totalAmount % totalShares â‰  0`, which is the common case for realistic token amounts and share distributions
- **No Attacker Required:** Occurs naturally through legitimate `DistributeProfits` calls by authorized managers
- **No Special Preconditions:** Works with standard contract execution flow
- **Operational Reality:** Most token distributions won't divide evenly by share counts, making this near-universal across active schemes

The issue affects every non-evenly-divisible profit distribution across the entire protocol, accumulating linearly with the number of distribution periods over time.

## Recommendation

**Implement Dust Recovery Mechanism:**

Add a manager-only function to sweep remaining balances from period virtual addresses after claims are complete. For example:

```csharp
public override Empty RecoverPeriodDust(RecoverPeriodDustInput input)
{
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(scheme != null, "Scheme not found.");
    Assert(Context.Sender == scheme.Manager, "Only manager can recover dust.");
    
    // Ensure period is old enough that all claims should be complete
    Assert(input.Period < scheme.CurrentPeriod.Sub(scheme.ProfitReceivingDuePeriodCount), 
        "Period too recent to recover dust.");
    
    var periodAddress = GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = periodAddress,
        Symbol = input.Symbol
    }).Balance;
    
    if (balance > 0)
    {
        Context.SendVirtualInline(
            GeneratePeriodVirtualAddressFromHash(input.SchemeId, input.Period),
            State.TokenContract.Value,
            nameof(State.TokenContract.Transfer),
            new TransferInput
            {
                To = scheme.VirtualAddress, // or scheme.Manager
                Symbol = input.Symbol,
                Amount = balance
            }.ToByteString());
    }
    
    return new Empty();
}
```

**Alternative Solution:** Modify the distribution logic to allocate dust to the first beneficiary or add it to the next period's distribution.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_DustAccumulation_Test()
{
    const long distributionAmount = 100;
    const long shares1 = 1;
    const long shares2 = 1;
    const long shares3 = 1;
    // Total shares = 3, so 100 / 3 = 33 per beneficiary (truncated)
    // Expected dust = 100 - (33 * 3) = 1 token locked

    var creator = Creators[0];
    var beneficiary1 = Normal[0];
    var beneficiary2 = Normal[1];
    var beneficiary3 = Normal[2];
    
    var schemeId = await CreateSchemeAsync();
    await ContributeProfits(schemeId, distributionAmount);

    // Add three beneficiaries with equal shares
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = Address.FromPublicKey(NormalKeyPair[0].PublicKey), 
            Shares = shares1 
        }
    });
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = Address.FromPublicKey(NormalKeyPair[1].PublicKey), 
            Shares = shares2 
        }
    });
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = Address.FromPublicKey(NormalKeyPair[2].PublicKey), 
            Shares = shares3 
        }
    });

    // Distribute profits for period 1
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, distributionAmount } }
    });

    // Get period 1 virtual address
    var period1Address = await creator.GetSchemeAddress.CallAsync(new SchemePeriod
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    var initialPeriodBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = period1Address,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    
    initialPeriodBalance.ShouldBe(distributionAmount); // 100 tokens in period address

    // All beneficiaries claim their profits
    await beneficiary1.ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    await beneficiary2.ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    await beneficiary3.ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });

    // Check remaining balance in period address - should show 1 token dust
    var finalPeriodBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = period1Address,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    
    // This proves dust accumulation: 100 - (33 + 33 + 33) = 1 token remains locked
    finalPeriodBalance.ShouldBe(1); 
    
    // Attempt to recover dust by manager should fail - no such method exists
    // This demonstrates the funds are permanently inaccessible
}
```

**Notes:**
- The POC demonstrates that after all beneficiaries claim their calculated shares (33 tokens each), 1 token remains locked in the period virtual address
- No mechanism exists for the scheme manager or any party to recover this dust
- This pattern repeats for every period with non-divisible distributions, causing cumulative permanent loss across all schemes protocol-wide

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L417-499)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");

        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }

        var totalShares = scheme.TotalShares;

        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }

        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");

        var profitsReceivingVirtualAddress =
            GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, releasingPeriod);

        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);

        Context.LogDebug(() => $"Receiving virtual address: {profitsReceivingVirtualAddress}");

        UpdateDistributedProfits(profitsMap, profitsReceivingVirtualAddress, totalShares);

        PerformDistributeProfits(profitsMap, scheme, totalShares, profitsReceivingVirtualAddress);

        scheme.CurrentPeriod = input.Period.Add(1);

        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-60)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }

    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```

**File:** test/AElf.Contracts.Economic.AEDPoSExtension.Tests/EconomicTestHelpers.cs (L88-106)
```csharp
    /// <summary>
    ///     Tolerance: 10
    /// </summary>
    /// <param name="keyPairs"></param>
    /// <param name="shouldIncrease"></param>
    /// <param name="balancesBefore"></param>
    /// <returns></returns>
    internal async Task CheckBalancesAsync(IEnumerable<ECKeyPair> keyPairs, long shouldIncrease,
        Dictionary<ECKeyPair, long> balancesBefore = null)
    {
        const long tolerance = 20;
        balancesBefore ??= new Dictionary<ECKeyPair, long>();
        foreach (var keyPair in keyPairs)
        {
            var amount = await GetBalanceAsync(Address.FromPublicKey(keyPair.PublicKey));
            amount.ShouldBeGreaterThanOrEqualTo(shouldIncrease + balancesBefore[keyPair] - tolerance);
            amount.ShouldBeLessThanOrEqualTo(shouldIncrease + balancesBefore[keyPair] + tolerance);
        }
    }
```
