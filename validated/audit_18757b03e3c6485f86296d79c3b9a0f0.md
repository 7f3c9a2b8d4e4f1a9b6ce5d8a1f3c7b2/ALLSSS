# Audit Report

## Title
Permanent Method Fee Controller Lock Due to Null Parliament Contract During Initialization

## Summary
The TokenContract's `RequiredMethodFeeControllerSet()` method contains a critical flaw where it persists an `AuthorityInfo` with null `OwnerAddress` when the Parliament contract is not deployed. This creates an irrecoverable state where all method fee governance operations permanently fail, with no administrative override mechanism.

## Finding Description

The vulnerability exists in the `RequiredMethodFeeControllerSet()` helper method that initializes the method fee controller authority. [1](#0-0) 

When `State.MethodFeeController.Value` is null, the method attempts to retrieve the Parliament contract address. If Parliament is not deployed or registered, `Context.GetContractAddressByName()` returns null. The code then creates an empty `AuthorityInfo` object. The conditional check at line 101 fails because `State.ParliamentContract.Value` is null, so the object's `OwnerAddress` and `ContractAddress` fields remain null. **This invalid authority is unconditionally persisted to state at line 108.**

The defensive code comment "Parliament Auth Contract maybe not deployed" indicates developers anticipated this scenario, but the handling creates a worse problem than immediate failure. [2](#0-1) 

Once corrupted, subsequent calls to `ChangeMethodFeeController()` will always fail: [3](#0-2) 

The authorization check at line 27 delegates to `AssertSenderAddressWith()` which compares `Context.Sender` against null, an assertion that can never pass in AElf's execution model: [4](#0-3) 

Similarly, `SetMethodFee()` performs the same check and will permanently fail: [5](#0-4) 

The `CheckOrganizationExist()` validation would also fail as it attempts to call a null contract address: [6](#0-5) 

## Impact Explanation

**Complete Governance Breakdown**: The method fee controller becomes permanently locked. No address can satisfy the `Context.Sender == null` check, preventing all changes to transaction fee parameters for the TokenContract.

**No Recovery Path**: Contract upgrades via `UpdateSmartContract` preserve state rather than resetting it: [7](#0-6) 

The update mechanism modifies code but maintains contract state. Any migration logic would still require passing the broken authorization check. No administrative override exists.

**Critical System Impact**: TokenContract is a foundational system contract. Loss of fee governance affects the ability to adjust economic parameters critical for chain operation.

**Severity: HIGH** - Permanent, irrecoverable loss of method fee governance for a critical system contract.

## Likelihood Explanation

**Precondition**: `RequiredMethodFeeControllerSet()` must be called before Parliament contract deployment. This can occur via:
- `GetMethodFeeController()` (public view method, no authorization)
- `SetMethodFee()` 
- `ChangeMethodFeeController()`

**Deployment Order**: In standard test configurations, Token is deployed before Parliament: [8](#0-7) 

**Production Protection**: In production mainchain/sidechain genesis blocks, all contracts deploy atomically with no external call window between Token and Parliament initialization.

**Vulnerable Scenarios**:
- Test environments where Parliament is intentionally omitted
- Custom deployment configurations outside standard initialization flow  
- Manual contract deployments
- Development/staging environments

The code's defensive handling with the "maybe not deployed" comment confirms developers anticipated this scenario, suggesting it's considered a realistic edge case rather than impossible.

**Trigger Complexity**: LOW - Single call to `GetMethodFeeController()` (a public view method) triggers the corruption if preconditions are met.

**Overall Likelihood: MEDIUM** - Unlikely in production with standard procedures, but realistic in test/development environments and custom deployments where the defensive code pattern indicates this scenario was anticipated.

## Recommendation

Add validation before persisting the authority to ensure it contains valid addresses:

```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

    // Fail fast if Parliament not deployed rather than corrupting state
    Assert(State.ParliamentContract.Value != null, 
        "Parliament contract must be deployed before initializing method fee controller.");

    var defaultAuthority = new AuthorityInfo
    {
        OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
        ContractAddress = State.ParliamentContract.Value
    };
    
    // Validate before persisting
    Assert(defaultAuthority.OwnerAddress != null && defaultAuthority.ContractAddress != null,
        "Invalid authority info - addresses must not be null.");

    State.MethodFeeController.Value = defaultAuthority;
}
```

This ensures the contract fails immediately with a clear error message rather than silently corrupting state into an unrecoverable condition.

## Proof of Concept

```csharp
[Fact]
public async Task MethodFeeController_PermanentLock_WhenParliamentNotDeployed()
{
    // Setup: Deploy Token contract WITHOUT deploying Parliament contract
    // This simulates test environment or custom deployment scenario
    var chainId = ChainHelper.ConvertBase58ToChainId("AELF");
    var tester = new ContractTester<TokenContractTestAElfModule>(chainId);
    
    // Deploy ONLY Token contract (no Parliament)
    await tester.InitialChainAsync(list =>
    {
        list.AddGenesisSmartContract(
            tester.TokenContractCode,
            TokenSmartContractAddressNameProvider.Name,
            new List<ContractInitializationMethodCall>());
    });
    
    var tokenStub = tester.GetTokenContractStub(tester.GetDefaultSender());
    
    // Trigger the vulnerability: Call GetMethodFeeController before Parliament exists
    var controller = await tokenStub.GetMethodFeeController.CallAsync(new Empty());
    
    // Verify state corruption: OwnerAddress is null
    controller.OwnerAddress.ShouldBeNull();
    controller.ContractAddress.ShouldBeNull();
    
    // Verify permanent lock: Cannot change controller
    var result = await tokenStub.ChangeMethodFeeController.SendWithExceptionAsync(
        new AuthorityInfo { /* any valid authority */ });
    
    // This will ALWAYS fail with "Unauthorized behavior"
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Unauthorized behavior");
    
    // Even after deploying Parliament now, the corruption is permanent
    // No recovery mechanism exists
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L111-114)
```csharp
    private void AssertSenderAddressWith(Address address)
    {
        Assert(Context.Sender == address, "Unauthorized behavior.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-144)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

        var oldCodeHash = info.CodeHash;
        var newCodeHash = HashHelper.ComputeFrom(code);
        Assert(oldCodeHash != newCodeHash, "Code is not changed.");
        AssertContractNotExists(newCodeHash);

        info.CodeHash = newCodeHash;
        info.IsUserContract = isUserContract;
        info.Version++;

        var reg = new SmartContractRegistration
        {
            Category = info.Category,
            Code = ByteString.CopyFrom(code),
            CodeHash = newCodeHash,
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;

        Context.Fire(new CodeUpdated
        {
            Address = contractAddress,
            OldCodeHash = oldCodeHash,
            NewCodeHash = newCodeHash,
            Version = info.Version,
            ContractVersion = info.ContractVersion
        });

        Context.LogDebug(() => "BasicContractZero - update success: " + contractAddress.ToBase58());
    }
```

**File:** test/AElf.Contracts.TestBase/ContractTester.cs (L742-745)
```csharp
            list.AddGenesisSmartContract(TokenContractCode, TokenSmartContractAddressNameProvider.Name,
                tokenContractCallList);
            list.AddGenesisSmartContract(ParliamentContractCode, ParliamentSmartContractAddressNameProvider.Name,
                parliamentContractCallList);
```
