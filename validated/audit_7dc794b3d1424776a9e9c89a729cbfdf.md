# Audit Report

## Title
Insufficient Threshold Validation in Referendum Contract Allows Creation of Permanently Non-Functional Governance Organizations

## Summary
The Referendum contract's `CreateOrganization` function lacks validation to ensure `ProposalReleaseThreshold` values are achievable relative to the token's total supply. This allows creation of organizations with approval thresholds that exceed available token supply, rendering them permanently unable to release any proposals.

## Finding Description

The Referendum contract's `Validate` method performs insufficient validation when creating organizations. [1](#0-0) 

The validation only checks:
- Token existence (but not its supply)
- `MinimalApprovalThreshold <= MinimalVoteThreshold`
- `MinimalApprovalThreshold > 0`
- Non-negative maximal thresholds

Critically, it does NOT validate whether threshold values are achievable given the token's total supply.

In stark contrast, the Parliament contract validates thresholds against `AbstractVoteTotal` (a constant value of 10000 representing 100%) to ensure they cannot exceed what's mathematically possible. [2](#0-1)  The constant `AbstractVoteTotal` is defined as 10000. [3](#0-2) 

Similarly, the Association contract validates thresholds against `organizationMemberCount` to ensure achievability. [4](#0-3) 

When proposals attempt to be released, the system checks if the approval count meets the threshold. [5](#0-4) 

The approval count accumulates token allowances from voters. [6](#0-5) 

If `MinimalApprovalThreshold` exceeds the token's total supply, then even if all tokens vote to approve, `proposal.ApprovalCount` can never reach the threshold, making proposal release impossible.

The `CreateOrganization` function is publicly accessible as an RPC method. [7](#0-6) 

The Referendum contract already calls `GetTokenInfo` to verify token existence, which also returns `total_supply` and `supply` fields that could be used for validation. [8](#0-7)  The `TokenInfo` structure contains both current supply and total supply. [9](#0-8) 

## Impact Explanation

**Direct Governance Impact:**
- Organizations created with impossibly high thresholds become permanently non-functional
- No proposals can ever be released under such organizations, regardless of voting participation
- Violates the core governance invariant that organizations passing validation should be operable

**Token Locking:**
- Users who vote on proposals under broken organizations have their tokens locked via `TransferFrom` [10](#0-9) 
- Locked tokens cannot be reclaimed until proposal expiration [11](#0-10) 
- This represents a temporary but forced token lock for participants

**Protocol Consistency:**
- Creates inconsistency with Parliament and Association contracts, both of which validate threshold achievability
- Breaks the fundamental design principle that validated organizations should be functional

**Severity Amplification:**
- If a broken organization is adopted as a `MethodFeeController` or other governance authority, it creates permanent protocol-level deadlock
- This scenario requires existing authority approval but demonstrates cascading risk

## Likelihood Explanation

**Entry Point Accessibility:**
`CreateOrganization` is a public RPC method callable by any user without preconditions.

**Execution Simplicity:**
- Any user can call `CreateOrganization` with `MinimalApprovalThreshold = 10^20` and `MinimalVoteThreshold = 10^20`
- These values satisfy all existing validation checks (`MinimalApprovalThreshold <= MinimalVoteThreshold` and `> 0`)
- No special permissions or complex setup required

**Realistic Scenarios:**
1. **User Error (High Likelihood)**: Legitimate users confusing percentage-based values (as used in Parliament) with absolute token amounts, accidentally setting thresholds like `10^18` when intending `67%`
2. **Malicious Creation (Low Direct Harm)**: Attacker creates broken organization, but must convince others to use it
3. **Governance Authority Risk (Low Likelihood, High Impact)**: Broken organization adopted as authority, but requires existing governance approval

**Cost-Benefit:**
- Cost: Minimal (just transaction gas)
- Benefit to attacker: Limited unless organization is adopted
- Risk to users: High if they create/adopt such organizations

Overall likelihood: **Medium** - easy to trigger accidentally, moderate impact without social engineering.

## Recommendation

Add validation in the `Validate` method to ensure thresholds do not exceed the token's total supply:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // Add validation against token supply
    return proposalReleaseThreshold.MinimalApprovalThreshold <= tokenInfo.TotalSupply &&
           proposalReleaseThreshold.MinimalVoteThreshold <= tokenInfo.TotalSupply &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold <= tokenInfo.TotalSupply &&
           proposalReleaseThreshold.MaximalRejectionThreshold <= tokenInfo.TotalSupply;
}
```

Alternatively, consider validating against current `supply` if tokens may be minted dynamically, or add comprehensive checks similar to Parliament's approach with explicit bounds.

## Proof of Concept

```csharp
[Fact]
public async Task Create_Organization_With_Impossible_Threshold_Test()
{
    // Get token info to determine total supply
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "ELF"
    });
    
    var impossibleThreshold = tokenInfo.TotalSupply + 1000000; // Exceeds total supply
    
    // Create organization with impossible threshold
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = impossibleThreshold,
            MinimalVoteThreshold = impossibleThreshold,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { DefaultSender }
        },
        TokenSymbol = "ELF"
    };
    
    // This should fail but currently succeeds
    var result = await ReferendumContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Currently passes
    
    var organizationAddress = result.Output;
    
    // Create and vote on a proposal
    var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    
    // Even if we approve with maximum allowance, proposal cannot be released
    await ApproveAsync(DefaultSenderKeyPair, proposalId, tokenInfo.TotalSupply);
    
    // Attempt to release - should fail because threshold cannot be met
    var releaseResult = await ReferendumContractStub.Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // This proves the organization is permanently non-functional
}
```

## Notes

This vulnerability represents a **governance invariant violation** where the protocol allows creation of non-functional organizations. While Parliament and Association contracts properly validate threshold achievability against their respective bounds (`AbstractVoteTotal` and member count), Referendum lacks this critical validation against token supply. This inconsistency creates a protocol integrity issue where validated organizations may be permanently inoperable, violating the fundamental design principle that successful validation should guarantee operability.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L39-72)
```csharp
    private ReferendumReceiptCreated LockToken(string symbol, long amount, Hash proposalId, Address lockedAddress,
        Address organizationAddress)
    {
        Assert(State.LockedTokenAmount[lockedAddress][proposalId] == null, "Already locked.");

        var lockId = Context.GenerateId(Context.Self,
            HashHelper.ConcatAndCompute(proposalId, HashHelper.ComputeFrom(lockedAddress)));
        RequireTokenContractStateSet();
        Context.SendVirtualInline(proposalId, State.TokenContract.Value,
            nameof(TokenContractContainer.TokenContractReferenceState.TransferFrom), new TransferFromInput
            {
                From = Context.Sender,
                To = GetProposalVirtualAddress(proposalId),
                Symbol = symbol,
                Amount = amount,
                Memo = "Referendum."
            });
        State.LockedTokenAmount[Context.Sender][proposalId] = new Receipt
        {
            Amount = amount,
            LockId = lockId,
            TokenSymbol = symbol
        };

        return new ReferendumReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = proposalId,
            Amount = amount,
            Symbol = symbol,
            Time = Context.CurrentBlockTime,
            OrganizationAddress = organizationAddress
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L132-139)
```csharp
    private TokenInfo GetTokenInfo(string symbol)
    {
        RequireTokenContractStateSet();
        return State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = symbol
        });
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L70-82)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L115-122)
```csharp
    public override Empty ReclaimVoteToken(Hash input)
    {
        var proposal = State.Proposals[input];
        Assert(proposal == null ||
               Context.CurrentBlockTime >= proposal.ExpiredTime, "Unable to reclaim at this time.");
        UnlockToken(input, Context.Sender);
        return new Empty();
    }
```

**File:** protobuf/token_contract.proto (L250-265)
```text
message TokenInfo {
    // The symbol of the token.f
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The current supply of the token.
    int64 supply = 3;
    // The total supply of the token.
    int64 total_supply = 4;
    // The precision of the token.
    int32 decimals = 5;
    // The address that has permission to issue the token.
    aelf.Address issuer = 6;
    // A flag indicating if this token is burnable.
    bool is_burnable = 7;
    // The chain id of the token.
```
