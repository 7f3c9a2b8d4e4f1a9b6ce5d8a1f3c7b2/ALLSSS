# Audit Report

## Title
Invalid Profit Detail Creation When EndPeriod Equals CurrentPeriod with Delayed Distribution

## Summary
The `AddBeneficiary` function in the Profit contract has insufficient validation that allows creation of invalid profit details where `StartPeriod > EndPeriod` when a scheme has `DelayDistributePeriodCount > 0`. This causes permanent inflation of `TotalShares`, diluting all legitimate beneficiaries' profit distributions.

## Finding Description

The vulnerability exists in the `AddBeneficiary` method's validation logic. [1](#0-0)  This assertion only validates that `EndPeriod >= CurrentPeriod`, but fails to account for the scheme's `DelayDistributePeriodCount` configuration.

The `StartPeriod` for a new beneficiary is calculated as: [2](#0-1) 

When a manager adds a beneficiary with `EndPeriod = CurrentPeriod` to a scheme with `DelayDistributePeriodCount > 0`, the calculation produces `StartPeriod = CurrentPeriod + DelayDistributePeriodCount`, which exceeds `EndPeriod`. This violates the fundamental invariant that a beneficiary's valid period must have `StartPeriod <= EndPeriod`.

Despite this invalid state, the beneficiary's shares are immediately added to the scheme's `TotalShares`: [3](#0-2) 

When beneficiaries attempt to claim profits, the invalid detail is filtered out: [4](#0-3)  For a detail with `LastProfitPeriod = 0` (never claimed), the condition `d.EndPeriod >= d.StartPeriod` evaluates to false when `StartPeriod > EndPeriod`, excluding it from claimable details.

The automated cleanup mechanisms fail to remove the invalid detail. The cleanup in `AddBeneficiary` requires: [5](#0-4)  Since `LastProfitPeriod` starts at 0 and `EndPeriod = CurrentPeriod`, the condition `0 >= CurrentPeriod` is false, preventing cleanup.

The cleanup in `ClaimProfits` only processes details already in `profitableDetails`: [6](#0-5)  Since the invalid detail was filtered out earlier, it never reaches this cleanup logic.

Users can create profit schemes with delayed distribution: [7](#0-6)  The Treasury Welfare scheme in production uses this configuration: [8](#0-7) 

## Impact Explanation

**Permanent Fund Misallocation**: When an invalid beneficiary with shares S is added to a scheme with existing valid shares T, all future profit distributions use the calculation [9](#0-8)  This allocates `S/(T+S)` of profits to an address that can never claim, while legitimate beneficiaries receive only `T/(T+S)` instead of their rightful 100%.

**Quantified Example**: If a scheme has 100 existing shares and an invalid beneficiary is added with 100 shares, `TotalShares` becomes 200. Each distribution allocates 50% to legitimate beneficiaries (who should receive 100%) and 50% to the unclaimed invalid address. Over 100 periods distributing 1,000 tokens each, 50,000 tokens would be permanently locked in period virtual addresses.

**Recovery Limitation**: While a manager could manually call `RemoveBeneficiary` once `CurrentPeriod > EndPeriod`, this requires awareness of the issue. The invalid detail provides no indication it is unclaimed, and distributions in the interim are permanently diluted.

## Likelihood Explanation

The vulnerability is directly exploitable through public contract methods. [10](#0-9)  shows that `AddBeneficiary` is accessible to scheme managers.

**Feasible Scenarios**:
1. **User-Created Schemes**: Any user can create a profit scheme with `DelayDistributePeriodCount > 0` and subsequently add invalid beneficiaries, either accidentally (not understanding the delay requirement) or maliciously (intentionally diluting distributions).

2. **Execution Simplicity**: Requires only two transactions: `CreateScheme` with `DelayDistributePeriodCount > 0`, followed by `AddBeneficiary` with `EndPeriod = CurrentPeriod`. No complex state manipulation or precise timing needed.

**Probability**: Medium. While it requires a manager with scheme creation rights, the lack of validation makes the mistake straightforward. For user-created schemes with `DelayDistributePeriodCount > 0`, this vulnerability is directly exploitable.

## Recommendation

Add validation in `AddBeneficiary` to ensure `EndPeriod` accounts for the delay period:

```csharp
Assert(input.EndPeriod >= scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
    $"Invalid end period. End Period must be at least {scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount)} to account for delayed distribution.");
```

This ensures the invariant `StartPeriod <= EndPeriod` is always maintained.

## Proof of Concept

```csharp
[Fact]
public async Task AddBeneficiary_WithDelayedDistribution_CreatesInvalidDetail()
{
    // Create scheme with DelayDistributePeriodCount = 1
    var schemeId = await CreateSchemeWithDelay(1);
    var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    
    // CurrentPeriod = 1, EndPeriod = 1, DelayDistributePeriodCount = 1
    await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = UserAddress, Shares = 100 },
        EndPeriod = scheme.CurrentPeriod // EndPeriod = CurrentPeriod = 1
    });
    
    // Verify invalid detail created: StartPeriod (2) > EndPeriod (1)
    var details = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput { SchemeId = schemeId, Beneficiary = UserAddress });
    details.Details[0].StartPeriod.ShouldBe(2); // CurrentPeriod + DelayDistributePeriodCount
    details.Details[0].EndPeriod.ShouldBe(1);
    
    // Verify shares inflated TotalShares
    scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    scheme.TotalShares.ShouldBe(100);
    
    // Attempt to claim fails - detail filtered out
    await DistributeProfits(schemeId, 1000);
    var claimResult = await ProfitContractStub.ClaimProfits.SendAsync(
        new ClaimProfitsInput { SchemeId = schemeId, Beneficiary = UserAddress });
    // Profits remain unclaimed, locked in virtual address
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-59)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
    {
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-174)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-184)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-791)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```
