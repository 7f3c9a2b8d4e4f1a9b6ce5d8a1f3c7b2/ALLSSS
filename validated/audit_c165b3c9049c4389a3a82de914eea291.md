# Audit Report

## Title
Missing Election Results Validation in NextTerm Allows Current Miners to Bypass Elections and Retain Mining Authority

## Summary
The `NextTerm` method in the AEDPoS consensus contract lacks on-chain validation to ensure the miner list matches election results from `GetVictories`. A current miner can call `NextTerm` with an arbitrary miner list, completely bypassing the voting-based validator selection mechanism and retaining control indefinitely.

## Finding Description

The vulnerability exists in the validation and processing flow of term transitions in the AEDPoS consensus contract.

`NextTerm` is a public RPC endpoint that any transaction can invoke [1](#0-0) . When called, it invokes `ProcessConsensusInformation` [2](#0-1) .

Access control is performed via `PreCheck()` which allows **any current OR previous round miner** to call `NextTerm` [3](#0-2) . The validation chain for `NextTerm` behavior only adds `RoundTerminateValidationProvider` [4](#0-3) .

This validator only validates that term and round numbers increment correctly, but performs **NO validation of the miner list contents** [5](#0-4) .

The `ProcessNextTerm` method blindly accepts whatever miner list is provided in `NextTermInput.RealTimeMinersInformation` and sets it as the new miner list without any validation against election results [6](#0-5) .

While the protocol has `TryToGetVictories` to retrieve election results [7](#0-6)  and `GenerateFirstRoundOfNextTerm` to create the proper miner list [8](#0-7) , these are only used for off-chain consensus extra data generation [9](#0-8) , not for on-chain validation.

**Exploitation Flow:**
1. Current term has miners [A, B, C]
2. Elections occur, legitimate winners are [D, E, F] (retrievable via `ElectionContract.GetVictories`)
3. Miner A (from current term) wants to retain power
4. Miner A constructs a malicious `NextTermInput` with miner list [A, B, C] (or any arbitrary list including themselves)
5. Miner A calls `NextTerm` directly via transaction
6. `PreCheck` passes (A is in current round miner list)
7. `RoundTerminateValidationProvider` passes (term/round numbers increment correctly)
8. `ProcessNextTerm` executes and stores the malicious miner list [A, B, C] via `SetMinerList`
9. Miner A successfully retained power despite losing the election

## Impact Explanation

This is a **critical consensus integrity violation**:

**Consensus Breakdown:** The core security invariant that only election-winning validators can mine is completely bypassed. The democratic validator selection mechanism becomes meaningless, enabling permanent control over block production regardless of voting outcomes.

**Economic Damage:** Miners who lost elections continue receiving block rewards and transaction fees indefinitely, while legitimate election winners are excluded. The economic incentive model based on staking and voting collapses, as votes cannot change the validator set.

**Governance Capture:** The community loses the ability to remove malicious or underperforming miners through elections. A small cartel of miners can self-perpetuate control indefinitely, severely damaging protocol credibility and long-term viability.

## Likelihood Explanation

This vulnerability has **high likelihood** of exploitation:

**Reachable Entry Point:** `NextTerm` is a publicly accessible RPC method with no special authorization requirements beyond being a current or previous miner.

**Attacker Prerequisites:** The attacker must be a current miner (has mining authority in the current term) and can construct a `NextTermInput` with an arbitrary miner list. They can observe election results on-chain to know when exploitation is profitable.

**Execution Simplicity:** The attack requires a single transaction calling `NextTerm` with malicious input. No complex state manipulation is needed, and the transaction passes all existing validation checks.

**Economic Incentive:** The cost is a standard transaction fee, while the benefit is retaining mining rewards potentially worth millions in tokens over time. This makes the attack extremely profitable for miners facing election loss.

## Recommendation

Add on-chain validation in the `NextTerm` execution path to ensure the miner list matches election results:

1. In `ProcessNextTerm`, before calling `SetMinerList`, retrieve the legitimate election winners by calling `State.ElectionContract.GetVictories.Call(new Empty())`

2. Compare the provided miner list in `nextRound.RealTimeMinersInformation` with the election results

3. Assert that they match exactly (same miners, potentially allowing for ordering differences)

4. Only proceed with `SetMinerList` if validation passes

Alternatively, add a dedicated validation provider (e.g., `ElectionResultsValidationProvider`) to the validation chain for `NextTerm` behavior that performs this check during `ValidateBeforeExecution`.

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_WithArbitraryMinerList_BypassesElection()
{
    // Setup: Initialize consensus with miner [A, B, C]
    await InitializeConsensusContract();
    
    // Simulate election where [D, E, F] won
    await SetupElectionWinners(new[] {"D", "E", "F"});
    
    // Malicious miner A constructs NextTermInput with [A, B, C] instead of [D, E, F]
    var maliciousNextTermInput = CreateNextTermInput(
        minerList: new[] {"A", "B", "C"}, 
        termNumber: 2
    );
    
    // Miner A calls NextTerm directly
    var result = await MinerAStub.NextTerm.SendAsync(maliciousNextTermInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Miner list is [A, B, C] instead of election winners [D, E, F]
    var actualMiners = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    actualMiners.Pubkeys.ShouldBe(new[] {"A", "B", "C"}); // Election bypassed!
    
    // Election winners [D, E, F] are excluded despite winning
    actualMiners.Pubkeys.ShouldNotContain("D");
    actualMiners.Pubkeys.ShouldNotContain("E");
    actualMiners.Pubkeys.ShouldNotContain("F");
}
```

## Notes

The vulnerability exploits a trust assumption that miners will honestly use the off-chain consensus extra data generation flow which includes election result validation. However, nothing prevents a miner from bypassing this flow and calling `NextTerm` directly with a crafted input. The `SetMinerList` one-time-per-term protection creates a race condition but does not prevent exploitation - the first `NextTerm` to execute wins, and a malicious miner can front-run the legitimate term transition.

### Citations

**File:** protobuf/aedpos_contract.proto (L38-38)
```text
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-17)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-219)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
```
