# Audit Report

## Title
Invalid Behaviour Enum Bypass Enables Consensus State Freeze and Chain DOS

## Summary
A malicious miner can craft blocks with invalid `AElfConsensusBehaviour` enum values (e.g., 999) to bypass critical consensus validation and state update logic. This prevents consensus state progression while still allowing blocks to be committed, enabling unlimited continuous block production and complete chain halt.

## Finding Description

The vulnerability exists in the consensus validation and transaction generation flow where invalid enum values bypass essential security checks.

**Recovery Logic Bypass**: The `ValidateBeforeExecution` method conditionally calls recovery methods only for specific enum values. [1](#0-0)  When an invalid behaviour value is provided, both conditional checks fail, leaving `baseRound` unmodified from its state-fetched value.

**Validation Provider Skip**: The switch statement that adds behaviour-specific validators has no default case for invalid values. [2](#0-1)  This means critical validators like `UpdateValueValidationProvider`, `LibInformationValidationProvider`, `NextRoundMiningOrderValidationProvider`, and `RoundTerminateValidationProvider` are never added to the validation pipeline.

**Protobuf Enum Definition**: The enum only defines 5 valid values (0-4). [3](#0-2)  However, protobuf parsers accept any integer value without validation.

**Empty Transaction Generation**: When consensus transactions are generated, invalid behaviour values hit the default case and return an empty transaction list. [4](#0-3) 

**State Update Prevention**: Without a consensus transaction, `ProcessConsensusInformation` never executes. [5](#0-4)  This means the critical `ResetLatestProviderToTinyBlocksCount` method at line 69 never runs, preventing the continuous block counter from decrementing.

**Continuous Block Limit Bypass**: The `ContinuousBlocksValidationProvider` checks if the block counter has gone negative. [6](#0-5)  Since state never updates, the counter remains at its initial positive value and never triggers the limit.

**Time Slot Validation Bypass**: The `TimeSlotValidationProvider` checks `ActualMiningTimes` from the baseRound. [7](#0-6)  Without recovery or state updates, the baseRound never reflects recent mining activity.

**Recovery Methods**: The recovery methods that should update baseRound with current block information only execute for specific behaviours. [8](#0-7) 

## Impact Explanation

**Critical Consensus DOS**: A single malicious miner can completely halt the blockchain by producing unlimited consecutive blocks:
- Each block passes basic validation (mining permission checks) because the miner is authorized
- Continuous block limits never trigger because `LatestPubkeyToTinyBlocksCount.BlocksCount` never decrements
- Time slot validation passes because `ActualMiningTimes` in state is never updated to reflect previous blocks
- Consensus state (rounds, terms, LIB heights) never advances, freezing all consensus progression
- Other miners cannot produce blocks as their time slots never arrive
- The entire chain becomes non-functional

**Complete Security Mechanism Bypass**: All consensus safety mechanisms are disabled:
- Round transition validation bypassed
- Term transition validation bypassed  
- LIB height validation bypassed
- UpdateValue data validation bypassed
- Secret sharing mechanisms disabled

The severity is **CRITICAL** as it enables complete chain DOS by a single compromised miner with no recovery mechanism available.

## Likelihood Explanation

**Attack Feasibility: HIGH**

**Entry Point**: Any authorized miner can execute this attack through normal block production.

**Attack Complexity: LOW**
- Requires only being an authorized miner (normal operational requirement)
- Technical execution: Modify mining software to set `Behaviour` field to invalid value (e.g., 999)
- No complex timing, coordination, or multi-step setup required
- Can be executed immediately and repeatedly

**Preconditions**: 
- Attacker controls at least one miner node (realistic in any PoS/DPoS system)
- Miner is in current round's miner list (normal operational state)

**Detection Difficulty**: 
- No enum validation exists in the codebase
- Invalid values parse successfully via protobuf
- Blocks appear structurally valid at network layer
- Detection requires monitoring consensus state progression
- Once attack begins, rapid response is difficult as other miners are locked out

**Economic Rationality**: Varies but plausible for various attack motivations (competitor attack, ransom, griefing).

## Recommendation

**Immediate Fix**: Add enum validation in `ValidateBeforeExecution`:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    // Validate behaviour is a defined enum value
    if (!Enum.IsDefined(typeof(AElfConsensusBehaviour), extraData.Behaviour) || 
        extraData.Behaviour == AElfConsensusBehaviour.Nothing)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "Invalid consensus behaviour value." 
        };
    }
    
    // ... rest of existing validation logic
}
```

**Additional Hardening**:
1. Add default cases to all switch statements that handle `AElfConsensusBehaviour` to explicitly reject undefined values
2. Add behaviour validation in `GenerateConsensusTransactions` before processing
3. Consider adding state monitoring that detects when consensus progression stalls

## Proof of Concept

A test demonstrating this vulnerability would:

1. Set up a consensus contract with authorized miners
2. Craft a block with `extraData.Behaviour = 999` (invalid value)
3. Call `ValidateConsensusBeforeExecution` - observe it passes validation
4. Call `GenerateConsensusTransactions` - observe empty transaction list returned
5. Execute block without consensus transaction - observe state unchanged
6. Repeat steps 2-5 - observe unlimited blocks can be produced
7. Verify `LatestPubkeyToTinyBlocksCount.BlocksCount` never decrements
8. Verify consensus state (rounds, terms) never advances

The test would confirm that a single miner can produce unlimited blocks with invalid behaviour values, completely halting consensus progression.

---

**Notes**

This vulnerability represents a fundamental flaw in the consensus validation architecture where enum value validation is absent. The attack is particularly severe because:

1. It requires no special privileges beyond being an authorized miner
2. Detection is difficult as blocks appear valid at the protocol layer
3. Recovery requires manual intervention and cannot be automated
4. A single compromised miner can DOS the entire network

The fix is straightforward (enum validation) but the impact is critical due to the complete consensus halt it enables.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** protobuf/aedpos_contract.proto (L321-327)
```text
enum AElfConsensusBehaviour {
    UPDATE_VALUE = 0;
    NEXT_ROUND = 1;
    NEXT_TERM = 2;
    NOTHING = 3;
    TINY_BLOCK = 4;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L180-181)
```csharp
            default:
                return new TransactionList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-87)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }

        var miningInformationUpdated = new MiningInformationUpdated
        {
            // _processingBlockMinerPubkey is set during PreCheck.
            Pubkey = _processingBlockMinerPubkey,
            Behaviour = callerMethodName,
            MiningTime = Context.CurrentBlockTime,
            BlockHeight = Context.CurrentHeight,
            PreviousBlockHash = Context.PreviousBlockHash
        };
        Context.Fire(miningInformationUpdated);
        Context.LogDebug(() => $"Synced mining information: {miningInformationUpdated}");

        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);

        if (TryToGetCurrentRoundInformation(out var currentRound))
            Context.LogDebug(() =>
                $"Current round information:\n{currentRound.ToString(_processingBlockMinerPubkey)}");

        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");

        if (!State.IsMainChain.Value && currentRound.RoundNumber > 1) Release();

        // Clear cache.
        _processingBlockMinerPubkey = null;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-47)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }

    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```
