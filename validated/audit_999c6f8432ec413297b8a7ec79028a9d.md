# Audit Report

## Title
Vote Contract Option Capacity Exhaustion Enables Election System DoS

## Summary
The Vote contract enforces a hard limit of 64 options per voting item. An attacker can exhaust this capacity by announcing election with 64 different keypairs, permanently blocking all subsequent legitimate candidates from joining the election. The attack costs 6.4M ELF but is fully refundable, and governance has no mechanism to forcibly remove malicious options without attacker cooperation.

## Finding Description

The vulnerability stems from an architectural mismatch between the Election contract's candidate management and the Vote contract's option capacity constraints.

**Attack Vector:**

The Vote contract enforces a maximum of 64 options per voting item [1](#0-0) , checked during option addition [2](#0-1) .

When a candidate calls `AnnounceElection`, the Election contract adds them as an option to the miner election voting item [3](#0-2) . 

The duplicate check only prevents the same public key from announcing twice [4](#0-3) , meaning an attacker can use 64 different keypairs (trivially generated) to fill all slots.

**Critical Gap - Why Governance Cannot Mitigate:**

1. **QuitElection requires admin permission**: Only the candidate admin (controlled by attacker) can voluntarily free slots [5](#0-4) 

2. **RemoveEvilNode does NOT remove Vote options**: When governance removes an evil node, it updates internal Election state but critically fails to call `RemoveOption` on the Vote contract [6](#0-5) . Compare this to QuitElection, which properly calls RemoveOption [7](#0-6) 

3. **RemoveOption access control**: Only the voting item sponsor (the Election contract itself) can modify options [8](#0-7) , preventing direct governance intervention

4. **ReplaceCandidatePubkey is option-neutral**: This method removes the old key and adds the new key atomically [9](#0-8) , maintaining the same option count

**Economic Analysis:**

Each candidate must lock 100,000 ELF [10](#0-9) , totaling 6.4M ELF for 64 candidates. However, this deposit is fully refundable when the attacker calls QuitElection [11](#0-10) , making the attack cost-neutral except for transaction fees.

## Impact Explanation

**Severity: High**

This vulnerability enables a permanent denial-of-service attack on the election system with the following consequences:

1. **Consensus Stagnation**: No new candidates can announce election, preventing the AElf network from onboarding new miners or replacing underperforming ones. This directly impacts consensus security and decentralization.

2. **Governance Capture**: The election system is fundamental to AElf's governance model. Blocking new candidate entry effectively freezes the validator set, concentrating power among existing miners.

3. **Irreversible Without Attacker Cooperation**: The architectural gap means governance cannot forcibly remove malicious Vote options. Recovery requires the attacker to voluntarily call QuitElection on all 64 candidates.

4. **Zero Net Cost Attack**: While requiring 6.4M ELF in capital, the attack has zero net cost since deposits are fully refundable. An attacker can maintain the DoS indefinitely with no ongoing expense.

The impact is categorized as High rather than Critical because it does not result in direct fund loss or supply inflation, but it fundamentally breaks the election system's availability guarantees.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- 64 unique keypairs (trivially generated)
- Temporary access to 6.4M ELF (but maintains full custody)
- No special permissions required

**Attack Complexity:**
Low complexity - simply call `AnnounceElection` 64 times with different transaction signers. Each call succeeds because the duplicate check only prevents the same public key from announcing twice.

**Economic Feasibility:**
While 6.4M ELF is significant capital, the attack is fully recoverable, making it attractive for:
- Competitors seeking to disrupt the network
- Political actors attempting governance capture
- Malicious actors with temporary access to capital

**Detection vs. Remediation Gap:**
The attack is easily detectable (64 candidates from coordinated source), but detectability is irrelevant when governance has no remediation mechanism. The architectural flaw means even identified attacks cannot be mitigated without attacker cooperation.

## Recommendation

**Immediate Fix:**

Modify `RemoveEvilNode` to properly clean up Vote contract options:

```csharp
public override Empty RemoveEvilNode(StringValue input)
{
    Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
    // ... existing validation ...
    
    UpdateCandidateInformation(new UpdateCandidateInformationInput
    {
        Pubkey = input.Value,
        IsEvilNode = true
    });
    
    // ADD THIS: Remove from Vote contract options
    if (!State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value))
    {
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = input.Value
        });
    }
    
    return new Empty();
}
```

**Long-term Solutions:**

1. Increase the Vote contract's `MaximumOptionsCount` to a higher value (e.g., 256 or 512)
2. Implement a minimum reputation or staking period before candidates can consume a Vote option slot
3. Add a governance-controlled emergency cleanup mechanism for Vote contract options
4. Consider separating candidate registration from Vote option allocation

## Proof of Concept

```csharp
[Fact]
public async Task VoteCapacityExhaustion_BlocksNewCandidates()
{
    // Setup: Initialize election contract with voting item
    await InitializeElectionContract();
    
    // Attack: Fill all 64 Vote option slots
    var attackerKeys = new List<ECKeyPair>();
    for (int i = 0; i < 64; i++)
    {
        var keypair = CryptoHelper.GenerateKeyPair();
        attackerKeys.Add(keypair);
        
        // Fund each keypair with 100,000 ELF
        await TokenContractStub.Transfer.SendAsync(new TransferInput
        {
            To = Address.FromPublicKey(keypair.PublicKey),
            Symbol = "ELF",
            Amount = 100_000_00000000
        });
        
        // Announce election with unique keypair
        var electionStub = GetElectionContractStub(keypair);
        await electionStub.AnnounceElection.SendAsync(Address.FromPublicKey(keypair.PublicKey));
    }
    
    // Verify: Next legitimate candidate cannot join
    var legitimateCandidate = CryptoHelper.GenerateKeyPair();
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = Address.FromPublicKey(legitimateCandidate.PublicKey),
        Symbol = "ELF",
        Amount = 100_000_00000000
    });
    
    var legitimateStub = GetElectionContractStub(legitimateCandidate);
    var result = await legitimateStub.AnnounceElection.SendWithExceptionAsync(
        Address.FromPublicKey(legitimateCandidate.PublicKey)
    );
    
    // Assert: Transaction fails with capacity error
    result.TransactionResult.Error.ShouldContain("The count of options can't greater than 64");
    
    // Demonstrate: Governance cannot remove via RemoveEvilNode
    var governanceStub = GetElectionContractStub(GetEmergencyResponseOrganizationKeyPair());
    await governanceStub.RemoveEvilNode.SendAsync(new StringValue 
    { 
        Value = attackerKeys[0].PublicKey.ToHex() 
    });
    
    // Verify: Option count still 64, legitimate candidate still blocked
    var votingResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = MinerElectionVotingItemId,
        SnapshotNumber = 1
    });
    votingResult.Results.Count.ShouldBe(64); // Option still exists!
    
    // Still cannot announce
    result = await legitimateStub.AnnounceElection.SendWithExceptionAsync(
        Address.FromPublicKey(legitimateCandidate.PublicKey)
    );
    result.TransactionResult.Error.ShouldContain("The count of options can't greater than 64");
}
```

## Notes

This vulnerability represents a critical architectural oversight where the Election contract's removal mechanisms (`RemoveEvilNode`) do not properly synchronize with the Vote contract's option management. The deposit refundability transforms what should be an expensive attack into a cost-neutral denial-of-service vector. The lack of any governance-controlled remediation path makes this vulnerability particularly severe despite the capital requirements.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L305-306)
```csharp
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L154-157)
```csharp
        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L197-209)
```csharp
    private void AddCandidateAsOption(string publicKey)
    {
        if (State.VoteContract.Value == null)
            State.VoteContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName);

        // Add this candidate as an option for the the Voting Item.
        State.VoteContract.AddOption.Send(new AddOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = publicKey
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L239-249)
```csharp
        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L257-261)
```csharp
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L308-317)
```csharp
            State.VoteContract.RemoveOption.Send(new RemoveOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = oldPubkey
            });
            State.VoteContract.AddOption.Send(new AddOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = newPubkey
            });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
