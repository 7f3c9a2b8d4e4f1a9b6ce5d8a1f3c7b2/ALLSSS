# Audit Report

## Title
Missing UpdateValue Uniqueness Check Allows Mining Order Manipulation

## Summary
The AEDPoS consensus validation logic fails to verify whether a miner has already published their OutValue before accepting an UpdateValue transaction. This allows malicious miners to invoke UpdateValue multiple times within the same round with different InValues, repeatedly overwriting their signature to optimize their mining position in the next round, breaking the fairness of VRF-based mining order determination.

## Finding Description

The AEDPoS consensus mechanism expects each miner to call UpdateValue exactly once per round to commit their OutValue and Signature, which determines their mining order in the next round. However, the validation logic contains a critical gap that allows this invariant to be violated.

**Root Cause:**

The validation flow calls `RecoverFromUpdateValue` which overwrites the baseRound's OutValue with the provided value BEFORE validation occurs. [1](#0-0) 

The `RecoverFromUpdateValue` method unconditionally overwrites the OutValue and Signature fields, destroying any evidence that these values were previously set. [2](#0-1) 

The UpdateValueValidationProvider only checks that the ProvidedRound (from block header) contains non-empty values, but never verifies whether the ORIGINAL baseRound state (before recovery) already had OutValue set. [3](#0-2) 

**Expected Behavior:**

The consensus behavior logic expects OutValue to be null for the first block (UpdateValue behavior) and non-null for subsequent blocks (TinyBlock behavior). [4](#0-3) 

An honest miner would receive UpdateValue behavior once, then TinyBlock for additional blocks in their time slot.

**Insufficient Protection:**

The only duplicate prevention is `EnsureTransactionOnlyExecutedOnceInOneBlock`, which prevents multiple consensus transactions per BLOCK but not per ROUND. [5](#0-4) 

Since miners can produce up to 8 blocks per time slot [6](#0-5) , they can call UpdateValue up to 8 times per round.

**Attack Execution:**

When ProcessUpdateValue executes, it unconditionally overwrites OutValue and Signature. [7](#0-6) 

A malicious miner can produce multiple blocks with UpdateValue behavior and different InValues, with each execution overwriting the previous OutValue/Signature.

**Order Calculation:**

The signature directly determines mining order through modulo arithmetic. [8](#0-7) 

The GetAbsModulus helper implements the formula `(|signature| % minersCount) + 1`. [9](#0-8) 

Different signatures produce different mining orders, allowing optimization through multiple attempts.

## Impact Explanation

**Consensus Integrity Compromise:**

This vulnerability breaks a fundamental security guarantee of the AEDPoS consensus mechanism: that mining order is determined fairly through VRF-based randomness that miners cannot manipulate after seeing the value. By allowing multiple UpdateValue calls, miners can:

- Calculate offline which InValue produces the most favorable mining order
- Effectively "reroll" their mining position up to 8 times per round
- Consistently achieve top mining positions (e.g., with 21 miners and 8 attempts, improve from average position 11 to position ~3)

**Network-Wide Effects:**

- Honest miners receive reduced mining opportunities and lower block rewards
- Attackers gain disproportionate influence over block production and transaction ordering
- Network decentralization degrades as rational miners adopt this strategy
- Long-term consensus security weakens as mining becomes predictably manipulable

**Economic Harm:**

The attack costs only standard transaction fees for additional blocks (minimal), while providing significant benefit through improved mining positions and higher rewards. This makes it economically rational for all miners to exploit, creating a tragedy-of-the-commons scenario where consensus fairness collapses.

## Likelihood Explanation

**Attacker Requirements:**

- Must be an authorized miner (realistic for blockchain validators)
- Must control block production during their time slot (inherent miner capability)
- No special privileges or compromised keys required

**Attack Complexity:**

The attack is straightforward:
1. Call GetConsensusExtraData with UpdateValue behavior and different InValues for each block [10](#0-9) 
2. The validation accepts all blocks as valid
3. Each execution overwrites the previous OutValue/Signature

No exploitation of complex race conditions, no need to compromise other nodes, and the attack path uses normal transaction execution.

**Detection:**

While the attack leaves visible on-chain evidence (multiple UpdateValue transactions from the same miner in one round), the current validation logic treats this as acceptable behavior. No automated detection or prevention mechanism exists.

## Recommendation

Add a validation check in `UpdateValueValidationProvider` or `ValidateBeforeExecution` to verify that the miner's OutValue was null in the original baseRound state before accepting an UpdateValue transaction:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    // NEW: Check if miner already published OutValue in current round
    var originalMinerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    if (originalMinerInRound.OutValue != null && originalMinerInRound.OutValue.Value.Any())
        return new ValidationResult { Message = "Miner has already published OutValue in this round." };

    // Existing checks
    if (!NewConsensusInformationFilled(validationContext))
        return new ValidationResult { Message = "Incorrect new Out Value." };

    if (!ValidatePreviousInValue(validationContext))
        return new ValidationResult { Message = "Incorrect previous in value." };

    return new ValidationResult { Success = true };
}
```

Alternatively, move the RecoverFromUpdateValue call to occur AFTER validation passes, preserving the original state for validation checks.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test chain with multiple miners
2. Having a miner produce their first block with UpdateValue and InValue1
3. Having the same miner produce a second block with UpdateValue and InValue2 (instead of TinyBlock)
4. Observing that validation passes and the OutValue/Signature is overwritten
5. Verifying that different InValues produce different mining orders in the next round
6. Repeating up to 8 times to show mining order optimization

The test would verify that `ValidateBeforeExecution` does not reject the second UpdateValue call, confirming the missing uniqueness check.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L16-17)
```csharp
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-62)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-245)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-112)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        Assert(triggerInformation.InValue != null, "In value should not be null.");

        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
        var previousInValue = Hash.Empty; // Just initial previous in value.

        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
        }

        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
