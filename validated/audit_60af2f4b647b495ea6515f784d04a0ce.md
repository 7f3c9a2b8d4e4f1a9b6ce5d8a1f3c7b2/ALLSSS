# Audit Report

## Title
Arithmetic Underflow in Quadratic Voting Withdrawal Due to Vote/Withdraw Amount Mismatch

## Summary
The Vote contract contains a critical arithmetic mismatch between vote addition and withdrawal for quadratic voting items. When a quadratic vote is cast, only `1` is added to `Results[option]`, but during withdrawal, the full `votingRecord.Amount` (equal to `TicketCost * votesCount`) is subtracted. This causes an arithmetic underflow exception, permanently preventing users from withdrawing their locked tokens and creating a complete denial-of-service for all quadratic voting items.

## Finding Description

The Vote contract implements quadratic voting functionality where users pay an increasing cost for each additional vote. However, there is a fundamental inconsistency in how vote amounts are tracked versus how they are withdrawn.

**During Vote Execution:**

When a user votes on a quadratic voting item, the contract calculates the amount and stores this full amount in the voting record: [1](#0-0) 

However, when updating the voting results, the contract passes only `1` instead of the actual locked amount for quadratic votes: [2](#0-1) 

The `UpdateVotingResult()` function then adds this value (which is `1` for quadratic voting) to `Results[option]`: [3](#0-2) 

**During Withdrawal:**

When a user attempts to withdraw, the contract subtracts the full `votingRecord.Amount` from `Results[option]` without any special handling for quadratic voting: [4](#0-3) 

**Why This Fails:**

The `.Sub()` method is a checked arithmetic operation that throws an `OverflowException` when underflow occurs: [5](#0-4) 

Since `Results[option]` contains only `1` but the withdrawal attempts to subtract `TicketCost * votesCount` (which is always greater than 1 for any reasonable ticket cost), the operation throws an exception, causing the transaction to fail.

The `Withdraw()` function never checks the `IsQuadratic` flag to adjust its logic accordingly, making this issue affect every single quadratic voting withdrawal attempt.

## Impact Explanation

**Direct Fund Impact:**
- All tokens locked for quadratic voting become permanently locked and unrecoverable
- Users cannot withdraw their funds, resulting in complete loss of access to locked tokens
- For example: If `TicketCost = 100` and a user votes once, they lock 100 tokens but `Results[option]` only contains `1`, making withdrawal mathematically impossible

**Operational Impact:**
- Complete denial of service on the `Withdraw()` function for ALL quadratic voting items
- Voting results are corrupted as `Results[option]` values don't reflect actual token amounts locked
- The entire quadratic voting feature is non-functional in production

**Affected Parties:**
- All users who participate in quadratic voting items lose their locked tokens
- Vote sponsors who create quadratic voting items unknowingly create token traps
- The protocol's voting mechanism integrity is compromised

This represents a HIGH severity vulnerability due to guaranteed permanent fund loss and complete feature DoS with no available workaround.

## Likelihood Explanation

**No Attack Required:**
This is a fundamental logic bug that triggers during normal, legitimate operation. No malicious intent or special conditions are needed.

**Trivial Reproduction:**
Any user participating in quadratic voting will encounter this issue:
1. Sponsor creates a quadratic voting item with `IsQuadratic = true` and any `TicketCost > 1`
2. User votes normally using the public `Vote()` function
3. User attempts to withdraw using the public `Withdraw()` function
4. Transaction fails with `OverflowException`

**Feasibility:**
- Quadratic voting feature must be enabled (`IsQuadratic = true`)
- `TicketCost` must be greater than the vote count (always true for reasonable ticket costs like 100, 1000, etc.)
- No special permissions or state manipulation required
- Uses standard public contract methods

**Probability:**
100% reproducible on every quadratic voting withdrawal attempt. The arithmetic mismatch guarantees the failure.

## Recommendation

The fix requires consistent handling of quadratic voting amounts throughout the contract. There are two possible approaches:

**Option 1: Store vote count in Results for quadratic voting**
Modify `Withdraw()` to handle quadratic voting specially:

```csharp
public override Empty Withdraw(WithdrawInput input)
{
    // ... existing code ...
    
    var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);
    var votingResult = State.VotingResults[votingResultHash];
    
    // Fix: Handle quadratic voting differently
    var amountToSubtract = votingItem.IsQuadratic ? 1 : votingRecord.Amount;
    votingResult.Results[votingRecord.Option] = 
        votingResult.Results[votingRecord.Option].Sub(amountToSubtract);
    
    // ... rest of withdrawal logic ...
}
```

**Option 2: Store actual amounts in Results for quadratic voting**
Modify `Vote()` to pass the actual amount even for quadratic voting:

```csharp
UpdateVotingResult(votingItem, input.Option, amount);
```

Remove the ternary operator that passes `1` for quadratic votes.

Option 2 is recommended as it maintains consistency throughout the contract and makes `Results[option]` always represent the total token amount locked for that option.

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_Withdrawal_Underflow_Test()
{
    // Register a quadratic voting item
    var startTime = TimestampHelper.GetUtcNow();
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(10),
        StartTimestamp = startTime,
        Options = { "Option1", "Option2" },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = true,
        IsQuadratic = true,
        TicketCost = 100  // Cost per vote
    };
    
    var registerResult = await VoteContractStub.Register.SendAsync(input);
    registerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    input.Options.Clear();
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender)
    );
    
    // User votes once
    var voter = Accounts[1].KeyPair;
    var voteResult = await GetVoteContractTester(voter).Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "Option1",
        Amount = 0  // Not used for quadratic voting
    });
    voteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Get the vote ID
    var voteIds = await VoteContractStub.GetVotingIds.CallAsync(new GetVotingIdsInput
    {
        Voter = Address.FromPublicKey(voter.PublicKey),
        VotingItemId = votingItemId
    });
    var voteId = voteIds.ActiveVotes.First();
    
    // Check: votingRecord.Amount = 100 (TicketCost * 1)
    var votingRecord = await VoteContractStub.GetVotingRecord.CallAsync(voteId);
    votingRecord.Amount.ShouldBe(100);
    
    // Check: Results["Option1"] = 1 (not 100!)
    var votingResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItemId,
        SnapshotNumber = 1
    });
    votingResult.Results["Option1"].ShouldBe(1);  // Only 1, not 100!
    
    // Attempt to withdraw - THIS WILL FAIL
    var withdrawResult = await GetVoteContractTester(voter).Withdraw.SendWithExceptionAsync(
        new WithdrawInput { VoteId = voteId }
    );
    
    // Verify underflow exception occurs
    withdrawResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    withdrawResult.TransactionResult.Error.ShouldContain("Overflow");  // Checked arithmetic underflow
}
```

## Notes

The vulnerability is confirmed through code analysis. The mismatch occurs because:

1. `Vote()` stores full token amount in `votingRecord.Amount` but only increments `Results[option]` by 1 for quadratic voting [6](#0-5) 

2. `Withdraw()` attempts to subtract the full `votingRecord.Amount` from `Results[option]` [7](#0-6) 

3. The SafeMath library enforces checked arithmetic [5](#0-4) 

4. The `Results` map stores `int64` values [8](#0-7) 

This creates a guaranteed underflow scenario (e.g., `1.Sub(100)`) that throws an `OverflowException`, permanently locking user funds.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-119)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }

        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;

        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-216)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```

**File:** protobuf/vote_contract.proto (L166-166)
```text
    map<string, int64> results = 2;
```
