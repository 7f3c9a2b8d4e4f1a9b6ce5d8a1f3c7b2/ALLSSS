# Audit Report

## Title
Vote Contract Timestamp Enforcement Missing - Sponsor Can Manipulate Snapshot Timing

## Summary
The Vote contract accepts `StartTimestamp` and `EndTimestamp` during voting item registration with explicit protocol documentation describing these as "The start time of the voting" and "The end time of the voting," but completely fails to enforce these time constraints in any execution path. This allows sponsors to manipulate voting outcomes through strategic snapshot timing.

## Finding Description

The Vote contract's `Register` method accepts and stores `StartTimestamp` and `EndTimestamp` fields in the voting item structure. [1](#0-0)  The protocol documentation in the protobuf definition explicitly describes these fields as "The start time of the voting" and "The end time of the voting." [2](#0-1) 

During registration, the contract performs a single timestamp validation requiring `EndTimestamp > StartTimestamp`. [3](#0-2)  However, no timestamp enforcement exists in any subsequent execution path.

The `Vote` method calls `AssertValidVoteInput` to validate voting eligibility. [4](#0-3)  This validation function checks option validity and snapshot numbers but never compares `Context.CurrentBlockTime` against the voting item's `StartTimestamp` or `EndTimestamp`. [5](#0-4) 

The `TakeSnapshot` method similarly lacks any timestamp validation. [6](#0-5)  It only verifies sponsor permission, snapshot number limits, and sequential snapshot ordering, with no code preventing the sponsor from delaying snapshots indefinitely beyond the declared `EndTimestamp`.

Test evidence confirms this behavior. The test helper creates voting items with specific durations (e.g., 10 days), [7](#0-6)  yet snapshots can be taken immediately without waiting for the time period to elapse. [8](#0-7) 

## Impact Explanation

**Semantic Contract Violation:** The Vote contract is a public infrastructure component where anyone can call `Register` to create voting items. The protocol documentation creates an explicit semantic contract that timestamps define the voting period, yet this contract is completely unenforced, creating a false sense of security.

**Governance Manipulation:** Sponsors can strategically time snapshot captures to optimize voting outcomes. If early votes are unfavorable, the sponsor delays taking a snapshot. If later votes become unfavorable, the sponsor takes an immediate snapshot. Voting can continue indefinitely past the declared `EndTimestamp`, allowing outcome manipulation.

**Voter Deception:** Voters see `StartTimestamp` and `EndTimestamp` in the voting item structure and reasonably expect voting ends at that time. This can cause voters to either abstain from voting (believing the period has ended) or rush to vote before `EndTimestamp` (when timing is actually irrelevant).

**Protocol-Level Impact:** While the Election contract works around this issue by using effectively infinite timestamps, [9](#0-8)  the Vote contract remains a flawed generic infrastructure component. Any external contracts or users creating voting items with meaningful time constraints will find those constraints completely unenforced.

## Likelihood Explanation

**Attacker Profile:** The attacker is the voting item sponsor who registered the voting item. No special privileges beyond sponsor status are required.

**Attack Complexity:** Trivial - the sponsor simply delays calling `TakeSnapshot()` to the optimal time. No complex transactions, state manipulation, or precise timing is required.

**Preconditions:** Any voting item created with non-infinite timestamps where the sponsor wishes to manipulate outcomes. While the Election contract currently uses infinite timestamps, the Vote contract is publicly accessible and any future external usage would be vulnerable.

**Economic Rationality:** Zero cost to execute (just delay an action), with potentially high benefit from controlling voting outcome timing, making this economically rational for sponsors seeking favorable results.

## Recommendation

Add timestamp enforcement in both `Vote()` and `TakeSnapshot()` methods:

```csharp
// In AssertValidVoteInput method:
Assert(Context.CurrentBlockTime >= votingItem.StartTimestamp, 
    "Voting has not started yet.");
Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, 
    "Voting has already ended.");

// In TakeSnapshot method:
Assert(Context.CurrentBlockTime >= votingItem.EndTimestamp, 
    "Cannot take snapshot before voting end time.");
```

Alternatively, if timestamps are intended to be informational only, update the protocol documentation to clarify this and consider removing the misleading validation that `EndTimestamp > StartTimestamp`.

## Proof of Concept

```csharp
[Fact]
public async Task VoteContract_Timestamp_Not_Enforced_Test()
{
    // Register voting item with 10 days duration
    var startTime = TimestampHelper.GetUtcNow();
    var votingItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, 2);
    
    // Verify timestamps were set
    votingItem.StartTimestamp.ShouldBe(startTime);
    votingItem.EndTimestamp.ShouldBe(startTime.AddDays(10));
    
    // VULNERABILITY: Take snapshot immediately without waiting for EndTimestamp
    // This should fail if timestamps were enforced, but it succeeds
    var result = await TakeSnapshot(votingItem.VotingItemId, 1);
    result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Voting item is now "ended" despite EndTimestamp being 10 days away
    // This proves timestamps are not enforced
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L45-47)
```csharp
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L92-92)
```csharp
        var votingItem = AssertValidVoteInput(input);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L361-361)
```csharp
        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** protobuf/vote_contract.proto (L88-91)
```text
    // The start time of the voting.
    google.protobuf.Timestamp start_timestamp = 1;
    // The end time of the voting.
    google.protobuf.Timestamp end_timestamp = 2;
```

**File:** test/AElf.Contracts.Vote.Tests/VoteContractTestHelper.cs (L32-36)
```csharp
        var startTime = TimestampHelper.GetUtcNow();
        var input = new VotingRegisterInput
        {
            TotalSnapshotNumber = totalSnapshotNumber,
            EndTimestamp = startTime.AddDays(lastingDays),
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/SnapshotTests.cs (L45-51)
```csharp
        var votingItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, totalSnapshotNumber);
        await VoteContractStub.TakeSnapshot.SendAsync(
            new TakeSnapshotInput
            {
                VotingItemId = votingItem.VotingItemId,
                SnapshotNumber = 1
            });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L60-68)
```csharp
        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
        State.VoteContract.Register.Send(votingRegisterInput);
```
