# Audit Report

## Title
Insufficient Order Validation Allows Duplicate Mining Orders to Break Secret Sharing Reconstruction

## Summary
The AEDPoS consensus mechanism contains three interconnected validation failures that allow a malicious miner to create duplicate `FinalOrderOfNextRound` values through crafted `TuneOrderInformation`. These duplicate orders propagate to subsequent rounds and cause the Shamir's Secret Sharing reconstruction in `DecodeSecret` to produce incorrect results due to division by zero in Lagrange interpolation, compromising the consensus secret sharing verification mechanism.

## Finding Description

The vulnerability exists due to three interconnected validation failures:

**Root Cause #1 - Flawed Duplicate Detection:**

The `NextRoundMiningOrderValidationProvider` attempts to validate mining order uniqueness but the implementation is incorrect. [1](#0-0) 

The `Distinct()` method operates on `MinerInRound` objects rather than extracting and checking the `FinalOrderOfNextRound` property values themselves. Since each miner has a unique `MinerInRound` instance, the distinctness check always passes regardless of whether the actual `FinalOrderOfNextRound` values are duplicates.

**Root Cause #2 - Unvalidated TuneOrderInformation:**

When processing `UpdateValue`, the contract blindly applies whatever `TuneOrderInformation` is provided without validating uniqueness or range. [2](#0-1) 

A malicious miner can craft an `UpdateValueInput` with duplicate `FinalOrderOfNextRound` values in `TuneOrderInformation`, and these will be directly applied to the round state. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`. [3](#0-2) 

Additionally, the validation framework only applies `NextRoundMiningOrderValidationProvider` for `NextRound` behavior, not for `UpdateValue` behavior. [4](#0-3) 

**Root Cause #3 - Missing Duplicate Order Validation in DecodeSecret:**

When a new round is generated, the `FinalOrderOfNextRound` values from the current round become the `Order` values in the next round. [5](#0-4) 

Subsequently, `RevealSharedInValues` extracts order values from the previous round's miner information and passes them to `DecodeSecret`. [6](#0-5) 

The `DecodeSecret` function performs Shamir's Secret Sharing reconstruction using Lagrange interpolation but does not validate that the `orders` parameter contains unique values. [7](#0-6) 

When duplicate orders exist (e.g., `orders[j] == orders[i]` for `j != i`), the denominator calculation `orders[j] - orders[i]` becomes zero. [8](#0-7) 

This zero denominator flows through `MultiplyRational` [9](#0-8) , then `RationalToWhole` calls `Inverse(0)` [10](#0-9) . The `Inverse` function with input 0 returns 0 through the Extended Euclidean Algorithm [11](#0-10) , causing the Lagrange basis polynomial term to evaluate incorrectly, resulting in incorrect secret reconstruction.

**Attack Sequence:**

1. Round N: Malicious miner (who must be in the active miner set) submits `UpdateValue` with duplicate `FinalOrderOfNextRound` values in `TuneOrderInformation`
2. `ProcessUpdateValue` applies these duplicate values without validation
3. Round N+1: When `NextRound` is called, `GenerateNextRoundInformation` sets the `Order` values in the new round based on `FinalOrderOfNextRound` from Round N, creating duplicate `Order` values
4. Round N+1: Miners perform secret sharing with `DecryptedPieces`
5. Round N+2: When `RevealSharedInValues` is called, it extracts the duplicate `Order` values and passes them to `DecodeSecret`
6. `DecodeSecret` produces incorrect results due to division by zero, setting wrong `PreviousInValue` hashes

## Impact Explanation

**Consensus Integrity Compromise:**

The secret sharing mechanism is a critical component of AEDPoS consensus designed to reconstruct and verify miners' `PreviousInValue` through Lagrange interpolation. This ensures miners cannot cheat on their random value commitments, which are fundamental to consensus security and random number generation.

When `DecodeSecret` produces incorrect results due to duplicate orders:
- Miners' `PreviousInValue` fields are set to wrong hash values in the current round
- The cryptographic integrity of the random number generation chain is broken
- The consensus validation mechanism for miner behavior becomes unreliable
- Subsequent rounds may fail validation or accept invalid consensus states
- The network may experience consensus disruption requiring manual intervention

**Affected Parties:**
- All consensus participants are affected as the secret sharing verification becomes unreliable
- The entire network's consensus security is degraded when this mechanism fails
- Honest miners may be falsely flagged or malicious behavior may go undetected

**Severity Assessment: Medium**
- Does not directly result in fund theft or unauthorized token minting
- Compromises consensus integrity and random number generation security
- Could enable secondary attacks by breaking miner behavior verification
- May cause consensus disruption but does not permanently halt the chain

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner in the consensus set (requires winning election through governance)
- No special privileges beyond normal miner capabilities required
- Can craft malicious `UpdateValueInput` with duplicate `TuneOrderInformation` values

**Attack Complexity:**
- Low technical complexity: Simply requires modifying the `TuneOrderInformation` field when calling `UpdateValue`
- No sophisticated cryptographic attacks or precise timing manipulation needed
- Can be executed in a single transaction during the attacker's designated mining slot
- The flawed validation allows the attack to succeed on-chain

**Feasibility Conditions:**
- Requires the attacker to be selected as a miner through the election process
- Secret sharing must be enabled (checked via configuration contract) [12](#0-11) 
- The malicious round must successfully transition through `NextRound` to propagate duplicate orders
- Effects manifest two rounds later when `RevealSharedInValues` is called

**Detection Constraints:**
- The incorrect `PreviousInValue` values would be detectable through off-chain monitoring
- However, the flawed validation allows the attack to succeed on-chain before detection
- May cause observable consensus anomalies that alert network operators

**Likelihood Assessment: Medium**
- Requires compromised miner position, but miners are elected through governance mechanisms
- Easy to execute once in position with low technical barriers
- Detectable through monitoring but may cause temporary disruption before remediation

## Recommendation

**Fix 1: Correct the NextRoundMiningOrderValidationProvider**

Change the duplicate detection to operate on the actual `FinalOrderOfNextRound` values:
```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

**Fix 2: Add validation for TuneOrderInformation in ProcessUpdateValue**

Before applying the tuned orders, validate uniqueness:
```csharp
// Validate TuneOrderInformation for duplicates
var tunedOrders = updateValueInput.TuneOrderInformation.Values.ToList();
if (tunedOrders.Count != tunedOrders.Distinct().Count())
{
    Assert(false, "Duplicate orders in TuneOrderInformation.");
}

foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**Fix 3: Add duplicate order validation in DecodeSecret**

Validate the `orders` parameter before performing Lagrange interpolation:
```csharp
public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
{
    // Validate no duplicate orders
    if (orders.Count != orders.Distinct().Count())
    {
        throw new InvalidOperationException("Duplicate orders detected in secret sharing reconstruction");
    }
    
    var result = BigInteger.Zero;
    // ... rest of implementation
}
```

## Proof of Concept

```csharp
using System.Collections.Generic;
using System.Linq;
using AElf.Cryptography.SecretSharing;
using Xunit;

namespace AElf.Cryptography.Tests
{
    public class DuplicateOrderVulnerabilityTest
    {
        [Fact]
        public void DecodeSecret_WithDuplicateOrders_ProducesIncorrectResult()
        {
            // Arrange: Create a secret and encode it
            var secret = "test_secret";
            var secretBytes = System.Text.Encoding.UTF8.GetBytes(secret);
            var threshold = 3;
            var totalParts = 5;
            
            var encodedParts = SecretSharingHelper.EncodeSecret(secretBytes, threshold, totalParts);
            
            // Normal case: unique orders [1, 2, 3]
            var normalOrders = new List<int> { 1, 2, 3 };
            var normalResult = SecretSharingHelper.DecodeSecret(
                encodedParts.Take(threshold).ToList(), 
                normalOrders, 
                threshold);
            
            // Vulnerability: duplicate orders [1, 1, 3]
            var duplicateOrders = new List<int> { 1, 1, 3 };
            var vulnerableResult = SecretSharingHelper.DecodeSecret(
                encodedParts.Take(threshold).ToList(), 
                duplicateOrders, 
                threshold);
            
            // Assert: Results should differ, proving incorrect reconstruction
            Assert.NotEqual(normalResult, vulnerableResult);
            Assert.Equal(secretBytes, normalResult);
            Assert.NotEqual(secretBytes, vulnerableResult);
        }
    }
}
```

## Notes

This vulnerability requires the attacker to have miner privileges, which provides a natural barrier to exploitation. However, once a miner position is compromised (whether through election manipulation or other means), the attack is trivial to execute and can disrupt consensus integrity. The fix should be implemented across all three validation points to ensure comprehensive protection against duplicate order manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-50)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L67-70)
```csharp
        private static BigInteger RationalToWhole(BigInteger numerator, BigInteger denominator)
        {
            return numerator * Inverse(denominator) % SecretSharingConsts.FieldPrime;
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L83-96)
```csharp
        private static (BigInteger gcd, BigInteger invA, BigInteger invB) GetGreatestCommonDivisor2(BigInteger integer1,
            BigInteger integer2)
        {
            if (integer2 == 0) return (integer1, 1, 0);

            var div = BigInteger.DivRem(integer1, integer2, out var rem);
            var (g, iA, iB) = GetGreatestCommonDivisor2(integer2, rem);
            return (g, iB, iA - iB * div);
        }

        private static BigInteger Inverse(BigInteger integer)
        {
            return GetGreatestCommonDivisor2(SecretSharingConsts.FieldPrime, integer).invB.Abs();
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L98-106)
```csharp
        private static (BigInteger numerator, BigInteger denominator) MultiplyRational(
            BigInteger numeratorLhs, BigInteger denominatorLhs,
            BigInteger numeratorRhs, BigInteger denominatorRhs)
        {
            var numerator = numeratorLhs * numeratorRhs % SecretSharingConsts.FieldPrime;
            var denominator = denominatorLhs * denominatorRhs % SecretSharingConsts.FieldPrime;
            var gcd = GetGreatestCommonDivisor(numerator, denominator);
            return (numerator / gcd, denominator / gcd);
        }
```
