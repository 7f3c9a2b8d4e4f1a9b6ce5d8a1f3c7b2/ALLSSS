# Audit Report

## Title
Vote Target Change Denial of Service for Legacy Votes After Weight Settings Update

## Summary
Legacy votes created before the ProfitDetailId feature cannot change targets with extended profit periods (`IsResetVotingTime=true`) after governance updates vote weight calculation settings. The profit detail lookup fails because weight recalculation uses current settings while stored profit details use old settings, causing a mismatch that results in transaction failure.

## Finding Description

The vulnerability exists in the vote target change flow when users set `IsResetVotingTime=true` to extend their profit earning period.

**Root Cause - Weight Recalculation:**

When changing vote targets with `IsResetVotingTime=true`, the `ExtendVoterWelfareProfits` method is invoked [1](#0-0) . This method retrieves the election voting record via `GetElectionVotingRecordByVoteId` [2](#0-1) , which internally calls `TransferVotingRecordToElectionVotingRecord` [3](#0-2) .

The critical issue occurs in `TransferVotingRecordToElectionVotingRecord` where the vote weight is **recalculated** using the **current** `VoteWeightInterestList` and `VoteWeightProportion` settings [4](#0-3) . The weight calculation method `GetVotesWeight` explicitly uses current state values [5](#0-4) .

**Profit Detail Lookup Failure:**

The `GetProfitDetailByElectionVotingRecord` method attempts to find the voter's profit detail using two strategies: first by profit detail ID, then by shares as fallback [6](#0-5) . The code comment explicitly states "However, in the old world, profitDetail.Id is null, so use Shares" [7](#0-6) .

For legacy votes without IDs, the shares-based matching compares the **recalculated weight** against the **original shares** that were calculated with old weight settings. After governance changes weight settings via `SetVoteWeightInterest` or `SetVoteWeightProportion` [8](#0-7) , these values no longer match.

**Transaction Failure:**

When no matching profit detail is found, the method throws an `AssertionException` that prevents the entire transaction from succeeding [9](#0-8) . The same pattern exists in the Profit contract's `FixProfitDetail` method [10](#0-9) .

## Impact Explanation

**Affected Users:** All holders of legacy votes (created before ProfitDetailId feature or under previous weight settings) who attempt to change vote targets after governance updates weight calculation parameters.

**Impact Severity: MEDIUM**

The vulnerability causes:
1. **Denial of Service** - Users cannot execute the legitimate `ChangeVotingOption` operation with `IsResetVotingTime=true`
2. **Economic Loss** - Users lose the ability to extend their profit earning period when changing targets, forcing them to either keep their current vote target (losing voting flexibility) or change target with `IsResetVotingTime=false`, accepting a proportionally reduced profit period and forfeiting expected future rewards
3. **System-Wide Effect** - ALL legacy votes are affected after a single governance weight settings update
4. **No Direct Fund Theft** - While economically harmful, funds remain safe and accessible

The economic loss equals the difference between profits earned over a full extended period versus a reduced period, which could be substantial for long-term locked votes.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Preconditions:**
1. Legacy votes exist in the system (explicitly acknowledged in code comments as "old world" votes)
2. Governance executes `SetVoteWeightInterest` or `SetVoteWeightProportion` to update weight calculation parameters

**Feasibility: HIGH**
- Weight settings changes are legitimate governance operations that require parliament authorization [11](#0-10) 
- Test suite confirms this is an expected operation executable via parliament proposals [12](#0-11) 
- Such adjustments are economically rational for tuning incentives, fixing formulas, and adapting to changing economic conditions

**No Attacker Required:** This vulnerability is triggered by legitimate governance actions, not malicious actors.

**Probability:** Governance will likely adjust vote weight parameters during the protocol's operational lifetime for economic optimization purposes.

## Recommendation

Store the original weight calculation parameters used for each vote, or implement a migration mechanism to update existing profit detail shares when weight settings change. Potential fixes:

1. **Store Original Settings**: Record the `VoteWeightInterestList` and `VoteWeightProportion` values at vote creation time and use these original values when recalculating weight during vote target changes.

2. **Migration Mechanism**: When governance updates weight settings via `SetVoteWeightInterest` or `SetVoteWeightProportion`, iterate through all existing profit details and recalculate their shares using the new settings.

3. **Enhanced Matching Logic**: Instead of matching by shares alone, match profit details using a combination of beneficiary address, vote amount, and lock time, which remain constant regardless of weight setting changes.

4. **Graceful Degradation**: If profit detail matching fails for legacy votes, allow the operation to proceed without extending the profit period rather than reverting the entire transaction.

## Proof of Concept

```csharp
[Fact]
public async Task VoteTargetChange_FailsForLegacyVotes_AfterWeightSettingsUpdate()
{
    // Setup: Announce candidates
    var candidate1 = CoreDataCenterKeyPairs[0];
    var candidate2 = CoreDataCenterKeyPairs[1];
    await AnnounceElectionAsync(candidate1);
    await AnnounceElectionAsync(candidate2);
    
    // Step 1: User votes with original weight settings
    var voter = VoterKeyPairs[0];
    var lockTime = 90 * 86400; // 90 days
    var voteAmount = 1000;
    var voteId = await VoteToCandidateAsync(voter, candidate1.PublicKey.ToHex(), lockTime, voteAmount);
    
    // Verify vote exists with profit detail (shares calculated with old settings)
    var electorVote = await ElectionContractStub.GetElectorVote.CallAsync(
        new StringValue { Value = voter.PublicKey.ToHex() });
    electorVote.ActiveVotingRecordIds.Count.ShouldBe(1);
    
    // Step 2: Governance updates vote weight settings (changes weight calculation)
    var newWeightSettings = new VoteWeightProportion 
    { 
        TimeProportion = 3,  // Changed from default 2
        AmountProportion = 3  // Changed from default 1
    };
    await ExecuteProposalForParliamentTransaction(ElectionContractAddress,
        nameof(ElectionContractStub.SetVoteWeightProportion), newWeightSettings);
    
    // Step 3: User attempts to change vote target with extended profit period
    var changeVoteResult = await ElectionContractStub.ChangeVotingOption.SendAsync(
        new ChangeVotingOptionInput
        {
            VoteId = voteId,
            CandidatePubkey = candidate2.PublicKey.ToHex(),
            IsResetVotingTime = true  // Try to extend profit period
        });
    
    // Vulnerability: Transaction fails with "Cannot find profit detail" error
    changeVoteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    changeVoteResult.TransactionResult.Error.ShouldContain("Cannot find profit detail");
}
```

## Notes

This vulnerability demonstrates a critical gap in backward compatibility handling when governance parameters change. The codebase explicitly acknowledges legacy votes exist through comments about "old world" profit details with null IDs, but the weight recalculation logic does not account for this when settings are updated. This affects all voters who created votes before any weight settings update and represents a fundamental DoS attack surface triggered by legitimate governance operations.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-38)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-129)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L156-160)
```csharp
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L162-166)
```csharp
    private ElectionVotingRecord GetElectionVotingRecordByVoteId(Hash voteId)
    {
        var votingRecord = State.VoteContract.GetVotingRecord.Call(voteId);
        return TransferVotingRecordToElectionVotingRecord(votingRecord, voteId);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-216)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }

    public override Empty SetVoteWeightProportion(VoteWeightProportion input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.TimeProportion > 0 && input.AmountProportion > 0, "invalid input");
        State.VoteWeightProportion.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L385-399)
```csharp
    private void AssertPerformedByVoteWeightInterestController()
    {
        if (State.VoteWeightInterestController.Value == null)
            State.VoteWeightInterestController.Value = GetDefaultVoteWeightInterestController();

        Assert(Context.Sender == State.VoteWeightInterestController.Value.OwnerAddress, "No permission.");
    }

    private AuthorityInfo GetDefaultVoteWeightInterestController()
    {
        return new AuthorityInfo
        {
            ContractAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
            OwnerAddress = GetParliamentDefaultAddress()
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L337-355)
```csharp
    private ElectionVotingRecord TransferVotingRecordToElectionVotingRecord(VotingRecord votingRecord, Hash voteId)
    {
        var lockSeconds = State.LockTimeMap[voteId];
        return new ElectionVotingRecord
        {
            Voter = votingRecord.Voter,
            Candidate = GetNewestPubkey(votingRecord.Option),
            Amount = votingRecord.Amount,
            TermNumber = votingRecord.SnapshotNumber,
            VoteId = voteId,
            LockTime = lockSeconds,
            VoteTimestamp = votingRecord.VoteTimestamp,
            WithdrawTimestamp = votingRecord.WithdrawTimestamp,
            UnlockTimestamp = votingRecord.VoteTimestamp.AddSeconds(lockSeconds),
            IsWithdrawn = votingRecord.IsWithdrawn,
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
            IsChangeTarget = votingRecord.IsChangeTarget
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L284-294)
```csharp
        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L1477-1495)
```csharp
    public async Task Election_SetVoteWeightProportion_Test()
    {
        var defaultSetting = await ElectionContractStub.GetVoteWeightProportion.CallAsync(
            new Empty());
        defaultSetting.TimeProportion.ShouldBe(2);
        defaultSetting.AmountProportion.ShouldBe(1);
        defaultSetting = new VoteWeightProportion
        {
            TimeProportion = 3,
            AmountProportion = 3
        };
        await ExecuteProposalForParliamentTransaction(ElectionContractAddress,
            nameof(ElectionContractStub.SetVoteWeightProportion), defaultSetting);

        defaultSetting = await ElectionContractStub.GetVoteWeightProportion.CallAsync(
            new Empty());
        defaultSetting.TimeProportion.ShouldBe(3);
        defaultSetting.AmountProportion.ShouldBe(3);
    }
```
