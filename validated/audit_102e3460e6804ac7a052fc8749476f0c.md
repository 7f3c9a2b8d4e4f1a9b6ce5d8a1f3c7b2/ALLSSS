# Audit Report

## Title
Secret Sharing Threshold Validation Requires 100% Participation Instead of Configured 2/3 Threshold

## Summary
The AEDPoS consensus contract implements Shamir's 2/3 threshold secret sharing for InValue recovery but incorrectly enforces 100% miner participation before attempting secret reconstruction. This defeats the fault-tolerance purpose of threshold cryptography and enables any single miner to prevent all other miners' `PreviousInValue` revelation through a zero-cost griefing attack.

## Finding Description

The vulnerability exists in the `RevealSharedInValues` method where the system checks for complete (n-of-n) participation instead of the configured threshold (t-of-n where t=2/3).

**The Core Issue:**

The system correctly calculates the threshold as 2/3 of miners: [1](#0-0) 

However, it then incorrectly validates that ALL miners (100%) have submitted their decrypted pieces before attempting secret reconstruction: [2](#0-1) 

Yet the actual secret reconstruction correctly uses the 2/3 threshold, proving that the cryptographic scheme only needs 2/3 of the shares: [3](#0-2) 

**Attack Vector:**

1. Any active miner can call the public `UpdateValue` method: [4](#0-3) 

2. During secret sharing, `PerformSecretSharing` stores `DecryptedPieces` without any threshold validation: [5](#0-4) 

3. The attacker simply omits their `DecryptedPieces` from the `UpdateValueInput` transaction

4. Later, when `RevealSharedInValues` attempts to reconstruct other miners' `PreviousInValue`, it fails the 100% participation check and skips revelation via the `continue` statement

5. The system falls back to a deterministic "fake" value computed from the miner's public key and block height: [6](#0-5) 

**Why This Bypasses Protections:**

- `PreviousInValue` validation explicitly allows `Hash.Empty`: [7](#0-6) 

- Evil miner detection only checks `MissedTimeSlots`, not whether miners submitted `DecryptedPieces`: [8](#0-7) 

## Impact Explanation

**1. Defeats Threshold Cryptography Design:**
Shamir's Secret Sharing is specifically designed to reconstruct secrets when only t-of-n parties cooperate. The implementation in `SecretSharingHelper` correctly supports this (as confirmed by test cases using only threshold shares): [9](#0-8) [10](#0-9) 

However, the validation logic requires 100% participation, completely defeating the fault-tolerance benefit.

**2. Enables Griefing Attack:**
Any single malicious miner can prevent ALL other miners' `PreviousInValue` from being revealed by withholding their `DecryptedPiece`. This affects the entire miner set. Since there's no punishment mechanism for this behavior (evil detection only checks missed time slots), the attack has zero cost.

**3. Weakens Consensus Randomness:**
The commit-reveal scheme for `InValue` is critical for randomness generation. When `PreviousInValue` cannot be revealed through secret sharing, the system falls back to predictable deterministic values, potentially allowing manipulation of consensus randomness.

**4. Breaks Security Guarantee:**
The AEDPoS consensus design assumes that `PreviousInValue` can be recovered even if a minority of miners are uncooperative. By requiring unanimous participation, this security guarantee is violated.

**Severity: HIGH** - The vulnerability fundamentally breaks the threshold cryptography design, enables no-cost griefing attacks, and weakens the consensus randomness scheme.

## Likelihood Explanation

**Attacker Capabilities:** Any active miner in the consensus set can execute this attack through the public `UpdateValue` method. No special privileges beyond being a block producer are required.

**Attack Complexity:** Trivial - the attacker simply omits the `DecryptedPieces` field from their `UpdateValueInput` message. This is a passive attack (omission) rather than active manipulation.

**Feasibility Conditions:**
- Attacker must be an active miner (achievable through standard election process)
- No special preconditions needed
- Attack succeeds even if 99% of miners are honest (only one malicious miner needed)
- Zero economic cost to the attacker (no slashing or punishment)

**Detection Difficulty:** The attack is virtually indistinguishable from genuine network issues or temporary node unavailability.

**Probability: HIGH** - The attack is incentive-compatible for miners who want to create consensus instability or manipulate randomness.

## Recommendation

Change the validation check in `RevealSharedInValues` to use the calculated threshold instead of requiring all miners:

```csharp
// Current (vulnerable):
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// Should be:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This aligns the validation logic with the cryptographic capability and restores the intended fault-tolerance of the threshold secret sharing scheme.

Additionally, consider implementing detection and punishment for miners who consistently fail to submit `DecryptedPieces` while continuing to produce blocks.

## Proof of Concept

A proof of concept test demonstrating this vulnerability would:

1. Set up a consensus round with N miners
2. Have N-1 miners correctly submit their `DecryptedPieces` via `UpdateValue`
3. Have one malicious miner omit their `DecryptedPieces`
4. Verify that `RevealSharedInValues` fails to reconstruct any miner's `PreviousInValue` despite having 2/3+ shares available
5. Confirm the system falls back to deterministic fake values
6. Verify no punishment is applied to the malicious miner

The test would confirm that despite Shamir's Secret Sharing being capable of reconstruction with only the threshold number of shares (as proven by existing tests), the validation logic incorrectly blocks this reconstruction.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-101)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-96)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** test/AElf.Cryptography.Tests/SecretSharingTest.cs (L63-65)
```csharp
        var result = SecretSharingHelper.DecodeSecret(parts.Take(threshold).ToList(),
            Enumerable.Range(1, threshold).ToList(), threshold);
        Assert.Equal(bytes, result);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-44)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
```
