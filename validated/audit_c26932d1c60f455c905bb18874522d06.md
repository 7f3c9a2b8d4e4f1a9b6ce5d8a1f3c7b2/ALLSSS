# Audit Report

## Title
Contract Ownership Theft via Expired Proposal State Overwrite

## Summary
The Genesis contract's user deployment system allows an attacker to steal ownership of legitimately approved contract deployments by exploiting a race condition in the proposal expiration mechanism. When a deployment proposal is approved but not released within the expiration window, an attacker can overwrite the proposal metadata with their own address, causing the approved proposal to deploy with the attacker as owner.

## Finding Description

The vulnerability exists in the `SendUserContractProposal` function which manages proposal state for user contract deployments. The function stores proposal metadata in a state map keyed by the input hash, with an expiration check that permits overwrites after the expiration time passes. [1](#0-0) 

The critical flaw occurs at line 315 where the expiration check `Context.CurrentBlockTime >= registered.ExpiredTime` allows complete state overwrite without verifying whether an approved governance proposal is still pending execution. Line 323 then overwrites the entire `ContractProposingInputMap` entry, including the `Author` field which is set to the current transaction sender.

**Attack Execution:**

1. User A calls `DeployUserSmartContract` with contract code, creating a proposal with hash H and state entry with `Author = UserA` [2](#0-1) 

2. The code check proposal is approved by miners through governance but not released before expiration (default 15 minutes) [3](#0-2) 

3. After expiration, attacker submits identical `UserContractDeploymentInput`, generating the same hash H. The expiration check passes and line 323 overwrites the state with `Author = Attacker`

4. When miners release the original approved proposal via `ReleaseApprovedUserSmartContract`, it retrieves the corrupted state [4](#0-3) 

The status and proposer checks at lines 482-483 pass because the attacker set `Status = CodeCheckProposed` and `Proposer = Context.Self` during the overwrite.

5. The proposal release triggers `PerformDeployUserSmartContract`, which deploys using the overwritten `Author` field [5](#0-4) 

Line 503 calls `DeploySmartContract` with `contractProposingInput.Author`, which now contains the attacker's address instead of the legitimate proposer's address.

**Root Cause:**

The state map is keyed by input hash rather than proposal ID [6](#0-5) 

This design allows multiple proposals with identical inputs to share the same state entry, enabling the overwrite attack. There is no mechanism to bind a specific proposal ID to its corresponding state entry or prevent overwrites when approved proposals are pending.

## Impact Explanation

**Severity: HIGH**

This vulnerability results in complete theft of contract ownership, violating the core governance guarantee that approved proposals execute with their original parameters.

The attacker gains full author privileges, allowing them to:
- Update the contract code via `UpdateUserSmartContract` [7](#0-6) 

Line 451 enforces `Context.Sender == info.Author`, granting update rights exclusively to the author.

- Transfer authorship via `SetContractAuthor` [8](#0-7) 

Line 524 validates `Context.Sender == info.Author`, allowing the attacker to transfer ownership permanently.

The legitimate proposer loses all authorship rights despite their proposal being legitimately approved through governance. This breaks the fundamental security invariant that governance-approved actions execute as proposed, undermining trust in the entire contract deployment system.

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

The attack requires no special privileges beyond basic user access. On main chains, the permission check allows all users: [9](#0-8) 

Lines 349-352 show that when the native symbol equals the primary token symbol (main chain condition), any user can deploy contracts.

**Attack Complexity: LOW**

The attacker needs only to:
1. Monitor `CodeCheckRequired` events from `DeployUserSmartContract`
2. Wait for the 15-minute expiration period to elapse
3. Submit identical input to overwrite the state
4. Wait for automated proposal release

No cryptographic exploitation, miner compromise, or governance manipulation is required.

**Timing Window:**

While the system includes automated release: [10](#0-9) 

The 15-minute expiration window remains realistic due to:
- Network congestion causing block production delays
- Transaction generator execution not being instantaneous
- Operational delays in miner infrastructure
- Configurable expiration periods that could be set even shorter

The attack window exists whenever the time between approval and automated release exceeds the expiration period.

## Recommendation

Bind proposal state to specific proposal IDs rather than just input hashes. Store the proposal ID in the state entry and validate it during release:

```csharp
message ContractProposingInput {
    aelf.Address proposer = 1;
    ContractProposingInputStatus status = 2;
    google.protobuf.Timestamp expired_time = 3;
    aelf.Address author = 4;
    aelf.Hash proposal_id = 5;  // Add proposal ID binding
}
```

In `SendUserContractProposal`, store the proposal ID after creation and check it during `ReleaseApprovedUserSmartContract`:

```csharp
// During release
Assert(contractProposingInput.ProposalId == input.ProposalId, 
    "Proposal ID mismatch");
```

Alternatively, prevent state overwrites entirely when status is `CodeCheckProposed`:

```csharp
Assert(registered == null || 
    (Context.CurrentBlockTime >= registered.ExpiredTime && 
     registered.Status != ContractProposingInputStatus.CodeCheckProposed), 
    "Cannot overwrite pending approved proposal");
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task OwnershipTheft_Via_ExpiredProposalOverwrite()
{
    // 1. UserA deploys contract
    var deployInput = new UserContractDeploymentInput
    {
        Category = 0,
        Code = ByteString.CopyFrom(contractCode),
        Salt = HashHelper.ComputeFrom("salt")
    };
    
    var userAResult = await UserAStub.DeployUserSmartContract.SendAsync(deployInput);
    var proposalHash = userAResult.Output.CodeHash;
    
    // 2. Miners approve proposal
    await ApproveWithMiners(proposalHash);
    
    // 3. Wait for expiration (advance time by 901 seconds)
    await AdvanceBlockTimeAsync(901);
    
    // 4. Attacker submits identical input
    var attackerResult = await AttackerStub.DeployUserSmartContract.SendAsync(deployInput);
    
    // 5. Miners release original approved proposal
    await MinerStub.ReleaseApprovedUserSmartContract.SendAsync(
        new ReleaseContractInput { ProposedContractInputHash = proposalHash });
    
    // 6. Verify attacker is now the owner
    var contractAddress = GetDeployedAddress(proposalHash);
    var author = await GenesisStub.GetContractAuthor.CallAsync(contractAddress);
    
    Assert.Equal(AttackerAddress, author); // Attacker stole ownership
    Assert.NotEqual(UserAAddress, author); // UserA lost ownership
}
```

## Notes

This vulnerability specifically affects user contract deployments through the `DeployUserSmartContract` path. Regular contract deployments use a different flow (`ProposeNewContract`) which stores `Proposer` rather than `Author`, but may be vulnerable to similar timing attacks with different impact. The core issue is the state map design that keys entries by input hash rather than binding them to specific proposal IDs, combined with the expiration mechanism that allows unconditional overwrites.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-342)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;

        var codeCheckController = State.CodeCheckController.Value;
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName = releaseMethodName,
                Params = @params,
                OrganizationAddress = codeCheckController.OwnerAddress,
                ExpiredTime = proposedInfo.ExpiredTime
            },
            OriginProposer = Context.Self
        };

        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-443)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new DeployUserSmartContractOutput
        {
            CodeHash = codeHash
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L445-474)
```csharp
    public override Empty UpdateUserSmartContract(UserContractUpdateInput input)
    {
        AssertInlineDeployOrUpdateUserContract();

        var info = State.ContractInfos[input.Address];
        Assert(info != null, "Contract not found.");
        Assert(Context.Sender == info.Author, "No permission.");
        Assert(info.Deployer == null || info.Deployer == Context.Sender, "No permission to update.");
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Assert(info.CodeHash != codeHash, "Code is not changed.");
        AssertContractNotExists(codeHash);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformUpdateUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = info.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L476-493)
```csharp
    public override Empty ReleaseApprovedUserSmartContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Self, "Invalid contract proposing status.");

        AssertCurrentMiner();

        contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        var codeCheckController = State.CodeCheckController.Value;
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release), input.ProposalId);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L495-505)
```csharp
    public override Address PerformDeployUserSmartContract(UserContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address = DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
            contractProposingInput.Author, true, contractProposingInput.Author, input.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-535)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L6-6)
```csharp
    public const int DefaultCodeCheckProposalExpirationTimePeriod = 900; // 60 * 15
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroState.cs (L17-17)
```csharp
    public MappedState<Hash, ContractProposingInput> ContractProposingInputMap { get; set; }
```

**File:** src/AElf.Kernel.CodeCheck/Application/CodeCheckProposalReleaseTransactionGenerator.cs (L36-81)
```csharp
    public async Task<List<Transaction>> GenerateTransactionsAsync(Address from, long preBlockHeight, Hash preBlockHash)
    {
        var chainContext = new ChainContext
        {
            BlockHash = preBlockHash, BlockHeight = preBlockHeight
        };
        if (!_transactionPackingOptionProvider.IsTransactionPackable(chainContext)) return new List<Transaction>();

        var zeroContractAddress = _smartContractAddressService.GetZeroSmartContractAddress();

        if (zeroContractAddress == null) return new List<Transaction>();

        var releasableProposals =
            await _codeCheckProposalService.GetReleasableProposalListAsync(from, preBlockHash, preBlockHeight);
        if (releasableProposals == null || releasableProposals.Count == 0) return new List<Transaction>();

        var alreadyReleased = (await _codeCheckReleasedProposalIdProvider.GetProposalIdsAsync(new BlockIndex
        {
            BlockHash = preBlockHash,
            BlockHeight = preBlockHeight
        })).ProposalIds.ToHashSet();

        var releaseRequired = releasableProposals.Where(o => !alreadyReleased.Contains(o.ProposalId)).ToList();

        var releaseContractTransactions = releaseRequired.Select(proposal => new Transaction
        {
            From = from,
            MethodName = nameof(ACS0Container.ACS0Stub.ReleaseApprovedUserSmartContract),
            To = zeroContractAddress,
            RefBlockNumber = preBlockHeight,
            RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
            Params = new ReleaseContractInput
            {
                ProposalId = proposal.ProposalId,
                ProposedContractInputHash = proposal.ProposedContractInputHash
            }.ToByteString()
        }).ToList();

        await _codeCheckReleasedProposalIdProvider.AddProposalIdsAsync(new BlockIndex
        {
            BlockHash = preBlockHash,
            BlockHeight = preBlockHeight
        }, releaseRequired.Select(p => p.ProposalId).ToList());

        return releaseContractTransactions;
    }
```
