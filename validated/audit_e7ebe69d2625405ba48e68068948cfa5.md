# Audit Report

## Title
Transaction Fee Free Allowance Overflow Causes DoS Due to Missing Sum Validation

## Summary
The `ConfigTransactionFeeFreeAllowances` method allows parliament to configure multiple threshold symbols, each granting free transaction fee allowances for the same token. When a user qualifies for multiple thresholds and attempts to transact, the `GetFreeFeeAllowanceAmount` method sums all allowances using checked arithmetic. If the cumulative sum exceeds `long.MaxValue`, an `OverflowException` is thrown during fee charging, causing transaction failure and creating a denial-of-service for affected users. The root cause is missing validation during configuration to ensure cumulative allowances remain within valid bounds.

## Finding Description

The transaction fee system allows parliament to configure free allowances based on token balance thresholds. The configuration is stored in `TransactionFeeFreeAllowancesConfigMap` where each threshold symbol (e.g., "ELF", "USDT") can grant allowances for various tokens. [1](#0-0) 

When a user holds sufficient balances in multiple threshold tokens, `CalculateTransactionFeeFreeAllowances` includes all qualifying thresholds in the returned map. [2](#0-1) 

During transaction fee charging, `GetFreeFeeAllowanceAmount` is called to calculate total available allowances. This method iterates through all threshold symbols the user qualifies for and sums the allowances using the `Add` extension method. [3](#0-2) 

The `Add` method uses checked arithmetic, which throws `OverflowException` when the result exceeds `long.MaxValue`. [4](#0-3) 

The configuration method validates individual inputs (threshold >= 0, symbol exists, etc.) but does NOT validate that cumulative allowances across all threshold symbols for any given token stay within `long.MaxValue`. [5](#0-4) 

**Execution Path**: When an affected user attempts any transaction, the overflow occurs during fee charging at multiple call sites where `GetFreeFeeAllowanceAmount` is invoked. [6](#0-5) 

Since there is no exception handling around these calls, the `OverflowException` propagates up and causes transaction failure. [7](#0-6) 

## Impact Explanation

Users who hold sufficient balances in multiple threshold tokens to qualify for cumulative allowances exceeding `long.MaxValue` (9,223,372,036,854,775,807) become unable to submit any transactions. Every transaction attempt will fail during fee charging with an `OverflowException`, creating a complete denial-of-service for these users.

While no funds are lost, affected users are locked out of the system entirely. They cannot transfer tokens, interact with contracts, or perform any on-chain actions. This represents a severe operational disruption with the following characteristics:

- **Severity**: Medium-High - Complete DoS for affected users, but requires governance misconfiguration
- **Scope**: Limited to users qualifying for multiple high-value allowance thresholds
- **Duration**: Permanent until parliament reconfigures to fix the overflow condition
- **Reversibility**: Can be resolved by parliament removing or adjusting threshold configurations

## Likelihood Explanation

**Preconditions**:
1. Parliament must configure multiple threshold symbols where allowances for the same token sum to > `long.MaxValue`
2. Users must hold sufficient balances to qualify for multiple such thresholds simultaneously

**Feasibility Assessment**:
- While parliament is a trusted governance role, configuration mistakes are realistic operational risks
- With tokens using 8 decimals, values like 10^17 (representing 1 billion tokens) are plausible allowance amounts
- Configuring multiple thresholds granting such allowances could easily exceed the limit unintentionally
- The system provides NO warnings, validation, or safeguards against this specific misconfiguration
- Multiple threshold symbols are an explicitly supported use case as demonstrated in existing tests [8](#0-7) 

**Probability**: Low-Medium
- Requires governance error, not malicious action
- However, the absence of validation makes this a realistic failure mode
- Similar to how the system validates `threshold >= 0` to prevent negative values, it should validate cumulative sums to prevent overflow

This is fundamentally an **input validation gap** rather than an attack vector, making it a legitimate security concern that defensive programming should address.

## Recommendation

Add validation in `ConfigTransactionFeeFreeAllowances` to ensure that for each token symbol, the sum of allowances across all configured threshold symbols does not exceed `long.MaxValue`.

**Implementation approach**:
1. After processing each configuration entry, calculate the cumulative allowances for each token
2. Iterate through all existing and new threshold configurations
3. For each unique allowance token symbol, sum the amounts
4. Assert that no sum exceeds `long.MaxValue`
5. If validation fails, revert with a descriptive error message

This validation should be performed during configuration to prevent the misconfiguration from being stored, rather than attempting to handle the overflow during transaction execution.

## Proof of Concept

```csharp
[Fact]
public async Task TransactionFee_AllowanceOverflow_CausesDoS_Test()
{
    // Setup: Configure two threshold symbols with allowances that sum to > long.MaxValue
    await SetPrimaryTokenSymbolAsync();
    await CreateTokenAndIssueAsync(); // Creates ELF and USDT tokens
    
    // Configure first threshold: ELF holders get 5e18 TOKEN allowance
    await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendAsync(
        new ConfigTransactionFeeFreeAllowancesInput
        {
            Value =
            {
                new ConfigTransactionFeeFreeAllowance
                {
                    Symbol = NativeTokenSymbol, // ELF
                    TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                    {
                        Value =
                        {
                            new TransactionFeeFreeAllowance
                            {
                                Symbol = "TOKEN",
                                Amount = 5_000_000_000_000_000_000 // 5e18
                            }
                        }
                    },
                    RefreshSeconds = 0,
                    Threshold = 1_00000000 // 1 ELF
                }
            }
        });
    
    // Configure second threshold: USDT holders get 5e18 TOKEN allowance
    await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendAsync(
        new ConfigTransactionFeeFreeAllowancesInput
        {
            Value =
            {
                new ConfigTransactionFeeFreeAllowance
                {
                    Symbol = USDT,
                    TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                    {
                        Value =
                        {
                            new TransactionFeeFreeAllowance
                            {
                                Symbol = "TOKEN",
                                Amount = 5_000_000_000_000_000_000 // 5e18
                            }
                        }
                    },
                    RefreshSeconds = 0,
                    Threshold = 1_000000 // 1 USDT
                }
            }
        });
    
    // User holds both ELF and USDT above threshold, qualifying for both allowances
    // Total allowance: 5e18 + 5e18 = 10e18 > long.MaxValue (9.22e18)
    
    // Attempt transaction - should fail with OverflowException during fee charging
    var result = await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = UserAAddress,
        Symbol = NativeTokenSymbol,
        Amount = 1
    });
    
    // Expected: Transaction fails due to overflow in GetFreeFeeAllowanceAmount
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Overflow");
}
```

## Notes

This vulnerability represents a **validation gap** in governance configuration rather than a malicious attack vector. While parliament is a trusted role, robust systems should include defensive validation to prevent accidental misconfigurations that break core functionality. The system already validates other configuration parameters (threshold >= 0, symbol existence, etc.), demonstrating that protective validation is part of the design philosophy. The missing overflow check is inconsistent with this pattern and creates an avoidable failure mode.

The fix is straightforward: add cumulative sum validation during configuration. This would prevent the problematic state from being created while maintaining parliament's intended flexibility in configuring free allowances.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L84-126)
```csharp
    private ChargeTransactionFeesOutput TryToChargeTransactionFee(ChargeTransactionFeesInput input, Address fromAddress,
        TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee,
        bool isSizeFeeFree)
    {
        Context.LogDebug(() => "TryToChargeTransactionFee Start");
        var chargingResult =
            ChargeTransactionFeesToBill(input, fromAddress, ref bill, ref allowanceBill, fee, isSizeFeeFree);
        if (!chargingResult)
        {
            var delegatorAddress = fromAddress;
            chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                isSizeFeeFree, delegatorAddress);
        }

        if (!chargingResult)
        {
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }

        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L747-777)
```csharp
    private bool TryToChargeUserBaseFee(Dictionary<string, long> symbolToAmountMap, Address fromAddress,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, out long amount,
        out string symbolOfValidBalance, out long existingBalance, out long existingAllowance)
    {
        // priority: enough allowance -> symbolWithEnoughBalancePlusAllowance -> symbolWithEnoughBalance -> symbolWithAnything
        symbolOfValidBalance = null;
        string symbolWithAnything = null;
        string symbolWithEnoughBalance = null;
        string symbolWithEnoughBalancePlusAllowance = null;

        amount = 0;
        existingBalance = 0;
        existingAllowance = 0;
        //For user
        //Find the token that satisfies the balance of the fee,if there is no token that satisfies the balance of the fee, find the token that balance > 0
        foreach (var (symbol, value) in symbolToAmountMap)
        {
            // current token symbol
            amount = value;
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);

            var existingBalancePlusAllowance = existingBalance.Add(existingAllowance);

            
            // allowance is enough to cover the base fee
            if (existingAllowance >= amount)
            {
                symbolOfValidBalance = symbol;
                return true;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1224-1266)
```csharp
    public override Empty ConfigTransactionFeeFreeAllowances(ConfigTransactionFeeFreeAllowancesInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input.Value != null && input.Value.Count > 0, "Invalid input");

        State.TransactionFeeFreeAllowancesSymbolList.Value ??= new TransactionFeeFreeAllowancesSymbolList
        {
            Symbols = { new RepeatedField<string>() }
        };

        foreach (var allowances in input.Value!)
        {
            ValidateToken(allowances.Symbol);
            Assert(
                allowances.TransactionFeeFreeAllowances?.Value != null &&
                allowances.TransactionFeeFreeAllowances.Value.Count > 0,
                "Invalid input allowances");
            Assert(allowances.Threshold >= 0, "Invalid input threshold");
            Assert(allowances.RefreshSeconds >= 0, "Invalid input refresh seconds");

            var config = new TransactionFeeFreeAllowanceConfig
            {
                Symbol = allowances.Symbol,
                Threshold = allowances.Threshold,
                RefreshSeconds = allowances.RefreshSeconds,
                FreeAllowances = new TransactionFeeFreeAllowanceMap()
            };

            foreach (var allowance in allowances.TransactionFeeFreeAllowances!.Value!)
            {
                config.FreeAllowances.Map.TryAdd(allowance.Symbol, allowance);
            }

            State.TransactionFeeFreeAllowancesConfigMap[allowances.Symbol] = config;

            if (!State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Contains(allowances.Symbol))
            {
                State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Add(allowances.Symbol);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1313-1355)
```csharp
    private TransactionFeeFreeAllowancesMap CalculateTransactionFeeFreeAllowances(Address input)
    {
        var freeAllowanceMap = State.TransactionFeeFreeAllowances[input];

        var freeAllowancesConfig = State.TransactionFeeFreeAllowancesSymbolList.Value;
        if (freeAllowancesConfig == null)
        {
            return new TransactionFeeFreeAllowancesMap();
        }

        var transactionFeeFreeAllowancesMap = new TransactionFeeFreeAllowancesMap();

        foreach (var symbol in freeAllowancesConfig.Symbols)
        {
            var balance = State.Balances[input][symbol];
            if (balance < State.TransactionFeeFreeAllowancesConfigMap[symbol].Threshold) continue;

            var lastRefreshTime = State.TransactionFeeFreeAllowancesLastRefreshTimes[input][symbol];

            var freeAllowances = freeAllowanceMap[symbol];

            if (freeAllowances == null)
            {
                transactionFeeFreeAllowancesMap.Map.Add(symbol,
                    State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone());
                continue;
            }

            if (lastRefreshTime == null)
            {
                transactionFeeFreeAllowancesMap.Map.Add(symbol, freeAllowances);
            }
            else
            {
                transactionFeeFreeAllowancesMap.Map[symbol] =
                    (Context.CurrentBlockTime - lastRefreshTime).Seconds >
                    State.TransactionFeeFreeAllowancesConfigMap[symbol].RefreshSeconds
                        ? State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone()
                        : freeAllowances;
            }
        }

        return transactionFeeFreeAllowancesMap;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L179-194)
```csharp
    private long GetFreeFeeAllowanceAmount(TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, string symbol)
    {
        var allowance = 0L;
        var map = transactionFeeFreeAllowancesMap.Map;

        if (map == null) return allowance;

        foreach (var freeAllowances in map.Values)
        {
            freeAllowances.Map.TryGetValue(symbol, out var freeAllowance);

            allowance = allowance.Add(freeAllowance?.Amount ?? 0L);
        }

        return allowance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest_FreeAllowance.cs (L117-226)
```csharp
    public async Task ConfigTransactionFeeFreeAllowances_MultipleTokens_OneByOne_Test()
    {
        await SetPrimaryTokenSymbolAsync();
        await CreateTokenAndIssueAsync();

        await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendAsync(
            new ConfigTransactionFeeFreeAllowancesInput
            {
                Value =
                {
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = NativeTokenSymbol,
                        TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                        {
                            Value =
                            {
                                new TransactionFeeFreeAllowance
                                {
                                    Symbol = NativeTokenSymbol,
                                    Amount = 1_00000000
                                }
                            }
                        },
                        RefreshSeconds = 600,
                        Threshold = 1_00000000
                    }
                }
            });

        {
            var config = await TokenContractImplStub.GetTransactionFeeFreeAllowancesConfig.CallAsync(new Empty());
            config.Value.Count.ShouldBe(1);
            config.Value.First().Symbol.ShouldBe(NativeTokenSymbol);
            config.Value.First().Threshold.ShouldBe(1_00000000);
            config.Value.First().RefreshSeconds.ShouldBe(600);
            config.Value.First().FreeAllowances.Map.Keys.First().ShouldBe(NativeTokenSymbol);
            config.Value.First().FreeAllowances.Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            config.Value.First().FreeAllowances.Map.Values.First().Amount.ShouldBe(1_00000000);

            var userAFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserAAddress);
            userAFreeAllowances.Result.Map.Keys.First().ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Keys.First().ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Values.First().Amount.ShouldBe(1_00000000);
            var userBFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserBAddress);
            userBFreeAllowances.Result.Map.Count.ShouldBe(0);
            var userCFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserCAddress);
            userCFreeAllowances.Result.Map.ShouldBe(userAFreeAllowances.Result.Map);
        }

        await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendAsync(
            new ConfigTransactionFeeFreeAllowancesInput
            {
                Value =
                {
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = USDT,
                        TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                        {
                            Value =
                            {
                                new TransactionFeeFreeAllowance
                                {
                                    Symbol = NativeTokenSymbol,
                                    Amount = 1_00000000
                                }
                            }
                        },
                        RefreshSeconds = 300,
                        Threshold = 1_000000
                    }
                }
            });

        {
            var config = await TokenContractImplStub.GetTransactionFeeFreeAllowancesConfig.CallAsync(new Empty());
            config.Value.Count.ShouldBe(2);
            config.Value.First().Symbol.ShouldBe(NativeTokenSymbol);
            config.Value.First().Threshold.ShouldBe(1_00000000);
            config.Value.First().RefreshSeconds.ShouldBe(600);
            config.Value.First().FreeAllowances.Map.Keys.First().ShouldBe(NativeTokenSymbol);
            config.Value.First().FreeAllowances.Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            config.Value.First().FreeAllowances.Map.Values.First().Amount.ShouldBe(1_00000000);

            config.Value.Last().Symbol.ShouldBe(USDT);
            config.Value.Last().Threshold.ShouldBe(1_000000);
            config.Value.Last().RefreshSeconds.ShouldBe(300);
            config.Value.Last().FreeAllowances.Map.Keys.First().ShouldBe(NativeTokenSymbol);
            config.Value.Last().FreeAllowances.Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            config.Value.Last().FreeAllowances.Map.Values.First().Amount.ShouldBe(1_00000000);

            var userAFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserAAddress);
            userAFreeAllowances.Result.Map.Count.ShouldBe(1);
            userAFreeAllowances.Result.Map.Keys.First().ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Keys.First().ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            userAFreeAllowances.Result.Map.Values.First().Map.Values.First().Amount.ShouldBe(1_00000000);
            var userBFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserBAddress);
            userBFreeAllowances.Result.Map.Count.ShouldBe(1);
            userBFreeAllowances.Result.Map.Keys.First().ShouldBe(USDT);
            userBFreeAllowances.Result.Map.Values.First().Map.Keys.First().ShouldBe(NativeTokenSymbol);
            userBFreeAllowances.Result.Map.Values.First().Map.Values.First().Symbol.ShouldBe(NativeTokenSymbol);
            userBFreeAllowances.Result.Map.Values.First().Map.Values.First().Amount.ShouldBe(1_00000000);
            var userCFreeAllowances = TokenContractImplStub.GetTransactionFeeFreeAllowances.CallAsync(UserCAddress);
            userAFreeAllowances.Result.Map.Add(USDT, userBFreeAllowances.Result.Map.Values.First());
            userCFreeAllowances.Result.Map.ShouldBe(userAFreeAllowances.Result.Map);
        }
    }
```
