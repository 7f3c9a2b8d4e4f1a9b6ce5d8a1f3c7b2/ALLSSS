# Audit Report

## Title
Inconsistent Comparison Operators Allow Proposals to Pass with Tied Votes at Exact Threshold Boundaries

## Summary
The Parliament contract uses `>=` for approval threshold checks but `>` for rejection/abstention threshold checks, creating a logical inconsistency at exact threshold boundaries. When an organization is configured with `MinimalApprovalThreshold` + `MaximalRejectionThreshold` = `AbstractVoteTotal` (e.g., both at 50%), a proposal receiving exactly 50% approval and 50% rejection will pass, despite having equal support and opposition.

## Finding Description

The Parliament contract defines `AbstractVoteTotal = 10000` to represent 100% of votes [1](#0-0) 

The approval threshold check uses the `>=` operator (inclusive), allowing proposals that exactly meet the minimum threshold to pass [2](#0-1) 

The rejection threshold check uses the `>` operator (strict), requiring rejections to **exceed** the maximum threshold to fail the proposal [3](#0-2) 

Similarly, the abstention check uses `>` (strict) [4](#0-3) 

The validation function explicitly allows threshold configurations where `MaximalRejectionThreshold + MinimalApprovalThreshold <= AbstractVoteTotal` [5](#0-4) 

**Scenario:**
- Organization configured with `MinimalApprovalThreshold = 5000` (50%) and `MaximalRejectionThreshold = 5000` (50%)
- 10 parliament members vote: 5 approvals, 5 rejections
- Approval check: `5 * 10000 >= 5000 * 10` → `50000 >= 50000` → **TRUE**
- Rejection check: `5 * 10000 > 5000 * 10` → `50000 > 50000` → **FALSE**
- **Result: Proposal PASSES despite tied vote**

This breaks the semantic expectation that when `MaximalRejectionThreshold = 5000`, proposals reaching exactly 50% rejection should fail.

## Impact Explanation

**Governance Integrity Violation**: This inconsistency allows proposals to pass at exact threshold boundaries when they semantically should fail. Organizations setting `MaximalRejectionThreshold = 5000` (50%) expect proposals with 50% rejection to be blocked, but the strict `>` operator means only rejections exceeding 50% cause failure.

**Affected Scenarios**:
- Organizations with balanced thresholds (e.g., 50-50 split)
- Critical governance decisions (contract upgrades, parameter changes) at boundary conditions
- Any even number of parliament members with perfectly tied votes

**Severity**: Medium - requires specific boundary configuration but deterministically affects governance outcomes once configured, potentially allowing controversial actions to execute without clear consensus.

## Likelihood Explanation

**Attacker Capabilities**: Any authorized parliament member or whitelisted proposer can create organizations with custom thresholds.

**Attack Complexity**: Low:
1. Create organization with boundary thresholds via `CreateOrganization` [6](#0-5) 
2. Submit proposal under that organization
3. Obtain tied vote (naturally or through coordination)

**Feasibility**: The validation logic explicitly permits boundary configurations [7](#0-6) , making this a legitimate and reachable state.

**Probability**: Medium-High for organizations using boundary thresholds, as tied votes can occur naturally in divisive governance decisions.

## Recommendation

Change the rejection and abstention checks to use `>=` (inclusive) to match the approval logic, ensuring semantic consistency:

```csharp
// In IsProposalRejected
return rejectionMemberCount * AbstractVoteTotal >=
       organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;

// In IsProposalAbstained
return abstentionMemberCount * AbstractVoteTotal >=
       organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
```

This ensures that when organizations set `MaximalRejectionThreshold = 5000`, proposals with exactly 50% rejection will correctly fail.

## Proof of Concept

```csharp
[Fact]
public async Task TiedVote_AtExactBoundary_ProposalPasses()
{
    // Setup: Create organization with 50-50 thresholds
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 5000,  // 50%
            MaximalRejectionThreshold = 5000,  // 50%
            MinimalVoteThreshold = 10000,
            MaximalAbstentionThreshold = 0
        }
    };
    
    var organizationAddress = await ParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    
    // Create proposal
    var proposal = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ToAddress = TokenContractAddress,
        ContractMethodName = nameof(TokenContractStub.Transfer),
        Params = new TransferInput { Amount = 100 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    });
    
    var proposalId = proposal.Output;
    
    // Get 10 miners and split vote 5-5
    var miners = await GetCurrentMiners();
    Assert.Equal(10, miners.Count);
    
    // First 5 approve
    for (int i = 0; i < 5; i++)
    {
        var stub = GetParliamentContractStub(miners[i]);
        await stub.Approve.SendAsync(proposalId);
    }
    
    // Next 5 reject
    for (int i = 5; i < 10; i++)
    {
        var stub = GetParliamentContractStub(miners[i]);
        await stub.Reject.SendAsync(proposalId);
    }
    
    // Check proposal status
    var proposalOutput = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
    
    // BUG: Proposal can be released despite 50-50 tie
    Assert.True(proposalOutput.ToBeReleased); // This passes, demonstrating the vulnerability
}
```

## Notes

This vulnerability stems from an asymmetry in comparison operators rather than missing authorization checks. The behavior is deterministic and occurs within normal contract operations. While organizations have control over their threshold configurations, the semantic mismatch between intent (MaximalRejectionThreshold) and implementation (strict `>` check) creates a governance integrity issue at exact boundary values.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L68-69)
```csharp
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L76-77)
```csharp
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L84-86)
```csharp
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L50-59)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        Assert(
            ValidateAddressInWhiteList(Context.Sender) || ValidateParliamentMemberAuthority(Context.Sender) ||
            State.DefaultOrganizationAddress.Value == Context.Sender,
            "Unauthorized to create organization.");
        var organizationAddress = CreateNewOrganization(input);

        return organizationAddress;
    }
```
