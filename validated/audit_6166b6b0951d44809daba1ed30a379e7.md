# Audit Report

## Title
Proposal Hijacking via Expiration-Based Overwrite in Contract Deployment Workflow

## Summary
The Genesis contract's `RegisterContractProposingData()` function allows any user to overwrite in-progress contract deployment proposals after expiration, regardless of their current status. This enables attackers to hijack proposals that have already received governance approval, causing denial of service and permanent loss of control for legitimate proposers.

## Finding Description

The vulnerability exists in the `RegisterContractProposingData()` function which only validates expiration time without checking proposal status: [1](#0-0) 

The function allows complete overwriting if `Context.CurrentBlockTime >= registered.ExpiredTime`, treating all expired proposals identically regardless of whether they are:
- Fresh proposals that never progressed (status = PROPOSED)
- In-progress proposals awaiting code check (status = APPROVED or CODE_CHECK_PROPOSED)

The contract deployment workflow has multiple stages with drastically different expiration periods. Initial proposals expire after 72 hours: [2](#0-1) 

However, when a proposal is approved and transitions to the code check phase via `ProposeContractCodeCheck`, the expiration time is updated to only 15 minutes: [3](#0-2) 

This creates a critical vulnerability window. The release methods verify that the proposer matches the caller: [4](#0-3) 

And for code-checked contracts: [5](#0-4) 

After an attacker overwrites the proposal by calling `ProposeNewContract` with identical input, these checks prevent the legitimate proposer from completing their own proposal since the stored `Proposer` field now references the attacker's address.

**Attack Scenario:**
1. Alice calls `ProposeNewContract` → status=PROPOSED, proposer=Alice, expiry=72 hours
2. Governance votes and approves → Alice calls `ReleaseApprovedContract` → status=APPROVED
3. Parliament contract calls `ProposeContractCodeCheck` → status=CODE_CHECK_PROPOSED, expiry=15 minutes
4. Network delays or miner unavailability causes 15 minutes to elapse
5. Bob calls `ProposeNewContract` with identical input → overwrites with proposer=Bob, status=PROPOSED
6. Alice attempts `ReleaseCodeCheckedContract` → fails due to proposer mismatch
7. Alice's governance work is permanently lost

The same vulnerability pattern exists in user contract proposals: [6](#0-5) 

## Impact Explanation

**Severity: Medium**

The vulnerability has significant operational impact:
- Legitimate proposers lose complete control after investing time and resources in governance approvals
- All governance progress (APPROVED → CODE_CHECK_PROPOSED) is nullified when status resets to PROPOSED
- The original proposer is permanently blocked from deployment due to proposer verification failures
- Attackers can repeatedly hijack proposals, creating indefinite denial of service
- Governance integrity is compromised as approved proposals can be nullified through timing attacks

The severity is Medium rather than High because:
- No direct fund theft or token supply manipulation occurs
- Primary impact is operational disruption rather than financial loss
- Attack requires specific timing (expiration window)
- System can recover through re-proposal, though with significant cost

Affected parties include contract developers who successfully navigate governance only to have proposals hijacked, and the overall governance system credibility.

## Likelihood Explanation

**Likelihood: High**

The attack is highly practical:
- **No special privileges required**: Any user can call `ProposeNewContract` or `ProposeUpdateContract`
- **Minimal attack cost**: Only transaction fees required
- **Easy execution**: Attacker monitors blockchain for expiring proposals and submits identical inputs
- **Short vulnerability window**: The 15-minute code check expiration is extremely short and easily exceeded in production environments
- **Common trigger conditions**: Network congestion, block production delays, or validator unavailability commonly cause governance processes to exceed 15 minutes

The test suite confirms re-proposing after expiration is intentional behavior, but only validates the case where proposals at PROPOSED status expire: [7](#0-6) 

This test does not cover the vulnerability scenario where APPROVED or CODE_CHECK_PROPOSED proposals expire and get hijacked.

## Recommendation

Add status validation to `RegisterContractProposingData()` to prevent overwriting proposals that have progressed beyond PROPOSED status:

```csharp
private void RegisterContractProposingData(Hash proposedContractInputHash)
{
    var registered = State.ContractProposingInputMap[proposedContractInputHash];
    Assert(
        registered == null || 
        (Context.CurrentBlockTime >= registered.ExpiredTime && registered.Status == ContractProposingInputStatus.Proposed), 
        "Already proposed.");
    var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
    State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
    {
        Proposer = Context.Sender,
        Status = ContractProposingInputStatus.Proposed,
        ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
    };
}
```

Apply the same fix to `SendUserContractProposal()`. Additionally, consider extending the code check expiration period from 15 minutes to a more realistic timeframe that accounts for network conditions and governance participation delays.

## Proof of Concept

```csharp
[Fact]
public async Task ProposalHijacking_AfterCodeCheckExpiration()
{
    var contractDeploymentInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
    };

    // Alice proposes contract
    var aliceTester = Tester.CreateNewContractTester(AliceKeyPair);
    var proposingTxResult = await aliceTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract),
        contractDeploymentInput);
    
    var proposalId = ProposalCreated.Parser
        .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;
    var proposedContractInputHash = ContractProposed.Parser
        .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
        .ProposedContractInputHash;

    // Governance approves
    await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
    
    // Alice releases to trigger code check
    await aliceTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ReleaseApprovedContract),
        new ReleaseContractInput
        {
            ProposalId = proposalId,
            ProposedContractInputHash = proposedContractInputHash
        });

    var codeCheckProposalId = ProposalCreated.Parser
        .ParseFrom(releaseResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;

    // Wait for code check expiration (15 minutes)
    var expirationTime = TimestampHelper.GetUtcNow().AddSeconds(901);
    
    // Bob hijacks the proposal
    var bobTester = Tester.CreateNewContractTester(BobKeyPair);
    var hijackResult = await bobTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract),
        contractDeploymentInput,
        expirationTime);
    
    // Verify Bob successfully overwrote the proposal
    hijackResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Alice cannot complete her own proposal anymore
    await ApproveWithMinersAsync(Tester, ParliamentAddress, codeCheckProposalId);
    var aliceReleaseResult = await aliceTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ReleaseCodeCheckedContract),
        new ReleaseContractInput
        {
            ProposalId = codeCheckProposalId,
            ProposedContractInputHash = proposedContractInputHash
        });
    
    // Fails because proposer is now Bob, not Alice
    aliceReleaseResult.Status.ShouldBe(TransactionResultStatus.Failed);
    aliceReleaseResult.Error.ShouldContain("Invalid contract proposing status");
}
```

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-323)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-6)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
    public const int DefaultCodeCheckProposalExpirationTimePeriod = 900; // 60 * 15
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L254-260)
```csharp
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod())
            },
            OriginProposer = proposedInfo.Proposer
        };

        proposedInfo.ExpiredTime = proposalCreationInput.ProposalInput.ExpiredTime;
        State.ContractProposingInputMap[proposedContractInputHash] = proposedInfo;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L277-290)
```csharp
    public override Empty ReleaseApprovedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.Approved;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            input.ProposalId.ToByteString());
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L292-306)
```csharp
    public override Empty ReleaseCodeCheckedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        var codeCheckController = State.CodeCheckController.Value;
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release), input.ProposalId);
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L276-314)
```csharp
    public async Task Propose_MultiTimes()
    {
        var contractDeploymentInput = new ContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory, // test the default runner
            Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
        };

        var utcNow = TimestampHelper.GetUtcNow();
        // propose contract code
        var proposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow);
        proposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var proposalId = ProposalCreated.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
            .ProposalId;
        proposalId.ShouldNotBeNull();
        var proposedContractInputHash = ContractProposed.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
            .ProposedContractInputHash;

        var secondProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
        secondProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);

        var thirdProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow.AddSeconds(86399));
        thirdProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
        
        var byteResult = await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractProposalExpirationTimePeriod),
            new Empty());
        var expirationTimePeriod = Int32Value.Parser.ParseFrom(byteResult);
        
        var forthProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow.AddSeconds(expirationTimePeriod.Value));
        forthProposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
```
