# Audit Report

## Title
Original SEED Creator Can Sabotage Transferred SEEDs by Setting Expiration to Past

## Summary
The `ExtendSeedExpirationTime()` function uses `tokenInfo.Owner` for authorization, which is never updated when SEED NFTs are transferred. This allows the original creator to set the expiration time to the past even after selling the SEED, permanently destroying its utility and causing direct financial loss to the buyer.

## Finding Description
The vulnerability stems from a critical disconnect between **balance ownership** (who holds the tokens) and **metadata ownership** (the `tokenInfo.Owner` field) in the MultiToken contract's SEED NFT system.

When a SEED NFT is created via `CreateNFTInfo()`, the `tokenInfo.Owner` field is set to the creator's address and persisted through `RegisterTokenInfo()`. [1](#0-0) 

When the SEED is transferred via `Transfer()`, only the balance mappings are modified through `DoTransfer()` and `ModifyBalance()`. The `DoTransfer()` function exclusively calls `ModifyBalance()` twice to update sender and receiver balances. [2](#0-1) 

The `ModifyBalance()` function only updates the `State.Balances[address][symbol]` mapping and never touches `tokenInfo.Owner`. [3](#0-2) 

The `tokenInfo.Owner` field can only be changed through `ModifyTokenIssuerAndOwner()`, which requires the token to not have an owner already set, making it unusable for updating ownership after initial creation. [4](#0-3) 

The `ExtendSeedExpirationTime()` function authorizes callers by checking `tokenInfo.Owner == Context.Sender`, not the current balance holder. [5](#0-4) 

Critically, this function **imposes no validation** that the new expiration time must be in the future - it directly sets whatever timestamp is provided at line 711-712.

When the SEED is later used to create a token, `CheckSeedNFT()` validates if the expiration time has passed. [6](#0-5) 

If the expiration has been set to the past (e.g., timestamp 1), the check at line 130 fails, making the SEED permanently unusable despite the new owner having valid balance.

**Attack Flow:**
1. Alice creates SEED-1 NFT (`tokenInfo.Owner` = Alice, `State.Balances[Alice][SEED-1]` = 1)
2. Alice transfers SEED-1 to Bob (balances update, but `tokenInfo.Owner` still = Alice)
3. Alice calls `ExtendSeedExpirationTime({Symbol: "SEED-1", ExpirationTime: 1})`
4. Authorization passes because Alice == `tokenInfo.Owner`
5. Bob's SEED is now expired and unusable, causing complete financial loss

## Impact Explanation
**Direct Financial Loss:** SEED NFTs are valuable assets that grant exclusive rights to create tokens with specific symbols. They are tradeable on secondary markets. By setting the expiration to the past, the original creator permanently destroys the SEED's utility, making the buyer's purchase worthless.

**Who is Affected:** Any user who purchases or receives a SEED NFT from its original creator through legitimate transfers, marketplace transactions, or OTC trades.

**Severity: HIGH** - This enables theft-equivalent damage where Alice can destroy the value of assets she no longer possesses, with zero cost to execute (single transaction), no technical barriers, and no recovery mechanism. The attack is undetectable until Bob attempts to use the SEED.

## Likelihood Explanation
**Entry Point:** `ExtendSeedExpirationTime()` is a public method directly accessible via transaction submission.

**Attacker Prerequisites:** The attacker must be the original creator (or designated `tokenInfo.Owner`) of a SEED NFT that has been transferred to another party. This is a **common scenario** in NFT marketplaces and secondary sales.

**Attack Complexity:** Trivial - requires only a single transaction with `ExpirationTime = 1` or any past timestamp.

**Economic Rationality:**
- **Griefing attacks:** Malicious sellers sabotage buyers post-sale
- **Market manipulation:** Devalue competitor SEEDs or manipulate prices
- **Front-running:** Seller lists SEED, observes incoming purchase, front-runs with expiration modification
- **Exit scams:** Large-scale SEED creator sells inventory then destroys all sold SEEDs

**Likelihood: HIGH** - The vulnerability is directly reachable, requires only common preconditions (SEED transfer), and has multiple rational attack motivations.

## Recommendation
The authorization mechanism in `ExtendSeedExpirationTime()` should check the current balance holder, not the metadata owner. Two possible fixes:

**Option 1: Check balance ownership**
```csharp
Assert(State.Balances[Context.Sender][input.Symbol] > 0, "Sender does not own the SEED NFT.");
```

**Option 2: Update tokenInfo.Owner during transfers**
Modify the transfer flow to update `tokenInfo.Owner` to the new balance holder when transferring NFTs with unique supply (totalSupply == 1).

Additionally, add validation to prevent setting expiration time to the past:
```csharp
Assert(input.ExpirationTime > Context.CurrentBlockTime.Seconds, "Expiration time must be in the future.");
```

## Proof of Concept
```csharp
[Fact]
public async Task ExtendSeedExpirationTime_AfterTransfer_Vulnerability()
{
    // Setup: Alice creates SEED-1 with future expiration
    var seedSymbol = "SEED-1";
    var futureExpiration = DateTimeOffset.UtcNow.AddYears(1).ToUnixTimeSeconds();
    
    await CreateSeedNFT(AliceAddress, seedSymbol, futureExpiration);
    
    // Alice transfers SEED to Bob
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = BobAddress,
        Symbol = seedSymbol,
        Amount = 1
    });
    
    // Verify Bob owns the SEED balance
    var bobBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = BobAddress,
        Symbol = seedSymbol
    });
    Assert.Equal(1, bobBalance.Balance);
    
    // Alice (original owner) sets expiration to past
    await TokenContractStub.ExtendSeedExpirationTime.SendAsync(new ExtendSeedExpirationTimeInput
    {
        Symbol = seedSymbol,
        ExpirationTime = 1 // Timestamp in the past
    });
    
    // Bob attempts to use SEED to create token - should fail
    var result = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TEST",
        TokenName = "Test Token",
        TotalSupply = 1000,
        Decimals = 8,
        Issuer = BobAddress,
        Owner = BobAddress,
        IsBurnable = true,
        SymbolSeed = seedSymbol
    });
    
    // Verify creation fails due to expired SEED
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Failed);
    Assert.Contains("OwnedSymbol is expired", result.TransactionResult.Error);
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L36-36)
```csharp
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```
