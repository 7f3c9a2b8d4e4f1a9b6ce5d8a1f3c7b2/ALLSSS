# Audit Report

## Title
Race Condition in Mining Order Assignment Causes Duplicate Orders and Block Production Conflicts

## Summary
The AEDPoS consensus mechanism contains a race condition where multiple miners can independently calculate and commit the same `FinalOrderOfNextRound` value when generating consensus commands from stale round state. The validation logic that should detect duplicates is broken due to calling `.Distinct()` on `MinerInRound` objects instead of their order field values. This results in multiple miners receiving identical mining timestamps during round termination, causing blockchain forks and consensus degradation.

## Finding Description

The vulnerability exists in the interaction between off-chain conflict resolution, on-chain state updates, and broken validation:

**Off-chain Conflict Resolution Without State Synchronization:**

When miners generate consensus data, `ApplyNormalConsensusData` performs conflict resolution locally by checking for existing miners with the same `FinalOrderOfNextRound` and reassigning conflicted miners to different orders. [1](#0-0) 

However, this operates on a local copy of the round state fetched at call time. The results are packaged into `TuneOrderInformation` for later application. [2](#0-1) 

**No On-chain Conflict Re-validation:**

When blocks execute, `ProcessUpdateValue` directly sets each miner's `FinalOrderOfNextRound` to their `SupposedOrderOfNextRound` and applies the pre-calculated `TuneOrderInformation`. [3](#0-2) 

There is no re-validation to detect if `TuneOrderInformation` was calculated based on stale state. If multiple miners calculated orders from the same state before any blocks executed, their conflict resolutions become invalid.

**Race Condition Scenario:**

When two miners call consensus methods before either has produced a block, both fetch the same on-chain state (all `FinalOrderOfNextRound = 0`), both calculate the same `SupposedOrderOfNextRound` via hash modulo [4](#0-3) , both see no conflicts locally, generate empty `TuneOrderInformation`, and when blocks execute sequentially, both end up with `FinalOrderOfNextRound = 2`.

**Critical Validation Bug:**

The `NextRoundMiningOrderValidationProvider` calls `.Distinct()` on `MinerInRound` objects rather than on their `FinalOrderOfNextRound` values. [5](#0-4) 

Since `MinerInRound` is a protobuf-generated class [6](#0-5)  without custom equality implementation, each miner object is considered distinct regardless of having identical order values.

**Propagation to Next Round and Timestamp Collision:**

When the next round is generated, miners are ordered by `FinalOrderOfNextRound`, and each miner's `Order` field is set to their `FinalOrderOfNextRound` value. [7](#0-6) 

Miners with duplicate `Order` values calculate identical timestamps in `ArrangeAbnormalMiningTime` (used for extra block production during round termination), as the timestamp is directly computed from the `Order` field. [8](#0-7) 

This method is invoked via `TerminateRoundCommandStrategy` for round termination. [9](#0-8) 

## Impact Explanation

**Consensus Integrity Impact:**
- Multiple miners receive identical mining timestamps for round termination blocks
- Both attempt to produce extra blocks at the exact same time, creating competing blocks
- Results in temporary blockchain forks during round transitions
- Network must resolve forks through consensus mechanisms, increasing orphaned blocks
- Reduces consensus efficiency and creates observable network instability

**Operational Impact:**
- Degraded network performance during round transitions
- Wasted computational resources on orphaned blocks
- Potential for extended fork resolution if multiple miner pairs have conflicts
- Confusion in block explorers and monitoring tools

This violates the critical consensus invariant requiring correct round transitions and miner schedule integrity. While it doesn't directly enable fund theft, it significantly degrades consensus quality and causes recurring operational disruptions. The impact is **HIGH** for consensus integrity.

## Likelihood Explanation

**No Attack Required:**
This is a natural race condition requiring no malicious intent. It occurs probabilistically during normal mining operations through the public consensus interface that all miners regularly call.

**Feasibility Conditions:**

1. **Hash Collision Probability:** The `SupposedOrderOfNextRound` is calculated via `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [10](#0-9)  With N miners, the probability of two miners calculating the same order is approximately 1/N per pair. For 21 miners (typical mainnet configuration), collisions are expected to occur regularly.

2. **Timing Window:** Miners naturally generate consensus commands within the same round before blocks propagate. Network latency (100-500ms typical) provides a realistic window where multiple miners fetch the same round state before any updates are committed.

3. **Sequential Block Execution:** Both blocks can be in the canonical chain at different heights (normal case), not requiring competing forks at the same height for the race condition to manifest.

The probability assessment is **MEDIUM-HIGH** - given the hash collision probability and typical network conditions, duplicate orders are expected to occur periodically, making scheduling conflicts and resulting forks a recurring operational issue.

## Recommendation

Fix the validation to check for duplicate `FinalOrderOfNextRound` values, not object identity:

```csharp
// In NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Add this line
    .Distinct().Count();
```

Additionally, consider adding on-chain re-validation in `ProcessUpdateValue` to detect when `TuneOrderInformation` was calculated based on stale state, or implement a mechanism to ensure conflict resolution sees the latest committed state.

## Proof of Concept

Due to the complexity of the AEDPoS consensus system, a full PoC would require setting up a multi-node test environment with precise timing control. However, the vulnerability can be demonstrated by:

1. Setting up two miners with signatures that hash to the same modulo value
2. Having both miners call consensus generation simultaneously before either block is executed
3. Observing that both miners end up with the same `FinalOrderOfNextRound` value
4. Verifying the validation passes despite duplicate orders
5. Observing timestamp collisions when the next round is generated

The key validation failure can be unit tested by creating `MinerInRound` objects with identical `FinalOrderOfNextRound` values and verifying that `.Distinct()` on the objects returns all objects (not detecting duplicates), while `.Select(m => m.FinalOrderOfNextRound).Distinct()` would correctly detect the duplicate values.

## Notes

This vulnerability is particularly insidious because:
1. It manifests only under specific timing and hash collision conditions
2. The validation appears to check for uniqueness but is broken due to a subtle bug
3. The resulting forks may appear as "normal" temporary forks to observers
4. The issue compounds with network size - more miners means more potential collision pairs

The broken validation is the critical enabler - without it, blocks with duplicate orders would be rejected during validation, preventing the consensus degradation even if the race condition occurred.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-260)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L36-36)
```csharp
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L25-26)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```
