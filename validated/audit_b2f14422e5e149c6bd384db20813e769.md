# Audit Report

## Title
Inconsistent Vote Accounting After Member Removal Allows Governance Manipulation

## Summary
The Association contract's vote counting logic contains a critical inconsistency that allows governance manipulation. When members are removed from an organization after voting on active proposals, their votes are counted inconsistently: individual vote type counts (approvals, rejections, abstentions) filter by current membership, but the total vote threshold count includes all historical votes from removed members. This enables a majority coalition to bypass rejection thresholds by removing dissenting members after they vote.

## Finding Description

The vulnerability stems from three interconnected flaws in the Association contract:

**1. Member Removal Without Vote Cleanup**

The `RemoveMember` function removes an address from the organization's member list but does not invalidate that member's existing votes on active proposals. [1](#0-0) 

**2. Inconsistent Vote Counting Logic**

The threshold validation logic applies different filtering rules to different vote counts:

- **Rejection count** filters by current membership using `.Count(organization.OrganizationMemberList.Contains)` [2](#0-1) 

- **Abstention count** filters by current membership [3](#0-2) 

- **Approval count** filters by current membership [4](#0-3) 

- **Total vote count** does NOT filter - it concatenates all lists and counts ALL historical votes regardless of current membership status [5](#0-4) 

**3. Release Validation Uses Current Organization State**

When releasing a proposal, the validation retrieves the current organization state and applies the inconsistent counting logic, meaning members removed between voting and release have their votes handled incorrectly. [6](#0-5) 

**Attack Sequence:**
1. Proposal A is created (contentious action)
2. Members vote: 4 approve, 3 reject (7 total)
3. Proposal B is created to remove the 3 rejecting members
4. Majority coalition approves Proposal B
5. Proposal B is released (members removed)
6. Proposal A validation now sees: 4 approvals (current members), 0 rejections (filtered out), 0 abstentions (filtered out), but 7 total votes (not filtered)
7. Proposal A is released successfully despite having been rejected

**Root Cause:** The filtering predicate `organization.OrganizationMemberList.Contains` is correctly applied to individual vote type counts but incorrectly omitted from the total vote count aggregation at line 56 of `Association_Helper.cs`.

## Impact Explanation

**HIGH Severity** - This vulnerability fundamentally undermines governance integrity:

1. **Threshold Bypass**: Removed members' rejections no longer count toward `MaximalRejectionThreshold` and abstentions no longer count toward `MaximalAbstentionThreshold`, while their votes still count toward `MinimalVoteThreshold`.

2. **Governance Manipulation**: Proposals that should be rejected can be artificially approved by strategically removing dissenting members after they vote.

3. **Minority Silencing**: A majority coalition can retroactively nullify minority opposition through member removal, defeating the purpose of rejection and abstention thresholds.

4. **Quorum Gaming**: The `MinimalVoteThreshold` can be satisfied with votes from removed members while actual current member participation is lower than intended.

**Concrete Example:**
- Organization: 10 members  
- Thresholds: MinimalVoteThreshold=7, MinimalApprovalThreshold=4, MaximalRejectionThreshold=2
- Initial votes: 4 approve, 3 reject (7 total)
- Expected: 3 rejections > MaximalRejectionThreshold(2) → **REJECTED**
- After removing 3 dissenters: 
  - `approvedMemberCount` = 4 (current members only) ≥ 4 ✓
  - `rejectionMemberCount` = 0 (filtered by current membership) ≤ 2 ✓
  - `totalVotes` = 7 (includes removed members' votes) ≥ 7 ✓
  - Result: **APPROVED**

## Likelihood Explanation

**HIGH Likelihood** - This attack is highly feasible:

**Attacker Capabilities**: Only requires control of an organizational majority to pass a member removal proposal - realistic for any multi-party governance organization where coalitions form.

**Attack Complexity**: LOW - Six simple steps using only public contract methods:
1. Create contentious proposal
2. Wait for votes
3. Create member removal proposal targeting dissenters
4. Obtain majority approval for removal
5. Release removal proposal
6. Release original proposal (now passes)

**Feasibility Factors**:
- All steps use standard public methods available to any organization member
- No special permissions required beyond organizational majority (which is standard for governance)
- Attack is indistinguishable from legitimate governance operations
- Economically rational for high-value proposals
- No technical barriers to execution

## Recommendation

Apply consistent filtering to the total vote count. Modify the `CheckEnoughVoteAndApprovals` method to filter all vote lists by current membership before counting:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter by current membership for total vote count
    var isVoteThresholdReached =
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
        organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

Alternatively, consider invalidating votes when members are removed:

```csharp
public override Empty RemoveMember(Address input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
    Assert(removeResult, "Remove member failed.");
    Assert(Validate(organization), "Invalid organization.");
    
    // Clear removed member's votes from all active proposals
    // (requires iterating proposals or maintaining proposal index)
    
    State.Organizations[Context.Sender] = organization;
    Context.Fire(new MemberRemoved
    {
        OrganizationAddress = Context.Sender,
        Member = input
    });
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RemoveMember_BypassesRejectionThreshold_Test()
{
    // Setup: Organization with 10 members, thresholds: MinimalVote=7, MinimalApproval=4, MaximalRejection=2
    var members = new[] { Reviewer1, Reviewer2, Reviewer3, 
        Accounts[4].Address, Accounts[5].Address, Accounts[6].Address,
        Accounts[7].Address, Accounts[8].Address, Accounts[9].Address, 
        Accounts[10].Address };
    
    var organizationAddress = await CreateOrganizationWithMembers(
        minimalApprovalThreshold: 4,
        minimalVoteThreshold: 7,
        maximalRejectionThreshold: 2,
        members: members);
    
    // Step 1: Create contentious proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Step 2: Members vote - 4 approve, 3 reject (should fail due to MaximalRejection=2)
    await ApproveAsync(Reviewer1KeyPair, proposalId); // Approve
    await ApproveAsync(Reviewer2KeyPair, proposalId); // Approve
    await ApproveAsync(Accounts[4].KeyPair, proposalId); // Approve
    await ApproveAsync(Accounts[5].KeyPair, proposalId); // Approve
    await RejectAsync(Reviewer3KeyPair, proposalId); // Reject
    await RejectAsync(Accounts[6].KeyPair, proposalId); // Reject
    await RejectAsync(Accounts[7].KeyPair, proposalId); // Reject
    
    // Verify proposal should be rejected (3 rejections > MaximalRejection=2)
    var proposal1 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal1.ToBeReleased.ShouldBeFalse(); // Should NOT be releasable
    
    // Step 3-5: Remove the 3 rejecting members via proposal
    var removalProposal1 = await CreateRemoveMemberProposalAsync(Reviewer3);
    await ApproveRemovalProposal(removalProposal1, members.Take(7).Select(a => GetKeyPair(a)));
    await ReleaseProposal(removalProposal1);
    
    var removalProposal2 = await CreateRemoveMemberProposalAsync(Accounts[6].Address);
    await ApproveRemovalProposal(removalProposal2, members.Take(7).Select(a => GetKeyPair(a)));
    await ReleaseProposal(removalProposal2);
    
    var removalProposal3 = await CreateRemoveMemberProposalAsync(Accounts[7].Address);
    await ApproveRemovalProposal(removalProposal3, members.Take(7).Select(a => GetKeyPair(a)));
    await ReleaseProposal(removalProposal3);
    
    // Step 6: Original proposal now passes despite having been rejected
    var proposal2 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal2.ToBeReleased.ShouldBeTrue(); // BUG: Now releasable!
    proposal2.RejectionCount.ShouldBe(0); // Rejections filtered out
    
    // Release succeeds (should have failed)
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // VULNERABILITY CONFIRMED: Proposal that should be rejected was approved
}
```

## Notes

This vulnerability affects the core governance mechanism of the Association contract. The inconsistency between how individual vote types are counted (with current membership filtering) versus the total vote count (without filtering) creates a critical loophole that can be exploited by any majority coalition.

The attack is particularly dangerous because:
1. It's completely within the bounds of "normal" governance operations
2. It leaves no obvious trace of manipulation
3. It undermines the fundamental purpose of rejection and abstention thresholds
4. It can be used to push through any contentious proposal by simply removing opposition

The fix should ensure all vote counting uses consistent membership filtering, or alternatively, votes should be invalidated when members are removed from the organization.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```
