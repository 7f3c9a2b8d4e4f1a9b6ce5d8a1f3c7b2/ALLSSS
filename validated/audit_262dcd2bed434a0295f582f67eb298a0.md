# Audit Report

## Title
Stale Beneficiaries Due to Custom Profits Receiver Address Changes in Treasury Reward Distribution

## Summary
The Treasury contract's reward weight update functions fail to properly remove beneficiaries when miners change their custom profits receiver address. When `SetProfitsReceiver` updates the receiver mapping, the Treasury's three reward schemes (BasicReward, VotesWeightReward, ReElectionReward) are not updated. Subsequently, the removal logic queries the current receiver mapping to identify beneficiaries for removal, but this targets the new receiver instead of the old one, causing the old receiver to remain as a permanent stale beneficiary that continues draining rewards indefinitely.

## Finding Description

The vulnerability exists in three Treasury reward update functions that share the same flawed pattern.

In `UpdateBasicMinerRewardWeights`, beneficiaries are removed by calling `RemoveBeneficiaries` with addresses obtained from `GetAddressesFromCandidatePubkeys`: [1](#0-0) 

The `GetAddressesFromCandidatePubkeys` function returns both pubkey-derived addresses and calls `GetProfitsReceiver` for each pubkey: [2](#0-1) 

The `GetProfitsReceiver` function returns the CURRENT value from `State.ProfitsReceiverMap[pubkey]`, falling back to the pubkey-derived address if no custom receiver is set: [3](#0-2) 

When beneficiaries are added in the same function, they also use `GetProfitsReceiver` which captures the receiver address at that specific point in time: [4](#0-3) 

The root cause is that when a miner changes their custom receiver via `SetProfitsReceiver`, it updates `State.ProfitsReceiverMap[input.Pubkey]` but does NOT update the Treasury's BasicReward, VotesWeightReward, or ReElectionReward schemes: [5](#0-4) 

The Treasury contract only notifies the Election contract to update the Subsidy scheme (lines 621-626), but leaves its own three reward schemes unchanged.

The Profit contract's `RemoveBeneficiary` function silently fails if the beneficiary address doesn't exist in the profit details map: [6](#0-5) 

At line 235, when `currentDetail == null`, the function returns `new Empty()` without any assertion or event, enabling the silent failure.

The same vulnerability pattern exists in `UpdateWelcomeRewardWeights`: [7](#0-6) 

And in `UpdateFlexibleRewardWeights`: [8](#0-7) 

**Attack Scenario:**
1. **Term N**: Miner with pubkey "ABC" has no custom receiver. Address_1 (derived from pubkey) is added as beneficiary to BasicReward scheme with X shares.
2. **Between Terms**: Miner's admin calls `SetProfitsReceiver` to change receiver to Address_2. The `ProfitsReceiverMap` is updated, but BasicReward scheme is not.
3. **Term N+1**: `UpdateBasicMinerRewardWeights` attempts to remove beneficiaries using current receiver mapping, which now returns Address_2 for "ABC". The removal of Address_2 fails silently because it was never added. Address_1 remains with X shares.
4. **Result**: Address_1 continues receiving rewards indefinitely as a stale beneficiary, while Address_2 is added for the new term, effectively doubling the miner's share allocation.

## Impact Explanation

**Direct Fund Impact:**
- Stale beneficiary addresses continue receiving shares of BasicReward, WelcomeReward (VotesWeightReward), and FlexibleReward (ReElectionReward) schemes indefinitely
- Each stale beneficiary dilutes rewards for legitimate current miners by inflating the total shares
- The reward calculation follows the pattern `(beneficiary_shares / total_shares) * period_rewards`, so stale shares directly reduce legitimate miner rewards proportionally
- Multiple receiver changes compound the issue exponentially, as each change creates a new stale beneficiary while the new receiver also gets added
- Affects all three major Treasury reward distribution channels simultaneously

**Who is Affected:**
- Active miners receive reduced rewards due to inflated total shares from stale beneficiaries
- The Treasury's reward pool is systematically drained by addresses that should no longer be beneficiaries
- Legitimate candidates who don't exploit this mechanism lose competitive advantage

**Severity Justification:**
This is a HIGH severity vulnerability because:
1. It enables permanent theft of mining rewards through a simple, repeatable action
2. There is no cost to the attacker beyond being a registered candidate
3. The funds cannot be recovered once distributed to stale beneficiaries
4. The silent failure in `RemoveBeneficiary` prevents any detection mechanism
5. No expiry mechanism exists to automatically clean up stale beneficiaries
6. The vulnerability affects three separate reward schemes, multiplying the impact

## Likelihood Explanation

**Attacker Capabilities:**
- Any candidate can call `SetProfitsReceiver` through their admin account, as verified by the permission check: [9](#0-8) 

- No special privileges required beyond being a registered candidate
- Multiple changes can be made to accumulate stale beneficiaries across multiple terms

**Attack Complexity:**
- Extremely low complexity: requires only calling `SetProfitsReceiver` to change the receiver address
- No timing constraints or race conditions needed
- Works reliably due to deterministic state management in the contracts
- The term-based update cycle provides ample opportunity window for the receiver change

**Feasibility Conditions:**
- Attacker must be a current candidate (realistic for adversarial miners)
- The function is publicly accessible with only basic candidate verification
- No monitoring exists to detect stale beneficiaries in profit schemes

**Detection/Operational Constraints:**
- Stale beneficiaries are indistinguishable from legitimate beneficiaries in profit schemes
- No events or logs indicate when `RemoveBeneficiary` fails silently
- The silent failure mechanism prevents any automated detection
- Total shares in the schemes would grow unexpectedly, but this requires manual inspection

**Probability:**
HIGH - The attack is trivial to execute (single function call), costs nothing beyond transaction fees, and is extremely difficult to detect. Any rational adversarial candidate could exploit this to gain unfair advantage and drain Treasury rewards.

## Recommendation

The fix requires updating the Treasury's three reward schemes when `SetProfitsReceiver` is called. The recommended approach:

1. **In `SetProfitsReceiver`**, before updating the `ProfitsReceiverMap`, remove the old receiver from BasicReward, VotesWeightReward, and ReElectionReward schemes if the candidate is currently a miner.

2. **Add the new receiver** to these schemes if the candidate is currently a miner.

3. **Alternative approach**: Store the historical receiver address that was used when adding the beneficiary, and use that stored value during removal instead of querying the current map.

The key principle is: **The address used for removal must match the address that was added**. The current implementation violates this invariant by allowing the receiver mapping to change between add and remove operations.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Deploy Treasury, Profit, and Election contracts
2. Set up a miner for Term N with no custom receiver (uses pubkey-derived Address_1)
3. Call `UpdateBasicMinerRewardWeights` to add Address_1 as beneficiary
4. Call `SetProfitsReceiver` to change receiver to Address_2
5. Advance to Term N+1 and call `UpdateBasicMinerRewardWeights` again
6. Verify that:
   - RemoveBeneficiary was called with Address_2 (which doesn't exist, so fails silently)
   - Address_1 still has shares in BasicReward scheme
   - Address_2 is also added with new shares
   - Total shares increased instead of remaining constant
7. Distribute rewards and verify Address_1 receives funds despite not being a current miner

The test would confirm that stale beneficiaries persist and continue receiving rewards indefinitely.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L601-629)
```csharp
    public override Empty SetProfitsReceiver(SetProfitsReceiverInput input)
    {
        if (State.ElectionContract.Value == null)
            State.ElectionContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
        var pubkey = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.Pubkey));
        
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
        
        var candidateList = State.ElectionContract.GetCandidates.Call(new Empty());
        Assert(candidateList.Value.Contains(pubkey),"Pubkey is not a candidate.");

        var previousProfitsReceiver = State.ProfitsReceiverMap[input.Pubkey];
        //Set same profits receiver address.
        if (input.ProfitsReceiverAddress == previousProfitsReceiver)
        {
            return new Empty();
        }
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
        State.ElectionContract.SetProfitsReceiver.Send(new AElf.Contracts.Election.SetProfitsReceiverInput
        {
            CandidatePubkey = input.Pubkey,
            ReceiverAddress = input.ProfitsReceiverAddress,
            PreviousReceiverAddress = previousProfitsReceiver ?? new Address()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L657-663)
```csharp
    private List<Address> GetAddressesFromCandidatePubkeys(ICollection<string> pubkeys)
    {
        var addresses = pubkeys.Select(k => Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)))
            .ToList();
        addresses.AddRange(pubkeys.Select(GetProfitsReceiver));
        return addresses;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L780-787)
```csharp
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L793-821)
```csharp
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L848-891)
```csharp
    private void UpdateWelcomeRewardWeights(Round previousTermInformation, List<string> newElectedMiners)
    {
        var previousMinerAddresses =
            GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
        var possibleWelcomeBeneficiaries = new RemoveBeneficiariesInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Beneficiaries = { previousMinerAddresses }
        };
        State.ProfitContract.RemoveBeneficiaries.Send(possibleWelcomeBeneficiaries);
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });

        if (newElectedMiners.Any())
        {
            Context.LogDebug(() => "Welcome reward will go to new miners.");
            var newBeneficiaries = new AddBeneficiariesInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                EndPeriod = previousTermInformation.TermNumber.Add(1)
            };
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });

            if (newBeneficiaries.BeneficiaryShares.Any()) State.ProfitContract.AddBeneficiaries.Send(newBeneficiaries);
        }
        else
        {
            Context.LogDebug(() => "Welcome reward will go to Basic Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                SubSchemeId = State.BasicRewardHash.Value,
                SubSchemeShares = 1
            });
        }
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L893-936)
```csharp
    private void UpdateFlexibleRewardWeights(Round previousTermInformation)
    {
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.WelfareHash.Value
        });
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });
        if (State.ProfitContract.GetScheme.Call(State.ReElectionRewardHash.Value).TotalShares > 0)
        {
            var previousMinerAddresses =
                GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                Beneficiaries = { previousMinerAddresses }
            });
        }

        if (State.HasNewMiner[previousTermInformation.TermNumber])
        {
            Context.LogDebug(() => "Flexible reward will go to Welfare Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                SubSchemeId = State.WelfareHash.Value,
                SubSchemeShares = 1
            });
        }
        else
        {
            Context.LogDebug(() => "Flexible reward will go to Basic Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                SubSchemeId = State.BasicRewardHash.Value,
                SubSchemeShares = 1
            });
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```
