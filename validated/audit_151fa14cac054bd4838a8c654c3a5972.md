# Audit Report

## Title
Quadratic Voting Implementation Broken - All Votes Cost Same Amount Due to Incorrect Vote Count Tracking

## Summary
The quadratic voting mechanism in the Vote contract is fundamentally broken because `QuadraticVotesCountMap` is keyed by `VoteId`, which changes with every vote. This causes each vote to start with a fresh counter at zero instead of accumulating, resulting in all votes costing a flat `TicketCost × 1` instead of the intended progressive quadratic cost (1×, 2×, 3×, etc.).

## Finding Description

The quadratic voting implementation tracks vote counts in `QuadraticVotesCountMap` using `VoteId` as the key. [1](#0-0) 

However, the `VoteId` is generated during input validation by incorporating the current `votingResult.VotesAmount` value, which changes with every vote. [2](#0-1) 

Since `VotesAmount` is incremented after each vote, [3](#0-2)  every subsequent vote by the same voter generates a different `VoteId`. This breaks the quadratic cost calculation. [4](#0-3) 

**Execution Flow:**

**Vote 1 by Alice:**
- Current `VotesAmount = 0`
- `VoteId` generated with `VotesAmount = 0` → `VoteId_1`
- `QuadraticVotesCountMap[VoteId_1] = 0 + 1 = 1`
- Cost = `TicketCost × 1`
- `VotesAmount` updated to `TicketCost`

**Vote 2 by Alice (same voting item, same snapshot):**
- Current `VotesAmount = TicketCost`
- `VoteId` generated with `VotesAmount = TicketCost` → `VoteId_2` (DIFFERENT!)
- `QuadraticVotesCountMap[VoteId_2] = 0 + 1 = 1` (starts at 0 again!)
- Cost = `TicketCost × 1` (should be `TicketCost × 2`!)
- `VotesAmount` updated to `2 × TicketCost`

**Vote N by Alice:**
- Always creates new VoteId due to changing VotesAmount
- Counter always starts at 0
- Always costs `TicketCost × 1`

The map should be keyed by `(Voter, VotingItemId, SnapshotNumber)` to properly track cumulative votes per voter. Searching the codebase confirms `QuadraticVotesCountMap` only appears in its declaration and the two lines where it's used - there is no reset or decrement logic anywhere.

## Impact Explanation

**Severity: High** - This completely negates the fundamental security mechanism of quadratic voting.

Quadratic voting is designed to prevent plutocracy by making it progressively more expensive to dominate voting outcomes. The intended cost progression is:
- 1st vote: `TicketCost × 1`
- 2nd vote: `TicketCost × 2`
- 3rd vote: `TicketCost × 3`
- Total for N votes: `TicketCost × (1+2+3+...+N) = TicketCost × N(N+1)/2`

**With this bug:**
- Every vote costs: `TicketCost × 1`
- Total for N votes: `TicketCost × N` (linear instead of quadratic)

**Concrete Impact:**
- A voter wanting 100 votes should pay: `TicketCost × 5,050`
- Instead they pay: `TicketCost × 100` (50× cheaper!)
- For 1000 votes: should pay `TicketCost × 500,500`, actually pays `TicketCost × 1,000` (500× cheaper!)

**Protocol Damage:**
- Wealthy voters can buy disproportionate voting power cheaply
- Governance becomes plutocratic (money-based) instead of quadratic (preference-intensity-based)
- All decisions made through quadratic voting are invalidated
- The core security property that distinguishes quadratic voting from simple token-weighted voting is completely broken

The vulnerability affects all voting items where `IsQuadratic = true`. [5](#0-4) 

## Likelihood Explanation

**Likelihood: Certain** - This bug triggers automatically for every quadratic vote.

**Attacker Capabilities:** Any user can call the public `Vote()` method. [6](#0-5) 

**Attack Complexity:** Trivial - simply call `Vote()` multiple times on the same quadratic voting item. Each subsequent call will cost the same flat `TicketCost` instead of increasing quadratically.

**Preconditions:** Only requires:
- A voting item registered with `IsQuadratic = true`
- The voting item must be active (within start/end timestamps)

The bug is inherent in the design - there are no special conditions, timing windows, or state manipulations required. Every single quadratic vote in the system suffers from this issue. The execution flow shows that [7](#0-6)  the VoteId generation happens automatically during input validation using the changing VotesAmount value, and there is no duplicate vote prevention mechanism.

**Economic Rationality:** Exploiting this provides maximum voting power for minimum cost with no downside. A rational voter would always exploit this to maximize their influence.

## Recommendation

The `QuadraticVotesCountMap` should be keyed by a stable identifier that represents the voter's cumulative voting activity on a specific voting item and snapshot, not by the individual VoteId which changes with each vote.

**Recommended Fix:**

1. Change the key structure from `Hash (VoteId)` to a composite key representing `(Address voter, Hash votingItemId, long snapshotNumber)`

2. Update the Vote method logic:
```csharp
// Instead of using input.VoteId as the key
var quadraticKey = HashHelper.ConcatAndCompute(
    HashHelper.ComputeFrom(input.Voter),
    votingItem.VotingItemId,
    HashHelper.ComputeFrom(votingItem.CurrentSnapshotNumber)
);
var currentVotesCount = State.QuadraticVotesCountMap[quadraticKey].Add(1);
State.QuadraticVotesCountMap[quadraticKey] = currentVotesCount;
amount = votingItem.TicketCost.Mul(currentVotesCount);
```

3. When a snapshot is taken or voting ends, the counters for that snapshot should be cleared or a new snapshot number should be used to create a new key space.

## Proof of Concept

A valid test demonstrating this vulnerability would:

1. Register a quadratic voting item with `IsQuadratic = true` and `TicketCost = 100`
2. Have a voter call `Vote()` three times on the same voting item
3. Verify that:
   - First vote costs: 100 (correct)
   - Second vote costs: 100 (INCORRECT - should be 200)
   - Third vote costs: 100 (INCORRECT - should be 300)
   - Total cost: 300 (INCORRECT - should be 600)
4. Show that the voter gained 3 votes for 300 tokens instead of the intended 600 tokens

The test would demonstrate that the quadratic pricing mechanism is completely bypassed, allowing voters to purchase voting power at a flat linear rate instead of the intended quadratic rate.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L31-33)
```csharp
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-91)
```csharp
    public override Empty Vote(VoteInput input)
    {
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L94-103)
```csharp
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
        }
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```
