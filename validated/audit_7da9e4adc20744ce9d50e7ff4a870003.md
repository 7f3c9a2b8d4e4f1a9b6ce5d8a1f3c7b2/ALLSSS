# Audit Report

## Title
Missing UpdateValue Uniqueness Check Allows Mining Order Manipulation

## Summary
The AEDPoS consensus validation logic fails to verify whether a miner has already published their OutValue in the current round, allowing miners to invoke UpdateValue multiple times within the same round with different InValues to manipulate their mining order position in the next round. This breaks the VRF-based fairness guarantee of the consensus mechanism.

## Finding Description

The vulnerability exists in the consensus validation flow where UpdateValue operations are validated against modified state rather than the original blockchain state, enabling repeated UpdateValue calls within a single round.

**Root Cause Analysis:**

The `UpdateValueValidationProvider.NewConsensusInformationFilled()` method only checks that the ProvidedRound contains non-empty OutValue and Signature fields, but never validates whether the miner has already set their OutValue in the current round state. [1](#0-0) 

The BaseRound represents the actual on-chain state ("Round information fetch from StateDb"), while ProvidedRound contains the miner-provided data. [2](#0-1) 

**Critical Validation Flaw:**

Before validation occurs, `ValidateBeforeExecution` calls `RecoverFromUpdateValue` which MODIFIES the baseRound with the provided data. [3](#0-2) 

The RecoverFromUpdateValue method unconditionally overwrites OutValue and Signature without any pre-existing value check. [4](#0-3) 

**Expected vs Actual Behavior:**

The consensus behavior logic dictates that when OutValue is null, miners should use UpdateValue behavior. Once OutValue is set, subsequent blocks should use TinyBlock behavior. [5](#0-4) 

However, ProcessUpdateValue unconditionally overwrites the miner's OutValue and Signature without checking if they're already set. [6](#0-5) 

**Insufficient Protection:**

The only existing duplicate protection is `EnsureTransactionOnlyExecutedOnceInOneBlock()`, which prevents multiple consensus transactions at the same block height but does NOT prevent multiple UpdateValue calls across different blocks within the same round. [7](#0-6) 

**Mining Order Manipulation Mechanism:**

The Signature value directly determines mining order for the next round through modulo arithmetic: `GetAbsModulus(sigNum, minersCount) + 1`. Different InValues produce different Signatures, enabling selection of favorable mining positions. [8](#0-7) 

**Attack Vector:**

The system allows up to 8 blocks per time slot by design, enabling multiple attempts. [9](#0-8) 

1. At block height H: Miner produces UpdateValue with InValue₁ → sets Signature₁
2. At block height H+1 (same round, same time slot): Miner produces UpdateValue with InValue₂ → overwrites with Signature₂
3. Validation passes because baseRound is modified before the uniqueness check would occur
4. Miner repeats with different InValues, selecting the Signature yielding optimal next-round mining position

## Impact Explanation

**Consensus Integrity Compromise:** This vulnerability fundamentally breaks the VRF-based fairness guarantee of AEDPoS. The VRF scheme ensures mining order cannot be predicted or manipulated, but by allowing miners to try multiple InValues and select the resulting Signature producing the most favorable order, the randomness guarantee is destroyed.

**Quantified Economic Advantage:** With 21 miners and 8 blocks per time slot, an attacker can consistently achieve top 3 mining positions instead of the expected average position of 11. This translates to more frequent block production opportunities in future rounds, yielding disproportionate block rewards.

**Systemic Risk:** As rational miners adopt this strategy, consensus becomes increasingly centralized around exploiters. The mechanism degrades from cryptographically random to predictably manipulable, undermining the security model's foundational assumptions.

## Likelihood Explanation

**Attack Feasibility:** Any authorized miner can execute this attack without requiring additional privileges, cryptographic breaks, or network exploitation. The attack complexity is minimal - miners need only call UpdateValue multiple times with different InValues during their time slot and select the Signature yielding the best modulo result.

**Preconditions Met:** All preconditions are inherently satisfied in normal operation: miners have time slots allowing multiple blocks (by design), and the validation logic erroneously accepts repeated UpdateValue calls as valid behavior.

**Economic Rationality:** The attack is profitable with minimal cost (standard transaction fees) against significant benefit (improved mining position → higher rewards), and carries no risk since current validation accepts it as valid.

## Recommendation

Add a uniqueness check in `UpdateValueValidationProvider.ValidateHeaderInformation()` to verify that the miner's OutValue in the ORIGINAL on-chain BaseRound state (before RecoverFromUpdateValue modifies it) is null:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    // Get the original on-chain state BEFORE recovery modification
    if (!TryToGetCurrentRoundInformation(out var originalBaseRound))
        return new ValidationResult { Message = "Failed to get original round state." };
    
    // Check that OutValue is not already set in original state
    var originalMinerInfo = originalBaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    if (originalMinerInfo.OutValue != null && originalMinerInfo.OutValue.Value.Any())
        return new ValidationResult { Message = "OutValue already published in this round." };
    
    // Existing checks...
    if (!NewConsensusInformationFilled(validationContext))
        return new ValidationResult { Message = "Incorrect new Out Value." };
    
    if (!ValidatePreviousInValue(validationContext))
        return new ValidationResult { Message = "Incorrect previous in value." };
    
    return new ValidationResult { Success = true };
}
```

Alternatively, restructure the validation flow to check BaseRound BEFORE calling RecoverFromUpdateValue, ensuring validators see the unmodified on-chain state.

## Proof of Concept

The vulnerability can be demonstrated by a miner executing the following sequence within their time slot:

```csharp
// Block H - First UpdateValue (legitimate)
var input1 = new UpdateValueInput 
{
    InValue = Hash.FromString("test1"),
    OutValue = Hash.FromString("out1"),
    Signature = ComputeSignature(Hash.FromString("test1")),
    // ... other fields
};
consensusContract.UpdateValue(input1); // Sets OutValue1, Signature1

// Block H+1 - Second UpdateValue (exploit)
var input2 = new UpdateValueInput 
{
    InValue = Hash.FromString("test2"), // Different InValue
    OutValue = Hash.FromString("out2"),
    Signature = ComputeSignature(Hash.FromString("test2")), // Different Signature
    // ... other fields
};
consensusContract.UpdateValue(input2); // OVERWRITES OutValue1 with OutValue2, Signature1 with Signature2

// Validation passes for both transactions
// Final state contains OutValue2 and Signature2
// Mining order for next round calculated from Signature2, not Signature1
// Attacker can repeat with input3, input4, etc., selecting optimal Signature
```

The exploit succeeds because `UpdateValueValidationProvider` only checks the ProvidedRound (controlled by the miner), never verifying that OutValue was already set in the original on-chain BaseRound state before the RecoverFromUpdateValue modification.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-27)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-60)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-62)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-253)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
