# Audit Report

## Title
ActualMiningTimes Manipulation Enables Unauthorized Extra Block Production Rights

## Summary
A malicious miner can inject forged timestamps into the `ActualMiningTimes` state by crafting consensus transactions with arbitrary `ActualMiningTime` values that are not validated against `Context.CurrentBlockTime`. This allows the attacker to artificially inflate their `blocksBeforeCurrentRound` calculation and gain unauthorized additional tiny block production rights, violating consensus fairness and enabling reward theft.

## Finding Description

The AEDPoS consensus mechanism determines block production rights based on the `blocksBeforeCurrentRound` calculation, which counts how many blocks a miner produced before the current round started. [1](#0-0) 

This count is used to grant extra production rights to the miner who terminated the previous round (ExtraBlockProducerOfPreviousRound). [2](#0-1) 

**Root Cause**: The vulnerability exists because `ProcessUpdateValue` and `ProcessTinyBlock` directly persist the `ActualMiningTime` from transaction input to state without validating that it equals `Context.CurrentBlockTime`. [3](#0-2) [4](#0-3) 

**Why Validation Fails**: The consensus validation occurs in two separate stages using two independent data sources:

1. **ValidateConsensusBeforeExecution** validates using consensus header extra data by merging `ActualMiningTimes` from the provided Round object into the base round. [5](#0-4)  This merged data is checked by validation providers, but:
   - `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` fields, completely ignoring `ActualMiningTime`. [6](#0-5) 
   - `TimeSlotValidationProvider` only checks the latest `ActualMiningTime` from the merged base round against time slot boundaries, not whether it matches `Context.CurrentBlockTime`. [7](#0-6) 

2. **ValidateConsensusAfterExecution** compares Round hashes, but `ActualMiningTimes` is intentionally excluded from hash calculation. [8](#0-7)  Specifically, line 193 explicitly clears `ActualMiningTimes` before computing the hash, preventing detection of manipulated timestamps.

**Attack Execution**:
1. Attacker (as block producer) crafts a malicious `UpdateValueInput` or `TinyBlockInput` transaction with forged `ActualMiningTime` set to a timestamp from a previous round (before current round start time)
2. Attacker crafts consensus header extra data with legitimate-looking `ActualMiningTimes` to pass time slot validation
3. Validation passes because it checks the consensus header (crafted correctly) but not the transaction input
4. `ProcessUpdateValue` executes and persists the forged timestamp to state without validation
5. Hash comparison in `ValidateConsensusAfterExecution` passes because `ActualMiningTimes` is excluded from the hash
6. On subsequent block production attempts, `GetConsensusBehaviour` calculates `blocksBeforeCurrentRound` by counting the forged timestamps
7. Attacker receives `_maximumBlocksCount + blocksBeforeCurrentRound` production rights instead of the legitimate `_maximumBlocksCount`

## Impact Explanation

**Severity: HIGH** - This vulnerability breaks a critical consensus invariant by allowing unauthorized block production beyond legitimate limits.

**Direct Financial Impact**:
- Attacker produces additional tiny blocks and collects undeserved block rewards
- Honest miners lose proportional block rewards and production opportunities  
- If `_maximumBlocksCount` is 8 and attacker forges 3 timestamps before round start, they gain 11 production rights instead of 8 (37.5% increase in rewards)

**Consensus Integrity Impact**:
- Violates the fairness guarantees of the AEDPoS consensus mechanism
- Allows attacker to dominate block production and control transaction ordering for more blocks than permitted
- Undermines the round-robin scheduling intended by the consensus algorithm
- Token economics are distorted through unfair reward distribution

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Prerequisites**:
- Must be a valid miner (naturally satisfied for any miner in the network)
- Must become `ExtraBlockProducerOfPreviousRound` (happens regularly in round-robin rotation for all miners)
- Round must not be first round of term (`IsMinerListJustChanged` check)

**Attack Complexity: LOW**:
- Attacker has full control over transaction content as block producer
- No special privileges or governance approval required
- Attack is deterministic and repeatable
- Simple modification of `ActualMiningTime` field in transaction input

**Detection Difficulty: HIGH**:
- No cryptographic binding between `ActualMiningTime` and `Context.CurrentBlockTime`
- Validation uses consensus header data, not transaction input
- Hash validation intentionally excludes `ActualMiningTimes` by design
- No audit trail or event emission for timestamp discrepancies

## Recommendation

Implement strict validation in `ProcessUpdateValue` and `ProcessTinyBlock` to ensure `ActualMiningTime` matches `Context.CurrentBlockTime`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // ADD THIS VALIDATION
    Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime,
        $"ActualMiningTime must equal Context.CurrentBlockTime. " +
        $"Provided: {updateValueInput.ActualMiningTime}, Expected: {Context.CurrentBlockTime}");
    
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of method
}
```

Apply similar validation to `ProcessTinyBlock`. Additionally, consider adding validation that compares the consensus header `ActualMiningTimes` against the transaction input for consistency.

## Proof of Concept

The following test demonstrates the vulnerability by showing that a miner can successfully persist forged timestamps to state:

```csharp
[Fact]
public async Task ActualMiningTime_Manipulation_Attack_Test()
{
    // Setup: Initialize consensus with test miner
    await InitializeConsensusContract();
    var miner = await GetCurrentMinerPublicKey();
    
    // Attacker becomes ExtraBlockProducerOfPreviousRound
    await ProduceBlocksUntilRoundEnd(miner);
    
    // Start new round - miner has ExtraBlockProducerOfPreviousRound status
    var currentRound = await GetCurrentRoundInformation();
    var roundStartTime = currentRound.GetRoundStartTime();
    
    // ATTACK: Create UpdateValueInput with forged ActualMiningTime from previous round
    var forgedTimestamp = roundStartTime.AddMilliseconds(-10000); // Before round start
    var maliciousInput = new UpdateValueInput
    {
        OutValue = GenerateOutValue(),
        Signature = GenerateSignature(),
        ActualMiningTime = forgedTimestamp, // FORGED - not Context.CurrentBlockTime
        RoundId = currentRound.RoundId,
        // ... other required fields
    };
    
    // Execute attack transaction
    var result = await ConsensusContract.UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify forged timestamp was persisted to state
    var updatedRound = await GetCurrentRoundInformation();
    var minerInfo = updatedRound.RealTimeMinersInformation[miner];
    minerInfo.ActualMiningTimes.ShouldContain(forgedTimestamp);
    
    // Verify exploit: Calculate blocksBeforeCurrentRound
    var blocksBeforeCurrentRound = minerInfo.ActualMiningTimes
        .Count(t => t <= roundStartTime);
    blocksBeforeCurrentRound.ShouldBeGreaterThan(0); // Forged timestamp counted!
    
    // Attacker gains unauthorized extra production rights
    var maxBlocksCount = await GetMaximumBlocksCount();
    var unauthorizedLimit = maxBlocksCount + blocksBeforeCurrentRound;
    // Attacker can now produce unauthorizedLimit blocks instead of maxBlocksCount
}
```

**Notes**:
- This vulnerability represents a critical break in consensus fairness and economic security
- The attack is practical and executable by any miner during normal network operations
- The lack of validation between `ActualMiningTime` and `Context.CurrentBlockTime` creates a time-of-check-time-of-use (TOCTOU) vulnerability where validation checks one data source (consensus header) while state update uses another (transaction input)
- Immediate patching is recommended to prevent exploitation in production environments

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L64-65)
```csharp
                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```
