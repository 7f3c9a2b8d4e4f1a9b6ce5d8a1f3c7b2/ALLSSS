# Audit Report

## Title
Consensus Round Number Reset Vulnerability via Validation Bypass During Bootstrap Phase

## Summary
A malicious miner can exploit a validation bypass during the first 23 blocks to reset the consensus round number back to 1, causing critical consensus state corruption. The attack combines a bootstrap-phase bypass that skips round number validation with an unsafe update method that permits arbitrary regression to round 1.

## Finding Description

The AEDPoS consensus contract contains two interconnected flaws that enable round number regression:

**Flaw 1: Bootstrap Validation Bypass**

During blocks 1-23, when only a single miner has been producing blocks across all rounds, the `ValidateBeforeExecution` method returns success early without adding critical validation providers. [1](#0-0) 

This early return occurs BEFORE `RoundTerminateValidationProvider` is added to the validation pipeline [2](#0-1) , completely bypassing critical round number increment validation.

**Flaw 2: Unsafe Round Number Update Logic**

The `TryToUpdateRoundNumber` method contains a special case that allows setting the round number to 1 without validating whether this represents valid progression from the current round. [3](#0-2) 

When `roundNumber == 1`, the condition `roundNumber != 1` evaluates to false, causing short-circuit evaluation that skips validation entirely, allowing the update regardless of the current round number.

**Normal Protection That Gets Bypassed**

Under normal circumstances, `RoundTerminateValidationProvider` validates that new round numbers increment by exactly 1 from the base round. [4](#0-3) 

However, this provider is never instantiated when the bootstrap bypass activates.

**Attack Execution Path:**

1. Malicious miner is the sole active miner during blocks 1-23 (multiple miners configured but not yet online)
2. System progresses to round 2 or higher through normal consensus
3. Attacker crafts a `NextRound` transaction with `NextRoundInput{RoundNumber: 1}` [5](#0-4) 
4. `ValidateBeforeExecution` enters bootstrap bypass and returns success without adding validation providers
5. `ProcessNextRound` executes and first calls `AddRoundInformation` which overwrites the original round 1 data [6](#0-5) 
6. Then `TryToUpdateRoundNumber(1)` succeeds and resets `State.CurrentRoundNumber.Value` to 1 [7](#0-6) 

**Consequence: Wrong Strategy Selection**

After the attack, `GetConsensusCommand` incorrectly selects `FirstRoundCommandStrategy` instead of `NormalBlockCommandStrategy` for UpdateValue behavior. [8](#0-7) 

`FirstRoundCommandStrategy` uses simplified time calculations and critically omits `RoundId` and `PreviousRoundId` fields from consensus hints. [9](#0-8) 

In contrast, `NormalBlockCommandStrategy` properly includes these fields required for round continuity validation. [10](#0-9) 

## Impact Explanation

**Critical Consensus State Corruption**

The vulnerability directly undermines the fundamental consensus mechanism:

1. **Round Number Regression**: Violates the monotonic progression invariant - the round number resets from 2+ back to 1, breaking the sequential round tracking that consensus relies on.

2. **Historical Data Loss**: The original round 1 data in `State.Rounds[1]` is permanently overwritten, destroying immutable consensus history required for validation and synchronization.

3. **Mining Strategy Corruption**: Future blocks use `FirstRoundCommandStrategy` which calculates mining times using `(Order + MinersCount - 1) * miningInterval` instead of actual expected mining times from the round state, causing incorrect block production timing.

4. **Broken Round Continuity**: Consensus hints omit `RoundId` and `PreviousRoundId`, breaking the chain of round proofs essential for consensus integrity validation.

5. **Irrecoverable Fork**: When additional miners come online after the bootstrap phase ends at block 24, they observe `CurrentRoundNumber == 1` while the blockchain has progressed significantly beyond genesis. The conflicting state views cause permanent consensus disagreement requiring manual chain rollback.

The severity is **Critical** because it fundamentally compromises consensus integrity, affects all network participants, and has no automated recovery mechanism.

## Likelihood Explanation

**High Exploitability During Bootstrap Phase**

The vulnerability is highly exploitable during network initialization:

**Required Conditions:**
1. Block height must be within 1-23 (verified: `MaximumTinyBlocksCount = 8`, so `8 * 3 = 24` blocks) [11](#0-10) 
2. Multiple miners must be configured (system designed for multi-validator consensus)
3. Only one miner actively producing blocks (attacker maintains sole producer status)
4. Attacker must be in legitimate miner list

**Realistic Attack Scenario:**

Highly realistic during blockchain launch:
- **Staged Deployment**: Not all validators start simultaneously due to coordination complexity, network latency, or phased rollout
- **Network Issues**: Temporary connectivity problems naturally prevent other miners from participating initially
- **Intentional Design**: The system explicitly accommodates single-miner bootstrap (as evidenced by the bypass logic), but fails to protect against malicious exploitation
- **No Economic Barrier**: Attacker is a legitimate miner earning normal block rewards with no additional cost

**Low Attack Complexity:**
- Single transaction with `NextRoundInput{RoundNumber: 1}`
- No complex sequencing or timing requirements
- No need for external resources or sophisticated tooling
- Attack succeeds on first attempt if preconditions met

**Difficult Detection:**
- Malicious transaction appears as valid consensus operation during bootstrap
- No immediate errors or anomalies
- Corruption only becomes apparent after block 24 when other miners synchronize

The combination of high exploitability and realistic conditions during the critical bootstrap phase results in a **High** likelihood assessment.

## Recommendation

Add round number validation to the bootstrap bypass path to prevent regression:

```csharp
// In ValidateBeforeExecution method, after line 43:
if (result) {
    // Still validate critical invariants during bootstrap
    if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) {
        if (baseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber) {
            return new ValidationResult { 
                Success = false, 
                Message = "Invalid round number progression during bootstrap." 
            };
        }
    }
    return new ValidationResult { Success = true };
}
```

Alternatively, modify `TryToUpdateRoundNumber` to remove the special case for round 1:

```csharp
private bool TryToUpdateRoundNumber(long roundNumber)
{
    var oldRoundNumber = State.CurrentRoundNumber.Value;
    // Remove special case - always validate progression
    if (oldRoundNumber != 0 && oldRoundNumber + 1 != roundNumber) return false;
    State.CurrentRoundNumber.Value = roundNumber;
    return true;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RoundNumberResetVulnerability_BootstrapBypass()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = GenerateInitialMiners(3);
    await InitializeConsensus(initialMiners);
    
    // Setup: Only first miner produces blocks (bootstrap condition)
    var maliciousMiner = initialMiners[0];
    
    // Progress to round 2 normally
    await ProduceNormalBlocks(maliciousMiner, roundCount: 1);
    var currentRound = await GetCurrentRoundNumber();
    Assert.Equal(2, currentRound); // Now at round 2
    
    // Attack: Craft malicious NextRound with RoundNumber = 1
    var maliciousNextRound = new NextRoundInput {
        RoundNumber = 1,  // Regression to round 1
        // ... populate other fields ...
    };
    
    // Exploit: Call NextRound within bootstrap window (block < 24)
    Assert.True(await GetCurrentHeight() < 24); // Verify still in bootstrap
    await maliciousMiner.SendTransaction(
        nameof(NextRound), 
        maliciousNextRound
    );
    
    // Verify: Round number reset to 1 (vulnerability confirmed)
    var attackedRound = await GetCurrentRoundNumber();
    Assert.Equal(1, attackedRound); // SUCCESS: Round regressed to 1
    
    // Verify: Wrong strategy selected
    var command = await GetConsensusCommand(maliciousMiner.PublicKey);
    var hint = AElfConsensusHint.Parser.ParseFrom(command.Hint);
    Assert.False(hint.RoundId > 0); // FirstRoundCommandStrategy omits RoundId
    
    // Impact: When other miners join after block 24, consensus is broken
    await AdvanceToBlock(25);
    var otherMiner = initialMiners[1];
    var syncResult = await otherMiner.TrySync();
    Assert.False(syncResult.Success); // Consensus disagreement
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L23-43)
```csharp
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-90)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L28-30)
```csharp
        if (currentRound.RoundNumber == 1 && behaviour == AElfConsensusBehaviour.UpdateValue)
            return new ConsensusCommandProvider(new FirstRoundCommandStrategy(currentRound, pubkey,
                currentBlockTime, behaviour)).GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/FirstRoundCommandStrategy.cs (L31-47)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var miningInterval = MiningInterval;
            var offset =
                _consensusBehaviour == AElfConsensusBehaviour.UpdateValue && Order == 1
                    ? miningInterval
                    : Order.Add(MinersCount).Sub(1).Mul(miningInterval);
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeMiningTimeWithOffset(CurrentBlockTime, offset);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint { Behaviour = _consensusBehaviour }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(miningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L23-41)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeNormalBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);

            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                {
                    Behaviour = AElfConsensusBehaviour.UpdateValue,
                    RoundId = CurrentRound.RoundId,
                    PreviousRoundId = _previousRoundId
                }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                // Cancel mining after time slot of current miner because of the task queue.
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
