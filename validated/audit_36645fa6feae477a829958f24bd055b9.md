# Audit Report

## Title
Lexicographic Backup Selection Allows Malicious Miners to Persist Without Voting Support

## Summary
The `GetVictories()` function in the Election contract uses arbitrary lexicographic ordering to select backup miners when valid candidates are insufficient, enabling attackers to game the selection mechanism through vanity public key generation and maintain mining privileges indefinitely during candidate shortages without community voting support.

## Finding Description

The vulnerability exists in the backup selection logic of the Election contract's `GetVictories()` method. When the number of valid candidates (those with `ObtainedActiveVotedVotesAmount > 0`) is less than the required `MinersCount`, the function fills the gap by selecting backups from current miners and initial miners using purely lexicographic ordering. [1](#0-0) 

The backup selection creates a pool from current miners not in valid candidates, plus initial miners, then sorts this pool lexicographically and takes the first `diff` entries. This breaks the fundamental security guarantee that miners should be selected based on community voting support.

**Why This Breaks Security Guarantees:**

1. **No Merit-Based Selection**: Unlike the normal path which orders candidates by `ObtainedActiveVotedVotesAmount`, backup selection uses arbitrary string ordering with no correlation to miner quality or community support. [2](#0-1) 

2. **Missing Ban Checks**: The backup selection path does not check `State.BannedPubkeyMap`, creating an inconsistency with `GetMinerReplacementInformation` which explicitly filters banned pubkeys when selecting replacement miners. [3](#0-2) 

3. **Valid Candidate Threshold**: Valid candidates only need votes greater than zero with no meaningful minimum threshold. [4](#0-3) 

**Execution Path:**

The consensus contract calls `GetVictories()` during term transitions via `TryToGetVictories()` to determine the new miner list, which then becomes the `currentMiners` for the next term. [5](#0-4) [6](#0-5) 

**Attack Scenario:**

1. Attacker generates a vanity public key with low lexicographic value (e.g., starting with "0000...") - requires ~65k keypair generations for 4 leading zeros
2. Attacker locks the required 100,000 ELF and announces candidacy [7](#0-6) [8](#0-7) 

3. Attacker obtains enough votes to be elected once, entering the current miner list
4. After being elected, attacker's voting support drops to zero (no longer a valid candidate)
5. When a candidate shortage occurs (`diff > 0`), `GetVictories()` selects the attacker as a backup due to their low-sorting pubkey
6. Attacker is included in the new term's miner list and continues earning mining rewards
7. This cycle repeats as long as candidate shortages persist, creating a circular dependency where attackers remain in `currentMiners` and get selected as backups

## Impact Explanation

**Direct Harms:**

1. **Reward Misallocation**: Attackers continue earning block production rewards and transaction fees without maintaining community voting support. Mining rewards over multiple terms can far exceed the 100,000 ELF lock requirement, making this attack profitable.

2. **Consensus Integrity Compromise**: Miners without community backing remain in the consensus set, enabling potential censorship attacks, transaction filtering, or collusion with other similarly-positioned miners to control block production during shortage periods.

3. **Democratic Subversion**: The Election contract's fundamental purpose is to enable token holders to vote for miners. This vulnerability completely bypasses that mechanism during shortage periods, allowing miners to persist based on an arbitrary technical detail (lexicographic ordering) rather than community support.

**Severity: HIGH** because it:
- Directly compromises the vote-based miner selection mechanism that is core to AElf's consensus
- Enables persistent control during candidate shortages
- Amplifies with multiple colluding attackers using coordinated low-sorting pubkeys
- Has no detection or removal mechanism once established
- Cannot be mitigated by governance without code changes
- Shows clear inconsistency with ban checking in `GetMinerReplacementInformation`

## Likelihood Explanation

**Attacker Capabilities Required:**

1. **Vanity Pubkey Generation** (Low Complexity): Generating public keys with low lexicographic values is computationally feasible. Finding a pubkey starting with four zeros requires approximately 16^4 = 65,536 keypair generations on average, which is trivial with modern hardware.

2. **Initial Election** (Medium Complexity): The main barrier is getting elected at least once, which requires:
   - Locking 100,000 ELF per candidate
   - Obtaining enough votes to be in the top N candidates initially
   - Can be achieved through vote buying, building legitimate reputation then acting maliciously, or Sybil attacks

3. **Vote Manipulation** (Low Complexity): After initial election, attacker can simply let voting support drop, knowing they'll be selected as backup during shortages.

**Feasibility Conditions:**

- **Candidate Shortage** (`diff > 0`): More likely in new chains, ecosystems with low participation, or after mass candidate exodus
- **Attacker Persistence**: Attacker must remain in current miner list (achieved via initial election and circular backup selection)
- **Attack Amplification**: Multiple colluding attackers with low-sorting pubkeys amplify impact

**Probability: MEDIUM** because:
- Initial election barrier is non-trivial (requires significant capital and votes)
- Candidate shortages may not be common in mature, healthy ecosystems
- However, when shortage conditions occur, exploitation is straightforward
- The vulnerability is exploitable in new/struggling chains where shortages are more likely

## Recommendation

Implement merit-based backup selection that respects voting support and applies consistent ban checking:

1. **Add Ban Checks**: Apply `State.BannedPubkeyMap` filtering in the backup selection path, consistent with `GetMinerReplacementInformation`

2. **Vote-Based Backup Selection**: Instead of lexicographic ordering, select backups based on their previous term voting support or other merit-based criteria

3. **Minimum Vote Threshold**: Require a meaningful minimum vote threshold for miners to be eligible as backups, not just `> 0`

4. **Backup Selection from Previous Term Snapshot**: Use the previous term's election snapshot to select backups based on vote counts, rather than arbitrary ordering

Example fix for the backup selection logic:
```csharp
// Apply ban check
var backups = currentMiners
    .Where(k => !validCandidates.Contains(k))
    .Where(k => !State.BannedPubkeyMap[k])
    .ToList();

// Add initial miners with ban check
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value.Select(k => k.ToHex())
            .Where(k => !backups.Contains(k))
            .Where(k => !State.BannedPubkeyMap[k]));

// Order by previous term votes instead of lexicographic
victories.AddRange(backups
    .OrderByDescending(p => GetPreviousTermVotes(p))
    .Take(Math.Min(diff, currentMiners.Count))
    .Select(v => ByteStringHelper.FromHexString(v)));
```

## Proof of Concept

A proof of concept would involve:

1. Setting up a test network with minimal miners (e.g., 5 required)
2. Creating a candidate with a vanity pubkey (e.g., "00000abc...")
3. Getting the candidate elected once with sufficient votes
4. Allowing votes to drop to zero
5. Creating a candidate shortage scenario (only 3 valid candidates with votes > 0)
6. Triggering a term transition
7. Verifying the attacker with the vanity pubkey is selected as a backup despite having zero votes
8. Verifying this persists across multiple terms as long as the shortage continues

The test would demonstrate that lexicographic ordering (not vote-based selection) determines backup miners, and that banned pubkey checks are not applied in this path.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-50)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L60-76)
```csharp
        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```
