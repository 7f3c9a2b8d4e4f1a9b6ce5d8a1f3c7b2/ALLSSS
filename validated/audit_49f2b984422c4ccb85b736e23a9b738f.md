# Audit Report

## Title
Banned Candidates Can Become Miners Through Incomplete Duplicate Prevention in Snapshot Processing

## Summary
The `GetPreviousTermSnapshotWithNewestPubkey()` function in the Election Contract contains a flawed duplicate prevention check that fails to remove banned candidates when multiple banned pubkeys resolve to the same newest pubkey through replacement chains. This allows banned candidates to remain in election snapshots and subsequently be selected as alternative miners by the consensus contract, violating consensus security guarantees.

## Finding Description

The vulnerability exists in the snapshot processing logic where banned candidates are replaced with their newest pubkeys. When processing replacement chains, the duplicate prevention check causes incomplete removal of banned candidates. [1](#0-0) 

The flaw occurs when multiple banned candidates (e.g., A and B) resolve to the same newest pubkey C:

**Processing banned candidate A:**
- `GetNewestPubkey(A)` returns C
- Check `snapshot.ElectionResult.ContainsKey(C)` returns false
- C is added with A's votes, A is removed ✓

**Processing banned candidate B:**
- `GetNewestPubkey(B)` also returns C  
- Check `snapshot.ElectionResult.ContainsKey(C)` returns **true** (C was just added)
- Execution hits `continue` statement at line 154
- **Line 157 removal is never executed - B remains in snapshot** ✗

The replacement chain is established through `PerformReplacement`: [2](#0-1) 

Both old and new pubkeys in replacement chains are marked as banned: [3](#0-2) 

The `GetNewestPubkey` helper correctly resolves pubkeys through replacement chains: [4](#0-3) 

However, `GetMinerReplacementInformation` does **not** filter banned pubkeys from the snapshot - it only checks banned status for fallback initial miners: [5](#0-4) 

The consensus contract then directly uses these alternative candidates without validating their banned status: [6](#0-5) 

## Impact Explanation

This vulnerability allows banned candidates—potentially marked as evil nodes—to become active miners and participate in block production. The impact is severe:

**Consensus Security Breach**: Candidates banned for malicious behavior (via `UpdateCandidateInformation` with `IsEvilNode=true`) can regain miner status and continue attacking the network.

**Reward Misallocation**: Banned candidates receive mining rewards they are not entitled to, diluting rewards for legitimate miners.

**Protocol Integrity**: Undermines the fundamental security mechanism designed to remove compromised or misbehaving nodes from the active miner set.

The banned status check exists and is correctly enforced elsewhere: [7](#0-6) 

But this protection is bypassed in the snapshot processing path, allowing banned candidates to slip through when they share a newest pubkey with another banned candidate.

## Likelihood Explanation

This vulnerability has **Medium to High** likelihood of occurrence:

**Attack Complexity**: Low. Replacement chains occur naturally during normal operations when candidates rotate keys for security or administrative purposes.

**Preconditions Required**:
1. Multiple candidates whose replacement chains converge to the same newest pubkey
2. A snapshot taken containing these candidates
3. Snapshot processing via `GetPreviousTermSnapshotWithNewestPubkey`

**Attacker Capabilities**: No special privileges required. Any candidate admin can call the public `ReplaceCandidatePubkey` method: [8](#0-7) 

**Economic Rationale**: Cost is minimal (standard transaction fees), while potential gains include mining rewards and ability to influence consensus decisions.

The vulnerability is particularly concerning because it can be triggered unintentionally through legitimate key rotation practices, meaning no malicious intent is required for the security breach to occur.

## Recommendation

Add a banned status check when filtering alternative candidates in `GetMinerReplacementInformation`. Modify the snapshot filtering logic to exclude banned candidates:

```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    // Except initial miners.
    .Where(cs => !State.InitialMiners.Value.Value.Contains(...))
    // Except current miners.
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    // ADD: Except banned candidates
    .Where(cs => !State.BannedPubkeyMap[cs.Key])
    .OrderByDescending(s => s.Value).ToList();
```

Alternatively, fix the duplicate prevention logic in `GetPreviousTermSnapshotWithNewestPubkey` to always remove banned candidates regardless of whether their newest pubkey already exists:

```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    
    // Always remove the banned candidate
    if (snapshot.ElectionResult.ContainsKey(bannedCandidate))
        snapshot.ElectionResult.Remove(bannedCandidate);
    
    // Add newest pubkey only if valid and not duplicate
    if (newestPubkey != null && newestPubkey != bannedCandidate && 
        !snapshot.ElectionResult.ContainsKey(newestPubkey))
    {
        var electionResult = snapshot.ElectionResult[bannedCandidate];
        snapshot.ElectionResult.Add(newestPubkey, electionResult);
    }
}
```

## Proof of Concept

```csharp
// Test scenario demonstrating the vulnerability
public async Task BannedCandidateBecomesMiners_ThroughDuplicatePrevention()
{
    // Setup: Two initial miners A and B
    var minerA_InitialPubkey = "pubkeyA";
    var minerB_InitialPubkey = "pubkeyB";
    var commonReplacementPubkey = "pubkeyC";
    
    // 1. Take snapshot with both A and B having votes
    await ElectionContract.TakeSnapshot(new TakeElectionSnapshotInput 
    { 
        TermNumber = 1,
        MinedBlocks = 100,
        RoundNumber = 10 
    });
    
    // 2. Miner A replaces their pubkey with C
    await ElectionContract.ReplaceCandidatePubkey(new ReplaceCandidatePubkeyInput 
    {
        OldPubkey = minerA_InitialPubkey,
        NewPubkey = commonReplacementPubkey
    });
    // A is now banned, C is active
    
    // 3. Miner B also replaces their pubkey with C (if possible via initial miners)
    await ElectionContract.ReplaceCandidatePubkey(new ReplaceCandidatePubkeyInput 
    {
        OldPubkey = minerB_InitialPubkey,
        NewPubkey = commonReplacementPubkey
    });
    // B is now banned, C is still active
    
    // 4. Call GetMinerReplacementInformation
    var replacementInfo = await ElectionContract.GetMinerReplacementInformation.CallAsync(
        new GetMinerReplacementInformationInput 
        {
            CurrentMinerList = { "pubkeyD", "pubkeyE" } // Some other miners
        });
    
    // 5. Verify: B should NOT be in alternative candidates but it is
    Assert.Contains(minerB_InitialPubkey, replacementInfo.AlternativeCandidatePubkeys);
    // This proves B (banned) can be selected as an alternative miner
    
    // 6. Verify B is indeed banned
    var isBanned = await ElectionContract.IsPubkeyBanned.CallAsync(
        new StringValue { Value = minerB_InitialPubkey });
    Assert.True(isBanned);
    
    // Vulnerability confirmed: Banned candidate B is in alternative candidates list
}
```

## Notes

The vulnerability requires that multiple banned pubkeys resolve to the same newest pubkey. This can occur when:
- An initial miner A replaces with pubkey C (C not added to Candidates list)
- A regular candidate B also replaces with pubkey C (C now in Candidates list)
- Both A and B are banned, both resolve to C via `GetNewestPubkey`
- Snapshot processing fails to remove B due to duplicate prevention check

The issue demonstrates a critical gap in the consensus security model where banned status verification is inconsistently applied across different code paths.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L149-158)
```csharp
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-391)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-291)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-342)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```
