# Audit Report

## Title
Predictable NFT Symbol Generation Enables Selective Participation Attack

## Summary
The NFT contract's `GenerateSymbolNumber()` function uses the previous block's random hash as entropy, which is publicly readable before transactions execute. Combined with the attacker-controlled `Context.Sender` value, this allows attackers to predict their exact symbol number offline and selectively submit Create transactions only when obtaining desirable vanity symbols (e.g., "AR888888", "AR123456").

## Finding Description

The vulnerability exists in the NFT protocol symbol generation mechanism. When creating an NFT protocol via the `Create` method, the system generates a unique symbol by combining a type prefix with a random number. [1](#0-0) 

The symbol generation calls `GenerateSymbolNumber()` which retrieves random bytes from the consensus contract using the previous block height: [2](#0-1) 

The `GetRandomBytes` method is a view method that only reads blockchain state without modifying it: [3](#0-2) 

The random hashes are stored during block production and become publicly readable after the block is finalized: [4](#0-3) 

The critical flaw is that the random hash combines the sender's address (attacker-controlled) with the publicly readable random bytes. The do-while loop at lines 79-82 only prevents duplicate symbols, not predictability.

**Attack Execution:**
1. After block H-1 is finalized, `State.RandomHashes[H-1]` becomes publicly readable via `GetRandomBytes(H-1)`
2. Attacker computes offline: `Hash(Hash(AttackerAddress) + RandomBytes[H-1])`  
3. Attacker converts this to a symbol number using the same `ConvertHashToInt64` logic
4. If the resulting symbol is desirable (e.g., "AR888888"), submit `Create` transaction in block H
5. If undesirable, skip and wait for the next block to try again

Since attackers control their own address and can read the previous block's random hash, they have complete predictability before submitting any transaction.

## Impact Explanation

**Protocol Fairness Violation**: The NFT protocol's design assumes unpredictable, fair symbol allocation. This vulnerability fundamentally breaks that assumption, allowing sophisticated actors to systematically game the system.

**Economic Value Extraction**: NFT symbols with desirable patterns (repeating digits, sequential numbers, palindromes) carry significant market value, similar to premium domain names or vanity cryptocurrency addresses. Attackers can:
- Monopolize premium symbols over time through selective participation
- Create artificial scarcity by accumulating valuable symbols
- Extract value from legitimate creators who must accept randomly assigned symbols
- Potentially resell accumulated premium symbols at inflated prices

**Ecosystem Trust Impact**: The attack is completely undetectable to normal users who assume symbol allocation is random and fair. When premium symbols consistently go to the same sophisticated actors, it undermines trust in the NFT protocol's integrity.

**Severity Assessment**: This represents a protocol integrity violation with real economic consequences. While it does not directly steal funds, break consensus, or inflate token supply, it enables systematic value extraction and violates core fairness assumptions of the NFT symbol allocation mechanism.

## Likelihood Explanation

**Attack Complexity: LOW**
- Requires only standard blockchain query capabilities (view method calls)
- Standard cryptographic hash computation (available in any programming environment)  
- Basic transaction submission capability
- No special node setup or modified client software needed

**Attacker Requirements:**
- No privileged access or special permissions required
- No need to compromise any systems
- Can be fully automated with simple scripts (< 100 lines of code)
- Economic cost is minimal (only pay transaction fees for desirable symbols, skip the rest)
- Can use multiple addresses to avoid detection patterns

**Practical Execution Steps:**
1. Monitor blockchain for new blocks (standard node query)
2. For each finalized block H-1, call `GetRandomBytes(H-1)` (free view method call)
3. Compute predicted symbol for attacker's address using same hash logic as contract
4. Evaluate if symbol meets desirability criteria (e.g., contains repeating digits)
5. Submit `Create` transaction only if symbol is valuable
6. Repeat for every block indefinitely

**Detection Difficulty**: The attack is completely indistinguishable from normal legitimate usage since attackers submit valid `Create` transactions through standard means. Multiple addresses can be rotated to avoid any statistical pattern detection.

**Likelihood: HIGH** - The attack is practical, profitable, fully automatable, requires no special privileges, and is undetectable through normal monitoring.

## Recommendation

**Mitigation Strategy**: Introduce unpredictable entropy that cannot be known before transaction execution.

**Option 1: Transaction-Dependent Entropy**
Incorporate transaction-specific data that is only finalized during block execution:
```
var randomHash = HashHelper.ConcatAndCompute(
    HashHelper.ComputeFrom(Context.Sender),
    HashHelper.ComputeFrom(randomBytes),
    HashHelper.ComputeFrom(Context.TransactionId)  // Add transaction hash
);
```

**Option 2: Current Block Height**
Use the current block's random hash instead of the previous block:
```
var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
{
    Value = Context.CurrentHeight  // Current block instead of CurrentHeight-1
}.ToBytesValue());
```
Note: This requires the random hash to be available during transaction execution in the current block.

**Option 3: Commit-Reveal Scheme**
Implement a two-step process where users commit to creating an NFT protocol in one transaction, and the symbol is revealed in a subsequent transaction after additional entropy becomes available.

The most practical solution is Option 1, which maintains the existing flow while adding unpredictable transaction-specific entropy.

## Proof of Concept

```csharp
// Attacker Script (off-chain)
public async Task<string> PredictMyNFTSymbol(string myAddress, long blockHeight)
{
    // Step 1: Query previous block's random hash (view method - no cost)
    var randomBytes = await consensusContract.GetRandomBytes(blockHeight - 1);
    
    // Step 2: Compute what MY symbol would be using same logic as contract
    var senderHash = HashHelper.ComputeFrom(Address.FromBase58(myAddress));
    var randomBytesHash = HashHelper.ComputeFrom(randomBytes);
    var combinedHash = HashHelper.ConcatAndCompute(senderHash, randomBytesHash);
    
    // Step 3: Convert to symbol number using same logic
    var symbolNumber = ConvertHashToInt64(combinedHash, from, to);
    
    // Step 4: Check if desirable (e.g., repeating digits)
    var fullSymbol = $"AR{symbolNumber}";
    
    return fullSymbol;
}

public async Task SelectivelyParticipate()
{
    while (true)
    {
        var currentHeight = await GetCurrentBlockHeight();
        var predictedSymbol = await PredictMyNFTSymbol(myAddress, currentHeight);
        
        if (IsDesirable(predictedSymbol))  // e.g., contains "888888"
        {
            // Submit Create transaction
            await nftContract.Create(createInput);
            Console.WriteLine($"Submitted for desirable symbol: {predictedSymbol}");
        }
        else
        {
            // Skip this block, wait for next
            Console.WriteLine($"Skipping undesirable symbol: {predictedSymbol}");
        }
        
        await WaitForNextBlock();
    }
}
```

**Test Case Demonstrating Predictability:**
```csharp
[Fact]
public async Task Test_SymbolPredictability()
{
    // Attacker can predict their symbol before submitting transaction
    var blockHeight = await GetCurrentBlockHeight();
    var randomBytes = await ConsensusContract.GetRandomBytes(blockHeight - 1);
    
    // Compute offline what symbol would be generated
    var predictedSymbol = ComputeSymbol(attackerAddress, randomBytes);
    
    // Now actually create the NFT protocol
    var result = await NFTContract.Create(createInput);
    var actualSymbol = result.Value;
    
    // Assert prediction matches reality
    Assert.Equal(predictedSymbol, actualSymbol);
}
```

## Notes

This vulnerability represents a **protocol fairness violation** rather than a critical security flaw like fund theft or consensus break. The severity assessment of "Medium-High" in the original report is reasonable given the economic consequences and systematic exploitation potential, though it could also be argued as "Low-Medium" depending on how one weighs fairness violations versus direct fund loss.

The core technical issue is valid and exploitable: using publicly readable blockchain state combined with attacker-controlled input as the sole source of entropy for generating economically valuable identifiers (NFT symbols) enables predictability and selective participation attacks.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-22)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L117-129)
```csharp
    public override Hash GetRandomHash(Int64Value input)
    {
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }

    public override BytesValue GetRandomBytes(BytesValue input)
    {
        var height = new Int64Value();
        height.MergeFrom(input.Value);
        return GetRandomHash(height).ToBytesValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```
