# Audit Report

## Title
Missing Validation of Term Transition State Allows Arbitrary Miner List Manipulation

## Summary
The AEDPoS consensus contract fails to validate miner list content during term transitions. When processing `NextTerm` transactions, the contract performs only numeric validation (round/term increments) without verifying that submitted miner information matches the authoritative source from election victories or current miners. This allows a malicious block producer to inject arbitrary miner lists that bypass validation and are directly committed to state, completely compromising consensus integrity.

## Finding Description

The vulnerability exists in a critical validation gap between miner list generation and validation during term transitions.

**Legitimate Generation Path:**
The contract generates legitimate miner lists through `GenerateFirstRoundOfNextTerm`, which derives miners from election victories (mainchain) or current miners (sidechain): [1](#0-0) 

**Vulnerable Execution Path:**
When `ProcessNextTerm` executes, it performs a blind conversion of the input without validating miner information content: [2](#0-1) 

The `ToRound()` method is a simple data structure conversion with no validation logic - it just copies the `RealTimeMinersInformation` field directly: [3](#0-2) 

**Insufficient Validation:**
The pre-execution validation only checks that round and term numbers increment correctly and InValues are null, but does NOT validate the actual miner list content: [4](#0-3) 

The validation pipeline for NextTerm behavior only adds `RoundTerminateValidationProvider`: [5](#0-4) 

**Direct State Commitment:**
Finally, the unvalidated miner information is extracted and directly committed to state via `SetMinerList`: [6](#0-5) 

**Attack Sequence:**
1. Malicious miner calls `GetConsensusExtraData` with NextTerm behavior to obtain legitimate Round data structure
2. Modifies `Round.RealTimeMinersInformation` dictionary to include colluding nodes and exclude legitimate elected miners
3. Creates `NextTermInput` from the modified Round using `NextTermInput.Create`
4. Submits NextTerm transaction with the malicious input during their block production slot
5. Validation passes because it only checks numeric increments, not miner list content
6. Malicious miner list is committed to state and used for all future block production

## Impact Explanation

**Critical Consensus Integrity Violation:**
- The miner schedule determines who can produce blocks - this is the foundation of consensus security
- A compromised miner list means attackers control future block production, enabling censorship, double-spending, and chain halts
- On mainchain deployments, this completely bypasses the election system where token holders vote for block producers via: [7](#0-6) 

**Concrete Harm:**
- Attacker can exclude all legitimate miners and populate the list with their own nodes
- Can manipulate mining time slots and orders to create unfair advantages
- Breaks the fundamental trust assumption that consensus follows election results
- All network participants are affected as consensus safety underpins all blockchain operations
- Enables complete network capture by a single malicious miner

This represents a HIGH severity issue as it violates the core protocol invariant that miner lists must reflect election results or authorized consensus rules.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a current block producer (member of active miner list) - verified by: [8](#0-7) 

- Must produce the specific block when term transition occurs (happens once per term, typically every few days/weeks)

**Attack Complexity: LOW**
The attack requires only basic data manipulation:
1. Call standard consensus method `GetConsensusExtraData` to get legitimate data structure
2. Modify miner list fields in memory (simple dictionary manipulation)
3. Submit modified input via standard `NextTerm` transaction

**Feasibility: HIGH**
- Any compromised or malicious miner can execute this attack
- Opportunity occurs regularly at predictable intervals (every term transition)
- No special cryptographic operations or complex exploits required
- Detection is difficult as the malicious list appears legitimate in state after commitment

**Probability Assessment:** MEDIUM-HIGH - The attack is simple to execute and any malicious miner controlling a block production slot during term transition can perform it. The only constraint is timing (must produce the NextTerm block), but this occurs predictably and the attacker has full control over the block content during their time slot.

## Recommendation

Add miner list content validation during NextTerm processing. The validation should verify that the submitted miner list matches the authoritative source:

1. **For mainchain:** Compare submitted miner list against election victories from the Election contract
2. **For sidechain:** Compare submitted miner list against current miners

Add a new validation provider `MinerListContentValidationProvider` that performs these checks:

```csharp
public class MinerListContentValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Success = true };
            
        var expectedMiners = GetExpectedMinersForNextTerm(validationContext);
        var submittedMiners = validationContext.ExtraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        if (!expectedMiners.SequenceEqual(submittedMiners))
        {
            return new ValidationResult 
            { 
                Message = "Submitted miner list does not match expected miners from election results." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Then add this provider to the validation pipeline for NextTerm in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new MinerListContentValidationProvider()); // ADD THIS
    break;
```

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_WithArbitraryMinerList_ShouldFail()
{
    // Setup: Initialize consensus with legitimate miners
    var legitimateMiners = await InitializeConsensusWithElectedMiners();
    
    // Attacker: Current miner obtains legitimate Round structure
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Behaviour = AElfConsensusBehaviour.NextTerm,
        Pubkey = ByteString.CopyFrom(legitimateMiners[0].PublicKey)
    };
    var legitimateRound = await ConsensusStub.GetConsensusExtraData.CallAsync(
        triggerInfo.ToBytesValue());
    var round = AElfConsensusHeaderInformation.Parser.ParseFrom(legitimateRound.Value).Round;
    
    // Attacker: Modifies miner list to include colluding nodes
    round.RealTimeMinersInformation.Clear();
    round.RealTimeMinersInformation["malicious_pubkey_1"] = new MinerInRound { Order = 1 };
    round.RealTimeMinersInformation["malicious_pubkey_2"] = new MinerInRound { Order = 2 };
    
    // Attacker: Creates NextTermInput with malicious miner list
    var maliciousInput = NextTermInput.Create(round, Hash.Empty.ToByteString());
    
    // Attack: Submit NextTerm transaction with arbitrary miner list
    var result = await ConsensusStub.NextTerm.SendAsync(maliciousInput);
    
    // Verify: Malicious miner list should be rejected (currently not)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("miner list");
    
    // Verify: State should not contain malicious miners
    var actualMiners = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    actualMiners.Pubkeys.Select(p => p.ToHex()).ShouldNotContain("malicious_pubkey_1");
}
```

**Note:** This test currently PASSES the transaction (demonstrating the vulnerability) when it should FAIL. After implementing the recommended fix, the test should pass with the transaction being rejected.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```
