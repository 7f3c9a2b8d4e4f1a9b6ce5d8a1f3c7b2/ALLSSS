# Audit Report

## Title
Missing Pubkey Validation in Round Transitions Allows LIB Consensus Manipulation

## Summary
The AEDPoS consensus contract fails to validate that `MinerInRound.Pubkey` field values match their dictionary keys in `RealTimeMinersInformation` during `NextRound` and `NextTerm` transitions. This allows a malicious miner to inject round data with mismatched pubkey fields, causing incorrect exclusion of miners from Last Irreversible Block (LIB) consensus calculations and breaking Byzantine Fault Tolerance guarantees.

## Finding Description

The vulnerability exists in the round transition logic where the `NextRound` method accepts external input without validating the critical invariant that dictionary keys must match their corresponding `MinerInRound.Pubkey` field values. [1](#0-0) 

When processing round transitions, the contract converts `NextRoundInput` directly to a `Round` object via the `ToRound()` method, which performs a direct copy of `RealTimeMinersInformation` without any validation: [2](#0-1) [3](#0-2) 

The validation system includes multiple providers, but **none** check whether the `Pubkey` field inside each `MinerInRound` matches its dictionary key: [4](#0-3) 

The `MiningPermissionValidationProvider` only checks if the sender exists in the dictionary **keys** of the current round, not the provided round's `Pubkey` field values: [5](#0-4) 

`NextRoundMiningOrderValidationProvider` only validates mining order counts: [6](#0-5) 

`RoundTerminateValidationProvider` only checks round numbers and InValues: [7](#0-6) 

**Critical Impact on LIB Calculation:**

When LIB is calculated, the system retrieves mined miners from the current round and queries their implied irreversible block heights from the previous round: [8](#0-7) 

The `GetMinedMiners()` method returns `MinerInRound` objects from the dictionary **values**, and `.Select(m => m.Pubkey)` extracts the `Pubkey` **field**: [9](#0-8) 

The `GetSortedImpliedIrreversibleBlockHeights()` method then filters the previous round's miners using `specificPublicKeys.Contains(i.Pubkey)`: [10](#0-9) 

If an attacker provides a `NextRoundInput` where dictionary keys are valid hex pubkeys but `MinerInRound.Pubkey` fields are empty strings or different values, the `Contains()` check will fail to match miners from the previous round, excluding **all** legitimate miners from the LIB calculation.

## Impact Explanation

**Severity: HIGH - Consensus Integrity Violation**

The Last Irreversible Block (LIB) height is a critical consensus primitive that determines transaction finality in the AEDPoS system. The LIB calculation relies on Byzantine Fault Tolerance assumptions where at least 2/3+1 of miners must agree on irreversible block heights: [11](#0-10) 

By manipulating which miners are included in the LIB calculation, an attacker can:

1. **Delay finality**: Exclude miners with higher implied irreversible block heights, preventing LIB from advancing
2. **Accelerate finality inappropriately**: Exclude miners with lower heights, causing premature finalization  
3. **Break consensus assumptions**: If more than 1/3 of miners are excluded, the Byzantine consensus requirement is violated

This undermines the fundamental security model of the blockchain by allowing a single malicious miner to manipulate consensus finality calculations, affecting all network participants depending on transaction finality, cross-chain bridges, and DApps requiring finality guarantees.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Prerequisites:**
- Must be an elected miner (achievable through staking/voting in the Election contract)
- Must be selected as extra block producer (probability 1/N where N = 17-23 miners typically)

**Attack Execution:**
Once selected as extra block producer, the attack succeeds with high certainty because:
1. No validation checks pubkey field consistency
2. The malicious round data passes all existing validation providers
3. The effect is immediate - LIB calculation breaks in the next round

The `GenerateNextRoundInformation()` method normally creates properly formed round data where keys match Pubkey fields: [12](#0-11) 

However, a malicious miner can deviate from this by submitting a custom `NextRound` transaction with malformed data. Given the 1/N probability per round and typical round durations, a determined attacker would achieve extra block producer status within hours to days, making this a practically exploitable vulnerability.

## Recommendation

Add validation to ensure dictionary keys match `MinerInRound.Pubkey` field values. Implement a new validation provider that checks this invariant:

```csharp
public class PubkeyConsistencyValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        
        foreach (var kvp in providedRound.RealTimeMinersInformation)
        {
            if (kvp.Key != kvp.Value.Pubkey)
            {
                validationResult.Message = $"Dictionary key '{kvp.Key}' does not match MinerInRound.Pubkey '{kvp.Value.Pubkey}'";
                return validationResult;
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Add this provider to the validation chain for `NextRound` and `NextTerm` behaviors in `ValidateBeforeExecution`.

## Proof of Concept

A malicious miner can craft a `NextRoundInput` where:
- Dictionary keys: `{ "04abc123..." : MinerInRound, "04def456..." : MinerInRound }`
- MinerInRound.Pubkey fields: `{ Pubkey: "", ... }` or `{ Pubkey: "malicious", ... }`

When this passes validation and is stored, the subsequent LIB calculation will:
1. Call `GetMinedMiners()` which returns miners with empty Pubkey fields
2. Call `GetSortedImpliedIrreversibleBlockHeights([])` with empty pubkeys
3. Fail to match any miners from the previous round (which have actual hex pubkeys)
4. Return an empty or insufficient list of implied irreversible heights
5. Break LIB consensus calculation, either returning 0 or incorrect height

This violates the Byzantine Fault Tolerance assumption that at least 2/3+1 miners participate in LIB determination, compromising transaction finality guarantees across the entire blockchain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```
