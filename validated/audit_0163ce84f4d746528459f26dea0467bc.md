# Audit Report

## Title
Token Issuer and Owner Modifications Never Persist to Storage

## Summary
The `ModifyTokenIssuerAndOwner()` function in the MultiToken contract modifies token issuer and owner fields in memory but fails to persist these changes to contract state. This renders the function completely non-operational, preventing any token governance transfer and potentially bricking tokens whose issuers lose access to their keys.

## Finding Description
The vulnerability exists in the `ModifyTokenIssuerAndOwner()` method where it retrieves tokenInfo from storage, modifies the Issuer and Owner fields in memory, but returns without persisting these changes. [1](#0-0) 

In AElf's contract state model, reading from `State.TokenInfos[symbol]` via `GetTokenInfo()` returns a deserialized copy. [2](#0-1)  Modifications to this copy must be explicitly written back using `SetTokenInfo(tokenInfo)`. [3](#0-2) 

The state storage documentation explicitly warns about this requirement. [4](#0-3) 

The contract consistently follows the persistence pattern in other functions:
- `Issue()` calls `SetTokenInfo()` after modifications [5](#0-4) 
- `CrossChainReceiveToken()` calls `SetTokenInfo()` after modifications [6](#0-5) 
- `SetSymbolAlias()` calls `SetTokenInfo()` after modifications [7](#0-6) 

The test suite only validates error conditions and never verifies the success case where changes should persist. [8](#0-7) 

## Impact Explanation
This vulnerability completely breaks token governance transfer capability. The `issuer` field controls who can issue additional tokens, while the `owner` field controls privileged token operations. The inability to modify these fields means:

1. **Governance DoS:** Tokens cannot transfer control after creation, blocking organizational governance scenarios where control transfer is required
2. **Bricked Tokens:** If an issuer calls this function expecting it to work (it returns success silently), then loses access to their key before discovering the change never persisted, the token becomes permanently stuck with an inaccessible issuer
3. **Silent Failure:** The function returns `Empty` with no error, making it appear successful while actually failing, leading to delayed discovery

This affects all token creators who need governance transfer capabilities, particularly in multi-sig or organizational scenarios.

## Likelihood Explanation
**Certainty: 100%** - The function never persists changes under any circumstance due to missing persistence logic.

**Reachability:** The function is a public method callable by any address that is the current token issuer for a token without an owner set - normal operational conditions.

**Detection:** The bug is silent - returns success without error, making users discover the failure only later when attempting operations with the supposedly-updated issuer/owner.

**Complexity:** Zero - simply calling the function demonstrates it doesn't work. No special attack sequence required.

## Recommendation
Add the missing `SetTokenInfo()` call before returning from `ModifyTokenIssuerAndOwner()`:

```csharp
public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
{
    Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
    Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
    Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");
    
    var tokenInfo = GetTokenInfo(input.Symbol);
    
    Assert(tokenInfo != null, "Token is not found.");
    Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
    Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
    
    tokenInfo.Issuer = input.Issuer;
    tokenInfo.Owner = input.Owner;
    
    // ADD THIS LINE TO PERSIST CHANGES:
    SetTokenInfo(tokenInfo);
    
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ModifyTokenIssuerAndOwner_DoesNotPersist_Test()
{
    // Create a token WITHOUT an owner (so modification is allowed)
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TEST",
        TokenName = "Test Token",
        TotalSupply = 1000000,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = null, // No owner set - allows modification
        IssueChainId = _chainId,
        IsBurnable = true
    });
    
    // Get token info before modification
    var tokenInfoBefore = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "TEST"
    });
    tokenInfoBefore.Issuer.ShouldBe(DefaultAddress);
    tokenInfoBefore.Owner.ShouldBeNull();
    
    // Call ModifyTokenIssuerAndOwner - should succeed
    var result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendAsync(new ModifyTokenIssuerAndOwnerInput
    {
        Symbol = "TEST",
        Issuer = User1Address,
        Owner = User2Address
    });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Get token info after modification
    var tokenInfoAfter = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "TEST"
    });
    
    // BUG: Changes were NOT persisted!
    tokenInfoAfter.Issuer.ShouldBe(DefaultAddress); // Still the old issuer!
    tokenInfoAfter.Owner.ShouldBeNull(); // Still no owner!
    // Expected: Issuer should be User1Address, Owner should be User2Address
}
```

This test demonstrates that after calling `ModifyTokenIssuerAndOwner()` successfully (transaction mines), querying the token info shows the changes were never persisted to state. The issuer and owner remain unchanged.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L160-168)
```csharp
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L617-623)
```csharp
        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L760-766)
```csharp
        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L418-422)
```csharp
    private void SetTokenInfo(TokenInfo tokenInfo)
    {
        var symbol = tokenInfo.Symbol;
        State.TokenInfos[symbol] = tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L12-16)
```csharp
    /// <summary>
    /// WARNING: Use GetTokenInfo & SetTokenInfo to operate TokenInfos
    /// due to token symbol alias feature.
    /// </summary>
    public MappedState<string, TokenInfo> TokenInfos { get; set; }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L1827-1900)
```csharp
    public async Task TokenIssuerAndOwnerModification_Test()
    {
        var result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput());
        result.TransactionResult.Error.ShouldContain("Invalid input symbol.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST"
        });
        result.TransactionResult.Error.ShouldContain("Invalid input issuer.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST",
            Issuer = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Invalid input owner.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST",
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Token is not found.");
        
        result = await TokenContractStubUser.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Only token issuer can set token issuer and owner.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Can only set token which does not have owner.");
        
        var output = await TokenContractStub.GetTokenIssuerAndOwnerModificationEnabled.CallAsync(new Empty());
        output.Value.ShouldBeTrue();
        
        result = await TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled.SendWithExceptionAsync(
            new SetTokenIssuerAndOwnerModificationEnabledInput
            {
                Enabled = false
            });
        result.TransactionResult.Error.ShouldContain("Unauthorized behavior.");
        
        var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        var proposalId = await CreateProposalAsync(TokenContractAddress,
            defaultParliament, nameof(TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled),
            new SetTokenIssuerAndOwnerModificationEnabledInput
            {
                Enabled = false
            });
        await ApproveWithMinersAsync(proposalId);
        await ParliamentContractStub.Release.SendAsync(proposalId);
        
        output = await TokenContractStub.GetTokenIssuerAndOwnerModificationEnabled.CallAsync(new Empty());
        output.Value.ShouldBeFalse();
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Set token issuer and owner disabled.");

    }
```
