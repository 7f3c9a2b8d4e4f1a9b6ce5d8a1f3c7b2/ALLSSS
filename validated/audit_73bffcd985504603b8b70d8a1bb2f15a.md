# Audit Report

## Title
Authorization Bypass in Contract Update Proposals via Context.Self Author Field

## Summary
The `AssertAuthorityByContractInfo` function contains a critical authorization logic flaw that allows any user to propose updates to contracts whose author field is set to the Genesis contract address. This affects all contracts deployed by non-whitelisted proposers, completely bypassing the intended restriction that only contract authors can propose updates.

## Finding Description

The vulnerability exists in the authorization check performed during contract update proposals. When `ProposeUpdateContract` is called, it verifies authorization by calling `AssertAuthorityByContractInfo`: [1](#0-0) 

The authorization logic is implemented as: [2](#0-1) 

**Root Cause:**

The condition `contractInfo.Author == Context.Self || address == contractInfo.Author` incorrectly checks whether the **stored author field** equals `Context.Self` (the Genesis contract address), rather than checking whether the **caller** is the Genesis contract. When a contract has `Author = Context.Self` as stored state, the first condition is ALWAYS true during execution in the Genesis contract context, regardless of who the caller is.

**The intended logic should be:**
- `address == Context.Self || address == contractInfo.Author` (caller IS Genesis OR caller IS author)

**But the actual logic is:**
- `contractInfo.Author == Context.Self || address == contractInfo.Author` (stored author IS Genesis OR caller IS author)

**How Contracts Get Author=Context.Self:**

During deployment, the author is determined by `DecideNonSystemContractAuthor`: [3](#0-2) 

When the proposer is not in the deployment controller's whitelist, this function returns `Context.Self`, causing the contract's author to be set to the Genesis contract address. This behavior is confirmed by test evidence showing contracts deployed via Parliament governance have `Author = BasicContractZeroAddress`: [4](#0-3) 

The deployment process assigns this author value: [5](#0-4) 

**Comparison with Intended Behavior:**

The system correctly rejects unauthorized update proposals for contracts with normal authors, as demonstrated in tests: [6](#0-5) 

However, this protection fails for contracts with `Author=Context.Self` because the authorization check validates the stored author field value rather than the caller's identity.

## Impact Explanation

**Authorization Bypass:**
Any user can call `ProposeUpdateContract` on contracts with `Author=Context.Self`, completely bypassing the intended author-only restriction. While governance must still approve the actual update, the proposal stage represents a critical authorization boundary that is violated.

**Affected Contracts:**
All contracts deployed when proposers were not in the deployment controller's whitelist have `Author=Context.Self` and are permanently vulnerable. This is standard operational behavior, as evidenced by test scenarios showing Parliament-governed deployments result in contracts with `Author=BasicContractZeroAddress`.

**Attack Vectors:**
1. **Governance DoS:** Attackers can flood the governance system with malicious update proposals for vulnerable contracts, consuming resources and creating confusion
2. **Loss of Author Control:** Legitimate contract authors lose exclusive control over their contract's update lifecycle
3. **Governance Exploitation:** If governance approval thresholds are weak or compromised, malicious code updates could be pushed through proposals that should never have been created
4. **Reputation Damage:** Contract owners cannot prevent unauthorized parties from proposing updates to their contracts

**Severity Justification:**
This violates the fundamental access control invariant that only contract authors should initiate update proposals for their contracts. The flaw affects an entire class of legitimately deployed contracts with no remediation possible.

## Likelihood Explanation

**Attack Requirements:**
- No special permissions required
- Any address can call the public method `ProposeUpdateContract`
- No economic barriers beyond standard transaction fees
- Target contracts exist by design in normal operations

**Attack Simplicity:**
- Single transaction exploit with no complex setup
- No race conditions or timing dependencies
- Simply call `ProposeUpdateContract` with any contract address that has `Author=Context.Self`

**Preconditions:**
- Contracts with `Author=Context.Self` are created whenever non-whitelisted proposers deploy contracts
- This is standard operational behavior encoded in the deployment logic
- The vulnerable authorization check executes on every update proposal

**Probability:**
High - The vulnerability is deterministic and affects all contracts where the proposer was not whitelisted during deployment, which is an intentional system design pattern for Parliament-governed deployments.

## Recommendation

Change the authorization check in `AssertAuthorityByContractInfo` to validate the caller's identity rather than the stored author field:

```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    Assert(address == Context.Self || address == contractInfo.Author, "No permission.");
}
```

This ensures that only the Genesis contract itself (when `address == Context.Self`) or the actual author (when `address == contractInfo.Author`) can propose updates, regardless of what value is stored in `contractInfo.Author`.

## Proof of Concept

```csharp
[Fact]
public async Task Exploit_ProposeUpdateContract_WithGenesisAuthor_Test()
{
    // Deploy a contract via Parliament governance (non-whitelisted proposer)
    // This sets Author = BasicContractZeroAddress
    var contractDeploymentInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
    };
    
    var deployedAddress = await DeployAsync(Tester, ParliamentAddress, BasicContractZeroAddress, contractDeploymentInput);
    
    // Verify the contract author is Genesis (BasicContractZeroAddress)
    var contractInfo = ContractInfo.Parser.ParseFrom(
        await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractInfo), 
            deployedAddress));
    contractInfo.Author.ShouldBe(BasicContractZeroAddress);
    
    // Now an unauthorized user can propose an update (this should fail but succeeds due to the bug)
    var unauthorizedTester = Tester.CreateNewContractTester(AnotherUserKeyPair);
    var maliciousUpdateInput = new ContractUpdateInput
    {
        Address = deployedAddress,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TestContract.BasicFunction")).Value)
    };
    
    // This SHOULD fail with "No permission." but SUCCEEDS due to the vulnerability
    var exploitResult = await unauthorizedTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeUpdateContract), 
        maliciousUpdateInput);
    
    // The vulnerability allows this to succeed
    exploitResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Proposal is created, bypassing author-only restriction
    var proposalId = ProposalCreated.Parser
        .ParseFrom(exploitResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;
    proposalId.ShouldNotBeNull(); // Proof that unauthorized proposal was created
}
```

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-184)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-322)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L248-259)
```csharp
        var creator = ContractDeployed.Parser.ParseFrom(deploymentResult.Logs[1].Indexed[0]).Author;
        creator.ShouldBe(BasicContractZeroAddress);
        var deployAddress = ContractDeployed.Parser.ParseFrom(deploymentResult.Logs[1].NonIndexed).Address;
        deployAddress.ShouldNotBeNull();

        var contractVersion = ContractDeployed.Parser.ParseFrom(deploymentResult.Logs[1].NonIndexed).Version;
        contractVersion.ShouldBe(1);
        var contractInfo = ContractInfo.Parser.ParseFrom(await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractInfo), deployAddress));
        contractInfo.Version.ShouldBe(1);
        contractInfo.Author.ShouldBe(BasicContractZeroAddress);
        contractInfo.IsUserContract.ShouldBeFalse();
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractTest.cs (L160-173)
```csharp
    [Fact]
    public async Task Update_SmartContract_WrongAuthor_Test()
    {
        var contractAddress = await Deploy_SmartContracts_Test();

        var resultUpdate = await AnotherTester.UpdateSmartContract.SendWithExceptionAsync(
            new ContractUpdateInput
            {
                Address = contractAddress,
                Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("Consensus")).Value)
            });
        resultUpdate.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        resultUpdate.TransactionResult.Error.Contains("No permission.").ShouldBeTrue();
    }
```
