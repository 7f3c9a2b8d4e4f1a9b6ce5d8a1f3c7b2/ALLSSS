# Audit Report

## Title
Scheme ID Collision Enables Denial of Service on Profit Scheme Creation

## Summary
The `GenerateSchemeId()` function generates scheme IDs using only the per-manager scheme count without including the manager's address in the hash. This allows different managers with identical scheme counts to generate the same scheme ID, enabling attackers to front-run legitimate users and permanently deny them the ability to create profit schemes.

## Finding Description

The vulnerability exists in the `GenerateSchemeId()` function where scheme IDs are generated without including the manager address in the hash input. [1](#0-0) 

When no token parameter is provided, the function determines the manager address but only uses the scheme count for ID generation. The manager-specific count is retrieved, but critically, only the numeric count value is passed to `Context.GenerateId()`, not the manager address itself.

The uniqueness check in `CreateScheme()` prevents duplicate scheme IDs globally: [2](#0-1) 

**Root Cause:** The hash generation omits the manager address, causing:
- Manager A creating their 1st scheme (count=0): `Hash(ProfitContract, 0)`
- Manager B creating their 1st scheme (count=0): `Hash(ProfitContract, 0)`
- **Result:** Identical scheme IDs → "Already exists" assertion failure → DoS

This breaks the fundamental security guarantee that each manager can independently create their own profit schemes without interference from other users.

**Comparison with other contracts:** Other AElf contracts properly include identifying information to prevent collisions:

Election contract includes candidate public key in ID generation: [3](#0-2) 

TokenHolder contract includes both scheme manager and sender addresses: [4](#0-3) 

The Profit contract is the only system contract that omits the identifying address from ID generation.

**Affected callers:** System contracts like Treasury and TokenHolder do not provide the token parameter when creating schemes: [5](#0-4) [6](#0-5) 

## Impact Explanation

**Complete Denial of Service:**
- Any attacker can permanently prevent any target user from creating profit schemes at specific scheme counts
- Once an attacker creates their Nth scheme, no other user can create their Nth scheme without using the undocumented token parameter workaround
- This breaks core functionality of the Profit contract, which is fundamental to the protocol's economics

**Who is Affected:**
- All users calling `CreateScheme` without the optional `token` field (the standard use case)
- Protocol contracts (Treasury, TokenHolder) that depend on profit scheme creation
- Any future integrations expecting reliable scheme creation

**Severity Assessment:** This is a high-impact vulnerability because:
- Complete DoS of critical economic functionality
- Affects system contracts that are core to protocol economics
- Breaks the invariant that managers can independently create schemes
- While a workaround exists via the optional token parameter, it is undocumented, not enforced, and not used by system contracts, making it an unreliable mitigation

## Likelihood Explanation

**Attack Complexity:** Very Low
- Attacker reads target's current scheme count via public view method: [7](#0-6) 
- Attacker front-runs victim's transaction by submitting their own CreateScheme with higher gas
- No special permissions required beyond standard transaction submission

**Attacker Capabilities:**
- Read any manager's scheme count from public state via `GetManagingSchemeIds`
- Monitor mempool for pending CreateScheme transactions
- Control transaction ordering via gas price (standard front-running technique)
- Cost is minimal (only gas fees for legitimate scheme creation)

**Feasibility:** Highly Practical
- Scheme counts are publicly readable on-chain
- Front-running is a well-established attack vector on blockchain systems
- Attack succeeds with 100% certainty once collision occurs
- No rate limiting or additional uniqueness enforcement exists

**Economic Constraints:** Negligible
- Attacker only pays gas fees to create their own legitimate schemes
- Can permanently DoS multiple victims with minimal investment
- No penalty mechanism exists for creating colliding scheme IDs

## Recommendation

Include the manager address in the scheme ID generation to ensure uniqueness across different managers:

```csharp
private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
{
    var manager = createSchemeInput.Manager ?? Context.Sender;
    if (createSchemeInput.Token != null)
        return Context.GenerateId(Context.Self, createSchemeInput.Token);
    var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
    // FIX: Include manager address in hash to prevent collisions
    return Context.GenerateId(Context.Self, 
        ByteArrayHelper.ConcatArrays(manager.ToByteArray(), createdSchemeCount.ToBytes(false)));
}
```

This ensures that each manager's scheme IDs are derived from both their unique address and their scheme count, preventing collisions between different managers.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeIdCollision_CausesDoS()
{
    // Setup: Two different managers (Alice and Bob)
    var aliceKeyPair = SampleECKeyPairs.KeyPairs[0];
    var bobKeyPair = SampleECKeyPairs.KeyPairs[1];
    var aliceAddress = Address.FromPublicKey(aliceKeyPair.PublicKey);
    var bobAddress = Address.FromPublicKey(bobKeyPair.PublicKey);
    
    // Alice creates her first scheme (scheme count = 0)
    var aliceResult = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true
    });
    aliceResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var aliceSchemeId = aliceResult.Output;
    
    // Bob attempts to create his first scheme (scheme count = 0)
    // This will generate the SAME scheme ID as Alice's first scheme
    var bobStub = GetProfitContractStub(bobKeyPair);
    var bobResult = await bobStub.CreateScheme.SendWithExceptionAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true
    });
    
    // Bob's transaction FAILS due to scheme ID collision
    bobResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    bobResult.TransactionResult.Error.ShouldContain("Already exists");
    
    // Verify both would have generated the same ID
    // (Both have scheme count 0, so both generate Hash(ProfitContract, 0))
}
```

**Notes:**
- This vulnerability is confirmed by code analysis across multiple files
- The comparison with Election and TokenHolder contracts demonstrates that proper ID generation patterns exist elsewhere in the codebase
- System contracts (Treasury, TokenHolder) are directly affected as they don't use the token parameter workaround
- The attack is economically viable as it only requires creating legitimate schemes to block others
- The optional token parameter exists but is undocumented and not used by system contracts, making it an insufficient mitigation

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-59)
```csharp
        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L407-411)
```csharp
        var candidateVotesCount =
            State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0;
        return Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(voteMinerInput.CandidatePubkey.GetBytes(),
                candidateVotesCount.ToBytes(false)));
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-158)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```
