# Audit Report

## Title
Auto-Distribution Break Statement Prevents Multiple Token Threshold Checks in TokenHolder Contract

## Summary
The `RegisterForProfits` function contains a `break` statement that exits the threshold checking loop after processing only the first qualifying token, preventing subsequent tokens from being evaluated and distributed even when they simultaneously meet their configured thresholds. This breaks the multi-token auto-distribution functionality.

## Finding Description

The `RegisterForProfits` function implements auto-distribution logic to automatically trigger profit distribution when token balances exceed configured thresholds. [1](#0-0) 

The critical flaw is the unconditional `break` statement at line 199. When the first token meets its threshold, the token symbol is added to `distributedInput.AmountsMap` with value 0, then the `break` immediately exits the foreach loop. All remaining thresholds are never evaluated, and subsequent qualifying tokens are excluded from the distribution. [2](#0-1) 

The `AutoDistributeThreshold` field is explicitly designed as a `map<string, int64>` to support multiple token symbols with different threshold values. [3](#0-2) 

The downstream `DistributeProfits` function in the Profit contract only processes tokens explicitly listed in the `AmountsMap` parameter. When a token symbol maps to value 0, the contract fetches and distributes the full balance of that token from the scheme's virtual address. [4](#0-3) 

Therefore, tokens not added to `AmountsMap` due to the premature loop exit will not be distributed, regardless of whether their balances exceed their configured thresholds.

## Impact Explanation

**Direct Impact**: When multiple token types accumulate in a profit scheme's virtual address and simultaneously meet their thresholds, only the first token encountered in the dictionary iteration will be auto-distributed. Other qualifying tokens remain locked in the virtual address until manual intervention.

**Affected Scenarios**:
- Multi-token profit schemes with configurations like `{"ELF": 1000, "USDT": 500, "BTC": 1}`
- When all tokens exceed their thresholds simultaneously, only one gets distributed
- Remaining tokens' profits are trapped until the scheme manager manually calls `DistributeProfits`

**Severity Justification - Medium**:
1. Funds are not permanently lost but become temporarily inaccessible through the intended auto-distribution mechanism
2. Manual intervention by the scheme manager can distribute the trapped profits
3. The issue affects core functionality of multi-token profit schemes
4. User experience is significantly degraded as expected automatic distributions fail

## Likelihood Explanation

**Reachable Entry Point**: `RegisterForProfits` is a public RPC method callable by any user. [5](#0-4) 

**Feasible Preconditions**:
1. A profit scheme created with multiple tokens in `AutoDistributeThreshold`
2. Multiple token types contributed to the scheme over time
3. Multiple tokens simultaneously exceed their configured thresholds
4. Any user calls `RegisterForProfits` to lock tokens and register

These conditions are realistic in production environments where schemes accept diverse payment tokens.

**Execution Practicality**: The bug triggers automatically during normal operation. No attacker manipulation is required - the break statement executes whenever the first qualifying token is found.

**Probability**: High for multi-token schemes. As profit schemes accumulate various token types, it's expected that multiple thresholds would be reached simultaneously, especially after periods where no distribution occurs.

## Recommendation

Remove the `break` statement to allow all qualifying tokens to be evaluated and added to the `AmountsMap`. The corrected logic should be:

```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = threshold.Key
    }).Balance;
    if (balance < threshold.Value) continue;
    if (distributedInput == null)
        distributedInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
    distributedInput.AmountsMap[threshold.Key] = 0;
    // Remove the break statement here
}
```

This ensures all tokens that meet their configured thresholds are included in the auto-distribution.

## Proof of Concept

```csharp
[Fact]
public async Task MultiToken_AutoDistribute_OnlyDistributesFirstToken_Bug()
{
    var amount = 1000L;
    var elfSymbol = "ELF";
    var junSymbol = "JUN";
    
    // Create token JUN and approve
    await StarterCreateIssueAndApproveTokenAsync(junSymbol, 1000000L, 100000L);
    
    // Create scheme with two auto-distribute thresholds
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = elfSymbol,
        AutoDistributeThreshold =
        {
            { elfSymbol, amount },
            { junSymbol, amount }
        }
    });
    
    // Contribute both tokens (both meet threshold)
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = elfSymbol
    });
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = junSymbol
    });
    
    // Register for profits - should auto-distribute BOTH tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = amount,
        SchemeManager = Starter
    });
    
    // Check profits map - BUG: only ONE token will be distributed
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    var schemeId = schemeIds.SchemeIds.First();
    var profitMap = await ProfitContractStub.GetProfitsMap.CallAsync(
        new Profit.ClaimProfitsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
    
    // Expected: 2 tokens distributed
    // Actual: Only 1 token distributed due to break statement
    profitMap.Value.Count.ShouldBe(2); // This will FAIL, proving the bug
}
```

## Notes

The bug is confirmed by examining the execution flow: the `foreach` loop at line 184 iterates through `AutoDistributeThreshold`, but the unconditional `break` at line 199 exits after the first qualifying token is found. The `DistributeProfits` function only processes tokens present in `AmountsMap`, so tokens not added due to the premature exit remain undistributed in the scheme's virtual address, breaking the intended multi-token auto-distribution feature.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L178-206)
```csharp
        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** protobuf/token_holder_contract.proto (L41-42)
```text
    rpc RegisterForProfits (RegisterForProfitsInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/token_holder_contract.proto (L69-69)
```text
    map<string, int64> auto_distribute_threshold = 3;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-446)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
```
