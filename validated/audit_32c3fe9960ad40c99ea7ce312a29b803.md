# Audit Report

## Title
Vote Persistence After Member Removal Enables Governance Manipulation

## Summary
The Association contract's `RemoveMember()` function fails to clean up existing votes on pending proposals, creating a critical inconsistency in threshold calculations. Rejection, abstention, and approval counts filter votes by current membership, but the total vote threshold calculation does not, allowing organizations to bypass `MaximalRejectionThreshold` and `MaximalAbstentionThreshold` protections by strategically removing dissenting members.

## Finding Description

The vulnerability stems from an inconsistency between how individual vote types are counted versus how total votes are counted when determining if a proposal can be released.

The `RemoveMember()` function only modifies the organization's member list without touching existing votes on pending proposals. [1](#0-0) 

When a proposal's release threshold is evaluated, the `IsProposalRejected()` method filters rejection votes by checking if voters are still in the current member list. [2](#0-1)  Similarly, `IsProposalAbstained()` filters abstention votes by current membership. [3](#0-2) 

However, the `CheckEnoughVoteAndApprovals()` method contains a critical flaw. While it correctly filters approval votes by current membership, the total vote count concatenates all vote lists without any membership filtering. [4](#0-3) 

This inconsistency enables the following attack:
1. A proposal receives votes including rejections or abstentions
2. The organization (via another proposal) calls `RemoveMember()` to remove members who voted unfavorably
3. When the original proposal's `Release()` method evaluates `IsReleaseThresholdReached()`, removed members' rejection/abstention votes no longer count against the respective maximum thresholds [5](#0-4) 
4. However, their votes still count toward the `MinimalVoteThreshold` requirement
5. The proposal can now pass despite having exceeded rejection/abstention limits

## Impact Explanation

This vulnerability completely undermines the Association contract's governance safeguards:

**Direct Governance Bypass**: Organizations can circumvent `MaximalRejectionThreshold` and `MaximalAbstentionThreshold` - two critical protections designed to prevent proposals from passing when too many members oppose or abstain. For example, with 10 members, `MinimalVoteThreshold=7`, `MaximalRejectionThreshold=2`, and `MinimalApprovalThreshold=5`, a proposal with 5 approvals and 3 rejections (8 total votes) would normally fail. By removing the 3 rejecting members, the rejection count becomes 0 while maintaining 8 total votes, allowing the proposal to pass.

**Affected Parties**: All Association organization members and stakeholders relying on Association-based governance for protocol decisions, fund management, or multi-sig operations. This includes token holders, DApp users, and any entities dependent on honest governance outcomes.

**Severity**: This is a critical governance integrity violation. The Association contract's threshold system is designed as a check-and-balance mechanism. By allowing threshold manipulation through membership changes rather than genuine consensus, the vulnerability enables minority factions to force through proposals, fundamentally breaking the governance model.

## Likelihood Explanation

**Attacker Capabilities**: The organization itself (acting through a passed proposal) has the authority to remove members. [6](#0-5)  While this requires initial consensus, once a faction gains sufficient control to pass a single member removal proposal, they can leverage this vulnerability to manipulate subsequent proposals without proper scrutiny.

**Attack Complexity**: Low to medium complexity. The attack requires:
1. Achieving enough votes to pass an initial member removal proposal
2. Timing the removal to occur after unfavorable votes are cast on target proposals
3. Subsequently releasing the manipulated proposal

**Practical Feasibility**: The attack is realistic in organizations where a faction controls slightly above `MinimalApprovalThreshold` but faces opposition. The faction can pass one removal proposal, eliminate the opposition's voting power, then pass subsequent proposals that would have failed under normal circumstances.

**Detection Challenges**: The manipulation is not immediately obvious from on-chain activity and can appear as legitimate governance operations. Only careful analysis of the timing between member removals and proposal releases would reveal the exploitation pattern.

## Recommendation

Implement one of the following fixes:

**Option 1 (Recommended)**: Filter all vote counts by current membership consistently. Modify `CheckEnoughVoteAndApprovals()` to filter the total vote count:
```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Option 2**: Clean up votes in `RemoveMember()` by removing the member from all pending proposals' vote lists.

**Option 3**: Prevent member removal if the member has pending votes on active proposals.

## Proof of Concept

```csharp
[Fact]
public async Task VotePersistenceAfterMemberRemoval_GovernanceManipulation()
{
    // Setup: Create organization with 10 members
    // Thresholds: MinimalVoteThreshold=7, MaximalRejectionThreshold=2, MinimalApprovalThreshold=5
    var organizationAddress = await CreateTestOrganization(
        memberCount: 10,
        minimalVoteThreshold: 7,
        maximalRejectionThreshold: 2,
        minimalApprovalThreshold: 5
    );
    
    // Step 1: Create proposal A (e.g., fund transfer)
    var proposalA = await CreateProposal(organizationAddress, "Transfer funds");
    
    // Step 2: Vote on proposal A: 5 approve, 3 reject (8 total)
    await ApproveProposal(proposalA, members: 0, 1, 2, 3, 4); // 5 approvals
    await RejectProposal(proposalA, members: 5, 6, 7);        // 3 rejections
    
    // Step 3: Verify proposal A cannot be released (3 rejections > 2 threshold)
    var canRelease = await CanReleaseProposal(proposalA);
    Assert.False(canRelease); // Should fail due to rejections
    
    // Step 4: Create and pass proposal B to remove the 3 rejecting members
    var proposalB = await CreateRemoveMemberProposal(organizationAddress, members: 5, 6, 7);
    await PassAndReleaseProposal(proposalB);
    
    // Step 5: Now proposal A can be released despite originally exceeding rejection threshold
    canRelease = await CanReleaseProposal(proposalA);
    Assert.True(canRelease); // VULNERABILITY: Now passes!
    
    // Verification: Rejection count is 0 (filtered), but total votes still 8
    var proposalInfo = await GetProposalInfo(proposalA);
    Assert.Equal(0, proposalInfo.RejectionCount);  // Filtered by current membership
    Assert.Equal(8, proposalInfo.TotalVotes);       // NOT filtered - includes removed members
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```
