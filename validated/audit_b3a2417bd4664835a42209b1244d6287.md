# Audit Report

## Title
Miners Lose Term Credit When Replacing Pubkey Before Term End Due to Stale Round Data

## Summary
When a miner replaces their public key via `ReplaceCandidatePubkey`, the election contract transfers their `candidateInformation` to the new pubkey and removes the old pubkey's entry. However, the consensus contract's stored round data for previous rounds retains the old pubkey. When `TakeSnapshot` is called at term end to credit miners, it retrieves pubkeys from the stored round data and attempts to update candidate information. The private `UpdateCandidateInformation` method has an early return when `candidateInformation` is null, causing miners to lose credit for terms where they successfully produced blocks.

## Finding Description

The vulnerability exists in the interaction between the pubkey replacement mechanism and the term snapshot logic. The issue arises from a data consistency problem across two contracts:

**Root Cause:**

When `ReplaceCandidatePubkey` is called in the Election contract, it transfers the candidate's information from the old pubkey to the new pubkey and explicitly removes the old pubkey's entry from state storage. [1](#0-0) 

The Election contract then notifies the consensus contract via `RecordCandidateReplacement`. However, this consensus method only updates the **current** round's `RealTimeMinersInformation`. [2](#0-1) 

Previous rounds that are already stored in state remain unchanged and continue to reference the old pubkey.

**Failure Point:**

When a term ends, the consensus contract calls `TakeSnapshot` on the Election contract. [3](#0-2) 

This method retrieves the previous term's miner list by calling `GetPreviousTermMinerPubkeyList`, which returns pubkeys directly from the stored round data. [4](#0-3) 

The `TakeSnapshot` method then iterates through these pubkeys without mapping them to their newest replacements. [5](#0-4) 

For each pubkey in this list, the private `UpdateCandidateInformation` method is called. This method has a critical early return when `candidateInformation` is null. [6](#0-5) 

Since the old pubkey's `candidateInformation` was removed during replacement, the method returns early without updating the `Terms` list (which tracks participation history) or the `ContinualAppointmentCount` (which tracks consecutive terms).

**Why Existing Protections Fail:**

The codebase includes a `GetNewestPubkey` function specifically designed to map old pubkeys to their newest replacements. [7](#0-6) [8](#0-7) 

This function is correctly used in other parts of the codebase, such as when changing vote targets. [9](#0-8) 

There's even a dedicated method `GetPreviousTermSnapshotWithNewestPubkey` that applies this mapping when retrieving snapshots for queries. [10](#0-9) 

However, the `TakeSnapshot` method does **not** call `GetNewestPubkey` before attempting to update candidate information, causing it to use the stale old pubkey instead of the current one.

## Impact Explanation

**Direct Impact:**

Miners who replace their public keys during or before a term ends lose historical credit for that term. Specifically:

1. The `Terms` list, documented as "The number of terms that the candidate is elected" becomes incomplete and no longer reflects actual participation. [11](#0-10) 

2. The `ContinualAppointmentCount`, documented as "The count of continual appointment" is not updated correctly, breaking the continuity tracking mechanism. [12](#0-11) 

**Severity Justification:**

This is a **High** severity issue because:
- It violates a fundamental invariant of the election system: that miners receive credit for terms in which they actively participated
- The `Terms` list is part of the `CandidateInformation` that voters and the ecosystem rely on to evaluate miner performance
- Historical participation records are critical for the transparency and accountability mechanisms in a DPoS system
- If any future logic uses the `Terms` list for reward calculations, eligibility checks, or reputation scoring, affected miners would be disadvantaged

**Affected Parties:**

- Miners who use the legitimate pubkey replacement feature lose their participation history
- Voters lose access to accurate candidate history when making voting decisions
- Off-chain systems, explorers, and UI applications that display miner statistics will show incorrect data
- The protocol's accountability mechanisms are undermined as miner performance cannot be accurately tracked

## Likelihood Explanation

**Trigger Conditions:**

This vulnerability triggers automatically whenever:
1. A miner calls `ReplaceCandidatePubkey` (requires only being a registered candidate with admin privileges)
2. The term ends before the miner has a chance to replace their pubkey back
3. The consensus contract calls `TakeSnapshot` to finalize the term

**Attacker Capabilities:**

The "attacker" in this case is actually any legitimate user of the pubkey replacement feature. No special privileges beyond being a registered candidate are required. The vulnerability triggers passively through the normal term-end process executed by the consensus contract.

**Probability:**

This issue has **High** likelihood because:
- The `ReplaceCandidatePubkey` feature is specifically designed for key rotation scenarios, which are a common operational requirement
- Miners may need to replace keys for security reasons (compromised keys, hardware failures, operational changes)
- There is no warning mechanism to alert users that replacing their pubkey will cause them to lose term credits
- The vulnerability occurs deterministically every time the conditions are met

## Recommendation

Modify the `TakeSnapshot` method to map old pubkeys to their newest replacements before attempting to update candidate information. Specifically, in the loop that iterates through `previousTermMinerList`, call `GetNewestPubkey` to resolve the current pubkey:

```csharp
foreach (var pubkey in previousTermMinerList)
{
    var newestPubkey = GetNewestPubkey(pubkey);
    UpdateCandidateInformation(newestPubkey, input.TermNumber, previousTermMinerList);
}
```

This follows the pattern already established in `GetPreviousTermSnapshotWithNewestPubkey` [13](#0-12)  and ensures that participation credit is attributed to the candidate's current pubkey regardless of when the replacement occurred.

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task Test_MinerLosesTermCreditAfterPubkeyReplacement()
{
    // Setup: Initialize election and make a candidate a miner for term 1
    var minerKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    await AnnounceElectionAsync(minerKeyPair, Address.FromPublicKey(candidateAdmin.PublicKey));
    
    // Miner participates in term 1 and produces blocks
    // (simulate term progression and block production)
    
    // Before term ends, miner replaces their pubkey
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var candidateAdminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerKeyPair.PublicKey.ToHex(),
        NewPubkey = newKeyPair.PublicKey.ToHex()
    });
    
    // Term 1 ends, TakeSnapshot is called
    await ConsensusContractStub.TakeSnapshot.SendAsync(new TakeElectionSnapshotInput
    {
        TermNumber = 1,
        MinedBlocks = 100,
        RoundNumber = 10
    });
    
    // Verify: New pubkey's CandidateInformation should have term 1 in Terms list
    var candidateInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = newKeyPair.PublicKey.ToHex() });
    
    // BUG: Terms list is empty because UpdateCandidateInformation was called with old pubkey
    // and returned early due to null candidateInformation
    candidateInfo.Terms.ShouldContain(1); // This will FAIL, demonstrating the bug
}
```

This test shows that after pubkey replacement and term end, the miner's participation in term 1 is not recorded in the new pubkey's `Terms` list, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-242)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L331-334)
```csharp
    public override StringValue GetNewestPubkey(StringValue input)
    {
        return new StringValue { Value = GetNewestPubkey(input.Value) };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L402-408)
```csharp
    public override Empty TakeSnapshot(TakeElectionSnapshotInput input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L430-434)
```csharp
        var previousTermMinerList =
            State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L481-492)
```csharp
    private void UpdateCandidateInformation(string pubkey, long lastTermNumber,
        List<string> previousMiners)
    {
        var candidateInformation = State.CandidateInformationMap[pubkey];
        if (candidateInformation == null) return;
        candidateInformation.Terms.Add(lastTermNumber);
        var victories = GetVictories(previousMiners);
        candidateInformation.ContinualAppointmentCount = victories.Contains(ByteStringHelper.FromHexString(pubkey))
            ? candidateInformation.ContinualAppointmentCount.Add(1)
            : 0;
        State.CandidateInformationMap[pubkey] = candidateInformation;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L464-473)
```csharp
    public override PubkeyList GetPreviousTermMinerPubkeyList(Empty input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[State.CurrentTermNumber.Value].Sub(1);
        var lastRound = State.Rounds[lastRoundNumber];
        if (lastRound == null || lastRound.RoundId == 0) return new PubkeyList();
        return new PubkeyList
        {
            Pubkeys = { lastRound.RealTimeMinersInformation.Keys }
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L63-70)
```csharp
        var oldVoteOptionPublicKey = GetNewestPubkey(votingRecord.Option);
        var oldCandidateVotes = State.CandidateVotes[oldVoteOptionPublicKey];
        oldCandidateVotes.ObtainedActiveVotingRecordIds.Remove(input.VoteId);
        oldCandidateVotes.ObtainedActiveVotedVotesAmount =
            oldCandidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        oldCandidateVotes.AllObtainedVotedVotesAmount =
            oldCandidateVotes.AllObtainedVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[oldVoteOptionPublicKey] = oldCandidateVotes;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L130-161)
```csharp
    private TermSnapshot GetPreviousTermSnapshotWithNewestPubkey()
    {
        var termNumber = State.CurrentTermNumber.Value.Sub(1);
        var snapshot = State.Snapshots[termNumber];
        if (snapshot == null) return null;
        var invalidCandidates = snapshot.ElectionResult.Where(r => r.Value <= 0).Select(r => r.Key).ToList();
        Context.LogDebug(() => $"Invalid candidates count: {invalidCandidates.Count}");
        foreach (var invalidCandidate in invalidCandidates)
        {
            Context.LogDebug(() => $"Invalid candidate detected: {invalidCandidate}");
            if (snapshot.ElectionResult.ContainsKey(invalidCandidate)) snapshot.ElectionResult.Remove(invalidCandidate);
        }

        if (!snapshot.ElectionResult.Any()) return snapshot;

        var bannedCandidates = snapshot.ElectionResult.Keys.Where(IsPubkeyBanned).ToList();
        Context.LogDebug(() => $"Banned candidates count: {bannedCandidates.Count}");
        if (!bannedCandidates.Any()) return snapshot;
        Context.LogDebug(() => "Getting snapshot and there's miner replaced during current term.");
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }

        return snapshot;
    }
```

**File:** protobuf/election_contract.proto (L368-369)
```text
    // The number of terms that the candidate is elected.
    repeated int64 terms = 2;
```

**File:** protobuf/election_contract.proto (L374-375)
```text
    // The count of continual appointment.
    int64 continual_appointment_count = 5;
```
