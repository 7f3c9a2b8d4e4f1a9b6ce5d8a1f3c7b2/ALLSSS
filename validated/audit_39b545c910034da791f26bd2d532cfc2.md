# Audit Report

## Title
Unhandled KeyNotFoundException in RecoverFromUpdateValue During Miner Replacement Causes Block Validation DoS

## Summary
The `RecoverFromUpdateValue` method lacks validation when iterating over miners from the provided round, causing an unhandled `KeyNotFoundException` when a block contains both a miner replacement transaction and UpdateValue consensus behavior. This results in block validation failure and potential consensus disruption.

## Finding Description

The vulnerability exists in the `RecoverFromUpdateValue` method which is called during post-execution consensus validation. [1](#0-0) 

While lines 10-12 verify that the block producer's pubkey exists in both rounds, the foreach loop at lines 22-30 iterates over ALL miners in `providedRound.RealTimeMinersInformation` and directly accesses `RealTimeMinersInformation[information.Key]` without checking if each key exists. [2](#0-1) 

The vulnerability is triggered when:

1. A candidate admin calls `ReplaceCandidatePubkey` to replace a miner's pubkey [3](#0-2) 

2. This triggers `PerformReplacement` which sends a message to the consensus contract [4](#0-3) 

3. The consensus contract's `RecordCandidateReplacement` method removes the old pubkey and adds the new pubkey to the current round state [5](#0-4) 

4. After block execution, `ValidateConsensusAfterExecution` is called, which invokes `RecoverFromUpdateValue` with the header's round (containing old pubkey) and the state's current round (containing new pubkey) [6](#0-5) 

5. The foreach loop throws `KeyNotFoundException` when accessing the old pubkey that no longer exists in the current round's `RealTimeMinersInformation`

The exception is thrown BEFORE the replacement detection logic at lines 103-124 can execute, preventing proper handling of the miner replacement scenario. [7](#0-6) 

## Impact Explanation

**Severity: Medium**

**Operational Impact:**
- Blocks containing both miner replacement and UpdateValue transactions fail post-execution validation with an unhandled exception
- Block validation failure causes blocks to be rejected by validators
- This can disrupt consensus operations as legitimate blocks are rejected
- The issue can occur accidentally during normal miner replacement operations, not requiring malicious intent

**Affected Components:**
- Consensus validation system
- Block production and validation pipeline
- Network validators processing blocks with replacement transactions

**Security Boundary Violated:**
The consensus validation system should gracefully handle all valid state transitions, including miner replacements. The unhandled exception violates the expectation that validation either succeeds or fails with a proper error message, not with an exception that halts processing.

**No Direct Fund Loss:**
While this doesn't directly steal funds or inflate supply, it disrupts core consensus operations which affects overall chain availability and reliability.

## Likelihood Explanation

**Probability: Medium**

**Attacker Capabilities Required:**
- Must become a candidate by calling election contract methods (publicly accessible)
- Must obtain candidate admin privileges (automatic when registering as candidate)
- Can then call `ReplaceCandidatePubkey` at any time [8](#0-7) 

**Attack Complexity:**
1. Register as a candidate (medium barrier - requires meeting candidate requirements)
2. Submit `ReplaceCandidatePubkey` transaction during an active mining period
3. If a miner includes this transaction in their block with UpdateValue behavior, validation fails
4. No special network conditions or timing requirements beyond normal block production

**Feasibility:**
- The precondition (becoming candidate admin) is achievable through normal protocol operations
- Once achieved, the attack can be triggered reliably
- The miner may unknowingly include the replacement transaction, making it possible to affect honest miners
- UpdateValue behavior is the normal consensus behavior for most blocks

**Detection Difficulty:**
- Miners can see pending replacement transactions in the mempool
- However, they may not realize that including such transactions will cause their block to fail validation
- No obvious warning or protection mechanism exists to prevent miners from including these transactions

## Recommendation

Add existence checks in the foreach loop before accessing dictionary entries:

```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    // Add existence check before accessing
    if (!RealTimeMinersInformation.ContainsKey(information.Key))
        continue;
        
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

Alternatively, move the `RecoverFromUpdateValue` call inside a try-catch block and allow the replacement detection logic to execute even when miners don't match, or restructure the validation logic to check for replacements BEFORE attempting recovery.

## Proof of Concept

```csharp
// This test demonstrates the vulnerability
[Fact]
public async Task ValidateConsensusAfterExecution_WithMinerReplacement_ThrowsKeyNotFoundException()
{
    // Step 1: Setup - Get initial miner list and current round
    var initialMiners = await GetCurrentMinersAsync();
    var targetMiner = initialMiners.First();
    
    // Step 2: Become candidate admin
    var attackerKeyPair = SampleAccount.Accounts.Skip(10).First().KeyPair;
    await BecomeCandidate(attackerKeyPair);
    
    // Step 3: Wait for target miner's block production
    // Block is created with header containing old pubkey in consensus extra data
    var block = await ProduceBlockAsync(targetMiner);
    
    // Step 4: During block execution, call ReplaceCandidatePubkey
    // This modifies state to remove old pubkey and add new pubkey
    var newKeyPair = SampleAccount.Accounts.Skip(11).First().KeyPair;
    var replacementResult = await ElectionStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = targetMiner.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
        });
    
    // Step 5: Post-execution validation is called
    // This should throw KeyNotFoundException when RecoverFromUpdateValue
    // tries to access the old pubkey that was removed from current round
    var consensusExtraData = ExtractConsensusExtraData(block.Header);
    
    // This call will throw KeyNotFoundException
    var validationResult = await ConsensusStub.ValidateConsensusAfterExecution.CallAsync(
        new BytesValue { Value = consensusExtraData });
    
    // Test passes if KeyNotFoundException is thrown
    // In production, this causes block validation failure
}
```

The test demonstrates that when a block's consensus extra data contains a miner pubkey that has been replaced during block execution, the post-execution validation throws an unhandled `KeyNotFoundException`, causing the block to be rejected.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L142-146)
```csharp
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L103-124)
```csharp
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
```
