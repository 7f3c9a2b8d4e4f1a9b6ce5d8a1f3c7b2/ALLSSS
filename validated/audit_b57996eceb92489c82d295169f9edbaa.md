# Audit Report

## Title
Consensus Takeover via Unauthorized Miner Injection During NextTerm Transition

## Summary
The `NextTerm` method in the AEDPoS consensus contract fails to validate that the proposed miner list matches the Election contract's `GetVictories` result. A malicious current miner can construct a `NextTermInput` with arbitrary miners during term transitions, completely bypassing the election mechanism and taking over consensus.

## Finding Description

The vulnerability exists in the term transition validation flow where miner list legitimacy is never verified against election results.

**Root Cause:**

The `NextTermInput.Create()` method directly copies the `RealTimeMinersInformation` from any provided `Round` object without validation, allowing arbitrary miner lists to be injected. [1](#0-0) 

**Validation Failures:**

1. **Before Execution:** The `ValidateBeforeExecution` method only adds `RoundTerminateValidationProvider` for NextTerm behavior, which only validates round and term number increments but never checks miner list legitimacy. [2](#0-1) [3](#0-2) 

2. **During Execution:** The `ProcessNextTerm` method directly updates the miner list from the input without any validation against `GetVictories`. The only authorization check is `PreCheck()`, which only verifies the sender is in the current OR previous round's miner list, not that the NEW miner list is valid. [4](#0-3) [5](#0-4) 

3. **After Execution:** The `ValidateConsensusAfterExecution` compares the block header with the current state. However, by this point, the state has already been updated with the malicious miner list by `ProcessNextTerm`, so the validation passes as both contain the same malicious data. [6](#0-5) 

**Why Existing Protections Fail:**

The Election contract's `GetVictories` method is only called in the honest code path during `GenerateFirstRoundOfNextTerm`, which is used by `GetConsensusExtraDataForNextTerm`. However, a malicious miner can bypass this entire flow by constructing their own `NextTermInput` and calling `NextTerm` directly, as the method is public and only requires basic authorization. [7](#0-6) [8](#0-7) [9](#0-8) 

The `MiningPermissionValidationProvider` only validates that the sender is in the BaseRound (current round BEFORE execution), not that the proposed new miner list is legitimate. [10](#0-9) 

## Impact Explanation

**Critical Consensus Integrity Violation:**

This vulnerability completely breaks the core security guarantee of the blockchain: that miners are elected through voting and cannot unilaterally control consensus.

**Concrete Harms:**

1. **Complete Consensus Takeover:** A malicious miner can inject themselves and accomplices into the next term's miner list while excluding all legitimately elected miners, gaining total control over block production.

2. **Perpetual Control:** Once in control, malicious miners can repeat this attack indefinitely in subsequent term transitions, maintaining permanent control of the blockchain.

3. **Election Bypass:** The entire Election contract and voting mechanism becomes meaningless, as election results are never enforced during term transitions.

4. **Economic Exploitation:** 
   - Legitimate miners lose all block rewards and transaction fees
   - Attackers capture 100% of mining rewards
   - Control over treasury release enables fund theft via the Treasury contract integration

5. **Transaction Censorship:** Malicious miners can censor any transactions, enabling double-spending attacks and targeted exclusion of users.

6. **Chain Reorganization Risk:** Complete control over consensus enables deep reorganizations and reversal of finalized transactions.

**Affected Parties:**
- All legitimately elected miners (excluded and lose rewards)
- All token holders (votes become meaningless)
- All blockchain users (subject to censorship and potential theft)
- Protocol integrity and trustworthiness

## Likelihood Explanation

**High Likelihood for Current Miners:**

**Attacker Prerequisites:**
- Must be a current miner (required to pass `PreCheck` authorization check)
- Must produce blocks during their scheduled time slot
- No additional privileges required beyond being in the current miner set

**Attack Complexity: Low**

The attack requires only:
1. Constructing a `Round` object with arbitrary miner public keys in `RealTimeMinersInformation`
2. Properly incrementing `TermNumber` and `RoundNumber` from current values
3. Creating `NextTermInput` via `NextTermInput.Create(maliciousRound, randomNumber)`
4. Submitting a `NextTerm` transaction during the term transition block
5. Including matching consensus extra data in the block header

**Feasibility:**
- **Timing:** Term transitions occur predictably at regular intervals (every `PeriodSeconds`)
- **Opportunity:** Each current miner has a 1/N chance of producing the term transition block (where N = current miner count)
- **Repeatability:** Attack can be attempted at every term transition until successful
- **Detection:** No automated detection exists; other nodes accept the malicious block as it passes all validation checks

**Success Rate:** 100% when the attacker is scheduled to produce the term transition block and properly constructs the input with correct round/term number increments.

## Recommendation

Add validation in `ProcessNextTerm` to verify the proposed miner list matches the Election contract's `GetVictories` result:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // ADDED: Validate miner list against election results
    if (State.IsMainChain.Value && TryToGetVictories(out var legitimateVictories))
    {
        var proposedMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var electedMiners = legitimateVictories.Pubkeys.Select(p => p.ToHex()).OrderBy(k => k).ToList();
        
        Assert(proposedMiners.Count == electedMiners.Count && 
               proposedMiners.SequenceEqual(electedMiners),
               "Proposed miner list does not match election results.");
    }
    
    // ... rest of existing ProcessNextTerm logic
}
```

Additionally, consider adding a validation provider specifically for miner list legitimacy that runs during `ValidateBeforeExecution` for NextTerm behavior.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up an election with legitimate candidates
2. Have a malicious current miner construct a `NextTermInput` with arbitrary miners
3. Call `NextTerm` with this malicious input during a term transition
4. Verify the malicious miners are now in the active miner list
5. Confirm legitimate election winners were excluded

The test would show that all validations pass despite the miner list not matching `GetVictories` results, proving consensus can be hijacked by any current miner.

## Notes

This vulnerability represents a fundamental consensus integrity failure. The separation between the honest consensus extra data generation path (which calls `GetVictories`) and the transaction execution path (which accepts any miner list) creates an exploitable gap. The attacker controls both the transaction input and block header content, allowing them to make both use the same malicious data and pass all consistency checks despite bypassing the election mechanism entirely.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
