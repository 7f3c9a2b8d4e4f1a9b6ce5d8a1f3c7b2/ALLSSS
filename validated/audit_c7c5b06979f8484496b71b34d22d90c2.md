# Audit Report

## Title
Reserved External Info Key Collision Enables Arbitrary Contract Execution During Token Operations

## Summary
The MultiToken contract accepts user-provided ExternalInfo during token creation without validating against reserved callback keys. Attackers can create tokens with malicious callbacks that execute automatically during transfer, lock, and unlock operations, enabling denial-of-service attacks and gas exhaustion for all token holders.

## Finding Description

The vulnerability exists in the token creation flow where user-provided ExternalInfo is accepted without validation. The `CreateToken` method directly assigns user input to the token's ExternalInfo without checking for reserved keys: [1](#0-0) 

The system defines four reserved callback keys intended for controlled use: [2](#0-1) 

A view function `GetReservedExternalInfoKeyList` exposes these keys: [3](#0-2) 

However, grep search confirms this method is never invoked for validation during token creation - it only exists as a view method and in the protobuf interface definition.

When tokens are transferred, the contract unconditionally executes any callback specified in ExternalInfo: [4](#0-3) 

Similar callback execution occurs during lock operations: [5](#0-4) 

And unlock operations: [6](#0-5) 

The CallbackInfo structure allows specifying arbitrary contract addresses and method names: [7](#0-6) 

Callbacks are invoked via `Context.SendInline()`, which creates inline transactions that execute with the calling contract's authority. [8](#0-7) 

## Impact Explanation

**Guaranteed Denial of Service (HIGH)**: An attacker can create a token with a callback that reverts (e.g., an `Assert(false, "Attack")` statement). Any user attempting to transfer, lock, or unlock this malicious token will have their transaction fail. This affects all holders of the token and is straightforward to exploit.

**Gas Exhaustion (HIGH)**: Callbacks can contain computationally expensive operations (loops, complex calculations, multiple cross-contract calls). Victims are forced to pay gas fees for attacker-controlled code execution during routine token operations.

**Event Log Pollution (MEDIUM)**: The `aelf_log_event` key allows injecting arbitrary events that appear to originate from the MultiToken contract, potentially misleading indexers, explorers, and applications that rely on event data.

**Trust Model Breakdown**: The existence of `GetReservedExternalInfoKeyList` and the "reserved" naming convention clearly indicate these keys were intended to be system-controlled, not user-settable. Allowing user-set values breaks this security boundary.

**Note on Inline Transaction Semantics**: Callbacks execute via inline transactions AFTER the parent transaction's state changes are committed. While this prevents traditional mid-execution reentrancy, callback failures still cause the entire transaction to fail, enabling DoS attacks.

## Likelihood Explanation

**Attack Prerequisites (LOW BARRIER)**:
- Attacker needs a SEED NFT to create the malicious token, obtainable through normal token creation mechanisms
- No special permissions or whitelist membership required beyond SEED ownership [9](#0-8) 

**Attack Steps**:
1. Acquire SEED NFT for desired token symbol through standard mechanisms
2. Create malicious token with ExternalInfo containing reserved callback key pointing to attacker contract
3. Distribute tokens to victims via airdrops or social engineering
4. When victims attempt to transfer/lock/unlock, callbacks execute automatically and can cause transaction failure

**No Detection or Prevention**:
- Malicious tokens are indistinguishable from legitimate ones at creation time
- No on-chain validation prevents setting reserved keys
- No mechanism exists to blacklist or disable malicious callbacks after discovery
- Token holders have no way to remove malicious callbacks from existing tokens

**High Probability**: The attack is straightforward, economically viable (low cost of SEED NFT), requires no special privileges, and is difficult to detect until exploited.

## Recommendation

Implement validation of ExternalInfo keys during token creation to prevent users from setting reserved callback keys:

```csharp
private void ValidateExternalInfo(ExternalInfo externalInfo)
{
    if (externalInfo == null || externalInfo.Value.Count == 0) return;
    
    var reservedKeys = new HashSet<string>
    {
        TokenContractConstants.TransferCallbackExternalInfoKey,
        TokenContractConstants.LockCallbackExternalInfoKey,
        TokenContractConstants.UnlockCallbackExternalInfoKey,
        TokenContractConstants.LogEventExternalInfoKey
    };
    
    foreach (var key in externalInfo.Value.Keys)
    {
        Assert(!reservedKeys.Contains(key), $"Cannot set reserved key: {key}");
    }
}
```

Call this validation in the `CreateToken` method before assigning ExternalInfo:

```csharp
private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
{
    AssertValidCreateInput(input, symbolType);
    // Add validation here
    ValidateExternalInfo(input.ExternalInfo);
    
    // ... rest of the method
}
```

Additionally, implement similar validation in `CrossChainCreateToken` to prevent malicious tokens from being created via cross-chain transfers.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousCallbackCausesDoS()
{
    // Setup: Create a malicious contract that reverts
    var maliciousContract = await DeployMaliciousContractAsync();
    
    // Step 1: Attacker acquires SEED NFT
    var seedSymbol = "SEED-1";
    var targetSymbol = "ATTACK";
    await CreateSeedNFT(seedSymbol, targetSymbol);
    
    // Step 2: Create token with malicious callback in ExternalInfo
    var externalInfo = new ExternalInfo
    {
        Value =
        {
            {
                "aelf_transfer_callback",
                $"{{\"contract_address\":\"{maliciousContract}\",\"method_name\":\"RevertAlways\"}}"
            }
        }
    };
    
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = targetSymbol,
        TokenName = "Attack Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true,
        ExternalInfo = externalInfo
    });
    
    // Step 3: Issue tokens to victim
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = targetSymbol,
        Amount = 1000,
        To = VictimAddress
    });
    
    // Step 4: Victim attempts to transfer - transaction should fail due to callback
    var result = await TokenContractStubVictim.Transfer.SendWithExceptionAsync(new TransferInput
    {
        Symbol = targetSymbol,
        Amount = 100,
        To = AnotherAddress
    });
    
    // Assert: Transaction failed due to malicious callback
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Attack"); // Error from malicious callback
}
```

## Notes

The inline transaction execution semantics in AElf differ from Ethereum's call semantics. State changes from the parent transaction are committed before inline transactions execute, so this is NOT traditional reentrancy where callbacks can manipulate mid-execution state. However, inline transaction failures still cause the parent transaction to fail, enabling the DoS attack vector described above.

The severity remains HIGH due to the guaranteed DoS impact and gas exhaustion affecting all holders of maliciously crafted tokens.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-16)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
    public const string LogEventExternalInfoKey = "aelf_log_event";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L322-335)
```csharp
    private void DealWithExternalInfoDuringLocking(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L352-365)
```csharp
    private void DealWithExternalInfoDuringUnlock(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.UnlockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.UnlockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** protobuf/token_contract.proto (L530-533)
```text
message CallbackInfo {
    aelf.Address contract_address = 1;
    string method_name = 2;
}
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L216-247)
```csharp
    private async Task ExecuteInlineTransactions(int depth, Timestamp currentBlockTime,
        ITransactionContext txContext, TieredStateCache internalStateCache,
        IChainContext internalChainContext,
        Hash originTransactionId,
        CancellationToken cancellationToken)
    {
        var trace = txContext.Trace;
        internalStateCache.Update(txContext.Trace.GetStateSets());
        foreach (var inlineTx in txContext.Trace.InlineTransactions)
        {
            var singleTxExecutingDto = new SingleTransactionExecutingDto
            {
                Depth = depth + 1,
                ChainContext = internalChainContext,
                Transaction = inlineTx,
                CurrentBlockTime = currentBlockTime,
                Origin = txContext.Origin,
                OriginTransactionId = originTransactionId
            };

            var inlineTrace = await ExecuteOneAsync(singleTxExecutingDto, cancellationToken);

            if (inlineTrace == null)
                break;
            trace.InlineTraces.Add(inlineTrace);
            if (!inlineTrace.IsSuccessful())
                // Already failed, no need to execute remaining inline transactions
                break;

            internalStateCache.Update(inlineTrace.GetStateSets());
        }
    }
```
