# Audit Report

## Title
Authorization Chain Bypass via Malicious Contract Address in MethodFeeController

## Summary
The `ChangeMethodFeeController` method across all ACS1 implementations fails to validate that the `ContractAddress` field in `AuthorityInfo` points to a legitimate governance contract (Parliament/Association/Referendum). An attacker can deploy a malicious contract implementing `ValidateOrganizationExist` that always returns true, then get a governance proposal approved to set this malicious contract as the authority. Once set, the attacker gains permanent direct control over method fees, bypassing all future governance oversight.

## Finding Description

The vulnerability exists in the validation logic of `ChangeMethodFeeController` method. When changing the method fee controller, the system validates the new authority by calling `CheckOrganizationExist`: [1](#0-0) 

The `CheckOrganizationExist` method makes a cross-contract call to the provided `ContractAddress` without validating that it corresponds to a legitimate system governance contract: [2](#0-1) 

The same vulnerable pattern exists across all ACS1 implementations: [3](#0-2) [4](#0-3) [5](#0-4) 

**Root Cause**: The code blindly trusts any contract address provided in `authorityInfo.ContractAddress` and calls its `ValidateOrganizationExist` method. There is no validation that this address is a system governance contract.

**Why Existing Protections Fail**: The system has proper validation patterns using `GetSystemContractNameToAddressMapping()` to verify system contracts, as demonstrated in other authorization contexts: [6](#0-5) [7](#0-6) 

However, this validation is NOT applied to the `ContractAddress` in `CheckOrganizationExist`. The legitimate `ValidateOrganizationExist` implementations in governance contracts simply check if an organization exists in their state: [8](#0-7) [9](#0-8) [10](#0-9) 

Any deployed contract can implement this interface and return arbitrary values.

**Execution Path**:
1. Attacker deploys malicious contract implementing `ValidateOrganizationExist` that returns `BoolValue { Value = true }` for any input
2. Attacker creates Parliament proposal to call `ChangeMethodFeeController` with `AuthorityInfo { ContractAddress = malicious_contract, OwnerAddress = attacker_address }`
3. Proposal gets approved through normal governance channels
4. Validation passes because malicious contract returns true
5. `State.MethodFeeController.Value` now points to attacker's AuthorityInfo
6. Attacker can directly call `SetMethodFee` bypassing all future governance: [11](#0-10) 

The `SetMethodFee` method only checks that the sender matches the controller's `OwnerAddress`, not that the controller itself is legitimate.

## Impact Explanation

**Authorization Chain Violation**: The vulnerability breaks the fundamental security invariant that method fee changes must go through governance approval. Once the malicious controller is set, the attacker gains permanent direct control over method fees without organizational approval.

**Concrete Harms**:
1. **Fee Manipulation**: Attacker can set arbitrary fees for any contract method - setting fees to 0 enables transaction spam/DoS attacks, or setting extremely high fees enables economic griefing of users
2. **Governance Bypass**: All future `SetMethodFee` operations bypass organizational approval, permanently breaking the governance model until another governance proposal can reclaim control
3. **System-Wide Impact**: This vulnerability affects ALL system contracts implementing ACS1, including Parliament, Association, Referendum, Token, Consensus, Treasury, Profit, TokenConverter, Election, Vote, and more - over 15 critical system contracts

**Affected Parties**: All blockchain users and the protocol's governance integrity. Method fees directly control transaction costs and network resource usage, making this a protocol-level governance capture vulnerability.

## Likelihood Explanation

**Attacker Capabilities Required**:
1. Deploy a malicious contract with simple `ValidateOrganizationExist` implementation (trivial - single method returning true)
2. Create and get approved a Parliament proposal (requires proposer whitelist access or BP status - main barrier)
3. Standard transaction execution capability

**Attack Complexity**: LOW once proposal is approved. The malicious contract implementation requires only a single method returning `BoolValue { Value = true }`.

**Feasibility Conditions**: 
- Attacker needs to convince governance to approve the controller change (primary barrier)
- However, the `AuthorityInfo` structure appears legitimate on surface inspection (has both ContractAddress and OwnerAddress populated)
- No existing validation mechanisms would flag this as suspicious during proposal review
- No automatic detection mechanism exists
- The malicious controller persists indefinitely once set, providing permanent backdoor access

**Probability Assessment**: MEDIUM likelihood. While obtaining initial proposal approval is non-trivial, the attack is technically simple, difficult to detect during standard proposal review processes, provides significant permanent backdoor value, and could be embedded within seemingly legitimate governance restructuring proposals.

## Recommendation

Add validation to verify that `ContractAddress` in `AuthorityInfo` points to a legitimate system governance contract before accepting it as a controller. The fix should be applied to `CheckOrganizationExist` or `ChangeMethodFeeController` across all ACS1 implementations:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate that ContractAddress is a known system governance contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var validGovernanceContracts = new[]
    {
        systemContracts[SmartContractConstants.ParliamentContractSystemName],
        systemContracts[SmartContractConstants.AssociationContractSystemName],
        systemContracts[SmartContractConstants.ReferendumContractSystemName]
    };
    
    Assert(validGovernanceContracts.Contains(authorityInfo.ContractAddress),
        "ContractAddress must be a valid governance contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
}
```

This ensures that only Parliament, Association, or Referendum contracts can serve as governance authorities for method fee control.

## Proof of Concept

```csharp
// Malicious contract that bypasses validation
public class MaliciousGovernanceContract : MaliciousGovernanceContractContainer.MaliciousGovernanceContractBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        // Always returns true, bypassing organization existence checks
        return new BoolValue { Value = true };
    }
}

// Test demonstrating the vulnerability
[Fact]
public async Task ChangeMethodFeeController_AcceptsMaliciousContract_Test()
{
    // 1. Deploy malicious contract
    var maliciousContractAddress = await DeployMaliciousGovernanceContract();
    
    // 2. Create proposal to change method fee controller
    var defaultOrg = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    var proposalId = await CreateProposalAsync(
        ParliamentContractAddress,
        defaultOrg,
        nameof(ParliamentContractStub.ChangeMethodFeeController),
        new AuthorityInfo
        {
            ContractAddress = maliciousContractAddress, // Malicious contract
            OwnerAddress = AttackerAddress               // Attacker's address
        });
    
    // 3. Approve and release proposal
    await ApproveWithMinersAsync(proposalId);
    var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // SUCCESS - vulnerability exploited!
    
    // 4. Verify attacker now controls method fees directly
    var controller = await ParliamentContractStub.GetMethodFeeController.CallAsync(new Empty());
    controller.ContractAddress.ShouldBe(maliciousContractAddress);
    controller.OwnerAddress.ShouldBe(AttackerAddress);
    
    // 5. Attacker can now set arbitrary fees without governance
    var setFeeResult = await AttackerParliamentStub.SetMethodFee.SendAsync(new MethodFees
    {
        MethodName = nameof(ParliamentContractStub.CreateProposal),
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 0 } } // Set to 0 for DoS
    });
    setFeeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Attacker bypasses governance!
}
```

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L41-42)
```csharp
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L98-99)
```csharp
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L218-221)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```
