# Audit Report

## Title
Election Contract Miners Count Desynchronization After MinerIncreaseInterval Change

## Summary
When `SetMinerIncreaseInterval()` modifies the miner increase interval, it fails to notify the Election contract, causing desynchronization. During the next term transition, the Election contract uses stale miners count data, resulting in an incorrect number of block producers being elected.

## Finding Description

The AEDPoS consensus contract's `SetMinerIncreaseInterval()` function updates the miner increase interval parameter but does not synchronize this change with the Election contract. [1](#0-0) 

The `GetMinersCount()` function calculates the effective miners count using the formula: `SupposedMinersCount + ((BlockchainAge / MinerIncreaseInterval) * 2)`, capped by `MaximumMinersCount`. When `MinerIncreaseInterval` decreases, the calculated miners count increases proportionally. [2](#0-1)  The constant `SupposedMinersCount` is defined as 17. [3](#0-2) 

In contrast, `SetMaximumMinersCount()` correctly notifies the Election contract immediately via `UpdateMinersCount.Send()`. [4](#0-3) 

During term transitions, the Election contract's `GetVictories()` function uses its stored `State.MinersCount.Value` to determine how many candidates to select as block producers. [5](#0-4) 

The critical timing issue occurs during term transitions. When a new term begins, `GetConsensusExtraDataForNextTerm()` is called during block generation (before execution) to prepare the consensus header. [6](#0-5) 

This calls `GenerateFirstRoundOfNextTerm()`, which retrieves candidates from the Election contract. [7](#0-6) 

The `TryToGetVictories()` method calls the Election contract's `GetVictories()`, which uses the stale `MinersCount` value. [8](#0-7) 

Only after the block is executed does `ProcessNextTerm()` update the Election contract's miners count via `UpdateMinersCountToElectionContract()`. [9](#0-8) [10](#0-9) 

However, by this point the round has already been generated with the wrong number of miners based on the stale Election contract data. The Election contract's `UpdateMinersCount()` method updates the stored value, but this happens too late. [11](#0-10) 

## Impact Explanation

**Concrete Harm to Protocol Integrity:**

When `MinerIncreaseInterval` is decreased (to accelerate miner growth), the auto-calculated count increases, but the Election contract still uses the old lower count. This causes fewer candidates to be elected as block producers than the system intends.

**Example Scenario:**
- Blockchain age: 2 years (63,072,000 seconds)
- Initial `MinerIncreaseInterval`: 31,536,000 (1 year)
- Auto-increased count: 17 + (63,072,000 / 31,536,000) * 2 = 21
- Election contract `MinersCount`: 21
- After governance reduces interval to 15,768,000 (6 months)
- New auto-increased count: 17 + (63,072,000 / 15,768,000) * 2 = 25
- Election contract still has `MinersCount`: 21
- At next term: `GetVictories()` returns only 21 candidates instead of 25

**Affected Parties:**
- Candidates ranked 22-25 who should be elected but are excluded from block production
- Voters who voted for these candidates expecting staking returns and rewards
- Network decentralization objectives are compromised with fewer active validators than intended

**Duration:** The desynchronization persists from the `SetMinerIncreaseInterval()` call until the next term transition (typically 1 day in AElf), though the incorrect miner count affects the entire subsequent term.

## Likelihood Explanation

This is not a traditional attack but an operational vulnerability triggered by legitimate governance actions. The Parliament organization (requiring 2/3 miner consensus) can call `SetMinerIncreaseInterval()`.

**Feasibility Factors:**
- `SetMinerIncreaseInterval()` is a legitimate administrative function for network policy adjustments
- No malicious intent required - the desynchronization is an unintentional side effect of normal operations
- The validation constraint only prevents increasing the interval, not decreasing it
- Term transitions happen regularly (daily on mainnet)

**Execution Practicality:** The vulnerability manifests automatically during normal protocol operation whenever `MinerIncreaseInterval` is changed between term transitions.

**Probability Assessment:** Medium - While `MinerIncreaseInterval` changes are infrequent governance decisions, they are legitimate protocol adjustments that could occur during network growth phases or when governance decides to modify validator expansion policy.

## Recommendation

Modify `SetMinerIncreaseInterval()` to immediately notify the Election contract of the change, similar to how `SetMaximumMinersCount()` operates:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    
    State.MinerIncreaseInterval.Value = input.Value;
    
    // Add synchronization with Election contract
    TryToGetCurrentRoundInformation(out var round);
    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
    {
        MinersCount = GetMinersCount(round)
    });
    
    return new Empty();
}
```

This ensures the Election contract always has the correct miners count before any term transitions occur.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Initialize the blockchain with initial `MinerIncreaseInterval` (e.g., 31,536,000 seconds)
2. Advance blockchain age to create a scenario where reducing the interval would increase miners count
3. Call `SetMinerIncreaseInterval()` with a reduced value (e.g., 15,768,000 seconds)
4. Verify Election contract's `MinersCount` is NOT updated
5. Trigger a term transition via `GetConsensusExtraDataForNextTerm()`
6. Verify the returned victories count matches the OLD (stale) count instead of the NEW calculated count
7. Verify that after `ProcessNextTerm()` executes, the Election contract is finally updated (but too late)

The test would confirm that the round is generated with an incorrect number of miners due to the timing gap between `SetMinerIncreaseInterval()` and the Election contract update.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-84)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }

    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```
