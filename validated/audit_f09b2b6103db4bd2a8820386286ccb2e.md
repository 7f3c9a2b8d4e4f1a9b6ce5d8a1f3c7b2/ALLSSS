# Audit Report

## Title
Token Alias Resolution Causes Undeclared NFT Collection Allowance Path Access in Parallel Execution

## Summary
The `TransferFrom` method fails to declare NFT collection allowance paths when invoked with token aliases, creating a critical mismatch between declared and accessed state paths. This violates AElf's ACS2 parallel execution contract by allowing undeclared state access, potentially enabling race conditions on collection-level allowances.

## Finding Description

AElf's parallel execution engine relies on the `GetResourceInfo` method (ACS2 standard) to declare all state paths that a transaction will access before execution. This enables conflict detection and proper transaction scheduling. However, a fundamental inconsistency exists when token aliases are used with NFT `TransferFrom` operations involving collection-level allowances.

**State Path Declaration Phase:**

When `TransferFrom` is invoked, `GetResourceInfo` parses the raw transaction parameters without resolving aliases. [1](#0-0) 

The method calls `AddPathForAllowance` with the unresolved symbol to determine which allowance paths to declare. [2](#0-1) 

The critical issue occurs in `GetSymbolType`, which classifies symbols based on the presence of a '-' separator. For an alias like "TP" (no separator), it returns `SymbolType.Token`. [3](#0-2) 

Since the symbol type is classified as `Token`, the conditional check evaluates to false, and the NFT collection allowance path (e.g., "TP-*") is never added to `WritePaths`. [4](#0-3) 

**Execution Phase:**

During actual execution, `TransferFrom` calls `AssertValidToken`, which invokes `GetTokenInfo` to resolve aliases. [5](#0-4) 

The `GetTokenInfo` method checks the `SymbolAliasMap` and resolves the alias to the actual NFT symbol. [6](#0-5) 

`DoTransferFrom` is then invoked with the resolved symbol and calls `GetAllowance`. [7](#0-6) 

For the resolved NFT symbol, `GetSymbolType` now correctly returns `SymbolType.Nft`, triggering access to the NFT collection allowance path. [8](#0-7) 

The collection allowance is retrieved using `GetNftCollectionAllSymbolAllowance`, which accesses the undeclared collection path. [9](#0-8) 

**Confirming the Vulnerability:**

Token aliases are officially supported and map to NFT symbols, as demonstrated in production code. [10](#0-9) 

The test suite confirms that `TransferFrom` works with aliases. [11](#0-10) 

Collection-level allowances using the wildcard notation are also supported features. [12](#0-11) 

## Impact Explanation

**Critical Parallel Execution Integrity Violation:**

This vulnerability breaks AElf's fundamental parallel execution assumption that `GetResourceInfo` accurately declares all state paths. The parallel execution engine schedules transactions based on these declarations—two transactions are considered non-conflicting if their declared paths don't overlap.

When multiple `TransferFrom` transactions using the same NFT collection alias execute concurrently:
1. Both declare paths for the alias symbol (e.g., "TP") but NOT the collection path ("TP-*")
2. The parallel scheduler sees no conflict and allows concurrent execution
3. Both transactions access the same undeclared "TP-*" allowance path
4. Without proper locking, race conditions can corrupt the allowance state

This affects all NFT collection owners, DApps, marketplaces, and multi-signature wallets that use collection-level allowances with token aliases. The vulnerability violates the ACS2 contract's core security guarantee.

## Likelihood Explanation

**HIGH Likelihood:**

1. **Public Entry Point:** `TransferFrom` is publicly callable without special privileges. [5](#0-4) 

2. **Documented Feature:** Token aliases are an officially implemented feature, not an edge case. [10](#0-9) 

3. **Natural Usage Pattern:** Users prefer short aliases over long NFT symbols, as shown in test cases where alias "TP" is used instead of "TP-31175". [13](#0-12) 

4. **No Runtime Detection:** The parallel execution service extracts resource info without runtime validation of accessed paths. [14](#0-13) 

5. **Economic Feasibility:** Exploitation requires only normal transaction fees—an attacker can deliberately create parallel conflicting transactions.

## Recommendation

Modify `AddPathForAllowance` in `TokenContract_ACS2_StatePathsProvider.cs` to resolve aliases before determining symbol type:

```csharp
private void AddPathForAllowance(ResourceInfo resourceInfo, string from, string spender, string symbol)
{
    // Resolve alias to actual symbol before classification
    var actualSymbol = GetActualTokenSymbol(symbol);
    
    resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender, actualSymbol));
    resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
        GetAllSymbolIdentifier()));
    
    var symbolType = GetSymbolType(actualSymbol); // Use resolved symbol
    if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
    {
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
            GetNftCollectionAllSymbolIdentifier(actualSymbol)));
    }
}

private string GetActualTokenSymbol(string aliasOrSymbol)
{
    if (State.TokenInfos[aliasOrSymbol] == null)
    {
        return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
    }
    return aliasOrSymbol;
}
```

Additionally, declare balance paths using the resolved symbol to ensure consistency between declaration and execution phases.

## Proof of Concept

```csharp
[Fact]
public async Task TransferFrom_With_Alias_Undeclared_Collection_Path_Test()
{
    // Setup: Create NFT collection with alias
    await CreateNftCollectionAsync(NftCollection1155WithAliasInfo);
    await CreateNftAsync(NftCollection1155WithAliasInfo.Symbol, Nft721Info);
    
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "TP-31175",
        Amount = 100,
        To = DefaultAddress
    });
    
    // Approve using collection wildcard
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Symbol = "TP-*",
        Amount = 50,
        Spender = User1Address
    });
    
    // Create TransferFrom transaction using ALIAS
    var transaction = GenerateTokenTransaction(User1Address, nameof(TokenContractStub.TransferFrom),
        new TransferFromInput
        {
            Amount = 10,
            Symbol = "TP", // Using ALIAS, not actual symbol
            From = DefaultAddress,
            To = User2Address
        });
    
    // Get declared paths
    var resourceInfo = await Acs2BaseStub.GetResourceInfo.CallAsync(transaction);
    
    // VULNERABILITY: Collection path "TP-*" is NOT in declared WritePaths
    var collectionPath = GetPath(nameof(TokenContractState.Allowances), 
        DefaultAddress.ToBase58(), User1Address.ToBase58(), "TP-*");
    
    resourceInfo.WritePaths.ShouldNotContain(p => 
        p.Path.Parts[0] == "Allowances" && 
        p.Path.Parts[3] == "TP-*");
    
    // But execution WILL access "TP-*" path (confirmed by successful transfer)
    var result = await TokenContractStubUser.TransferFrom.SendAsync(new TransferFromInput
    {
        Symbol = "TP",
        Amount = 10,
        From = DefaultAddress,
        To = User2Address
    });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify collection allowance was accessed/modified
    var allowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
    {
        Owner = DefaultAddress,
        Spender = User1Address,
        Symbol = "TP-*"
    });
    allowance.Allowance.ShouldBe(40); // 50 - 10 = 40, proving path was accessed
}
```

This test demonstrates that `GetResourceInfo` does not declare the "TP-*" collection allowance path when the alias "TP" is used, yet the execution successfully accesses and modifies this path. In a parallel execution environment with multiple such transactions, this undeclared access creates race conditions.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L40-64)
```csharp
            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L76-81)
```csharp
        var symbolType = GetSymbolType(symbol);
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
                GetNftCollectionAllSymbolIdentifier(symbol)));
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L97-116)
```csharp
    private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
        out string allowanceSymbol)
    {
        allowanceSymbol = sourceSymbol;
        var allowance = State.Allowances[from][spender][sourceSymbol];
        if (allowance >= amount) return allowance;
        var tokenType = GetSymbolType(sourceSymbol);
        if (tokenType == SymbolType.Token)
        {
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }
        else
        {
            allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
            if (allowance >= amount) return allowance;
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }

        return allowance;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L125-136)
```csharp
    private long GetNftCollectionAllSymbolAllowance(Address from, Address spender, string sourceSymbol,
        out string allowanceSymbol)
    {
        allowanceSymbol = GetNftCollectionAllSymbolIdentifier(sourceSymbol);
        return State.Allowances[from][spender][allowanceSymbol];
    }

    private string GetNftCollectionAllSymbolIdentifier(string sourceSymbol)
    {
        // "AAA-*"
        return $"{sourceSymbol.Split(TokenContractConstants.NFTSymbolSeparator)[0]}-{TokenContractConstants.AllSymbolIdentifier}";
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenAliasTests.cs (L14-52)
```csharp
    public async Task SetTokenAlias_NFTCollection_Test()
    {
        var symbols = await CreateNftCollectionAndNft();
        await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
        {
            Symbol = symbols[1],
            Alias = "TP"
        });

        {
            // Check TokenInfo of NFT Collection.
            var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
            {
                Symbol = symbols[0]
            });
            tokenInfo.ExternalInfo.Value.ContainsKey(TokenAliasExternalInfoKey);
            tokenInfo.ExternalInfo.Value[TokenAliasExternalInfoKey].ShouldBe("{\"TP-31175\":\"TP\"}");
        }

        {
            // Check TokenInfo of NFT Item.
            var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
            {
                Symbol = "TP"
            });
            tokenInfo.Symbol.ShouldBe(symbols[1]);
        }

        {
            // Check alias.
            var alias = await TokenContractStub.GetTokenAlias.CallAsync(new StringValue { Value = "TP-31175" });
            alias.Value.ShouldBe("TP");
        }

        {
            var alias = await TokenContractStub.GetSymbolByAlias.CallAsync(new StringValue { Value = "TP" });
            alias.Value.ShouldBe("TP-31175");
        }
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenAliasTests.cs (L204-238)
```csharp
    public async Task ApproveAndTransferFromViaAlias_Test()
    {
        await CreateTokenWithAlias_Test();

        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "TP-31175",
            Amount = 1,
            To = DefaultAddress
        });

        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Symbol = "TP",
            Amount = 1,
            Spender = User1Address
        });

        await TokenContractStubUser.TransferFrom.SendAsync(new TransferFromInput
        {
            Symbol = "TP",
            Amount = 1,
            From = DefaultAddress,
            To = User2Address,
        });

        {
            var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User2Address,
                Symbol = "TP"
            });
            balance.Balance.ShouldBe(1);
        }
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L572-577)
```csharp
        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Amount = 1,
            Symbol = "ABC-*",
            Spender = User1Address
        });
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L127-178)
```csharp
    private async Task<TransactionResourceInfo> GetResourcesForOneAsync(IChainContext chainContext,
        Transaction transaction, CancellationToken ct)
    {
        IExecutive executive = null;
        var address = transaction.To;

        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(chainContext, address);
            if (!executive.IsParallelizable())
                return new TransactionResourceInfo
                {
                    TransactionId = transaction.GetHash(),
                    ParallelType = ParallelType.NonParallelizable,
                    ContractHash = executive.ContractHash
                };

            var nonparallelContractCode =
                await _nonparallelContractCodeProvider.GetNonparallelContractCodeAsync(chainContext, address);
            if (nonparallelContractCode != null && nonparallelContractCode.CodeHash == executive.ContractHash)
                return new TransactionResourceInfo
                {
                    TransactionId = transaction.GetHash(),
                    ParallelType = ParallelType.NonParallelizable,
                    ContractHash = executive.ContractHash,
                    IsNonparallelContractCode = true
                };

            if (_resourceCache.TryGetValue(transaction.GetHash(), out var resourceCache) &&
                executive.ContractHash == resourceCache.ResourceInfo.ContractHash &&
                resourceCache.ResourceInfo.IsNonparallelContractCode == false)
                return resourceCache.ResourceInfo;

            var txContext = GetTransactionContext(chainContext, transaction.To, transaction.ToByteString());
            var resourceInfo = await executive.GetTransactionResourceInfoAsync(txContext, transaction.GetHash());
            // Try storing in cache here
            return resourceInfo;
        }
        catch (SmartContractFindRegistrationException)
        {
            return new TransactionResourceInfo
            {
                TransactionId = transaction.GetHash(),
                ParallelType = ParallelType.InvalidContractAddress
            };
        }
        finally
        {
            if (executive != null)
                await _smartContractExecutiveService.PutExecutiveAsync(chainContext, address, executive);
        }
    }
```
