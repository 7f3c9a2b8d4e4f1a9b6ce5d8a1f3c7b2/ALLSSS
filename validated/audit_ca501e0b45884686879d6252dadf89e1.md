# Audit Report

## Title
Arithmetic Overflow in Bancor Price Calculation Due to Unbounded Weight Ratios

## Summary
The TokenConverter contract's `GetAmountToPayFromReturn` function can overflow when computing exponential calculations for connector pairs with large weight ratios. Individual connector weights are validated to be between 0 and 1, but the ratio between paired connector weights is unbounded, allowing configurations like ResourceWeight=0.01 and NativeWeight=0.5 (ratio=50) that cause arithmetic overflow in the `Pow` function during large token purchases, rendering the connector pair unusable.

## Finding Description

The vulnerability exists in the Bancor price calculation implementation used by the TokenConverter contract. When users call the `Buy` method to purchase tokens, the contract calculates the amount to pay using `BancorHelper.GetAmountToPayFromReturn`. [1](#0-0) 

This function computes the weight ratio `y = wt / wf` without any bounds checking on the ratio itself: [2](#0-1) 

The result is then passed to `Exp(y * Ln(x))` where `Ln(x)` can approach ln(2) ≈ 0.693 when purchases approach 50% of reserves. The `Exp` function implements a 20-term Taylor series expansion that requires computing powers up to `Pow(y, 20)` for the final term: [3](#0-2) 

The `Pow` function uses binary exponentiation with repeated `A *= A` operations: [4](#0-3) 

When the exponential argument exceeds approximately 30, computing `Pow(30+, 20)` results in values exceeding `decimal.MaxValue` (≈7.9×10²⁸), causing an overflow exception.

The root cause is that connector weight validation only ensures individual weights are between 0 and 1, without validating the ratio between paired connectors: [5](#0-4) 

The `AddPairConnector` function validates both connectors individually but never checks their ratio: [6](#0-5) 

## Impact Explanation

**High Operational Severity:**

This vulnerability causes complete denial-of-service for token conversion through affected connector pairs:

1. **Unusable Connectors**: Connector pairs with weight ratios exceeding ~40-50 become completely unusable for purchases exceeding ~40% of reserves
2. **Transaction Failures**: All `Buy` transactions for affected connectors fail with `OverflowException`
3. **Liquidity Fragmentation**: Users cannot swap tokens through broken pairs, fragmenting protocol liquidity
4. **False Security**: Governance receives no warnings during connector creation, as both individual weights pass validation
5. **User Experience**: Smaller purchases may succeed while larger ones mysteriously fail, creating confusing behavior

**No Direct Fund Loss**: While no funds are directly stolen, the operational disruption is severe and affects protocol reliability.

**Affected Parties**:
- Regular users attempting legitimate token swaps
- Governance members who may unknowingly deploy broken configurations
- Protocol reputation and user trust

## Likelihood Explanation

**Medium Likelihood:**

**Preconditions**:
- ConnectorController (Parliament by default) must call `AddPairConnector` with unbalanced weights
- Example: ResourceWeight="0.01", NativeWeight="0.5" (both individually valid)

**Triggering Scenarios**:
1. **Governance Mistake**: Weight ratios like 50:1 or 100:1 might seem economically reasonable for certain token pairs without understanding the computational constraints
2. **No Warnings**: The contract provides no feedback that the configuration will fail at runtime
3. **Delayed Discovery**: The issue only manifests when users attempt purchases exceeding certain thresholds

**Execution Path**:
- Straightforward governance proposal to add connector pair
- No special contract semantics or race conditions required
- Observable through transaction failures

**Detection Difficulty**:
- Not visible until users attempt larger purchases
- Smaller trades succeed while larger ones fail
- No validation errors during connector creation

## Recommendation

Add validation in the `AddPairConnector` and `UpdateConnector` functions to enforce maximum weight ratios between paired connectors:

```csharp
private void AssertValidConnectorWeightRatio(decimal weight1, decimal weight2)
{
    // Ensure ratio doesn't exceed safe limits for exponential calculation
    // Max safe Exp argument is ~30, with Ln(x) max ~0.693, max safe ratio is ~40
    const decimal maxSafeRatio = 30m;
    var ratio = Math.Max(weight1 / weight2, weight2 / weight1);
    Assert(ratio <= maxSafeRatio, 
        $"Connector weight ratio {ratio} exceeds maximum safe ratio of {maxSafeRatio}");
}
```

Apply this validation in `AddPairConnector` after line 95 and 106, and in `UpdateConnector` when weights are modified. This prevents creation of connector pairs that would cause computational overflow during normal trading operations.

## Proof of Concept

```csharp
[Fact]
public async Task Buy_With_Large_Weight_Ratio_Causes_Overflow()
{
    // Setup: Create connector pair with large weight ratio
    var tokenSymbol = "OVERFLOW";
    await CreateTokenAsync(tokenSymbol);
    
    var pairConnector = new PairConnectorParam
    {
        ResourceConnectorSymbol = tokenSymbol,
        ResourceWeight = "0.01",  // Very small weight
        NativeWeight = "0.5",     // Large weight - ratio = 50
        NativeVirtualBalance = 1_000_000_00000000
    };
    
    // Add connector pair via governance (passes validation)
    await ExecuteProposalForParliamentTransaction(
        TokenConverterContractAddress,
        nameof(TokenConverterContractImplContainer.TokenConverterContractImplStub.AddPairConnector),
        pairConnector);
    
    // Enable connector
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 100_000_00000000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 100_000_00000000
    });
    
    // Attempt to buy ~49% of supply - this will overflow
    var buyResult = await DefaultStub.Buy.SendWithExceptionAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = 49_000_00000000  // 49% of supply
    });
    
    // Verify overflow exception occurs
    buyResult.TransactionResult.Error.ShouldContain("Overflow");
}
```

## Notes

The vulnerability stems from a validation gap where individual connector weights are properly bounded (0,1) but their ratio is unbounded. Since weight ratio directly becomes an exponent in the Bancor formula, large ratios cause exponential terms to overflow during binary exponentiation. This is a design flaw rather than an implementation bug - the mathematical constraints of the Taylor series expansion were not considered in the validation logic.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```
