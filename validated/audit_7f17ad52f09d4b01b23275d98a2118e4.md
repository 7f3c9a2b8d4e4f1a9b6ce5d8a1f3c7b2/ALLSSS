# Audit Report

## Title
Missing Miner List Validation in NextTerm Allows Malicious Miner to Monopolize Block Production

## Summary
The AEDPoS consensus contract's `NextTerm` function accepts arbitrary miner lists without validating them against the Election Contract's elected miners. A malicious current miner can submit a term transition containing only their own public key, establishing themselves as the sole block producer for the entire term, bypassing continuous block production limits and enabling complete transaction censorship.

## Finding Description

The vulnerability exists in the term transition validation and processing flow where miner list legitimacy is never verified.

**Validation Gap**: The `ValidationForNextTerm` method only validates that round and term numbers increment by 1 and that InValues are null. [1](#0-0)  It performs NO validation that the provided miner list matches elected miners from the Election Contract.

**Unvalidated Processing**: The `ProcessNextTerm` method extracts the miner list directly from `nextRound.RealTimeMinersInformation.Keys` without any cross-contract validation against `GetVictories()`. [2](#0-1)  The system blindly trusts the input-provided miner list.

**SetMinerList Accepts Without Validation**: The `SetMinerList` method only checks if a miner list was already set for the term number but performs zero validation of the miner list's legitimacy or content. [3](#0-2)  Any miner list passes as long as it's the first submission for that term.

**Continuous Blocks Bypass**: The continuous blocks validation is completely bypassed when `RealTimeMinersInformation.Count == 1`. [4](#0-3)  Once the attacker becomes the sole miner, they can produce unlimited consecutive blocks without restriction.

**Public Entry Point**: The `NextTerm` method is a public RPC endpoint [5](#0-4)  that accepts arbitrary `NextTermInput` from any caller, subject only to `PreCheck` which merely verifies the sender is a current or previous miner. [6](#0-5) 

**Correct vs. Malicious Flow**: Test code shows the INTENDED usage calls `GetVictories()` to retrieve elected miners before calling `NextTerm`. [7](#0-6)  However, the contract does not enforce this - it accepts any miner list in the input without verification.

**Attack Execution**: A malicious current miner crafts a `NextTermInput` with only their own public key in `RealTimeMinersInformation`, sets appropriate term/round numbers (current + 1), and calls `NextTerm`. The fraudulent miner list passes all validation checks and is stored as the legitimate miner set for the new term.

## Impact Explanation

**Consensus Integrity Violation**: The attacker achieves complete monopoly over block production for an entire term (typically 7 days), fundamentally breaking the distributed consensus security model which requires multiple independent validators.

**Transaction Censorship**: As the sole miner, the attacker can permanently censor any transactions including governance proposals to fix the issue, election votes to change the miner set, and any user transactions. This enables complete network-level censorship.

**Economic Theft**: The attacker captures 100% of mining rewards for the entire term while all legitimately elected miners receive nothing, constituting direct theft of protocol rewards from honest validators.

**Exclusion of Legitimate Miners**: All miners who were honestly elected through the voting process are completely removed from consensus participation despite having legitimate election mandate.

**Self-Perpetuating Attack**: The attacker controls the next term transition and can repeatedly submit fraudulent `NextTerm` transactions to maintain their monopoly indefinitely across multiple terms.

## Likelihood Explanation

**Realistic Preconditions**: The attacker must be one of the current miners, which is a realistic assumption for any compromised validator or initially honest validator who becomes malicious. No special privileges beyond normal miner status are required.

**Direct Entry Point**: The `NextTerm` method is publicly callable [8](#0-7)  with no authorization checks beyond being a current miner.

**Zero Detection**: The validation pipeline contains no checks to detect this attack. [9](#0-8)  Honest nodes will accept the malicious block as valid since it passes all implemented validation checks.

**Low Complexity**: The attack requires only (1) waiting for term transition timing, (2) crafting `NextTermInput` with correct term/round numbers and only attacker's pubkey, and (3) submitting the transaction during the attacker's time slot.

**Economic Rationality**: Attack cost is minimal (one transaction fee) while the benefit is capturing 100% of mining rewards and complete network control, making this economically rational for any profit-motivated attacker.

## Recommendation

Add miner list validation to `ValidationForNextTerm` that verifies the provided miner list matches the Election Contract's `GetVictories()` result:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // NEW: Validate miner list against Election Contract
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var providedMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var electedMiners = victories.Value.Select(v => v.ToHex()).OrderBy(k => k).ToList();
        
        if (!providedMiners.SequenceEqual(electedMiners))
            return new ValidationResult { Message = "Provided miner list does not match elected miners." };
    }

    return new ValidationResult { Success = true };
}
```

Additionally, add a defensive check in `ProcessNextTerm` before calling `SetMinerList` to validate against `GetVictories()` as a second layer of protection.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerCanMonopolizeBlockProduction()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = new[] { InitialCoreDataCenterKeyPairs[0], InitialCoreDataCenterKeyPairs[1], InitialCoreDataCenterKeyPairs[2] };
    await InitializeConsensusWithMiners(initialMiners);
    
    // Get current round and term information
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var currentTerm = await ConsensusStub.GetCurrentTermNumber.CallAsync(new Empty());
    
    // Attacker (first miner) crafts malicious NextTermInput with only themselves
    var attackerPubkey = InitialCoreDataCenterKeyPairs[0].PublicKey.ToHex();
    var maliciousNextTermInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentTerm.Value + 1,
        RealTimeMinersInformation = 
        {
            {
                attackerPubkey, new MinerInRound
                {
                    Pubkey = attackerPubkey,
                    Order = 1,
                    IsExtraBlockProducer = true,
                    ExpectedMiningTime = TimestampHelper.GetUtcNow().AddSeconds(100)
                }
            }
        }
    };
    
    // Attacker calls NextTerm with fraudulent miner list
    var attackerStub = GetConsensusContractTester(InitialCoreDataCenterKeyPairs[0]);
    var result = await attackerStub.NextTerm.SendAsync(maliciousNextTermInput);
    
    // Verify attack succeeded
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify attacker is now the only miner
    var newMinerList = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    newMinerList.Pubkeys.Count.ShouldBe(1);
    newMinerList.Pubkeys[0].ToHex().ShouldBe(attackerPubkey);
    
    // Verify legitimate miners were excluded
    var legitimateMiner1 = InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex();
    var legitimateMiner2 = InitialCoreDataCenterKeyPairs[2].PublicKey.ToHex();
    newMinerList.Pubkeys.Any(p => p.ToHex() == legitimateMiner1).ShouldBeFalse();
    newMinerList.Pubkeys.Any(p => p.ToHex() == legitimateMiner2).ShouldBeFalse();
    
    // Verify continuous blocks validation is now bypassed (Count == 1)
    var newRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.RealTimeMinersInformation.Count.ShouldBe(1);
}
```

## Notes

The vulnerability is particularly severe because:

1. **No Transaction Pool Filtering**: The code comment at line 324 of `AEDPoSContract_ProcessConsensusInformation.cs` mentions a `ConstrainedAEDPoSTransactionValidationProvider` that should prevent malicious consensus transactions, but this provider does not exist in the codebase.

2. **Protocol-Level Impact**: This is not a funds theft issue but a consensus integrity break that undermines the entire security model of the blockchain.

3. **Design vs. Implementation Gap**: The system design assumes `NextTerm` is called through the consensus command generation flow which properly queries `GetVictories()`, but the implementation allows direct calls with arbitrary miner lists.

4. **Main Chain Only**: The attack applies to main chain only, as side chains don't use the Election Contract for miner selection, but this is where the highest value and security requirements exist.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** protobuf/aedpos_contract.proto (L37-39)
```text
    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.Economic.TestBase/OtherContractsOperation.cs (L17-36)
```csharp
    protected async Task NextTerm(ECKeyPair keyPair)
    {
        var miner = GetConsensusContractTester(keyPair);
        var round = await miner.GetCurrentRoundInformation.CallAsync(new Empty());
        var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
        var miners = new MinerList
        {
            Pubkeys =
            {
                victories.Value
            }
        };
        var randomNumber = await GenerateRandomProofAsync(keyPair);
        var firstRoundOfNextTerm =
            miners.GenerateFirstRoundOfNewTerm(EconomicContractsTestConstants.MiningInterval,
                randomNumber, BlockTimeProvider.GetBlockTime(), round.RoundNumber, round.TermNumber);
        var executionResult = (await miner.NextTerm.SendAsync(firstRoundOfNextTerm)).TransactionResult;
        executionResult.Error.ShouldBeNullOrEmpty();
        executionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
