# Audit Report

## Title
Authorization Bypass via ExtraBlockProducerOfPreviousRound During Term Transition Window

## Summary
During term transitions in the AEDPoS consensus mechanism, the `IsCurrentMiner` authorization function incorrectly grants mining privileges to the `ExtraBlockProducerOfPreviousRound` even when they are excluded from the new term's miner list. This allows former miners to steal transaction fees and perform unauthorized cross-chain operations within a predictable 4-second time window.

## Finding Description

The vulnerability exists in the `IsCurrentMiner` function where miner list membership validation is bypassed during term transitions. When `IsMinerListJustChanged` is true, the critical check verifying that a pubkey exists in the current round's miner list is skipped: [1](#0-0) 

Subsequently, the function grants authorization to the `ExtraBlockProducerOfPreviousRound` if the current time is before the round start time, without verifying they are in the new miner list: [2](#0-1) 

During term transitions, the `ExtraBlockProducerOfPreviousRound` is set to whoever produces the term-transition block: [3](#0-2) 

The new round is marked with `IsMinerListJustChanged = true`: [4](#0-3) 

The round start time is set to `miningInterval` milliseconds after the current block time: [5](#0-4) 

The miner producing the term-transition block may not be included in the new term's miner list, as evidenced by the conditional handling and comment: [6](#0-5) 

## Impact Explanation

**Direct Fund Theft**: The `IsCurrentMiner` authorization is used to protect transaction fee claiming: [7](#0-6) 

The check delegates to the consensus contract's `IsCurrentMiner` method: [8](#0-7) 

A former miner excluded from the new term can exploit this bypass to claim transaction fees meant for legitimate current miners, directly stealing protocol revenue.

**Cross-Chain Integrity Compromise**: The same authorization controls cross-chain indexing operations: [9](#0-8) 

The authorization check delegates to the consensus contract: [10](#0-9) 

Which calls `CheckCrossChainIndexingPermission` that returns the result of `IsCurrentMiner`: [11](#0-10) 

This allows unauthorized miners to propose malicious cross-chain data, potentially corrupting cross-chain synchronization.

Impact severity: **HIGH** - Direct fund loss and critical cross-chain infrastructure compromise.

## Likelihood Explanation

**Attacker Profile**: Must be a legitimate miner from the previous term who produces the term-transition block, making them the `ExtraBlockProducerOfPreviousRound`.

**Attack Complexity**: LOW
1. The attacker waits for a term transition where they are excluded from the new miner list (common during elections)
2. If they produce the term-transition block, they submit a transaction calling `ClaimTransactionFees` or `ProposeCrossChainIndexing` immediately
3. The transaction executes successfully if included within the `miningInterval` window (typically 4000ms)

**Feasibility**: 
- Term transitions occur regularly (approximately every 7 days)
- Miner list changes are common when elections update the validator set
- The exploitation window is deterministic: from block time to `GetRoundStartTime()`: [12](#0-11) 

- The mining interval is typically 4000 milliseconds (4 seconds): [13](#0-12) 

- The authorization check in `PreCheck` allows old-term miners to produce the transition block: [14](#0-13) 

Likelihood: **HIGH** - Naturally occurs during term transitions with miner list changes, and the time window is adequate for exploitation.

## Recommendation

Add an explicit check to verify that `ExtraBlockProducerOfPreviousRound` is still in the current miner list before granting authorization:

```csharp
// Check confirmed extra block producer of previous round.
if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
    currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
{
    // NEW: Verify the miner is still in the current round
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        Context.LogDebug(() => "[CURRENT MINER]PREVIOUS - NOT IN CURRENT LIST");
        return false;
    }
    Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
    return true;
}
```

This ensures that only miners who are both the `ExtraBlockProducerOfPreviousRound` AND in the current miner list can mine during the transition window.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Set up a term transition where the current miner list changes (e.g., miner A is replaced by miner B)
2. Have miner A produce the term transition block (making them `ExtraBlockProducerOfPreviousRound`)
3. The new round has `IsMinerListJustChanged = true` and miner A is NOT in `RealTimeMinersInformation`
4. Within the 4-second window (before `GetRoundStartTime()`), miner A submits `ClaimTransactionFees` or `ProposeCrossChainIndexing`
5. The `IsCurrentMiner` check passes despite miner A not being in the new miner list
6. Miner A successfully claims fees or proposes cross-chain data without authorization

Expected: The authorization check should fail because miner A is not in the current miner list.
Actual: The authorization check passes because the miner list validation is skipped when `IsMinerListJustChanged` is true.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L32-33)
```csharp
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L28-34)
```csharp
        else
            // If the sender isn't in miner list of next term.
            State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
            {
                Pubkey = senderPubkey,
                RecentlyProducedBlocks = 1
            });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-869)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-286)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-74)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L105-108)
```csharp
    public Timestamp GetRoundStartTime()
    {
        return FirstMiner().ExpectedMiningTime;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-327)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
```
