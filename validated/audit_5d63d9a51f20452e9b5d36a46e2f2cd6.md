# Audit Report

## Title
Critical Consensus Takeover: NextTerm Miner List Bypass Enables Arbitrary Miner Installation

## Summary
The AEDPoS consensus contract's `NextTerm` transaction processing lacks validation that the proposed miner list matches the Election contract's `GetVictories()` results. A malicious extra block producer can install arbitrary miners for the next term, completely bypassing the election/governance system and achieving total blockchain control.

## Finding Description

The vulnerability exists in the term transition mechanism where miner lists are updated based on election results. The security guarantee that should be enforced is: **only miners elected through the Election contract's voting system can be installed as consensus miners for a new term**.

**Root Cause Analysis:**

The `NextTermInput.Create()` method directly copies `RealTimeMinersInformation` from the provided Round parameter without any validation: [1](#0-0) 

During execution, `ProcessNextTerm()` extracts the miner list directly from the unvalidated input and stores it in state: [2](#0-1) 

**Why Existing Protections Fail:**

1. **Pre-execution validation** only validates structural properties (round/term number increments, null InValues) via `RoundTerminateValidationProvider`: [3](#0-2) [4](#0-3) 

2. **Post-execution validation** retrieves the current round information AFTER the state has already been updated with malicious miners, so the comparison always passes: [5](#0-4) 

3. **Election contract integration** exists only in the honest generation path where `GenerateFirstRoundOfNextTerm` calls `TryToGetVictories`: [6](#0-5) [7](#0-6) 

This validation is **never enforced during NextTerm processing** - it's only used when honest nodes generate consensus data via `GetConsensusExtraDataForNextTerm`: [8](#0-7) 

**Attack Execution:**

A malicious miner can:
1. Wait until assigned as extra block producer at term end (determined by `MainChainConsensusBehaviourProvider`): [9](#0-8) 

2. Construct a `Round` with attacker-controlled public keys as miners
3. Create `NextTermInput` with this malicious Round
4. The block passes all validations (only structural checks exist)
5. Execution installs attacker's miners for the next term

## Impact Explanation

**CRITICAL - Complete Blockchain Takeover:**

- The attacker can install 100% attacker-controlled nodes as the miner set for the next term
- Once controlling all miners, the attacker achieves complete blockchain control:
  - Censor any transactions
  - Rewrite blockchain history
  - Halt the chain at will
  - Manipulate all governance mechanisms (Parliament/Association/Referendum)
  - Control all economic mechanisms (Treasury, token issuance, rewards)
  
- The election/voting system becomes completely meaningless as vote results are ignored
- All staked tokens and voting weights become worthless
- All token holders who voted in elections are disenfranchised
- The fundamental DPoS security model is broken

This violates the core security invariant that **only elected miners can participate in consensus**.

## Likelihood Explanation

**HIGH - Routinely Exploitable by Any Current Miner:**

**Attacker Prerequisites:**
- Be a current miner (achievable through normal election initially)
- Wait for rotation to extra block producer position at term end
- Modify node software to construct malicious `NextTermInput`

**Attack Complexity:** LOW
- No cryptographic barriers
- No economic barriers beyond normal block production
- Extra block producer role rotates among all current miners
- Attack is undetectable until after execution (state already poisoned during post-validation)

**Feasibility:** 
- The extra block producer position regularly rotates among miners
- Any term transition provides an opportunity
- The `PreCheck` only verifies the sender is in the current/previous miner list: [10](#0-9) 

This allows the attacker (a current miner) to pass while installing arbitrary future miners.

## Recommendation

**Implement Miner List Validation in NextTerm Processing:**

Add a new validation provider `NextTermMinerListValidationProvider` that:

1. Calls `State.ElectionContract.GetVictories.Call(new Empty())` to get the elected miner list
2. Compares the provided `RealTimeMinersInformation.Keys` against the election results
3. Rejects the block if they don't match

Add this provider to the validation chain in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new NextTermMinerListValidationProvider()); // NEW
    break;
```

The validation provider should verify:
- The set of public keys in `extraData.Round.RealTimeMinersInformation.Keys` exactly matches
- The public keys returned by `GetVictories()` 
- Reject if there's any mismatch

This ensures that term transitions can only install miners who were legitimately elected through the voting system.

## Proof of Concept

```csharp
// POC demonstrating the vulnerability
[Fact]
public async Task NextTerm_MinerList_Bypass_Attack()
{
    // Setup: Initialize blockchain with legitimate miners through election
    var initialMiners = await InitializeElectionAndMiners();
    
    // Attacker: Current miner waiting for extra block producer assignment
    var attackerMiner = initialMiners.First();
    
    // Advance to term end when attacker is extra block producer
    await AdvanceToTermEnd(attackerMiner);
    
    // Attack: Construct malicious NextTermInput with arbitrary miners
    var maliciousMiners = GenerateArbitraryMinerKeys(); // Attacker-controlled keys
    var maliciousRound = CreateRoundWithMiners(maliciousMiners);
    var maliciousInput = NextTermInput.Create(maliciousRound, GenerateRandomNumber());
    
    // Execute: Submit NextTerm transaction
    var result = await ConsensusStub.NextTerm.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Passes!
    
    // Verify: Malicious miners are now installed
    var currentMiners = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    currentMiners.Pubkeys.ShouldBe(maliciousMiners); // Attack succeeded!
    
    // Verify: Election results are ignored
    var electedMiners = await ElectionStub.GetVictories.CallAsync(new Empty());
    currentMiners.Pubkeys.ShouldNotBe(electedMiners.Value); // Elections bypassed!
}
```

The test demonstrates that:
1. An attacker with miner privileges can submit `NextTerm` with arbitrary miners
2. All validations pass despite miners not matching election results
3. The malicious miner list is installed in state
4. The election/voting system is completely bypassed

**Notes:**
- This vulnerability affects the mainchain only (sidechains don't use election mechanism)
- The attack can be chained across terms to maintain permanent control
- Once malicious miners are installed, they can continue the attack indefinitely
- No recovery mechanism exists without hard fork or governance intervention (which the attacker now controls)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```
