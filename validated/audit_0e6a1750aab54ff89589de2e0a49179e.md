# Audit Report

## Title
Miner Time Manipulation via Unvalidated ActualMiningTime in Consensus Extra Data

## Summary
Miners can manipulate their `ActualMiningTimes` by crafting consensus extra data with false timestamps that differ from `Context.CurrentBlockTime`. The consensus validation logic fails to verify that the reported `ActualMiningTime` matches the actual block time, enabling manipulation of term transitions, time slot calculations, and consensus timing mechanisms.

## Finding Description

The vulnerability exists in how `ActualMiningTime` values are validated when miners produce blocks. The protocol assumes that `ActualMiningTime` represents the actual block production time (`Context.CurrentBlockTime`), but this invariant is never enforced.

**Legitimate Flow:**
When generating consensus extra data, the system legitimately adds `Context.CurrentBlockTime` to the miner's `ActualMiningTimes` collection. [1](#0-0) 

The `ExtractInformationToUpdateConsensus` method then extracts the last `ActualMiningTime` to include in the `UpdateValueInput`. [2](#0-1) 

**Missing Validation - Root Cause:**

The critical flaw is that no validation exists to ensure the provided `ActualMiningTime` equals `Context.CurrentBlockTime`. The validation gaps are:

1. **Hash Comparison Bypass**: The `GetCheckableRound` method explicitly clears all `ActualMiningTimes` before computing the hash, meaning hash comparison cannot detect manipulated timestamps. [3](#0-2) 

2. **Insufficient Time Slot Validation**: The `TimeSlotValidationProvider` only validates that the timestamp falls within the miner's allocated time slot bounds, not that it equals the actual current block time. [4](#0-3) 

3. **Direct State Update**: The `ProcessUpdateValue` method directly adds the provided `ActualMiningTime` to state without any validation. [5](#0-4) 

During validation, `RecoverFromUpdateValue` simply adds the provided `ActualMiningTimes` from the consensus header to the base round without any validation checks. [6](#0-5) 

**Attack Execution:**
A malicious miner can craft custom `AElfConsensusHeaderInformation` with a manipulated `ActualMiningTime` value (e.g., 10 seconds earlier or later than `Context.CurrentBlockTime`, but still within their time slot). The block will pass all validations because:
- The miner has legitimate mining permission
- The timestamp is within their allocated time slot
- Hash validation excludes `ActualMiningTimes`
- No validator checks equality to `Context.CurrentBlockTime`

## Impact Explanation

**HIGH SEVERITY** - This vulnerability directly compromises consensus integrity through multiple attack vectors:

1. **Term Transition Manipulation**: The `NeedToChangeTerm` function uses `ActualMiningTimes.Last()` from each miner to determine when to change consensus terms. [7](#0-6)  If two-thirds of miners report manipulated timestamps, they can delay or accelerate term changes, violating the protocol's term transition timing.

2. **Round 1 Time Slot Distortion**: In the first round, `IsTimeSlotPassed` uses `FirstMiner().ActualMiningTimes.First()` as the reference time. [8](#0-7)  If the first miner manipulates this timestamp, all subsequent miners' time slot calculations are affected, potentially allowing or denying mining opportunities incorrectly.

3. **Consensus Behavior Manipulation**: Time-based decisions throughout the consensus mechanism rely on accurate `ActualMiningTimes`. Manipulation affects whether miners can produce tiny blocks, terminate rounds, and schedule subsequent mining operations.

The manipulated values are permanently stored in state and affect all future consensus calculations that depend on historical mining times.

## Likelihood Explanation

**MEDIUM-HIGH** - This vulnerability is highly exploitable:

**Attacker Profile**: Any scheduled miner in the AEDPoS consensus system can execute this attack during their allocated block production time slot. No special privileges beyond normal miner status are required.

**Attack Complexity**: LOW
1. Wait for scheduled mining turn
2. Craft custom `AElfConsensusHeaderInformation` with manipulated `ActualMiningTime` (within time slot bounds)
3. Produce and broadcast block with crafted consensus extra data
4. Block passes all validations and manipulated timestamp is stored

**Preconditions**: 
- Attacker must be in the current miner list (normal operational requirement)
- No governance control or special permissions needed

**Detection Difficulty**: HIGH - The manipulated timestamps appear as legitimate mining activity in contract state without external timestamp monitoring.

**Economic Rationality**: Attack cost is negligible (normal block production cost) while potential gains include extended mining windows, strategic term transition control, and competitive advantage in consensus timing.

## Recommendation

Add explicit validation that the provided `ActualMiningTime` equals `Context.CurrentBlockTime` during consensus validation. This can be implemented in `ValidateConsensusBeforeExecution` or as a new validation provider:

```csharp
// In ValidateConsensusBeforeExecution or new ActualMiningTimeValidationProvider
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    var providedActualMiningTime = extraData.Round.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()]
        .ActualMiningTimes.LastOrDefault();
    
    if (providedActualMiningTime != null && providedActualMiningTime != Context.CurrentBlockTime)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "ActualMiningTime must equal current block time." 
        };
    }
}
```

Alternatively, during `ProcessUpdateValue`, validate the input before storing:

```csharp
// In ProcessUpdateValue
Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime, 
    "ActualMiningTime must equal current block time.");
minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateActualMiningTime()
{
    // Setup: Initialize consensus with test miners
    var initialMiners = GetTestMiners();
    await InitializeConsensus(initialMiners);
    
    // Get current round and legitimate mining time
    var currentRound = await GetCurrentRound();
    var miner = initialMiners[0];
    var legitimateTime = await GetCurrentBlockTime();
    
    // Attack: Craft consensus header with manipulated ActualMiningTime
    // Set it 10 seconds earlier than actual block time (but within time slot)
    var manipulatedTime = legitimateTime.AddSeconds(-10);
    var maliciousHeader = CreateConsensusHeader(
        miner, 
        currentRound, 
        manipulatedTime // Manipulated time instead of legitimateTime
    );
    
    // Create UpdateValue transaction with manipulated time
    var updateValueInput = CreateUpdateValueInput(miner, manipulatedTime);
    
    // Validation should fail but doesn't - block is accepted
    var validationResult = await ValidateConsensusBeforeExecution(maliciousHeader);
    Assert.True(validationResult.Success); // Vulnerability: validation passes
    
    // Execute the transaction
    await ExecuteUpdateValue(updateValueInput);
    
    // Verify manipulated time is stored in state
    var updatedRound = await GetCurrentRound();
    var storedTime = updatedRound.RealTimeMinersInformation[miner.ToHex()]
        .ActualMiningTimes.Last();
    
    // Vulnerability confirmed: manipulated time is stored
    Assert.Equal(manipulatedTime, storedTime);
    Assert.NotEqual(legitimateTime, storedTime);
}
```

## Notes

The root cause is an unchecked assumption that `ActualMiningTime` always equals `Context.CurrentBlockTime`. While the legitimate flow generates this correctly, the validation pipeline never enforces this invariant when processing blocks from other nodes. This allows miners to inject arbitrary timestamps (within their time slot bounds) that permanently corrupt the consensus timing state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-243)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-21)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

```
