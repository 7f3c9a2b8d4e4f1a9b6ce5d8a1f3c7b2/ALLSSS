# Audit Report

## Title
Unbounded Candidate List Causes Consensus Failure via ExecutionBranchThreshold Breach

## Summary
The Election contract allows unlimited candidate registration without maximum bounds, enabling an attacker to register 15,001+ candidates that trigger a `RuntimeBranchThresholdExceededException` during term transitions. This causes the consensus-critical `TakeSnapshot` operation to fail, preventing the blockchain from transitioning to new consensus terms.

## Finding Description

The vulnerability exists in the interaction between unlimited candidate registration and the consensus term transition mechanism.

**Attack Vector:**

Any user can register as a candidate by calling `AnnounceElectionFor`, which requires locking 100,000 ELF tokens per candidate. [1](#0-0)  Each registration adds a public key to the candidates list without checking total candidate count. [2](#0-1) 

The only protection prevents the same public key from announcing twice, but an attacker can generate unlimited different public keys. [3](#0-2) 

**Critical Path:**

During term transitions, the consensus contract calls `TakeSnapshot` on the Election contract. [4](#0-3) 

`TakeSnapshot` internally calls `SavePreviousTermInformation`, which iterates through ALL candidates without pagination. [5](#0-4) 

**Threshold Breach:**

AElf enforces an ExecutionBranchThreshold of 15,000 to prevent infinite loops. [6](#0-5) 

When the branch counter reaches this threshold, a `RuntimeBranchThresholdExceededException` is thrown. [7](#0-6) 

Test evidence confirms that foreach loops with 15,000+ iterations trigger this exception. [8](#0-7) 

**Why Existing Protections Fail:**

The candidate count checks only control DataCenter subsidy eligibility, not total candidate registration. [9](#0-8) 

No maximum candidate limit exists in the registration flow, and pagination methods are only for view operations, not used in the consensus critical path.

## Impact Explanation

**Consensus Disruption:**

`ProcessNextTerm` is a critical consensus operation executed by validators to transition between governance terms. [10](#0-9) 

When this operation fails due to the threshold breach, the blockchain cannot rotate validator sets or update consensus parameters. While block production may continue with the current validator set, the inability to transition terms represents a fundamental breakdown of the AEDPoS consensus mechanism.

**Network-Wide Effects:**
- Validator rotation freezes indefinitely
- Term-based reward distributions cannot occur
- New validator elections cannot take effect
- Requires emergency governance intervention or hard fork to resolve

## Likelihood Explanation

**Economic Barrier:**

The attack requires locking 100,000 ELF per candidate. For 15,001 candidates: 1,500,100,000 ELF (1.5 billion ELF).

**Recoverable Capital:**

The locked tokens are fully recoverable via `QuitElection`, making this a temporary capital requirement rather than a permanent cost. [11](#0-10) 

An attacker can recover all funds after the attack succeeds, significantly reducing the economic disincentive.

**Technical Feasibility:**
- Generating 15,001 keypairs is trivial
- Submitting 15,001 transactions is achievable within a single term period (typically days/weeks)
- No privileged access required
- Deterministic outcome once threshold is reached

**Mitigation Challenges:**

While the emergency response organization can remove candidates via `RemoveEvilNode`, this method removes candidates one at a time. [12](#0-11)  Removing 15,001 candidates individually before the next term transition is impractical.

## Recommendation

Implement a maximum candidate limit in the Election contract:

1. Add a constant for maximum candidates (e.g., 10,000)
2. Add validation in `AnnounceElection` method to check total candidate count
3. Alternatively, implement pagination in `SavePreviousTermInformation` to process candidates in batches

Example fix in `ElectionContract_Candidate.cs`:
```csharp
private void AnnounceElection(byte[] pubkeyBytes)
{
    var pubkey = pubkeyBytes.ToHex();
    var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);
    
    // Add maximum candidate check
    Assert(State.Candidates.Value.Value.Count < ElectionContractConstants.MaxCandidates,
        "Maximum candidate limit reached.");
    
    // ... rest of existing logic
}
```

## Proof of Concept

A proof of concept would involve:

1. Creating 15,001 keypairs
2. Calling `AnnounceElectionFor` for each keypair with 100,000 ELF locked
3. Waiting for the next term transition
4. Observing that `ProcessNextTerm` fails with `RuntimeBranchThresholdExceededException`
5. Verifying that term number does not increment and validator set does not rotate

The test would demonstrate that the `TakeSnapshot` operation fails when iterating through the candidate list, preventing the consensus term transition from completing successfully.

## Notes

This vulnerability represents a serious availability issue for the AEDPoS consensus mechanism. While the economic barrier is substantial (1.5B ELF), the fact that capital is fully recoverable makes this attack economically viable for a well-funded adversary or nation-state actor. The deterministic nature of the attack (guaranteed to work once threshold is reached) and the difficulty of remediation (requires removing 15,001 candidates individually or hard fork) elevate the severity of this finding.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L112-116)
```csharp
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L156-157)
```csharp
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L174-174)
```csharp
        State.Candidates.Value.Value.Add(pubkeyByteString);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L239-249)
```csharp
        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-350)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L469-476)
```csharp
        foreach (var pubkey in State.Candidates.Value.Value)
        {
            var votes = State.CandidateVotes[pubkey.ToHex()];
            var validObtainedVotesAmount = 0L;
            if (votes != null) validObtainedVotesAmount = votes.ObtainedActiveVotedVotesAmount;

            snapshot.ElectionResult.Add(pubkey.ToHex(), validObtainedVotesAmount);
        }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L31-33)
```csharp
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");
```

**File:** test/AElf.Contracts.TestContract.Tests/PatchedContractSecurityTests.cs (L428-434)
```csharp
            await TestBasicSecurityContractStub.TestForeachInfiniteLoop.SendAsync(new ListInput
                { List = { new int[14999] } });
            var txResult =
                await TestBasicSecurityContractStub.TestForeachInfiniteLoop.SendWithExceptionAsync(
                    new ListInput { List = { new int[15000] } });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }
```
