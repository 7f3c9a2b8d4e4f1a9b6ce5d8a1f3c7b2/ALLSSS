# Audit Report

## Title
Missing LIB Validation in NextRound/NextTerm Allows Future Irreversible Block Heights to Persist in Consensus State

## Summary
The AEDPoS consensus contract validates Last Irreversible Block (LIB) fields only for `UpdateValue` behavior but not for `NextRound` or `NextTerm` behaviors. A malicious miner can inject arbitrary future LIB heights when producing NextRound/NextTerm blocks, permanently corrupting consensus state and disabling critical block production throttling mechanisms.

## Finding Description

The consensus validation system applies different validation providers based on the behavior type. The `LibInformationValidationProvider` ensures LIB fields cannot move backwards and is only applied to `UpdateValue` behavior: [1](#0-0) 

For `NextRound` and `NextTerm` behaviors, only `RoundTerminateValidationProvider` is added: [2](#0-1) 

The `RoundTerminateValidationProvider` validates round/term number increments and InValue fields but does not validate LIB fields: [3](#0-2) 

The `NextRoundInput` and `NextTermInput` structures include LIB fields that can be transmitted and stored: [4](#0-3) [5](#0-4) 

The round hash validation performed in `ValidateAfterExecution` cannot detect LIB manipulation because the `GetCheckableRound` method excludes LIB fields from the hash computation: [6](#0-5) [7](#0-6) 

When generating a new round, the LIB fields are copied from the current round without recalculation: [8](#0-7) 

The corrupted round is stored directly without LIB recalculation or validation: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Block Production Throttling Bypass**: The `GetMaximumBlocksCount` method uses LIB round number to evaluate blockchain mining status and throttle block production when the chain is experiencing excessive forking: [11](#0-10) 

The `BlockchainMiningStatusEvaluator` determines status based on the difference between `libRoundNumber` and `currentRoundNumber`: [12](#0-11) 

With a corrupted future LIB round number (e.g., `libRoundNumber = 200` when `currentRoundNumber = 101`), the blockchain mining status evaluator incorrectly returns "Normal" status, bypassing throttling mechanisms designed to prevent excessive forking.

**Permanent State Corruption**: The `ProcessUpdateValue` method only updates LIB if the calculated value exceeds the stored value: [13](#0-12) 

A future LIB height (e.g., 1,000,000) will never be exceeded by legitimate calculations, making the corruption permanent. Future rounds continue copying the corrupted values forward via `GenerateNextRoundInformation`, spreading the corruption across all subsequent consensus states.

**Consensus Integrity Violation**: The core consensus invariant that LIB height accurately reflects blockchain finality is permanently broken, potentially affecting cross-chain operations that rely on LIB for finality guarantees.

## Likelihood Explanation

**Attacker Prerequisites**: 
- Must be a valid miner in the active miner set (achievable for malicious validators through the election process)
- Must be scheduled to produce a NextRound or NextTerm block

**Attack Execution**:
- When producing a NextRound/NextTerm block, the miner receives consensus extra data containing legitimate LIB values generated by `GetConsensusExtraDataForNextRound`: [14](#0-13) 

- Before including the data in the block, the miner modifies `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` to arbitrary future values
- The modified data passes all validations because `LibInformationValidationProvider` is not applied
- The corrupted round is permanently stored

**Frequency**: NextRound blocks occur every round during normal operation, providing regular opportunities for exploitation. NextTerm blocks occur at term boundaries, which are less frequent but still predictable.

**Detection Difficulty**: The attack produces no validation failures, events, or logs indicating manipulation. Detection requires manual inspection of consensus state and comparison with actual blockchain height.

## Recommendation

Add `LibInformationValidationProvider` to the validation pipeline for `NextRound` and `NextTerm` behaviors:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
```

Alternatively, include LIB fields in the `GetCheckableRound` method so that `ValidateAfterExecution` can detect LIB manipulation through hash comparison.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_InjectsArbitraryLIB_BypassesThrottling()
{
    // Setup: Get to round 2 with legitimate LIB values
    await InitialAElfConsensusContract();
    var currentRound = await AElfConsensusContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Malicious miner modifies NextRoundInput before submitting
    var maliciousNextRound = GenerateNextRoundInformation(currentRound);
    maliciousNextRound.ConfirmedIrreversibleBlockHeight = 1000000; // Future value
    maliciousNextRound.ConfirmedIrreversibleBlockRoundNumber = 200; // Future value
    
    // Submit malicious NextRound transaction
    var maliciousInput = NextRoundInput.Create(maliciousNextRound, Hash.Generate());
    await AElfConsensusContractStub.NextRound.SendAsync(maliciousInput);
    
    // Verify: Corrupted LIB is stored
    var corruptedRound = await AElfConsensusContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    corruptedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(1000000);
    corruptedRound.ConfirmedIrreversibleBlockRoundNumber.ShouldBe(200);
    
    // Verify: Block production throttling is bypassed (GetMaximumBlocksCount returns MaximumTinyBlocksCount instead of 1)
    var maxBlocksCount = await AElfConsensusContractStub.GetMaximumBlocksCount.CallAsync(new Empty());
    maxBlocksCount.Value.ShouldBe(AEDPoSContractConstants.MaximumTinyBlocksCount); // Should be 1 if throttling worked
}
```

## Notes

This vulnerability represents a critical consensus integrity failure. The attack is practical (requires only miner privileges during normal operation), has severe impact (disables safety mechanisms and corrupts finality tracking), and is permanent (cannot be corrected through normal consensus operations). The fix is straightforward: extend LIB validation to all round transition behaviors, not just `UpdateValue`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-37)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L119-129)
```csharp
        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
