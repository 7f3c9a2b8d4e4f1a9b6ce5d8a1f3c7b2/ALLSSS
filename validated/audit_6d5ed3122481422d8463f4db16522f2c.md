# Audit Report

## Title
Incomplete Conflict Resolution in Miner Order Assignment Leads to Duplicate Orders and Non-Deterministic Consensus

## Summary
The `ApplyNormalConsensusData()` function contains a critical off-by-one error in its conflict resolution loop that fails to check the maximum valid miner position when `supposedOrderOfNextRound` equals `minersCount`. Combined with flawed validation logic that fails to detect duplicate order values, this allows multiple miners to be assigned identical `FinalOrderOfNextRound` values, violating the fundamental consensus invariant requiring unique miner orders and creating non-deterministic block production.

## Finding Description

The vulnerability exists in the conflict resolution mechanism within `ApplyNormalConsensusData()` that reassigns miners when hash collisions cause multiple miners to calculate the same next-round order. [1](#0-0) 

**Root Cause Analysis:**

The conflict resolution loop iterates from `supposedOrderOfNextRound + 1` to `minersCount * 2 - 1` with modulo wrapping. When `supposedOrderOfNextRound = minersCount` (the maximum valid order value), a critical gap emerges:

For a 21-miner configuration where `supposedOrderOfNextRound = 21`:
- Loop range: `i = 22` to `i = 41`
- Since all iterations have `i > minersCount`, the modulo branch executes: `maybeNewOrder = i % minersCount`
- Positions checked: `22 % 21 = 1`, `23 % 21 = 2`, ..., `41 % 21 = 20`
- **Position 21 is never evaluated** because no value of `i` in the loop range produces `i % 21 = 21`

The calculation of `supposedOrderOfNextRound` uses modulo with range `[1, minersCount]`: [2](#0-1) 

**Execution Flow:**

1. Miner A produces a block and is assigned `FinalOrderOfNextRound = 21` via normal calculation [3](#0-2) 

2. Miner B later produces a block and also calculates `supposedOrderOfNextRound = 21` (hash collision)

3. Conflict detection identifies Miner A already occupies position 21: [4](#0-3) 

4. The resolution loop attempts to reassign Miner A but only checks positions 1-20. If all positions are occupied, no free position is found and the loop completes without reassignment.

5. Miner B is then assigned `FinalOrderOfNextRound = 21`, creating a duplicate with Miner A.

**Why Existing Protections Fail:**

The validation mechanism calls `Distinct()` on `MinerInRound` objects instead of their `FinalOrderOfNextRound` values, using reference equality that always counts all unique miner objects even when they have duplicate order values: [5](#0-4) 

The `TuneOrderInformation` mechanism only tracks miners where `FinalOrderOfNextRound != SupposedOrderOfNextRound`. When both conflicted miners have `FinalOrderOfNextRound = SupposedOrderOfNextRound = 21`, neither appears in the tuning dictionary: [6](#0-5) 

During `ProcessUpdateValue`, the tuning information is applied but misses both miners: [7](#0-6) 

## Impact Explanation

**Critical Consensus Invariant Violation:**

When duplicate `FinalOrderOfNextRound` values persist into next round generation, both miners are assigned identical `Order` and `ExpectedMiningTime` values: [8](#0-7) 

**Direct Consequences:**

1. **Non-Deterministic Block Production:** Two miners simultaneously believe they should produce blocks at the same timeslot, creating a race condition where network latency determines which block propagates first rather than deterministic consensus rules.

2. **Unfair Penalties:** The miner whose block arrives second may be marked as having missed their timeslot despite legitimate production attempts, damaging their reputation and reducing rewards.

3. **Consensus Ambiguity:** Different network nodes may initially accept different blocks from the two miners, creating temporary forks that require additional reconciliation rounds.

4. **Cascading Effects:** Duplicate orders can persist across multiple round transitions until the next term change, compounding the problem.

**Severity Assessment:**

HIGH severity because this directly compromises the deterministic nature of AEDPoS consensus. The protocol's security model fundamentally relies on each miner having a unique, predetermined timeslot. Violating this invariant undermines consensus guarantees and can occur during normal operations without malicious actors.

## Likelihood Explanation

**Natural Occurrence Without Attacks:**

This vulnerability triggers during legitimate consensus operations:

- **Hash Collision Probability:** With signature-based order calculation, hash collisions naturally occur. The birthday paradox makes collisions at specific positions increasingly likely over extended operation.

- **Position Saturation:** As miners produce blocks throughout a round, available positions fill. The vulnerability becomes exploitable when a collision occurs at position `minersCount` while positions 1 through `minersCount-1` are already occupied.

- **Silent Failure:** The bug produces no error or exception. The conflict resolution loop completes normally, and flawed validation fails to detect duplicate orders.

**Realistic Trigger Conditions:**

1. **No Special Privileges Required:** Occurs during standard `UpdateValue` consensus behavior as miners produce blocks in their assigned timeslots.

2. **Common Scenarios:** More likely in:
   - High-participation rounds where most miners successfully produce blocks
   - Smaller miner sets where collision probability at any specific position is higher
   - Extended chain operation where cumulative collision probability increases

3. **Feasible Preconditions:** Only requires two miners to calculate the same order value (position `minersCount`) via natural hash collision, with most other positions already occupied.

The vulnerability is highly feasible because it requires only normal block production by honest miners with no coordination or timing manipulation needed.

## Recommendation

**Fix 1: Correct the Conflict Resolution Loop**

Ensure position `minersCount` is checked by adjusting the loop range or modulo calculation:

```csharp
for (var i = supposedOrderOfNextRound + 1; i <= minersCount + supposedOrderOfNextRound; i++)
{
    var maybeNewOrder = ((i - 1) % minersCount) + 1;
    if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
    {
        RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
        break;
    }
}
```

This ensures all positions in the valid range `[1, minersCount]` are checked exactly once.

**Fix 2: Correct the Validation Logic**

Fix the `NextRoundMiningOrderValidationProvider` to check for distinct order values:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

**Fix 3: Add Explicit Duplicate Detection**

Add explicit validation that fails the block if any duplicate `FinalOrderOfNextRound` values are detected, providing defense-in-depth even if the resolution logic has issues.

## Proof of Concept

```csharp
[Fact]
public void Test_DuplicateOrderWhenMaxPosition()
{
    const int minersCount = 21;
    var round = new Round();
    
    // Initialize round with 21 miners
    for (int i = 1; i <= minersCount; i++)
    {
        var pubkey = $"Miner{i}";
        round.RealTimeMinersInformation[pubkey] = new MinerInRound
        {
            Pubkey = pubkey,
            FinalOrderOfNextRound = 0
        };
    }
    
    // Miner A produces block first, gets order 21
    var minerAPubkey = "MinerA";
    var hashA = HashHelper.ComputeFrom(new byte[] { 20 }); // Hash that produces order 21
    round.ApplyNormalConsensusData(minerAPubkey, Hash.Empty, Hash.Empty, hashA);
    
    Assert.Equal(21, round.RealTimeMinersInformation[minerAPubkey].FinalOrderOfNextRound);
    
    // Occupy positions 1-20 with other miners
    for (int i = 1; i <= 20; i++)
    {
        var pubkey = $"Miner{i}";
        round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = i;
        round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = i;
    }
    
    // Miner B produces block later, also calculates order 21 (hash collision)
    var minerBPubkey = "MinerB";
    var hashB = HashHelper.ComputeFrom(new byte[] { 41 }); // Hash that also produces order 21
    round.ApplyNormalConsensusData(minerBPubkey, Hash.Empty, Hash.Empty, hashB);
    
    // BUG: Both miners have FinalOrderOfNextRound = 21
    Assert.Equal(21, round.RealTimeMinersInformation[minerAPubkey].FinalOrderOfNextRound);
    Assert.Equal(21, round.RealTimeMinersInformation[minerBPubkey].FinalOrderOfNextRound);
    
    // This violates the consensus invariant of unique orders
    var orders = round.RealTimeMinersInformation.Values
        .Select(m => m.FinalOrderOfNextRound)
        .Where(o => o > 0)
        .ToList();
    var distinctOrders = orders.Distinct().Count();
    
    Assert.NotEqual(orders.Count, distinctOrders); // Proof of duplicate orders
}
```

## Notes

This vulnerability affects the core AEDPoS consensus mechanism and represents a fundamental flaw in the conflict resolution logic. The combination of three separate issues (off-by-one error in conflict resolution, flawed validation using reference equality, and incomplete tuning tracking) creates a perfect storm where duplicate orders can silently persist through all safety checks. The issue is particularly insidious because it manifests during high network participation—a desired state—and produces no errors or warnings, potentially going undetected until consensus failures occur.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-26)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L31-40)
```csharp
            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
