# Audit Report

## Title
Minority Miner Collusion Can Block Term Changes via Strategic Non-Participation in Timestamp Recording

## Summary
The `NeedToChangeTerm` function contains a critical logic flaw where it uses the total miner count as the denominator for the 2/3 consensus threshold but only counts miners who have actually mined blocks in the numerator. This enables >1/3 of colluding miners to indefinitely prevent term changes by refusing to mine, thereby blocking governance-mandated miner rotations.

## Finding Description

The vulnerability exists in the term change detection mechanism within the AEDPoS consensus contract. The `NeedToChangeTerm` method determines whether a term change should occur by checking if at least `MinersCountOfConsent` miners have their last mining timestamp cross the term threshold. [1](#0-0) 

The `MinersCountOfConsent` property calculates the required threshold as ⌊totalMiners × 2/3⌋ + 1 using the total number of miners in `RealTimeMinersInformation`. [2](#0-1) 

**Root Cause:** The critical flaw is that `NeedToChangeTerm` filters miners with `.Where(m => m.ActualMiningTimes.Any())`, excluding miners who haven't mined any blocks. This creates a mathematical impossibility: if >1/3 of miners refuse to mine, they won't have `ActualMiningTimes`, making it impossible to reach the 2/3 threshold calculated from the total miner count.

**Concrete Attack Scenario:**
- With 17 total miners: `MinersCountOfConsent = 17 × 2 ÷ 3 + 1 = 12`
- If 6 miners (>1/3) refuse to mine: only 11 miners have `ActualMiningTimes`
- Maximum achievable count: 11 < 12 required
- `NeedToChangeTerm` returns false indefinitely

The consensus behavior provider uses this result to determine whether to trigger `NextTerm` or `NextRound`. [3](#0-2) 

When `NeedToChangeTerm` returns false, the behavior remains `NextRound`, preventing term transitions.

**Why Existing Protections Fail:**

Evil miner detection exists but provides insufficient protection. The threshold for marking miners as evil is 4,320 missed time slots. [4](#0-3) 

This translates to approximately 3 days (60 minutes × 24 hours × 3 days), providing a substantial attack window. The detection logic only identifies miners exceeding this threshold. [5](#0-4) 

Evil miners are only marked during `ProcessNextRound`, after the behavior decision has already been made. [6](#0-5) 

Additionally, colluding miners can strategically mine minimal blocks to avoid detection while maintaining sufficient abstention to block term changes. The `ActualMiningTimes` field is only populated when miners call `ProcessUpdateValue` or `ProcessTinyBlock`. [7](#0-6) 

## Impact Explanation

**HIGH Severity** - This vulnerability attacks a critical consensus invariant that enables democratic governance in AEDPoS.

**Governance Compromise:** Term changes are the fundamental mechanism for rotating mining power based on election results. Blocking term changes allows incumbent miners to retain exclusive control indefinitely, completely bypassing the election system.

**Quantified Impact:**
- **Timeframe:** Minimum 3-day attack window before evil miner detection triggers
- **Power Retention:** Colluding miners controlling >1/3 positions can prevent any term changes during detection window
- **Economic Impact:** Continued exclusive access to mining rewards (12,500,000 tokens per block initially) that should be distributed to newly elected validators [8](#0-7) 
- **Affected Parties:** All token holders who participated in elections, newly elected miners unable to assume positions, overall network governance integrity

The attack undermines the fundamental trust assumption that election results will be honored, which is critical for a DPoS-based consensus system.

## Likelihood Explanation

**HIGH Likelihood** - The attack is practical and economically rational.

**Attacker Capabilities:** Requires control of >1/3 of current miner positions. With the standard 17-miner configuration [9](#0-8) , 6+ colluding miners are needed.

**Economic Rationality:** Incumbent miners have strong financial incentive to maintain their positions rather than cede control to elected replacements. Mining rewards provide continuous revenue that incumbents would lose upon term rotation.

**Attack Complexity:** LOW - Execution is trivial:
1. Monitor when `ActualMiningTimes` of miners approach term change threshold
2. Coordinate >1/3 of miners to stop mining
3. Optionally rotate which miners abstain to avoid all being marked as evil simultaneously

**Detection Difficulty:** The attack is indistinguishable from normal network issues or miner downtime for up to 3 days. During this window, term changes remain blocked with no clear on-chain evidence of malicious coordination.

**Feasibility:** PRACTICAL - No sophisticated technical knowledge required beyond simple coordination. The attack can be sustained indefinitely by cycling which miners abstain.

## Recommendation

Modify the `NeedToChangeTerm` method to calculate the consensus threshold based on the number of miners who have actually participated in mining, rather than the total miner count. 

**Option 1:** Calculate `MinersCountOfConsent` dynamically within `NeedToChangeTerm` based on miners with `ActualMiningTimes`:

```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    var minersWithActivity = RealTimeMinersInformation.Values
        .Where(m => m.ActualMiningTimes.Any())
        .ToList();
    
    if (minersWithActivity.Count == 0) return false;
    
    var dynamicConsent = minersWithActivity.Count.Mul(2).Div(3).Add(1);
    
    return minersWithActivity
        .Select(m => m.ActualMiningTimes.Last())
        .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp, t, currentTermNumber, periodSeconds))
        >= dynamicConsent;
}
```

**Option 2:** Remove non-participating miners from `RealTimeMinersInformation` more aggressively (reduce `TolerableMissedTimeSlotsCount` significantly or implement immediate removal upon consecutive round absences).

**Option 3:** Implement a governance override mechanism that allows Parliament to force term changes when the automatic mechanism is blocked.

## Proof of Concept

```csharp
[Fact]
public async Task MinorityCollusionBlocksTermChange()
{
    // Setup: Initialize 17 miners in term 1
    var initialMiners = GenerateMinerList(17);
    await InitializeConsensusWithMiners(initialMiners);
    
    // Advance to term change threshold
    var termPeriodSeconds = 604800; // 7 days
    await AdvanceTime(termPeriodSeconds + 1);
    
    // Simulate 11 miners mining normally (recording ActualMiningTimes)
    for (int i = 0; i < 11; i++)
    {
        await MineBlock(initialMiners[i]);
    }
    
    // 6 miners (>1/3) refuse to mine - no ActualMiningTimes recorded
    // These miners simply don't call ProcessUpdateValue/ProcessTinyBlock
    
    // Check consensus behavior
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var needsTermChange = currentRound.NeedToChangeTerm(
        blockchainStartTimestamp,
        currentRound.TermNumber,
        termPeriodSeconds
    );
    
    // Verify: NeedToChangeTerm returns false despite term period elapsed
    needsTermChange.ShouldBeFalse();
    
    // Verify: MinersCountOfConsent = 12, but only 11 miners have ActualMiningTimes
    currentRound.MinersCountOfConsent.ShouldBe(12);
    currentRound.RealTimeMinersInformation.Values
        .Count(m => m.ActualMiningTimes.Any())
        .ShouldBe(11);
    
    // Verify: Consensus behavior remains NextRound instead of NextTerm
    var behaviour = GetConsensusBehaviour(currentRound);
    behaviour.ShouldBe(AElfConsensusBehaviour.NextRound);
    
    // Verify: Term change is blocked - term number unchanged after next round
    await ExecuteNextRound();
    var newRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.TermNumber.ShouldBe(currentRound.TermNumber); // Term unchanged!
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L7-7)
```csharp
    public const long InitialMiningRewardPerBlock = 12500000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```
