# Audit Report

## Title
NextRound Validation Fails to Verify Miner Participation Against Trusted State

## Summary
The `NextRoundMiningOrderValidationProvider` performs only internal consistency checks on the untrusted `ProvidedRound` without comparing it against the trusted `BaseRound` from StateDb. This allows a malicious miner producing a NextRound block to manipulate the next round's miner schedule by arbitrarily including or excluding miners, violating the consensus rule that participation determines next-round eligibility.

## Finding Description

The validation logic contains a critical flaw in how it verifies NextRound block data. The validator only examines the `ProvidedRound` (untrusted data from the block header) and never compares it against `BaseRound` (trusted state from StateDb). [1](#0-0) 

The validation checks whether the count of miners with `FinalOrderOfNextRound > 0` equals the count with `OutValue != null` within the ProvidedRound itself. However, when NextRound is legitimately generated, these fields are NOT populated in the new round: [2](#0-1) 

The new round only sets `Order`, `Pubkey`, `ExpectedMiningTime`, etc., leaving `FinalOrderOfNextRound` and `OutValue` at their default values (0 and null). This means the validation effectively checks `0 == 0`, which always passes regardless of the actual miner list.

**Critical difference from other behaviors**: UpdateValue and TinyBlock behaviors call recovery methods to populate BaseRound with provided data BEFORE validation: [3](#0-2) 

But NextRound has no such recovery step - the validation context is created directly after recovery for other behaviors, but NextRound skips this step entirely: [4](#0-3) 

The validation context provides both `BaseRound` (trusted state) and `ProvidedRound` (untrusted data): [5](#0-4) 

But the validator uses only `ProvidedRound`, ignoring `BaseRound` entirely.

**What should be validated**: The code comment explicitly states the intended invariant - miners who determined next round order should equal miners who mined during current round. The validation should verify that miners in `ProvidedRound` match those who actually participated in `BaseRound`, identified by `GetMinedMiners()`: [6](#0-5) 

This method identifies miners with `SupposedOrderOfNextRound != 0`, which is set when miners produce blocks: [7](#0-6) 

After the ineffective validation passes, the malicious round is directly stored: [8](#0-7) 

## Impact Explanation

**HIGH Severity** - This vulnerability breaks a critical consensus invariant:

1. **Consensus Integrity Violation**: A malicious extra block producer can manipulate who mines in the next round, directly violating the documented rule that miners who participated in the current round should determine next round participation.

2. **Reward Manipulation**: 
   - Legitimate miners who participated in the current round can be excluded from the next round, losing one round of block rewards
   - Non-participating miners or miners who missed their slots can be improperly included, receiving undeserved rewards
   - The mining order can be manipulated to favor specific miners for extra block producer assignment

3. **Decentralization Impact**: Excluding legitimate miners reduces network decentralization and undermines the fairness of the consensus mechanism.

4. **All Miners Affected**: Any miner can be victimized when a malicious miner gains the extra block producer role, affecting the entire validator set.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability is easily exploitable:

1. **Attacker Profile**: Any miner in the network can exploit this when they gain the extra block producer role, which rotates deterministically based on the first miner's signature in each round: [9](#0-8) 

2. **Attack Complexity**: LOW
   - Wait for turn as extra block producer
   - Craft `NextRoundInput` with arbitrary miner list and orders via the input structure
   - The validation (0 == 0 check) automatically passes
   - Malicious round is stored and becomes authoritative

3. **No Special Preconditions**: Only requires being a miner in the current validator set - no additional privileges or timing requirements beyond the normal consensus rotation.

4. **Detection Difficulty**: The manipulated round structure appears valid with all fields properly populated, making it indistinguishable from legitimate rounds without explicit comparison against expected state.

5. **Frequent Opportunity**: Every NextRound transition (end of each round) provides an opportunity, and all miners eventually rotate into the extra block producer role.

## Recommendation

Add a recovery method for NextRound behavior similar to UpdateValue and TinyBlock, or directly validate the ProvidedRound against BaseRound:

1. **Option 1**: Add `BaseRound.RecoverFromNextRound()` before validation to populate BaseRound with expected values, then validate against it.

2. **Option 2**: Modify `NextRoundMiningOrderValidationProvider` to compare `ProvidedRound` miners against `BaseRound.GetMinedMiners()`:
   - Verify that miners in ProvidedRound exactly match those with `SupposedOrderOfNextRound != 0` in BaseRound
   - Verify their `Order` values in ProvidedRound correspond to their `FinalOrderOfNextRound` from BaseRound
   - Ensure no unauthorized miners are included and no participating miners are excluded

3. **Option 3**: Add validation in `ProcessNextRound` to verify the provided miner list matches the expected list from legitimate round generation before storing.

## Proof of Concept

A malicious miner can exploit this by:

1. Waiting until they are assigned the extra block producer role (happens through normal rotation)
2. Creating a `NextRoundInput` with `RealTimeMinersInformation` containing an arbitrary miner list (excluding legitimate participants or including non-participants)
3. Calling `NextRound(maliciousInput)` when producing their extra block
4. The validation will check if count of miners with `FinalOrderOfNextRound > 0` equals count with `OutValue != null` in the provided round
5. Since these fields are at defaults (0 and null) in legitimate NextRound data, the check passes regardless of who is in the miner list
6. The malicious round is stored via `AddRoundInformation(nextRound)` and becomes the authoritative next round
7. The manipulated miner schedule takes effect, excluding legitimate miners from block production and rewards

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-27)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L242-247)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```
