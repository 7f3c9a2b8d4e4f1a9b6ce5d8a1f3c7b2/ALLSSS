# Audit Report

## Title
Unbounded Loop DoS in MinersCount Reduction via Branch Count Threshold Exceeded

## Summary
When `MinersCount` is drastically reduced through governance, the `SyncSubsidyInfoAfterReduceMiner` method attempts to remove all excess candidates in a single transaction without batching or upper bound checks. With hundreds of removals, each involving cross-contract calls, the transaction exceeds AElf's 15,000 branch count limit and throws `RuntimeBranchThresholdExceededException`, causing a DoS that prevents legitimate miner count adjustments. [1](#0-0) 

## Finding Description

The vulnerability exists in the `SyncSubsidyInfoAfterReduceMiner` method which performs an unbounded loop over excess candidates when miner count is reduced. [2](#0-1) 

**Execution Flow:**

1. Governance calls `SetMaximumMinersCount` via Parliament, which validates only that the value is greater than zero (no upper limit) [3](#0-2) 

2. This triggers `UpdateMinersCount` in the Election contract, which calls `SyncSubsidyInfoAfterReduceMiner` [4](#0-3) 

3. The method calculates `validDataCenterCount` as `MinersCount * 5` using `GetValidationDataCenterCount()` [5](#0-4) 

4. If `DataCentersRankingList` exceeds this limit, it loops through **ALL** `diffCount` excess candidates without any iteration limit or batching mechanism [6](#0-5) 

5. Each iteration calls `RemoveBeneficiary`, which makes a cross-contract call to ProfitContract [7](#0-6) 

6. The ProfitContract's `RemoveBeneficiary` performs additional operations including nested loops and LINQ operations [8](#0-7) [9](#0-8) 

**Why This Causes DoS:**

AElf enforces a **15,000 branch count limit** per transaction to prevent infinite loops. The ExecutionObserver tracks control flow transfers and throws `RuntimeBranchThresholdExceededException` when exceeded: [10](#0-9) [11](#0-10) 

**Realistic Scenario:**
- Governance sets `MaximumMinersCount` to 100 (allowed, only validates > 0)
- Over time, 500 candidates join `DataCentersRankingList` (100 × 5 = capacity) [12](#0-11) 

- Network decides to reduce `MaximumMinersCount` to 1
- `UpdateMinersCount` attempts to remove 495 candidates (500 - 5)
- With ~30-40 branches per iteration (foreach, cross-contract calls, LINQ operations, nested loops), total branches: 495 × 35 = **17,325** (exceeds 15,000 limit)
- Transaction fails with `RuntimeBranchThresholdExceededException`

**No Protections:**
The code contains no maximum iteration cap, batching mechanism, or branch count threshold check in the removal loop.

## Impact Explanation

**Operational Denial of Service:**
- The `UpdateMinersCount` function becomes permanently unusable when large reductions are needed
- Network governance cannot reduce miner count during security incidents, network optimization, or economic adjustments
- Critical governance function is DoS'd, preventing the network from adapting to changing conditions
- Emergency response capabilities are compromised, and long-term network evolution is blocked

This breaks the **availability guarantee** of governance functions - the system cannot perform legitimate administrative operations when scaling down is required, effectively locking the network into a high miner count configuration.

## Likelihood Explanation

**High Likelihood in Production:**

The vulnerable state emerges from **legitimate operations**, not malicious actions:

1. **Initial Growth Phase**: Network starts with high `MaximumMinersCount` (50-100) to encourage participation
2. **Natural Accumulation**: Hundreds of candidates announce and receive votes, filling `DataCentersRankingList` to capacity
3. **Network Maturity**: Governance decides to reduce miner count for efficiency
4. **DoS Triggered**: Reduction attempt exceeds branch limit

**Evidence:**
- `MaximumMinersCount` has no hardcoded upper bound (only validated > 0) [13](#0-12) 

- Testing only validates small reductions (10 candidates removed in existing test) [14](#0-13) 

- The branch count limit is enforced and tested at exactly 15,000 iterations [15](#0-14) 

**Probability: Medium-High** - Any long-running network that needs to scale down miner participation will face this issue during normal operational adjustments.

## Recommendation

Implement a batched removal mechanism with iteration limits:

```csharp
private void SyncSubsidyInfoAfterReduceMiner()
{
    var rankingList = State.DataCentersRankingList.Value;
    if (rankingList == null)
        return;
    var validDataCenterCount = GetValidationDataCenterCount();
    if (rankingList.DataCenters.Count <= validDataCenterCount) return;
    
    Context.LogDebug(() => "sync DataCenter after reduce bp");
    var diffCount = rankingList.DataCenters.Count.Sub(validDataCenterCount);
    
    // Add maximum batch size to prevent branch threshold exceeded
    const int maxBatchSize = 50;
    var batchSize = Math.Min(diffCount, maxBatchSize);
    
    var toRemoveList = rankingList.DataCenters.OrderBy(x => x.Value)
        .Take(batchSize).ToList();
    foreach (var kv in toRemoveList)
    {
        rankingList.DataCenters.Remove(kv.Key);
        RemoveBeneficiary(kv.Key);
    }

    State.DataCentersRankingList.Value = rankingList;
    
    // If more candidates need removal, require another transaction
    if (diffCount > maxBatchSize)
    {
        Context.Fire(new CandidateRemovalIncomplete
        {
            RemainingCount = diffCount - maxBatchSize
        });
    }
}
```

Alternatively, allow the consensus contract to call `UpdateMinersCount` multiple times with progressive reductions, or implement a separate batched removal method callable by governance.

## Proof of Concept

A test demonstrating this vulnerability would create a scenario with high `MaximumMinersCount`, fill the `DataCentersRankingList` to capacity, then attempt to reduce to a very low value. The transaction would fail with `RuntimeBranchThresholdExceededException`:

```csharp
[Fact]
public async Task UpdateMinersCount_LargeReduction_ExceedsBranchThreshold()
{
    // Setup: Set high miner count and fill data center list
    var initialMinersCount = 100;
    await SetMaximumMinersCount(initialMinersCount);
    
    // Add 500 candidates (100 * 5)
    for (int i = 0; i < 500; i++)
    {
        await AnnounceElectionAsync(ValidationDataCenterKeyPairs[i]);
        await VoteToCandidateAsync(voter, ValidationDataCenterKeyPairs[i].PublicKey.ToHex(), lockTime, voteAmount + i);
    }
    
    // Attempt drastic reduction from 100 to 1 (requires removing 495 candidates)
    await SetMaximumMinersCount(1);
    
    // This should throw RuntimeBranchThresholdExceededException
    var result = await NextTermWithException();
    result.TransactionResult.Error.ShouldContain("RuntimeBranchThresholdExceededException");
}
```

This test would fail with the branch threshold exception when attempting to remove 495 candidates in a single transaction, confirming the DoS vulnerability.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L359-377)
```csharp
    private void SyncSubsidyInfoAfterReduceMiner()
    {
        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList == null)
            return;
        var validDataCenterCount = GetValidationDataCenterCount();
        if (rankingList.DataCenters.Count <= validDataCenterCount) return;
        Context.LogDebug(() => "sync DataCenter after reduce bp");
        var diffCount = rankingList.DataCenters.Count.Sub(validDataCenterCount);
        var toRemoveList = rankingList.DataCenters.OrderBy(x => x.Value)
            .Take(diffCount).ToList();
        foreach (var kv in toRemoveList)
        {
            rankingList.DataCenters.Remove(kv.Key);
            RemoveBeneficiary(kv.Key);
        }

        State.DataCentersRankingList.Value = rankingList;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L102-109)
```csharp
        else if (dataCenterList.DataCenters.Count < GetValidationDataCenterCount())
        {
            // add data center
            dataCenterList.DataCenters.Add(input.CandidatePubkey,
                State.CandidateVotes[input.CandidatePubkey].ObtainedActiveVotedVotesAmount);

            AddBeneficiary(input.CandidatePubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L797-807)
```csharp
    private void RemoveBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var previousSubsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            Beneficiary = beneficiaryAddress,
            ProfitDetailId = previousSubsidyId
        });
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L308-360)
```csharp
    private RemovedDetails RemoveProfitDetails(Scheme scheme, Address beneficiary, Hash profitDetailId = null)
    {
        var removedDetails = new RemovedDetails();

        var profitDetails = State.ProfitDetailsMap[scheme.SchemeId][beneficiary];
        if (profitDetails == null)
        {
            return removedDetails;
        }
        
        // remove all removalbe profitDetails.
        // If a scheme can be cancelled, get all available profitDetail.
        // else, get those available and out of date ones.
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
        //id == null
        if (scheme.CanRemoveBeneficiaryDirectly && profitDetailId != null)
        {
            detailsCanBeRemoved = detailsCanBeRemoved.All(d => d.Id != profitDetailId)
                ? detailsCanBeRemoved.Where(d => d.Id == null).ToList()
                : detailsCanBeRemoved.Where(d => d.Id == profitDetailId).ToList();
        }

        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }

        if (detailsCanBeRemoved.Any())
        {
            foreach (var profitDetail in detailsCanBeRemoved)
            {
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }

                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
            }

```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-36)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L1844-1856)
```csharp
        var fullCount = 5.Mul(5);
        foreach (var keyPair in ValidationDataCenterKeyPairs.Take(fullCount))
        {
            await AnnounceElectionAsync(keyPair);
            await VoteToCandidateAsync(voter, keyPair.PublicKey.ToHex(), lockTime, voteAmount);
            voteAmount = voteAmount.Add(span);
        }

        var minerCount = 3;
        await NextRound(InitialCoreDataCenterKeyPairs[0]);
        var dataCenterList = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
        dataCenterList.DataCenters.Count.ShouldBe(fullCount);
        var diffCount = fullCount.Sub(minerCount.Mul(5));
```

**File:** test/AElf.Contracts.TestContract.Tests/PatchedContractSecurityTests.cs (L392-406)
```csharp
            await TestBasicSecurityContractStub.TestWhileInfiniteLoop.SendAsync(new Int32Input
                { Int32Value = 14999 });
            var txResult = await TestBasicSecurityContractStub.TestWhileInfiniteLoop.SendWithExceptionAsync(
                new Int32Input
                    { Int32Value = 15000 });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }

        {
            await TestBasicSecurityContractStub.TestForInfiniteLoop.SendAsync(new Int32Input { Int32Value = 14999 });
            var txResult = await TestBasicSecurityContractStub.TestForInfiniteLoop.SendWithExceptionAsync(
                new Int32Input
                    { Int32Value = 15000 });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }
```
