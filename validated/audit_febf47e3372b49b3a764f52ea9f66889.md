# Audit Report

## Title
Term Transition Bypass via Hardcoded isNewTerm in TinyBlock Termination Strategy

## Summary
When a miner producing tiny blocks terminates their time slot, the `TinyBlockCommandStrategy` hardcodes `isNewTerm=false` when creating a `TerminateRoundCommandStrategy`, bypassing the proper term transition check. This causes `ProcessNextRound` to execute instead of `ProcessNextTerm` when a term change is required, allowing old miners to continue, preventing mining rewards from being donated to treasury, and causing blocks to be produced with insufficient mining time limits.

## Finding Description

**Root Cause:**

In `TinyBlockCommandStrategy.GetAEDPoSConsensusCommand()`, when the arranged mining time exceeds the current time slot, the code creates a `TerminateRoundCommandStrategy` with `isNewTerm` hardcoded to `false` [1](#0-0) 

This bypasses the proper term transition logic that should occur in `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()`, which checks `CurrentRound.NeedToChangeTerm()` to determine whether to return `NextTerm` or `NextRound` [2](#0-1) 

The `NeedToChangeTerm()` method checks if at least two-thirds of miners have produced blocks whose timestamps indicate a term transition is required [3](#0-2) 

**Why Protections Fail:**

The `isNewTerm` parameter in `TerminateRoundCommandStrategy` directly determines the consensus behaviour and mining time limit [4](#0-3) 

When `isNewTerm=false`, the system uses `DefaultBlockMiningLimit` instead of `LastBlockOfCurrentTermMiningLimit`. The mining limits show an 8x difference [5](#0-4) 

The validation in `RoundTerminateValidationProvider` does NOT check whether a term transition should have occurred - it only validates that round/term numbers increment correctly [6](#0-5) 

**Execution Path:**

When consensus command generation occurs via `GetConsensusCommand()`, the behavior provider determines `TinyBlock` behavior for the extra block producer [7](#0-6) 

The command strategy is selected based on the behavior [8](#0-7) 

When the miner produces a block with `NextRound` behavior (due to the hardcoded `false`), the consensus transaction is generated [9](#0-8) 

Finally, `ProcessNextRound()` is executed instead of `ProcessNextTerm()` [10](#0-9) 

## Impact Explanation

When `ProcessNextRound()` is executed instead of `ProcessNextTerm()`, critical term transition operations are skipped. Compare the two methods:

**ProcessNextRound** only performs basic round progression [11](#0-10) 

**ProcessNextTerm** performs essential term transition operations that are completely skipped [12](#0-11) 

The skipped operations include:
1. **Term number not updated** - Breaking term progression invariant
2. **Miner list not updated** - Old miners continue instead of newly elected miners [13](#0-12) 
3. **Mining rewards not donated** - `DonateMiningReward()` not called [14](#0-13) 
4. **Treasury release not triggered** - Treasury contract doesn't receive scheduled release [15](#0-14) 
5. **Election snapshot not taken** - Disrupting reward distribution to voters [16](#0-15) 
6. **Miner statistics not reset** - `MissedTimeSlots` and `ProducedBlocks` not cleared [17](#0-16) 
7. **Insufficient mining time** - Block produced with 1/8th the required time limit

This represents a complete breakdown of the term transition mechanism, affecting elections, economics, treasury operations, and governance.

## Likelihood Explanation

**Attacker Capabilities:**

The extra block producer from the previous round can trigger this vulnerability. This role rotates naturally as miners terminate rounds. The maximum blocks count is configurable but typically 8 [18](#0-17) 

**Attack Feasibility:**

The attack requires:
1. Being the extra block producer (rotates naturally)
2. Waiting until a term transition is required
3. Producing tiny blocks until the time slot ends
4. The bug triggers automatically without special permissions

**Probability:**

This can occur **accidentally** during normal operations when a term transition becomes required while a miner is producing tiny blocks. It can also be **intentionally triggered** by malicious miners who want to prevent newly elected miners from taking over, delay treasury operations, or maintain the current miner set.

If multiple consecutive extra block producers trigger this bug (through collusion or accident), term transitions can be delayed indefinitely, causing sustained governance and economic disruption.

## Recommendation

The `TinyBlockCommandStrategy` should use the behavior provider to determine whether a term transition is required, rather than hardcoding `false`. 

Replace the hardcoded value with a proper check:

```csharp
// In TinyBlockCommandStrategy.GetAEDPoSConsensusCommand()
if (arrangedMiningTime > currentTimeSlotEndTime)
{
    // Use the behavior provider to determine if term transition is needed
    var behaviour = new MainChainConsensusBehaviourProvider(
        CurrentRound, 
        Pubkey, 
        _maximumBlocksCount,
        CurrentBlockTime,
        blockchainStartTimestamp, // Need to pass this parameter
        periodSeconds // Need to pass this parameter
    ).GetConsensusBehaviourToTerminateCurrentRound();
    
    bool isNewTerm = behaviour == AElfConsensusBehaviour.NextTerm;
    
    return new TerminateRoundCommandStrategy(
        CurrentRound, 
        Pubkey, 
        CurrentBlockTime, 
        isNewTerm
    ).GetAEDPoSConsensusCommand();
}
```

## Proof of Concept

A PoC would require setting up a test scenario where:
1. Configure a term with period of 7 seconds for quick testing
2. Deploy consensus contract and initialize miners
3. Advance time to just before term transition boundary
4. Have the extra block producer start producing tiny blocks
5. Allow their time slot to exceed while term transition becomes required
6. Verify that `ProcessNextRound()` is called instead of `ProcessNextTerm()`
7. Confirm term number not updated, old miners still active, no rewards donated

The test would verify that the miner list remains unchanged and no treasury donation occurs, demonstrating the bypass of term transition logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L40-42)
```csharp
            return arrangedMiningTime > currentTimeSlotEndTime
                ? new TerminateRoundCommandStrategy(CurrentRound, Pubkey, CurrentBlockTime, false)
                    .GetAEDPoSConsensusCommand() // The arranged mining time already beyond the time slot.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L29-38)
```csharp
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L49-60)
```csharp
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);

        /// <summary>
        ///     If this tiny block is the last one of current time slot, give half of producing time for mining.
        /// </summary>
        protected int LastTinyBlockMiningLimit => TinyBlockSlotInterval.Div(2);

        /// <summary>
        ///     If this block is of consensus behaviour NEXT_TERM, the producing time is MiningInterval,
        ///     so the limitation of mining is 8 times than DefaultBlockMiningLimit.
        /// </summary>
        protected int LastBlockOfCurrentTermMiningLimit => MiningInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L39-46)
```csharp
        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L46-52)
```csharp
            case AElfConsensusBehaviour.TinyBlock:
            {
                var consensusCommand =
                    new ConsensusCommandProvider(new TinyBlockCommandStrategy(currentRound, pubkey,
                        currentBlockTime, GetMaximumBlocksCount())).GetConsensusCommand();
                return consensusCommand;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L37-44)
```csharp
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
