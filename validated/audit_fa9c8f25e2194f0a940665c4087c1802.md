# Audit Report

## Title
ImpliedIrreversibleBlockHeight Validation Bypass Due to Premature State Recovery

## Summary
The `LibInformationValidationProvider` validation logic in the AEDPoS consensus contract is broken because `RecoverFromUpdateValue` modifies the `baseRound` state before validation occurs. This causes the validation check to compare identical values instead of comparing StateDb values against newly provided values, allowing malicious miners to report artificially low `ImpliedIrreversibleBlockHeight` values that would otherwise be rejected. This can prevent Last Irreversible Block (LIB) advancement if 1/3+ miners collude.

## Finding Description

The vulnerability exists in the validation flow for UpdateValue consensus behavior. The validation sequence executes as follows:

1. **State Retrieval**: The validation process begins by fetching the current round from StateDb [1](#0-0) 

2. **Premature Recovery**: Before validation providers are invoked, `RecoverFromUpdateValue` is called on `baseRound` for UpdateValue behavior [2](#0-1) 

3. **State Corruption**: The `RecoverFromUpdateValue` method copies values from `providedRound` into `baseRound`, including the miner's `ImpliedIrreversibleBlockHeight` [3](#0-2) 

4. **Validation Context Creation**: A validation context is created using the now-modified `baseRound` [4](#0-3) 

5. **Broken Validation**: The `LibInformationValidationProvider` is added to validators [5](#0-4)  and attempts to validate that the miner's `ImpliedIrreversibleBlockHeight` hasn't decreased [6](#0-5) 

**Root Cause**: Since `baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` was already overwritten with `providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight`, the comparison always evaluates identical values. The check can never detect a decrease because both sides of the comparison reference the same value.

The intended behavior is to compare the value from StateDb (representing the miner's previously reported height) against the new value being provided, rejecting any regression. However, the premature recovery destroys the StateDb baseline before comparison occurs.

## Impact Explanation

**Operational Impact - High Severity**:

1. **LIB Finalization Prevention**: Malicious miners can report artificially low `ImpliedIrreversibleBlockHeight` values without detection. During LIB calculation, these values are sorted and the value at position `(count-1)/3` is selected as the new LIB height [7](#0-6) . If 1/3+ miners collude to provide artificially low values, the calculated LIB will be suppressed.

2. **Cross-Chain Operations Disruption**: LIB height is critical for cross-chain verification and merkle proof validation. Stalled LIB prevents parent/side-chain synchronization and cross-chain message processing.

3. **State Management Issues**: LIB determines which blocks can be safely pruned from the state database. Preventing LIB advancement causes unbounded state growth and eventual resource exhaustion.

4. **Transaction Finality Delay**: Users cannot achieve finality guarantees on their transactions when LIB is stalled, affecting economic activity and user confidence in the system.

While this is a liveness attack rather than a safety violation (LIB cannot decrease due to the check at line 272 of ProcessUpdateValue [8](#0-7) ), the operational impact is severe enough to warrant HIGH severity classification.

## Likelihood Explanation

**Medium Likelihood**:

**Attacker Capabilities**: 
- Must be an elected miner in the consensus round (achievable through the election mechanism)
- Can modify consensus extra data before block production, as the `ImpliedIrreversibleBlockHeight` is set by the contract [9](#0-8)  and the miner receives this data which they can tamper with before signing and producing the block

**Attack Complexity**: 
- Low complexity for an individual miner to provide false data
- Medium complexity to coordinate 1/3+ miners for significant LIB impact
- No cryptographic protection prevents miners from modifying their own consensus extra data

**Feasibility Conditions**:
- Block validation is sequential, eliminating race conditions
- Post-execution validation also fails to detect tampering since StateDb is already updated with fake values
- No upper-bound validation exists, only the broken lower-bound check

**Detection/Operational Constraints**:
- Attack is detectable through explicit monitoring of individual miner `ImpliedIrreversibleBlockHeight` reports
- Miners have reputation and economic stake at risk through the election mechanism
- However, subtle variations in reported heights may go unnoticed without dedicated monitoring infrastructure

The attack requires malicious intent from elected miners but is technically straightforward to execute once mining permissions are obtained through the election process.

## Recommendation

The fix requires preserving the original StateDb values for validation purposes. Store the original `ImpliedIrreversibleBlockHeight` value before calling `RecoverFromUpdateValue`:

```csharp
// In ValidateBeforeExecution method, before line 46:
var originalImpliedHeight = baseRound.RealTimeMinersInformation.ContainsKey(extraData.SenderPubkey.ToHex())
    ? baseRound.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()].ImpliedIrreversibleBlockHeight
    : 0;

if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

// Then pass originalImpliedHeight to the validation context for use by validators
```

Alternatively, restructure the validation flow to perform all validation checks BEFORE calling `RecoverFromUpdateValue`, ensuring validators always compare against pristine StateDb values.

A third approach is to modify the validation context to include both the original StateDb round and the recovered round as separate properties, allowing validators to explicitly compare the two.

## Proof of Concept

A conceptual PoC would demonstrate:

1. Setup: Deploy AEDPoS consensus contract with multiple elected miners
2. Obtain miner status through the election mechanism
3. Produce a block with UpdateValue behavior where:
   - The miner's previous `ImpliedIrreversibleBlockHeight` in StateDb is X
   - The miner provides a new `ImpliedIrreversibleBlockHeight` of X-100 (artificially low value)
4. Observe that:
   - The validation passes (no error thrown by LibInformationValidationProvider)
   - The artificially low value X-100 is stored in state
   - Subsequent LIB calculations use this corrupted value
5. With 1/3+ miners providing low values, demonstrate LIB stalling

The test would verify that the validation check at LibInformationValidationProvider lines 25-26 never rejects the decreased height because both `baseRound` and `providedRound` contain identical values after `RecoverFromUpdateValue` executes.

## Notes

This vulnerability represents a critical flaw in the consensus validation logic. The broken monotonicity check for `ImpliedIrreversibleBlockHeight` undermines the LIB finalization mechanism, which is essential for blockchain finality, cross-chain operations, and state management. While the attack requires miner privileges and coordination, the impact on chain liveness justifies immediate remediation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L82-82)
```csharp
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-33)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-272)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
```
