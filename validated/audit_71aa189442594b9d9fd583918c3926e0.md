# Audit Report

## Title
Validators Can Manipulate Block Timestamps to Bypass Parliament Proposal Expiration

## Summary
Validators can set block timestamps backwards to bypass Parliament proposal expiration checks, allowing them to vote on and execute governance proposals after their intended expiration time. This occurs because block validation only enforces an upper bound on timestamps (no more than 4 seconds ahead of UTC) but lacks any lower bound or monotonicity checks.

## Finding Description

The Parliament contract validates proposal expiration by comparing `Context.CurrentBlockTime` against the proposal's `ExpiredTime`. [1](#0-0)  This check is called whenever a proposal is validated, including during `Approve`, `Reject`, `Abstain` operations. [2](#0-1) 

The `Context.CurrentBlockTime` value is derived from the block header's timestamp, which is set by the block producer during block generation. [3](#0-2)  The timestamp comes from the `blockTime` parameter provided during mining. [4](#0-3) 

Block validation only prevents timestamps that are more than 4 seconds **ahead** of current UTC time. [5](#0-4)  The threshold is defined as 4 seconds. [6](#0-5) 

Critically, there is **no validation** ensuring block timestamps are monotonically increasing or preventing validators from setting timestamps to past values. The consensus `TimeSlotValidationProvider` only validates the miner's **previous** `ActualMiningTimes` from the base round, not the current block's timestamp. [7](#0-6) 

The current block's timestamp is added to `ActualMiningTimes` **after** validation during consensus transaction processing. [8](#0-7) [9](#0-8) 

**Attack Scenario:**
1. A Parliament proposal expires at time T = 1000
2. Current real-world time is T = 1050 (proposal already expired)
3. A malicious validator produces a block with timestamp = 999
4. Block validation passes: 999 ≤ 1050 + 4 = 1054 ✓
5. During execution, `Context.CurrentBlockTime` = 999
6. Parliament expiration check: 999 < 1000 ✓ (passes - proposal appears valid)
7. Validator successfully votes on the expired proposal

This affects all Parliament governance operations: [10](#0-9) [11](#0-10) 

## Impact Explanation

This vulnerability has **High** severity impact because it directly violates the governance time-lock mechanism, which is a critical security invariant. The proposal expiration system exists to ensure that governance actions cannot be approved or executed indefinitely, providing a safety mechanism for the protocol.

By bypassing expiration checks, malicious validators can:
- Vote on proposals that stakeholders believed had safely expired
- Execute governance actions that were no longer actively supported
- Circumvent the intended temporal bounds on governance decisions
- Undermine the predictability and safety of the governance process

The impact extends to all Parliament proposals across the entire protocol, potentially affecting critical system configurations, upgrades, and resource allocations. The same pattern affects Association and Referendum contracts as well.

## Likelihood Explanation

The likelihood of exploitation is **High** because:

1. **Low Complexity**: The attack requires only setting a block header timestamp to a past value during the mining process - no complex state manipulation or multiple transactions needed.

2. **Realistic Attacker**: Any validator with an active mining slot can execute this attack. In AEDPoS consensus, validators regularly produce blocks as part of normal operations.

3. **No Special Preconditions**: The attack doesn't require:
   - Compromising cryptographic keys
   - Coordinating with other validators
   - Exploiting race conditions
   - Manipulating complex state

4. **Persistent Effect**: The manipulated timestamp applies to all transactions in that block, making the attack straightforward and effective.

5. **Detection Difficulty**: While timestamp manipulation might be observable in block explorers, there is no automatic validation that rejects such blocks, so the attack succeeds before detection can prevent it.

## Recommendation

Implement monotonicity checks for block timestamps to ensure each block's timestamp is greater than or equal to its parent block's timestamp. Add validation in `BlockValidationProvider.ValidateBeforeAttachAsync`:

```csharp
// Add check for monotonicity
var chain = await _blockchainService.GetChainAsync();
if (block.Header.Height > AElfConstants.GenesisBlockHeight)
{
    var previousBlock = await _blockchainService.GetBlockByHashAsync(block.Header.PreviousBlockHash);
    if (previousBlock != null && block.Header.Time < previousBlock.Header.Time)
    {
        Logger.LogDebug("Block timestamp is earlier than previous block");
        return Task.FromResult(false);
    }
}
```

Additionally, consider implementing a minimum acceptable timestamp threshold based on recent block times to prevent significant backwards time manipulation.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a Parliament proposal with `ExpiredTime` set to a specific timestamp
2. Advancing real-world time past the expiration
3. A validator producing a block with a backdated timestamp (before expiration but within 4 seconds of current UTC)
4. Successfully calling `Parliament.Approve()` on the expired proposal within that block
5. The approval succeeds despite the proposal being expired in real-world time

The key validation points that fail to prevent this are clearly identified in the cited code sections above.

## Notes

This vulnerability affects not only Parliament but also Association and Referendum governance contracts, as they follow the same pattern of checking `Context.CurrentBlockTime` against proposal expiration times. The root cause is the lack of lower bound validation on block timestamps at the blockchain core level, combined with the consensus layer's reliance on this unvalidated timestamp for all time-based contract logic.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/BlockGenerationService.cs (L17-36)
```csharp
    public async Task<Block> GenerateBlockBeforeExecutionAsync(GenerateBlockDto generateBlockDto)
    {
        var block = new Block
        {
            Header = new BlockHeader
            {
                ChainId = _staticChainInformationProvider.ChainId,
                Height = generateBlockDto.PreviousBlockHeight + 1,
                PreviousBlockHash = generateBlockDto.PreviousBlockHash,
                Time = generateBlockDto.BlockTime
            },
            Body = new BlockBody()
        };

        // get block extra data with _blockExtraDataService including consensus data, cross chain data etc.. 
        await _blockExtraDataService.FillBlockExtraDataAsync(block.Header);
        // calculate and set tx merkle tree root 
        //block.Complete(currentBlockTime, results);
        return block;
    }
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L124-134)
```csharp
    private async Task<Block> GenerateBlock(Hash preBlockHash, long preBlockHeight, Timestamp expectedMiningTime)
    {
        var block = await _blockGenerationService.GenerateBlockBeforeExecutionAsync(new GenerateBlockDto
        {
            PreviousBlockHash = preBlockHash,
            PreviousBlockHeight = preBlockHeight,
            BlockTime = expectedMiningTime
        });
        block.Header.SignerPubkey = ByteString.CopyFrom(await _accountService.GetPublicKeyAsync());
        return block;
    }
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L133-139)
```csharp
        if (block.Header.Height != AElfConstants.GenesisBlockHeight &&
            block.Header.Time.ToDateTime() - TimestampHelper.GetUtcNow().ToDateTime() >
            KernelConstants.AllowedFutureBlockTimeSpan.ToTimeSpan())
        {
            Logger.LogDebug("Future block received {Block}, {BlockTime}", block, block.Header.Time.ToDateTime());
            return Task.FromResult(false);
        }
```

**File:** src/AElf.Kernel.Types/KernelConstants.cs (L19-19)
```csharp
    public static Duration AllowedFutureBlockTimeSpan = new() { Seconds = 4 };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-244)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L78-94)
```csharp
    public override Empty Approve(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Approvals.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
