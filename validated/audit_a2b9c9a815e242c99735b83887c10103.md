# Audit Report

## Title
Integer Overflow in TokenHolder Withdraw Function Enables Permanent Token Lock via Malicious MinimumLockMinutes

## Summary
The `Withdraw()` function in TokenHolderContract contains a critical vulnerability where excessively large `MinimumLockMinutes` values cause an integer overflow during time validation, permanently trapping user funds. The overflow occurs in checked arithmetic operations, throwing an `OverflowException` that prevents withdrawal transactions from completing, leaving tokens locked indefinitely with no recovery mechanism.

## Finding Description

The vulnerability exists in the `Withdraw()` function's lock time validation logic, which performs an assertion to ensure the minimum lock period has elapsed before allowing withdrawals. [1](#0-0) 

When this assertion evaluates, it calls `AddMinutes()` which internally multiplies the minutes parameter by 60 to convert to seconds. [2](#0-1) 

The `Mul()` operation uses checked arithmetic that throws exceptions on overflow rather than wrapping silently. [3](#0-2) 

The root cause is that `CreateScheme()` accepts `MinimumLockMinutes` without any validation or bounds checking, allowing attackers to set arbitrarily large values. [4](#0-3) 

**Attack Execution Path:**
1. Attacker calls `CreateScheme()` with `MinimumLockMinutes = Int64.MaxValue` (or any value > 153,722,867,280,912,930)
2. Victim calls `RegisterForProfits()`, which locks tokens via the Token contract's Lock function
3. When victim attempts `Withdraw()`, the calculation `Int64.MaxValue * 60` overflows
4. The checked arithmetic throws `OverflowException`, causing transaction revert
5. Tokens remain locked with no alternative unlock path

**Why Users Cannot Bypass:**

The Token contract's `Unlock()` function computes virtual addresses based on `Context.Sender`, making direct unlock impossible for users. [5](#0-4) 

During `RegisterForProfits()`, tokens are locked to a virtual address computed as `Hash(TokenHolderContract || userAddress || lockId)`. [6](#0-5) 

If users call `Unlock()` directly, it computes `Hash(userAddress || userAddress || lockId)` - a different address, making token recovery impossible. Additionally, users must pass system contract permission checks which they cannot satisfy. [7](#0-6) 

**Why Other Protections Fail:**

The scheme manager's `RemoveBeneficiary()` function only removes beneficiaries from the profit scheme but does not unlock tokens from the Token contract. [8](#0-7) 

The ProfitContract's `RemoveBeneficiary()` similarly only manipulates profit share accounting without unlocking tokens. [9](#0-8) 

The TokenHolderContract has no alternative unlock mechanism - `Withdraw()` is the only method that calls Token.Unlock. [10](#0-9) 

## Impact Explanation

**Severity: HIGH**

**Direct Fund Impact:**
- Users lose 100% of tokens locked in malicious schemes permanently
- No recovery mechanism exists at contract level - tokens cannot be unlocked by users, scheme managers, or any admin function
- Each victim experiences complete, irrecoverable token loss for their entire locked amount

**Scope of Damage:**
- Any user who calls `RegisterForProfits` on a scheme with overflow-inducing `MinimumLockMinutes` loses all locked tokens
- The attacker does not gain direct access to funds but achieves permanent user fund denial
- Funds are not transferred to attacker but become permanently inaccessible in the virtual address

**Why HIGH Severity:**
1. **Permanence**: No time-based recovery or admin intervention possible - tokens are locked forever
2. **Completeness**: 100% of locked amount is lost with no partial recovery
3. **No Authorization Required**: Any address can create malicious schemes without permissions
4. **Simple Exploitation**: Single parameter manipulation in scheme creation
5. **Breaks Core Invariant**: Users should always be able to withdraw after lock period expires - this is a fundamental guarantee of the system that is violated

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

**Attacker Capabilities:**
- `CreateScheme()` is publicly accessible with no authorization checks - verified in code
- No special privileges, governance approval, or system contract status required
- Single transaction execution to set malicious parameter
- No transaction fees or token holdings required to create malicious scheme

**Attack Complexity: LOW**
- Set one parameter (`MinimumLockMinutes`) to extreme value (e.g., `Int64.MaxValue`)
- No complex transaction sequences, timing windows, or state manipulation required
- No need to manipulate oracle data, governance votes, or consensus mechanisms
- Attack is deterministic and guaranteed to work

**Feasibility Conditions:**
- Requires users to voluntarily register for profits in attacker's scheme
- `MinimumLockMinutes` value is queryable via `GetScheme()` but users unlikely to validate before registration
- Attacker can make scheme appear legitimate with attractive profit-sharing terms (e.g., high `AutoDistributeThreshold`)
- Value like `Int64.MaxValue` converts to ~292 million years - may appear as UI display bug rather than malicious parameter to non-technical users

**Detection Constraints:**
- No automatic validation or warnings during scheme creation
- Users must manually query scheme parameters before registration and understand the implications
- No UI/UX layer protections (this is a contract-level vulnerability)
- Malicious schemes would only show pattern of failed withdrawal transactions after exploitation begins

**Real-World Feasibility:**
Legitimate schemes use reasonable lock periods (typically days to months). Extreme values are clearly anomalous but detection requires users to proactively check parameters before participating, which is uncommon user behavior.

## Recommendation

Add validation to `CreateScheme()` to reject unreasonably large `MinimumLockMinutes` values:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation for MinimumLockMinutes
    Assert(input.MinimumLockMinutes >= 0 && input.MinimumLockMinutes <= 153722867280912930,
        "MinimumLockMinutes must be within valid range to prevent overflow.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

The maximum safe value is `Int64.MaxValue / 60 = 153,722,867,280,912,930` minutes (approximately 292 million years), though a more reasonable limit (e.g., 5 years = 2,628,000 minutes) would better serve practical use cases.

Alternative: Use unchecked overflow in the time validation logic, though this would allow setting timestamps far in the future, effectively achieving the same DoS but through a different mechanism.

## Proof of Concept

```csharp
[Fact]
public async Task TestOverflowVulnerability()
{
    // Attacker creates malicious scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = long.MaxValue // Malicious value
    });
    
    var schemeManager = DefaultSender; // Attacker's address
    
    // Victim registers for profits
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = schemeManager,
        Amount = 1000_00000000 // 1000 ELF
    });
    
    // Time passes...
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddYears(1));
    
    // Victim attempts to withdraw - this will throw OverflowException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await TokenHolderContractStub.Withdraw.SendAsync(schemeManager);
    });
    
    // Verify the withdrawal failed due to overflow
    Assert.Contains("Overflow", exception.Message);
    
    // Verify tokens remain locked
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = VictimAddress,
        Symbol = "ELF",
        LockId = lockId
    });
    Assert.Equal(1000_00000000, lockedAmount.Amount); // Tokens still locked
}
```

## Notes

This vulnerability affects all users who participate in TokenHolder profit schemes. The issue is particularly severe because:

1. **No Time-Based Recovery**: Unlike typical lock mechanisms where users can wait for expiration, these tokens are locked forever
2. **System-Wide Risk**: Any scheme can be created with malicious parameters, making this a protocol-wide vulnerability
3. **No Admin Override**: There are no emergency functions or governance mechanisms to recover locked tokens
4. **Silent Failure for Users**: Users have no way to detect the issue until they attempt withdrawal, at which point it's too late

The fix should be implemented immediately and existing schemes should be audited for potentially dangerous `MinimumLockMinutes` values.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-165)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L39-42)
```csharp
    public static Timestamp AddMinutes(this Timestamp timestamp, long minutes)
    {
        return timestamp + new Duration { Seconds = minutes.Mul(60) };
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L234-235)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** protobuf/token_holder_contract.proto (L44-46)
```text
    // After the lockup time expires, the user can withdraw token.
    rpc Withdraw (aelf.Address) returns (google.protobuf.Empty) {
    }
```
