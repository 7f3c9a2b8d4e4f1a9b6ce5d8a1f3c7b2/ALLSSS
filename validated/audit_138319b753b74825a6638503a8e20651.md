# Audit Report

## Title
Proposal Hash Squatting via Expired Entry Overwrite Enables Denial-of-Service and Authorship Hijacking

## Summary
The `RegisterContractProposingData` function in the Genesis contract (BasicContractZero) lacks validation to verify that the caller is the original proposer when overwriting an expired proposal entry. This allows any address to hijack expired proposal hashes, preventing legitimate proposers from re-submitting their proposals and potentially enabling authorship takeover through governance manipulation.

## Finding Description

The vulnerability exists in the `RegisterContractProposingData` helper function, which is invoked during contract deployment and update proposals. [1](#0-0) 

The root cause is insufficient validation when an expired proposal entry is overwritten. The function checks whether no entry exists OR the current time exceeds the expiration time, but then unconditionally creates a new entry with the caller as the proposer. [2](#0-1)  There is no verification that the caller is the original proposer before overwriting.

This function is called from both contract deployment and update proposal methods. [3](#0-2) [4](#0-3) 

Proposal hashes are deterministically computed from input parameters. [5](#0-4)  The default expiration period is 72 hours (259,200 seconds). [6](#0-5) 

The proposer identity is critical because `ReleaseApprovedContract` validates that only the registered proposer can progress the proposal. [7](#0-6)  Additionally, when contracts are deployed, the proposer can become the contract author if they are in the deployment controller's whitelist. [8](#0-7) [9](#0-8) 

**Attack Flow:**
1. Original proposer Alice calls `ProposeNewContract` with specific parameters, creating a proposal entry that expires in 72 hours
2. Proposal expires due to governance delays or timing issues
3. Attacker Bob calls `ProposeNewContract` with identical parameters
4. `RegisterContractProposingData` allows the overwrite because the expiration check passes
5. Bob becomes the new proposer, locking out Alice for another 72 hours
6. If Bob is whitelisted and his proposal passes governance, Bob becomes the contract author

## Impact Explanation

**Denial-of-Service Impact:** When a legitimate proposer's entry expires, an attacker can immediately re-register the same proposal hash as their own. The original proposer cannot re-submit for another 72 hours due to the "Already proposed" assertion. For deterministic contract deployments requiring specific salt values to achieve particular contract addresses, this becomes a permanent denial-of-service since changing the salt changes the resulting address.

**Authorship Hijacking Impact:** If the attacker is in the deployment controller's proposer whitelist and their duplicate proposal passes through Parliament approval and code checking, the attacker becomes the contract author instead of the legitimate designer. Contract authors have privileged operations including the ability to propose contract updates and transfer authorship. [10](#0-9) 

**Indefinite Squatting:** An attacker can maintain control over a proposal hash indefinitely by re-registering it every 72 hours before expiration, effectively preventing the legitimate proposer from ever using those parameters.

This violates the security invariant that proposal lifecycle should be controlled exclusively by the original proposer.

## Likelihood Explanation

**Attack Complexity:** Low. The attacker needs to:
1. Monitor the chain for expired proposal entries (easily automated)
2. Extract the input parameters from the original proposal transaction (publicly available on-chain)
3. Call `ProposeNewContract` or `ProposeUpdateContract` with identical parameters immediately after expiration

**Economic Barriers:** Minimal. No explicit fees, stakes, or deposits are required beyond standard transaction gas costs. The attacker doesn't need to complete the full governance process to achieve denial-of-service; merely registering the hash is sufficient to block the legitimate proposer.

**Entry Points:** The attack uses public methods `ProposeNewContract` and `ProposeUpdateContract` that are accessible to any address. Note that the proposer authority check is commented out in the code. [11](#0-10) 

**Realistic Scenario:** Legitimate proposals may expire due to governance bottlenecks, Parliament coordination delays, or deliberate timing by participants. Once expired, they become vulnerable to hijacking.

## Recommendation

Add a validation check in `RegisterContractProposingData` to verify that when overwriting an expired entry, the caller must be the original proposer:

```csharp
private void RegisterContractProposingData(Hash proposedContractInputHash)
{
    var registered = State.ContractProposingInputMap[proposedContractInputHash];
    
    // If entry exists and is expired, only original proposer can re-register
    if (registered != null && Context.CurrentBlockTime >= registered.ExpiredTime)
    {
        Assert(Context.Sender == registered.Proposer, 
            "Only the original proposer can re-register an expired proposal.");
    }
    else
    {
        Assert(registered == null, "Already proposed.");
    }
    
    var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
    State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
    {
        Proposer = Context.Sender,
        Status = ContractProposingInputStatus.Proposed,
        ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
    };
}
```

Alternatively, automatically remove expired entries to allow anyone to create a fresh proposal with the same parameters.

## Proof of Concept

```csharp
[Fact]
public async Task ProposalHashSquatting_ExpiredEntryOverwrite_Test()
{
    // Alice proposes a contract deployment
    var contractCode = Codes.Single(kv => kv.Key.Contains("MultiToken")).Value;
    var contractDeploymentInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(contractCode)
    };
    
    // Alice creates proposal
    var aliceTester = Tester.CreateNewContractTester(CreatorKeyPair);
    var aliceProposalResult = await aliceTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract),
        contractDeploymentInput);
    
    var aliceProposalHash = ContractProposed.Parser
        .ParseFrom(aliceProposalResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
        .ProposedContractInputHash;
    
    // Fast forward past expiration (72 hours + 1 second)
    await Tester.MineAsync(new List<Transaction>(), TimestampHelper.GetUtcNow().AddSeconds(259201));
    
    // Bob (attacker) submits identical proposal after expiration
    var bobTester = Tester.CreateNewContractTester(AnotherMinerKeyPair);
    var bobProposalResult = await bobTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract),
        contractDeploymentInput);
    
    bobProposalResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var bobProposalHash = ContractProposed.Parser
        .ParseFrom(bobProposalResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
        .ProposedContractInputHash;
    
    // Same proposal hash
    bobProposalHash.ShouldBe(aliceProposalHash);
    
    // Alice cannot re-submit now - she's locked out
    var aliceRetryResult = await aliceTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract),
        contractDeploymentInput);
    
    aliceRetryResult.Status.ShouldBe(TransactionResultStatus.Failed);
    aliceRetryResult.Error.ShouldContain("Already proposed");
    
    // Bob is now the proposer and can release the proposal (if he gets Parliament approval)
    // Alice cannot release it even if she had the original proposal ID
}
```

## Notes

This vulnerability is particularly severe because:

1. **No proposer authentication**: The commented-out `AssertDeploymentProposerAuthority` check means anyone can call these methods.

2. **Deterministic addressing**: For contracts deployed with specific salt values to achieve deterministic addresses, an attacker can permanently prevent deployment at that address by continuously squatting the proposal hash.

3. **Authorship privileges**: If the attacker is whitelisted, they gain full contract author privileges including update and transfer capabilities.

4. **Governance impact**: This could be used to disrupt legitimate governance processes by systematically hijacking expired proposals.

The fix should ensure that proposal entries are either owned exclusively by the original proposer until explicitly cleared, or automatically cleaned up after expiration to allow fresh proposals.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L175-178)
```csharp
    private Hash CalculateHashFromInput(IMessage input)
    {
        return HashHelper.ComputeFrom(input);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-128)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-178)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L277-283)
```csharp
    public override Empty ReleaseApprovedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-321)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-535)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```
