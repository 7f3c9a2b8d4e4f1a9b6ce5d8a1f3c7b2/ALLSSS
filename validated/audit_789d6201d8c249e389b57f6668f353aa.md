# Audit Report

## Title
Last Miner InValue Grinding Attack - Mining Order Manipulation

## Summary
The AEDPoS consensus validation fails to prevent the last miner in a round from grinding their current `InValue` to manipulate their mining order in subsequent rounds. By observing all other miners' signatures before committing their own `OutValue`, the last miner can choose an `InValue` that produces a favorable signature for the next round, violating the consensus mechanism's randomness guarantee and fairness.

## Finding Description

The AEDPoS consensus uses a commit-reveal scheme where miners commit `OutValue = hash(InValue)` in round N and reveal `InValue` in round N+1. The revealed `InValue` is used to calculate a signature that determines mining order. [1](#0-0) 

The signature calculation XORs the `inValue` with all signatures from the previous round. This signature then determines the miner's order in the next round: [2](#0-1) 

**Root Cause**: The validation only checks that the revealed `PreviousInValue` matches the previously committed `PreviousOutValue`: [3](#0-2) 

It does NOT validate the randomness or unbiased selection of the CURRENT `InValue` being committed.

**Attack Flow:**

When the last miner in round N produces their block:
1. They can observe all other miners' signatures (Sig_N^1, Sig_N^2, ..., Sig_N^{K-1}) already published in round N
2. They calculate their own Sig_N^K using their known InValue_{N-1}^K
3. They now know ALL Sig_N values
4. They need to commit OutValue_N^K = hash(InValue_N^K) for the current round
5. They try different InValue_N^K candidates offline:
   - Calculate Sig_{N+1}^K = XOR(InValue_N^K, XOR of all Sig_N)
   - Calculate order_{N+2}^K = (Sig_{N+1}^K.ToInt64() % minersCount) + 1
6. Select the InValue_N^K that gives the best order (e.g., order 1)
7. Commit the optimized OutValue_N^K = hash(chosen InValue_N^K)

When producing blocks, miners calculate their signature from the previous round: [4](#0-3) 

The next round's mining order is determined by these signatures: [5](#0-4) 

The validation providers for UpdateValue behavior do not include any randomness checks: [6](#0-5) 

## Impact Explanation

**Consensus Integrity Violation**: The randomness guarantee of the AEDPoS consensus mechanism is broken. The system assumes mining order is unpredictable and fair, but the last miner can systematically bias their position.

**Concrete Harm**:
- The last miner can systematically obtain better mining positions (e.g., order 1) more frequently than statistically expected
- Better positions correlate with more blocks produced and higher rewards
- Over many rounds, this advantage compounds significantly  
- Mining becomes unfair, with the attacker gaining disproportionate rewards
- Network decentralization is compromised as the attacking miner gains disproportionate influence

**Who is Affected**:
- All other honest miners who follow the protocol correctly suffer reduced block production opportunities
- The network's decentralization guarantee is violated
- Block reward distribution becomes skewed toward the attacker

**Severity**: Medium - Requires being last in mining order (1/K probability), but impact accumulates over time and violates a critical consensus invariant (mining order randomness).

## Likelihood Explanation

**Attacker Capabilities**: Any elected miner who mines last in their round order can execute this attack. No special privileges beyond normal mining rights are required.

**Attack Complexity**: Low
- Computational cost is minimal (just hash computations offline)
- No complex timing or coordination needed
- Can be automated in mining software
- Takes only seconds to find an optimal InValue

**Feasibility Conditions**:
- Attacker is an elected miner (normal requirement)
- Attacker mines last in round order (probability = 1/K per round where K is miner count)
- Attack can be repeated every time the miner is last

**Detection Difficulty**: Very hard to detect because:
- The chosen `InValue` looks like any other random value to observers
- Validation only checks hash consistency, not randomness source
- Statistical analysis would require many rounds and be inconclusive
- No on-chain evidence distinguishes grinding from honest behavior

**Probability**: High for any miner who is last in order, which occurs regularly in the mining rotation (1/K of all rounds).

## Recommendation

Implement a Verifiable Random Function (VRF) or commit the `InValue` for round N+1 before revealing `InValue` for round N. This prevents the miner from having complete information when choosing their InValue.

**Option 1 - VRF-based InValue:**
```csharp
// Require InValue to be generated using VRF with proof
// Verify VRF proof before accepting InValue
private bool ValidateInValueRandomness(Hash inValue, byte[] vrfProof, string pubkey)
{
    // Verify VRF proof shows inValue was generated randomly
    return VRFHelper.Verify(pubkey, vrfProof, inValue);
}
```

**Option 2 - Extended Commit-Reveal:**
```csharp
// In UpdateValueValidationProvider, also validate that CurrentInValue 
// was committed in the previous round to prevent grinding
private bool ValidateCurrentInValueCommitment(ConsensusValidationContext validationContext)
{
    var previousRound = validationContext.PreviousRound;
    var currentInValue = validationContext.ExtraData.Round.RealTimeMinersInformation[publicKey].InValue;
    
    // Check that hash of current InValue matches a value committed 2 rounds ago
    // This prevents miners from choosing InValue after seeing current round signatures
    if (previousRound.RoundNumber > 1)
    {
        var roundTwoBack = GetRound(previousRound.RoundNumber - 1);
        var expectedCommitment = roundTwoBack.RealTimeMinersInformation[publicKey].FutureOutValue;
        return HashHelper.ComputeFrom(currentInValue) == expectedCommitment;
    }
    return true;
}
```

## Proof of Concept

```csharp
// Simulated POC demonstrating the grinding attack
public void TestLastMinerGrindingAttack()
{
    // Setup: 5 miners in round N, attacker is miner 5 (last)
    var minersCount = 5;
    var attackerIndex = 4; // Last miner (index 4)
    
    // Round N: All miners 1-4 have published their Sig_N values
    var allSigN = new List<Hash>();
    for (int i = 0; i < minersCount - 1; i++)
    {
        allSigN.Add(GenerateRandomHash());
    }
    
    // Attacker knows their InValue_{N-1} and can calculate their Sig_N
    var attackerInValueN1 = GenerateRandomHash();
    var previousRoundSigs = GenerateRandomHashes(minersCount); // All Sig_{N-1}
    var attackerSigN = CalculateSignature(attackerInValueN1, previousRoundSigs);
    allSigN.Add(attackerSigN);
    
    // Now attacker knows ALL Sig_N values
    var combinedSigN = CombineXOR(allSigN);
    
    // GRINDING: Try different InValue_N candidates
    int targetOrder = 1; // Attacker wants position 1 in round N+2
    Hash chosenInValue = null;
    
    for (int nonce = 0; nonce < 10000; nonce++)
    {
        var candidateInValue = HashHelper.ComputeFrom($"attacker_seed_{nonce}");
        var futureSignature = HashHelper.XorAndCompute(candidateInValue, combinedSigN);
        var futureOrder = (Math.Abs(futureSignature.ToInt64()) % minersCount) + 1;
        
        if (futureOrder == targetOrder)
        {
            chosenInValue = candidateInValue;
            break; // Found optimal InValue
        }
    }
    
    Assert.NotNull(chosenInValue); // Attacker successfully found a good InValue
    
    // Attacker commits OutValue_N = hash(chosen InValue_N)
    var outValueN = HashHelper.ComputeFrom(chosenInValue);
    
    // Verify this passes validation (it will, because validation only checks previous round)
    // In round N+1, when InValue_N is revealed, attacker gets favorable position in round N+2
    var futureSignature = HashHelper.XorAndCompute(chosenInValue, combinedSigN);
    var finalOrder = (Math.Abs(futureSignature.ToInt64()) % minersCount) + 1;
    
    Assert.Equal(targetOrder, finalOrder); // Attack successful
}
```

This POC demonstrates that the last miner can find an `InValue` that produces their desired mining order in a subsequent round, violating the randomness guarantee of the consensus mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```
