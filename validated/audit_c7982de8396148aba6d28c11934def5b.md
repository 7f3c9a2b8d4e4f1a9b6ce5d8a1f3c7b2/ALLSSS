# Audit Report

## Title
Last Irreversible Block (LIB) Advancement Halts in Two-Miner Networks With Single Round Participation Gap

## Summary
In a 2-miner AEDPoS network, the LIB calculation mechanism requires both miners to have participated in two consecutive rounds for finality to advance. If either miner misses a single round, the LIB calculator fails its consensus threshold check and returns zero, preventing irreversible block height advancement until two consecutive rounds of full participation occur.

## Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method which calculates LIB height based on a cross-round consensus requirement. [1](#0-0) 

The core issue stems from the filtering logic that requires miners to have participated in BOTH the current and previous rounds. The method first retrieves miners who mined in the current round via `GetMinedMiners()`, then uses their pubkeys to filter implied irreversible heights from the previous round. [2](#0-1) 

For a 2-miner network, `MinersCountOfConsent` is calculated as `RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1)`, which equals `(2 * 2 / 3) + 1 = 2`, requiring both miners. [3](#0-2) 

The `GetMinedMiners()` method returns only miners where `SupposedOrderOfNextRound != 0`, which is set during normal consensus data processing. [4](#0-3)  Miners who miss their time slot will not have this field set. [5](#0-4) 

When the consensus threshold check fails, `libHeight = 0` is returned and no `IrreversibleBlockFound` event is fired. [6](#0-5) 

**Concrete Scenario:**
- Round N: Miners A and B both mine successfully
- Round N+1: Only Miner A mines (B misses the round)
- Round N+2: Both miners A and B mine
- During Round N+2 LIB calculation in `ProcessUpdateValue`: [7](#0-6) 
  - `GetMinedMiners()` on Round N+2 returns [A, B] (both mining in current round)
  - `GetSortedImpliedIrreversibleBlockHeights([A, B])` on Round N+1 only finds A's data (since B didn't mine in N+1), returning 1 height
  - Check: 1 < 2 fails, `libHeight = 0`

The contract allows 2-miner configurations without validation during initialization. [8](#0-7) 

## Impact Explanation

**Operational Impact:**
- **Finality Halted**: LIB advancement stops until two consecutive rounds of 100% miner participation occur, breaking the irreversibility guarantee that dependent systems rely on
- **Cross-Chain Operations Affected**: Cross-chain mechanisms relying on LIB for merkle path validation and synchronization are blocked, potentially halting cross-chain transactions
- **State Pruning Disabled**: Node state cleanup operations depending on LIB advancement cannot proceed, leading to unbounded state growth
- **Self-Recovering But Fragile**: System recovers after sustained participation, but any intermittent issues cause repeated failures

**Severity: Medium**
The chain continues producing blocks (safety preserved), but the complete halt of finality advancement represents a liveness failure affecting transaction irreversibility guarantees and dependent systems. While self-recovering, the requirement for sustained 100% participation in 2-miner networks creates operational fragility that violates availability expectations.

## Likelihood Explanation

**In 2-Miner Networks: High**
- No minimum miner count validation prevents this configuration in the `FirstRound` initialization method
- Any operational issue (network delays, maintenance, hardware failures) triggers the condition
- No attacker required—normal operational events cause it
- Recovery requires multiple consecutive rounds of perfect participation

**In Production Networks: Low to Medium**
The protocol defines `SupposedMinersCount = 17` as a constant, suggesting production deployments should use more miners. [9](#0-8)  However, this is not enforced as a minimum requirement during initialization, leaving 2-miner networks as a valid but fragile configuration primarily suited for testing environments.

## Recommendation

Add validation to enforce a minimum miner count during contract initialization. The minimum should be at least 3 miners to ensure proper Byzantine fault tolerance:

```csharp
public override Empty FirstRound(Round input)
{
    /* Basic checks. */
    Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");
    
    // Add minimum miner count validation
    var minersCount = input.RealTimeMinersInformation.Count;
    Assert(minersCount >= 3, "At least 3 miners required for proper consensus operation.");
    
    /* Initial settings. */
    State.CurrentTermNumber.Value = 1;
    // ... rest of initialization
}
```

Alternatively, implement a special LIB calculation strategy for small networks that doesn't require cross-round participation, or explicitly document that 2-miner networks are unsupported.

## Proof of Concept

The following test demonstrates the vulnerability by setting up a 2-miner network and showing that LIB fails to advance when one miner misses a round:

```csharp
[Fact]
public async Task TwoMinerNetwork_LIB_Fails_When_OneMinerMisses()
{
    // Setup: Initialize a 2-miner network
    var twoMiners = new[] { BootMinerKeyPair, ValidationDataCenterKeyPairs[0] };
    var minerList = new MinerList();
    minerList.Pubkeys.AddRange(twoMiners.Select(m => ByteStringHelper.FromHexString(m.PublicKey.ToHex())));
    
    var firstRound = minerList.GenerateFirstRoundOfNewTerm(
        AEDPoSContractTestConstants.MiningInterval, 
        BlockchainStartTimestamp);
    
    await AEDPoSContractStub.FirstRound.SendAsync(firstRound);
    
    // Round N: Both miners participate
    await ProduceBothMinersBlocks(firstRound);
    
    // Round N+1: Only first miner participates
    await BootMinerChangeRoundAsync(nextRoundNumber: 2);
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RoundNumber.ShouldBe(2);
    
    // Round N+2: Both miners participate again
    await ProduceBothMinersBlocks(currentRound);
    
    // Verify: LIB should fail to advance (returns 0 or stays at old value)
    var libHeight = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    libHeight.ConfirmedIrreversibleBlockHeight.ShouldBe(0); // LIB stuck at 0
}
```

## Notes

This vulnerability represents a **design limitation** in the BFT consensus threshold calculation that becomes problematic when the contract allows configurations below the practical minimum. Byzantine Fault Tolerant protocols require N ≥ 3f+1 nodes to tolerate f faulty nodes. A 2-miner network cannot tolerate any faults while maintaining finality progression.

The issue is validated as a legitimate Medium severity vulnerability because:
1. The contract accepts a configuration that leads to operational failure
2. The failure mode affects critical blockchain properties (finality)
3. No validation or documentation warns against this configuration
4. The impact extends to dependent systems (cross-chain, state management)

While test configurations use 5+ miners and production is expected to use 17+, the lack of enforcement creates a deployment footgun that could affect testnets, private chains, or misconfigured networks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-281)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
