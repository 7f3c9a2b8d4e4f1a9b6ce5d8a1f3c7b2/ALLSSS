# Audit Report

## Title
Missing TermNumber Validation in NextRound Allows Consensus Time Slot Bypass

## Summary
The AEDPoS consensus contract fails to validate the TermNumber field in NextRoundInput during NextRound processing, allowing malicious miners to store rounds with incorrect TermNumber values. This causes time slot validation to be incorrectly bypassed in subsequent rounds, breaking the fundamental consensus invariant that ensures miners can only produce blocks during their assigned time slots.

## Finding Description

The vulnerability exists due to missing validation of the TermNumber field across the NextRound consensus flow, combined with an incorrect time slot bypass condition.

**Root Causes:**

1. **Unvalidated Field Copying:** The `ToRound()` method blindly copies all fields from NextRoundInput including TermNumber without any validation. [1](#0-0) 

2. **Incomplete Pre-Execution Validation:** The `RoundTerminateValidationProvider` validates NextRound behavior by checking only RoundNumber increment and InValue nullity, but completely omits TermNumber validation. [2](#0-1)  TermNumber validation only exists for NextTerm behavior. [3](#0-2) 

3. **Asymmetric State Updates:** `ProcessNextRound` only updates RoundNumber in state via `TryToUpdateRoundNumber`, never updating TermNumber. [4](#0-3)  In contrast, `ProcessNextTerm` explicitly calls both `TryToUpdateTermNumber` and `TryToUpdateRoundNumber`. [5](#0-4) 

4. **State.CurrentTermNumber Only Updated by NextTerm:** The global term number is exclusively managed by `TryToUpdateTermNumber` which is only called from `ProcessNextTerm`. [6](#0-5) 

**Attack Execution Path:**

1. **Initial State:** TermNumber = N, RoundNumber = R
2. **Malicious NextRound (Round R→R+1):** Attacker crafts NextRoundInput with RoundNumber = R+1 (valid) but TermNumber = N+1 (invalid). This passes validation since TermNumber is never checked for NextRound.
3. **Round R+1 Storage:** The manipulated round with TermNumber = N+1 is stored in State.Rounds[R+1] via `AddRoundInformation`. State.CurrentTermNumber remains N.
4. **Normal Round Transition (R+1→R+2):** A legitimate miner creates Round R+2 using normal generation, which preserves the current TermNumber = N as expected. [7](#0-6) 
5. **Validation Context Construction for Round R+2:** When validating blocks in round R+2, the validation context retrieves `PreviousRound` from state (which is the malicious Round R+1 with TermNumber N+1) and `CurrentTermNumber` from State.CurrentTermNumber.Value (which is N). [8](#0-7) 
6. **Time Slot Bypass:** `CheckMinerTimeSlot` calls `IsFirstRoundOfCurrentTerm`, which compares PreviousRound.TermNumber (N+1) against CurrentTermNumber (N). [9](#0-8)  Since N+1 ≠ N, it returns true, causing `CheckMinerTimeSlot` to immediately return true without performing any time slot validation. [10](#0-9) 

**Security Invariant Broken:**

The AEDPoS consensus mechanism guarantees that miners can only produce blocks during their assigned time slots to ensure fair block production and prevent centralization. This vulnerability breaks that invariant by allowing time slot validation to be bypassed.

## Impact Explanation

**Critical Consensus Integrity Violation:**

The AEDPoS time slot mechanism is a fundamental consensus invariant that ensures:
- Each miner has a specific time window for block production
- Fair distribution of block production opportunities
- Prevention of mining centralization
- Predictable consensus schedule

**Concrete Impacts:**

1. **Time Slot Enforcement Bypass:** Miners in round R+2 can produce blocks outside their assigned time slots without rejection
2. **Unfair Block Rewards:** Attackers gain additional mining opportunities beyond their allocated slots, earning more rewards
3. **Consensus Centralization:** Single malicious miner can dominate block production by producing blocks continuously
4. **State Corruption:** Creates permanent divergence between Round.TermNumber values in state storage and the global State.CurrentTermNumber
5. **Schedule Breakdown:** The carefully designed mining time arrangement becomes meaningless during the affected round

**Severity: Medium** - While the impact on consensus integrity is severe, the attack requires the attacker to be an active miner (limiting attack surface), and the bypass only affects one subsequent round before the state inconsistency may be detected.

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Low Attack Complexity:** Attack requires only crafting a NextRoundInput message with manipulated TermNumber field - no cryptographic attacks or complex state manipulation needed

2. **Realistic Preconditions:** Attacker must be a valid miner in the current round, which is achievable through normal election/staking mechanisms. The `PreCheck` function only verifies miner list membership. [11](#0-10) 

3. **No Special Privileges:** Beyond being in the miner list (publicly verifiable), no additional authority or permissions required

4. **Low Economic Cost:** Only standard transaction fees; no token burning or staking penalties

5. **Immediate Effect:** Bypass takes effect in the very next round (R+2) after the malicious round (R+1) is stored

6. **Difficult Detection:** The manipulated TermNumber is stored in State.Rounds but State.CurrentTermNumber appears correct. The bypass behavior mimics the legitimate "first round of new term" scenario, making it hard to distinguish from normal operations

## Recommendation

Add TermNumber validation to the NextRound validation flow:

**Option 1: Add validation in RoundTerminateValidationProvider**

In `ValidationForNextRound`, add a check to ensure TermNumber remains unchanged:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number increment
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // ADD THIS: Validate TermNumber remains unchanged for NextRound
    if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Term number must not change during NextRound." };
    
    // Validate InValues are null
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**Option 2: Add validation in ProcessNextRound**

Add explicit validation before storing the round:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // ADD THIS: Validate TermNumber hasn't changed
    Assert(nextRound.TermNumber == currentRound.TermNumber, 
        "TermNumber cannot be changed in NextRound.");
    
    // ... rest of processing
}
```

**Recommended:** Implement Option 1 as it provides defense-in-depth by catching the issue during validation before execution.

## Proof of Concept

```csharp
[Fact]
public async Task TermNumberManipulation_BypassesTimeSlotValidation()
{
    // Setup: Initialize consensus with term N, round R
    await InitializeConsensusAsync();
    var currentRound = await GetCurrentRoundInformation();
    var currentTerm = await GetCurrentTermNumber();
    
    // Attack: Malicious miner creates NextRound with manipulated TermNumber
    var maliciousNextRoundInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentTerm + 1, // MANIPULATED - should be currentTerm
        RealTimeMinersInformation = { /* valid miner info */ },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Execute malicious NextRound - should fail but doesn't due to missing validation
    await MaliciousMiner.NextRound(maliciousNextRoundInput);
    
    // Verify: Malicious round stored with wrong TermNumber
    var storedRound = await GetRoundInformation(currentRound.RoundNumber + 1);
    Assert.Equal(currentTerm + 1, storedRound.TermNumber); // Wrong TermNumber stored
    
    // Verify: Global term number unchanged
    var globalTermNumber = await GetCurrentTermNumber();
    Assert.Equal(currentTerm, globalTermNumber); // Correct - still N
    
    // Next round transition: Create round R+2 normally
    await LegitimateMiners.NextRound(CreateValidNextRoundInput());
    
    // Vulnerability Trigger: Time slot validation in round R+2
    var validationContext = CreateValidationContext();
    
    // Previous round (R+1) has TermNumber N+1 (malicious)
    Assert.Equal(currentTerm + 1, validationContext.PreviousRound.TermNumber);
    
    // Current term is still N
    Assert.Equal(currentTerm, validationContext.CurrentTermNumber);
    
    // IsFirstRoundOfCurrentTerm incorrectly returns true
    var timeSlotProvider = new TimeSlotValidationProvider();
    var result = timeSlotProvider.ValidateHeaderInformation(validationContext);
    
    // TIME SLOT VALIDATION BYPASSED - returns success even outside time slot
    Assert.True(result.Success); 
    
    // Miner can now produce blocks outside assigned time slot
    await MaliciousMiner.ProduceBlockOutsideTimeSlot();
    // This should fail but succeeds due to bypassed validation
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-39)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L21-23)
```csharp
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L53-58)
```csharp
    private bool IsFirstRoundOfCurrentTerm(out long termNumber, ConsensusValidationContext validationContext)
    {
        termNumber = validationContext.CurrentTermNumber;
        return validationContext.PreviousRound.TermNumber != termNumber ||
               validationContext.CurrentRoundNumber == 1;
    }
```
