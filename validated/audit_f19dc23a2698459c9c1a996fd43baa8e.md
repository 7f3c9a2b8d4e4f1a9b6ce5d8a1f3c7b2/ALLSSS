# Audit Report

## Title
Missing Upper Bound Validation on MaximumMinersCount Enables Consensus DoS via ExecutionCallThreshold Exhaustion

## Summary
The `SetMaximumMinersCount` function lacks upper bound validation, allowing Parliament governance to configure parameters that cause consensus system transactions to exceed AElf's ExecutionCallThreshold of 15,000 method calls. When approximately 1,500+ miners are elected, the `ExtractInformationToUpdateConsensus` function exhausts the call limit during block production, causing a `RuntimeCallThresholdExceededException` that halts the entire blockchain until governance intervention.

## Finding Description
The vulnerability exists in the consensus contract's miner count configuration mechanism. The `SetMaximumMinersCount` function only validates that the input value is positive, with no upper bound check: [1](#0-0) 

This allows Parliament to set arbitrarily high values. The actual effective miner count is determined by `GetMaximumMinersCount()`, which returns the minimum of the auto-increased count and the Parliament-set maximum: [2](#0-1) 

The auto-increase mechanism adds 2 miners per `MinerIncreaseInterval` period: [3](#0-2) 

Parliament can reduce this interval to accelerate miner growth: [4](#0-3) 

During block production, the `GenerateConsensusTransactions` method (marked as a view method) is called: [5](#0-4) 

This invokes `ExtractInformationToUpdateConsensus` when the consensus behaviour is `UpdateValue`: [6](#0-5) 

This function performs three O(N) LINQ operations on `RealTimeMinersInformation.Values`: [7](#0-6) 

The AElf runtime patches all contract methods with `ExecutionObserverProxy.CallCount()` tracking: [8](#0-7) 

Each lambda invocation, enumerator operation, and method call in the LINQ operations increments the call counter. The ExecutionObserver throws an exception when the threshold is reached: [9](#0-8) 

AElf enforces an ExecutionCallThreshold of 15,000 method calls: [10](#0-9) 

With N=1,500 miners, the three LINQ operations perform approximately 12N+ method calls (including lambdas, enumerators, and dictionary operations), totaling ~18,000+ calls, which exceeds the 15,000 threshold. The consensus transaction generation service has no exception handling: [11](#0-10) 

The `RuntimeCallThresholdExceededException` propagates, causing block production to fail completely.

## Impact Explanation
This vulnerability breaks the blockchain's availability invariant. Once triggered, the network experiences complete consensus failure:

1. **Block Production Halt**: Every miner attempting to produce a block will have their `GenerateConsensusTransactions` call fail with `RuntimeCallThresholdExceededException`
2. **Chain Freezes**: No new blocks can be produced, halting all transactions and state transitions
3. **Recovery Requires Governance**: The network remains frozen until Parliament reduces `MaximumMinersCount` or increases `MinerIncreaseInterval` to bring the effective miner count below the threshold (~1,250 miners)
4. **Deterministic Trigger**: Once the threshold is crossed, the failure is guaranteed for every block production attempt

While no funds are directly at risk, the complete loss of blockchain availability represents a critical security failure that violates the system's core operational requirements. The impact is **HIGH** - complete denial of service of the entire blockchain.

## Likelihood Explanation
The likelihood is **LOW but non-zero** due to the following factors:

**Preconditions Required:**
1. Parliament must approve a proposal to reduce `MinerIncreaseInterval` significantly (e.g., to 1 second) OR set `MaximumMinersCount` extremely high while waiting for natural growth
2. Sufficient time must pass for the auto-increase mechanism to reach 1,500+ miners
3. The Election contract must successfully elect 1,500+ miners (requires that many candidates)
4. The issue manifests during the next block production attempt with `UpdateValue` behaviour

**Natural Growth Assessment:**
With the default `MinerIncreaseInterval` of 31,536,000 seconds (1 year): [12](#0-11) 

Natural growth from 17 initial miners to 1,500 would take approximately 740 years, making accidental trigger via natural growth implausible.

**Acceleration Vector:**
However, Parliament can accelerate this by setting `MinerIncreaseInterval` to 1 second, which would allow the system to reach 1,500 miners in approximately 741.5 seconds (~12 minutes). This could occur due to:
- Governance misconfiguration
- Misunderstanding of the ExecutionCallThreshold constraints
- Testing scenarios that inadvertently reach production

**Detection:**
The issue would be immediately obvious upon the first block production attempt after the miner count exceeds the threshold, providing rapid feedback but also immediate operational impact.

## Recommendation
Add an upper bound validation to `SetMaximumMinersCount` based on the ExecutionCallThreshold constraints. The recommended fix:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();

    Assert(input.Value > 0, "Invalid max miners count.");
    
    // Add upper bound validation to prevent ExecutionCallThreshold exhaustion
    // Conservative limit: 3 LINQ operations * 4 calls per miner ≈ 12 calls per miner
    // 15000 / 12 ≈ 1250 safe maximum
    const int MaxSafeMinersCount = 1250;
    Assert(input.Value <= MaxSafeMinersCount, 
        $"Maximum miners count cannot exceed {MaxSafeMinersCount} to prevent consensus DoS.");

    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set max miners count.");

    TryToGetCurrentRoundInformation(out var round);

    State.MaximumMinersCount.Value = input.Value;
    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
    {
        MinersCount = GetMinersCount(round)
    });

    return new Empty();
}
```

Additionally, consider adding similar validation to `SetMinerIncreaseInterval` to prevent it from being set to extremely low values that could accelerate miner growth unreasonably.

## Proof of Concept
Due to the complexity of setting up a full AElf test environment with 1,500+ miners, a simplified theoretical proof demonstrates the issue:

```csharp
[Fact]
public async Task TestMaximumMinersCountDoS()
{
    // This test demonstrates the vulnerability path:
    // 1. Parliament sets MinerIncreaseInterval to 1 second
    // 2. Time passes allowing miner count to grow
    // 3. GenerateConsensusTransactions is called with high miner count
    // 4. ExtractInformationToUpdateConsensus exceeds ExecutionCallThreshold
    
    // Setup: Initialize Parliament and set controller
    var parliamentAddress = await InitializeParliament();
    
    // Step 1: Parliament reduces MinerIncreaseInterval to 1 second
    await ParliamentExecuteTransaction(
        nameof(SetMinerIncreaseInterval), 
        new Int64Value { Value = 1 }
    );
    
    // Step 2: Simulate time passage (741 seconds) to reach 1500 miners
    // In production, this would use BlockTimeProvider
    await AdvanceTime(741);
    
    // Verify effective miner count reached threshold
    var effectiveMinersCount = await GetMaximumMinersCount();
    Assert.True(effectiveMinersCount >= 1500);
    
    // Step 3: Attempt to generate consensus transactions
    // This should throw RuntimeCallThresholdExceededException
    await Assert.ThrowsAsync<RuntimeCallThresholdExceededException>(async () =>
    {
        await ConsensusStub.GenerateConsensusTransactions.CallAsync(
            new AElfConsensusTriggerInformation
            {
                Pubkey = ByteString.CopyFrom(InitialMiners[0]),
                Behaviour = AElfConsensusBehaviour.UpdateValue
            }
        );
    });
}
```

The actual exploitation requires:
1. Creating a Parliament proposal to set `MinerIncreaseInterval` to a very low value (e.g., 1 second)
2. Waiting for the auto-increase mechanism to grow the miner count to 1,500+
3. Ensuring the Election contract has elected 1,500+ miners
4. Observing block production failure when any miner attempts to produce a block with `UpdateValue` behaviour

## Notes
This vulnerability specifically affects the `UpdateValue` consensus behaviour where `ExtractInformationToUpdateConsensus` is called. Other consensus behaviours (`TinyBlock`, `NextRound`, `NextTerm`) may have different computational complexity patterns and should also be audited for similar ExecutionCallThreshold exhaustion risks.

The Election contract's `UpdateMinersCount` method has no upper bound validation either: [13](#0-12) 

This means the validation must be enforced in the Consensus contract's `SetMaximumMinersCount` method to prevent the issue.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L14-14)
```csharp
        Assert(input.Value > 0, "Invalid max miners count.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L72-78)
```csharp
    public override Int32Value GetMaximumMinersCount(Empty input)
    {
        return new Int32Value
        {
            Value = Math.Min(GetAutoIncreasedMinersCount(), State.MaximumMinersCount.Value)
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** protobuf/acs4.proto (L32-34)
```text
    rpc GenerateConsensusTransactions (google.protobuf.BytesValue) returns (TransactionList) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-33)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/CallAndBranchCounts/Patcher.cs (L72-76)
```csharp
    private void InsertCallCountAtBeginningOfMethodBody(ILProcessor processor)
    {
        var callCallCountMethod = processor.Create(OpCodes.Call, _proxy.CallCountMethod);
        processor.InsertBefore(_method.Body.Instructions.First(), callCallCountMethod);
    }
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L21-27)
```csharp
    public void CallCount()
    {
        if (_callThreshold != -1 && _callCount == _callThreshold)
            throw new RuntimeCallThresholdExceededException($"Contract call threshold {_callThreshold} exceeded.");

        _callCount++;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-5)
```csharp
    public const int ExecutionCallThreshold = 15000;
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L216-244)
```csharp
    public async Task<List<Transaction>> GenerateConsensusTransactionsAsync(ChainContext chainContext)
    {
        _blockTimeProvider.SetBlockTime(_nextMiningTime, chainContext.BlockHash);

        Logger.LogDebug(
            $"Block time of getting consensus system txs: {_nextMiningTime.ToDateTime():hh:mm:ss.ffffff}.");

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var generatedTransactions =
            (await _contractReaderFactory
                .Create(contractReaderContext)
                .GenerateConsensusTransactions
                .CallAsync(_triggerInformationProvider.GetTriggerInformationForConsensusTransactions(
                    chainContext, _consensusCommand.ToBytesValue())))
            .Transactions
            .ToList();

        // Complete these transactions.
        foreach (var generatedTransaction in generatedTransactions)
        {
            generatedTransaction.RefBlockNumber = chainContext.BlockHeight;
            generatedTransaction.RefBlockPrefix =
                BlockHelper.GetRefBlockPrefix(chainContext.BlockHash);
            Logger.LogDebug($"Consensus transaction generated: \n{generatedTransaction.GetHash()}");
        }

        return generatedTransactions;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L13-13)
```csharp
    public long MinerIncreaseInterval { get; set; } = 31536000;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```
